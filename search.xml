<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS tutorial 6：使用Quick Look框架预览文件(Swift)]]></title>
    <url>%2F2017%2FiOS-tutorial-6%EF%BC%9A%E4%BD%BF%E7%94%A8Quick-Look%E6%A1%86%E6%9E%B6%E9%A2%84%E8%A7%88%E6%96%87%E4%BB%B6-Swift%2F</url>
    <content type="text"><![CDATA[参考 Using Quick Look Framework for Previewing Documents iOS SDK中有很多不常见，却非常好用的库，Quick Look框架就是一个非常好的例子。Quick Look框架提供了预览很多不同类型文件的功能，而不需要打开不同的APP查看，有点像Mac中的空格键功能。 Quick Look框架可以预览的文件类型： iWork documents (Pages, Numbers and Keynote) Microsoft Office documents (as long as they’ve been created with Office 97 or any other newer version) PDF files Images Text files Rich-Text Format documents Comma-Separated Value files (csv) 开始项目到开始项目处下载开始项目，这是原文提供了一个开始项目，代码是老版本的，需要转换一下。这个开始项目中包括了六种不同的类型的文件，一个navigation controller，一个table view controller（FileListViewController），另外还做了一些初始化工作。之后代码就在FileListViewController中完成。 文件和文件的URLS 在FileListViewController中定义一个文件名字的数组变量：let fileNames = [&quot;AppCoda-PDF.pdf&quot;, &quot;AppCoda-Pages.pages&quot;, &quot;AppCoda-Word.docx&quot;, &quot;AppCoda-Keynote.key&quot;, &quot;AppCoda-Text.txt&quot;, &quot;AppCoda-Image.jpeg&quot;] 继续定义一个数组变量，用户存储不同的文件的URL：var fileURLs = [NSURL]() 创建一个方法prepareFileURLs()，用于为fileURLs添加值： 123456789101112func prepareFileURLs() &#123; for file in fileNames &#123; // 1 let fileParts = file.components(separatedBy: &quot;.&quot;) if let fileURL = Bundle.main.url(forResource: fileParts[0], withExtension: fileParts[1]) &#123; // 2 if FileManager.default.fileExists(atPath: fileURL.path) &#123; fileURLs.append(fileURL as NSURL) &#125; &#125; &#125;&#125; 1 components(separatedBy:)方法用于把String按照给定的分隔符，分解成[String]。 2 判断文件地址是否真实存在。 在 viewDidLoad()中实现上面的函数： 12345override func viewDidLoad() &#123; ... prepareFileURLs()&#125; 展示文件用table view展示不同的文件： 根据文件的URL，获得文件名和文件后缀（文件类型），添加函数extractAndBreakFilenameInComponents(:)。 12345678910func extractAndBreakFilenameInComponents(fileURL: NSURL) -&gt; (fileName: String, fileExtension: String) &#123; let fileURLParts = fileURL.path!.components(separatedBy: &quot;/&quot;) let fileName = fileURLParts.last let filenameParts = fileName?.components(separatedBy: &quot;.&quot;) return (filenameParts![0], filenameParts![1])&#125; 修改 tableView(tableView:cellForRowAtIndexPath)： 123456789func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCellWithIdentifier(&quot;idCellFile&quot;, forIndexPath: indexPath) let currentFileParts = extractAndBreakFilenameInComponents(fileURLs[indexPath.row]) cell.textLabel?.text = currentFileParts.fileName return cell&#125; 根据不同的后缀名，定义不同的文件类型名称，添加函数getFileTypeFromFileExtension(:)： 12345678910111213141516171819202122232425func getFileTypeFromFileExtension(fileExtension: String) -&gt; String &#123; var fileType = &quot;&quot; switch fileExtension &#123; case &quot;docx&quot;: fileType = &quot;Microsoft Word document&quot; case &quot;pages&quot;: fileType = &quot;Pages document&quot; case &quot;jpeg&quot;: fileType = &quot;Image document&quot; case &quot;key&quot;: fileType = &quot;Keynote document&quot; case &quot;pdf&quot;: fileType = &quot;PDF document&quot; default: fileType = &quot;Text document&quot; &#125; return fileType&#125; 回到tableView(tableView:cellForRowAtIndexPath)，添加一段cell配置： cell.detailTextLabel?.text = getFileTypeFromFileExtension(fileExtension: currentFileParts.fileExtension) 修改每个section中row的数目为文件数目： 123func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return fileNames.count&#125; QLPreviewControllerDataSource 引入框架Quick Look import QuickLook 定义QLPreviewController let quickLookController = QLPreviewController() 让FileListViewController实现QLPreviewControllerDataSource协议 实现QLPreviewControllerDataSource协议的必须要实现的方法。第一方法表示有多少个文件需要预览： 123func numberOfPreviewItems(in controller: QLPreviewController) -&gt; Int &#123; return fileURLs.count&#125; 第二个方法：123func previewController(_ controller: QLPreviewController, previewItemAt index: Int) -&gt; QLPreviewItem &#123; return fileURLs[index]&#125; 在viewDidLoad()中添加：quickLookController.dataSource = self 预览文件在table view中选中文件，就要跳转的预览页面。实现方法tableView(_:didSelectRowAt:)：123456func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; if QLPreviewController.canPreview(fileURLs[indexPath.row]) &#123; quickLookController.currentPreviewItemIndex = indexPath.row navigationController?.pushViewController(quickLookController, animated: true) &#125; &#125; navigationController?.pushViewController(quickLookController, animated: true)可用presentViewController(quickLookController, animated: true, completion: nil)代替。 运行可预览文件： 观察上图，可发现 Quick Look Preview Controller自带了toolbar，左边一个是分享按钮(通过UIActivityViewController实现的)，右边一个是类似目录功能，当有很多预览文件时，来跳转到不同预览文件。 代码QuickLookDemo 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 6：使用Quick Look框架预览文件(Swift)//)]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 4：CALayer介绍(swift)]]></title>
    <url>%2F2017%2FiOS-tutorial-4%EF%BC%9ACALayer%E4%BB%8B%E7%BB%8D-swift%2F</url>
    <content type="text"><![CDATA[参考 A Beginner’s Guide to CALayer Layers是Core Animation Framework的一部分。Core Animation Framework在iOS架构的位置： 访问CALayer凡是继承至UIView的都将有一个属性layer来表示CALayer。myView.layer 初始化项目 新建CALayerDemo，single View Application模板 新建一个UIView和一个UILabel 圆角CALayer的cornerRadius属性大小表示UIView圆角处圆的半径大小。类似于box.layer.cornerRadius = 20，就形成了圆角，数字越大圆角效果越大，当cornerRadius等于box半径时，box就会变成一个园。 阴影效果1234box.layer.shadowOffset = CGSize(width: 5, height: 5)box.layer.shadowOpacity = 0.7box.layer.shadowRadius = 10box.layer.shadowColor = UIColor.blue.cgColor shadowOffset表示阴影偏移大小，也就是阴影向box的下放偏移5和向右方偏移5距离。 shadowOpacity是阴影透明度 shadowRadius是阴影涉及的半径，并且这个半径越大，阴影的颜色深浅就会越来越小。shadowRadius与shadowOffset是共同作用的 设置边的宽度和颜色12box.layer.borderColor = UIColor.black.cgColorbox.layer.borderWidth = 3 展示图片123box.layer.contents = UIImage(named: &quot;tree.jpg&quot;)?.cgImagebox.layer.contentsGravity = kCAGravityResizebox.layer.masksToBounds = true CALayer的contents属性是open var contents: Any?，可以设置为图片 contentsGravity设置成kCAGravityResize，表示contents的内容会调整大小以适应layer。如果设置成其他值可能出现大小不适的形象，比如kCAGravityBottomRight，将是： masksToBounds为true表示按照layer的边框范围显示内容；如果是false，将会是如下结果 背景颜色和透明度12box.layer.backgroundColor = UIColor.green.cgColorbox.layer.opacity = 0.5 代码CALayerDemo 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 4：CALayer介绍(swift)/]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 5：关于地理定位和特定区域(Swift)]]></title>
    <url>%2F2017%2FiOS-tutorial-5%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%E5%92%8C%E7%89%B9%E5%AE%9A%E5%8C%BA%E5%9F%9F-Swift%2F</url>
    <content type="text"><![CDATA[参考 Building a Geo Targeting iOS App in Swift 用户带着iPhone进入某个区域，并在某些区域待多久在开发肯能会有很大用处。 初始化项目 创建新的项目GeoTargeting，使用Single View Appliction模板 添加一个Map View，大小为整个页面 添加相关outlet 实现两个协议 123class ViewController: UIViewController, MKMapViewDelegate, CLLocationManagerDelegate &#123; @IBOutlet weak var mapView: MKMapView! 设置CLLocationManager和MKMapView。 1234567891011121314151617// 1let locationManager = CLLocationManager()override func viewDidLoad() &#123; super.viewDidLoad() // 2 locationManager.delegate = self locationManager.distanceFilter = kCLLocationAccuracyNearestTenMeters locationManager.desiredAccuracy = kCLLocationAccuracyBest // 3 mapView.delegate = self mapView.showsUserLocation = true mapView.userTrackingMode = .follow setupData() &#125; 1 创建一个CLLocationManager的实例，用于检测用户的位置变化 2 设置locationManager一些参数，确定精确性 在viewDidAppear中核查用户授权状态1234567891011121314151617override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) let authorizationStatus = CLLocationManager.authorizationStatus() // 1 if authorizationStatus == .notDetermined &#123; locationManager.requestAlwaysAuthorization() &#125; // 2 else if authorizationStatus == .denied &#123; showAlert(&quot;Location services &quot;) &#125; // 3 else if authorizationStatus == .authorizedAlways &#123; locationManager.startUpdatingLocation() &#125;&#125; 1 如果用户授权状态是不确定，就检查是否是一直的状态。 2 如果用户授权状态是拒绝，就用弹框显示信息给用户看。showAlert(title:)是弹框函数： 1234567891011func showAlert(_ title: String) &#123; print(title) let alertController = UIAlertController(title: title, message: nil, preferredStyle: .alert) let action = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler: nil) alertController.addAction(action) present(alertController, animated: true, completion: nil) &#125; 3 如果用户授权状态是一直，就开始更新地理位置。 另外，还需要在.plist文件中添加key为NSLocationAlwaysUsageDescription的提示信息 需要一直能获取你的位置 才可以。在调用requestAlwaysAuthorization()时这个key是必须的。允许获取当前位置。 添加函数setupData()1234567891011121314151617181920212223242526272829303132333435func setupData() &#123; // 1 if CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) &#123; // 2 let title = &quot;全季酒店&quot; let coordinate = CLLocationCoordinate2DMake(31.1849700000,121.6303200000) let regionRadius = 300.0 // 3 let region = CLCircularRegion(center: CLLocationCoordinate2D(latitude: coordinate.latitude, longitude: coordinate.longitude), radius: regionRadius, identifier: title) locationManager.startMonitoring(for: region) // 4 let restaurantAnnotation = MKPointAnnotation() restaurantAnnotation.coordinate = coordinate restaurantAnnotation.title = title mapView.addAnnotation(restaurantAnnotation) // 5 let circle = MKCircle(center: coordinate, radius: regionRadius) mapView.add(circle) &#125; else &#123; print(&quot;不能追踪区域&quot;) &#125;&#125;// 6func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123; let circleRenderer = MKCircleRenderer(overlay: overlay) circleRenderer.strokeColor = UIColor.red circleRenderer.lineWidth = 1.0 return circleRenderer&#125; 1 判断是否监控区域功能是否可用。当用户拒绝状态，或用户不让app背景下刷新，或飞行模式时这个功能不可用 2 随意构建一个位置（如全季酒店），经纬度可通过经纬度查询查询，并设置区域半径regionRadius，单位是米。 3 初始化CLCircularRegion。 4 添加一个注解，类似大头针形状。 5 添加区域圆圈标志。 6 这是MKMapViewDelegate的方法，用户画圆 CLRegionCLRegion就是上面标定的圆形区域。下面添加两个CLLocationManagerDelegate的回调方法，分别在是设备的定位位置进和出标定的区域时调用。12345678// MARK:- CLLocationManagerDelegatefunc locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;)&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;)&#125; Xcode中的位置调试上面设备的位置，不可能拿着手机到处跑，Xcode提高了方便的调式方式。可以建立位置文件.GPX: xcode也提供世界上一些常用的位置文件：点击上图调试栏最后的位置标志就可以调式了。 复杂逻辑下的位置处理如果位置不停变化，在监控区域停留时间比较短，或者监控区域比较多是，处理位置问题就比较复杂了。更新部分代码：123456789101112131415161718// 1var monitoredRegions: Dictionary&lt;String, NSDate&gt; = [:] func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;) // 2 monitoredRegions[region.identifier] = NSDate()&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;) // 3 monitoredRegions.removeValue(forKey: region.identifier)&#125;// 4func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; updateRegions()&#125; 1 定义以字典用于存储用户进入监控区的时间。 2 记录进入时间。 3 删除进入时间。 4 用户位置变化后调用 加入函数updateRegions()代码：1234567891011121314151617181920func updateRegions() &#123; // 1 let regionMaxVisiting = 10.0 var regionsToDelete: [String] = [] // 2 for regionIdentifier in monitoredRegions.keys &#123; // 3 if NSDate().timeIntervalSince(monitoredRegions[regionIdentifier]! as Date) &gt; regionMaxVisiting &#123; showAlert(&quot;谢谢访问&quot;) regionsToDelete.append(regionIdentifier) &#125; &#125; // 4 for regionIdentifier in regionsToDelete &#123; monitoredRegions.removeValue(forKey: regionIdentifier) &#125;&#125; 1 加的用户到某个区域10s，就确定用户已经到访问过这个区域。regionsToDelete用来存储即将删除的区域的identifier，也就用户待过超过10s的区域。 2 遍历所有监控区域 3 timeIntervalSince用来计算某个时间到当前时间的差值，单位为秒。 4 删除用户待过超过regionMaxVisiting的区域。 代码GeoTargeting 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 5：关于地理定位和特定区域(Swift)]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 3：Speech Framework的简单使用]]></title>
    <url>%2F2017%2FiOS-tutorial-3%EF%BC%9ASpeech-Framework%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考： Building a Speech-to-Text App Using Speech Framework in iOS 10 在WWDC 2016时，Apple介绍了Speech framework，这是一个很有用的声音识别框架。实际上这是利用Siri进行声音识别。 初始化项目 新建SpeechToTextDemo，模板是Single View Application。 添加简单的UI 分别定义UITextView和UIButton的两个outlet，为textView和microphoneButton。 再为UIButton添加一个action：123@IBAction func microphoneTapped(_ sender: AnyObject) &#123;&#125; 使用Speech Framework import Speech 实现SFSpeechRecognizerDelegate协议 用户授权获取声音数据是要获得用户的授权的。 在ViewController类中定义一个变量，作为语音识别器。参数identifier是识别的语种，可参考这个列表，中文是“ zh_Hans_CN”。private let speechRecognizer = SFSpeechRecognizer(locale: Locale.init(identifier: &quot;zh_Hans_CN&quot;)) 在viewDidLoad()中： 1234567891011121314151617181920212223242526272829override func viewDidLoad() &#123; super.viewDidLoad() // 1 microphoneButton.isEnabled = false speechRecognizer?.delegate = self // 2 SFSpeechRecognizer.requestAuthorization&#123; (authStatus) in var isButtionEnabled = false switch authStatus &#123; case .authorized: isButtionEnabled = true case .denied: isButtionEnabled = false print(&quot;用户拒绝接受语音识别&quot;) case .notDetermined: isButtionEnabled = false print(&quot;语音识别功能没有经过认可&quot;) case .restricted: isButtionEnabled = false print(&quot;当前设备不能语音识别&quot;) &#125; self.microphoneButton.isEnabled = isButtionEnabled &#125; startRecording()&#125; 1 默认按钮设成不可用 2 授权结果回调 Apple需要每个app如要用户授权时，都应该定制一个反馈信息（info.plist）。在info.plist中添加两个key，分别是麦克风和语音识别的授权，Privacy - Microphone Usage Description和Privacy - Speech Recognition Usage Description。 处理语音识别 在ViewController类中添加三个变量 123private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest? //识别请求private var recognitionTask: SFSpeechRecognitionTask? // 提供识别请求的结果private let audioEngine = AVAudioEngine() // SFSpeechAudioBufferRecognitionRequest对象处理语音识别的请求，代表语音进入语音识别器。 SFSpeechRecognitionTask 识别任务，用于操作识别器的停止和开始 AVAudioEngine 语音引擎，提供语音输出 创建新函数startRecording()，这个函数在点击button后调用，也就是microphoneTapped(:)中最后调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162func startRecording() &#123; // 1 if recognitionTask != nil &#123; recognitionTask?.cancel() recognitionTask = nil &#125; // 2 let audioSession = AVAudioSession.sharedInstance() do &#123; try audioSession.setCategory(AVAudioSessionCategoryRecord) try audioSession.setMode(AVAudioSessionModeMeasurement) try audioSession.setActive(true, with: .notifyOthersOnDeactivation) &#125; catch &#123; print(&quot;audioSession的属性设置失败&quot;) &#125; // 3 recognitionRequest = SFSpeechAudioBufferRecognitionRequest() // 4 guard let inputNode = audioEngine.inputNode else &#123; fatalError(&quot;Audio engine has no input node&quot;) &#125; // 5 guard let recognitionRequest = recognitionRequest else &#123; fatalError(&quot;Unable to create an SFSpeechAudioBufferRecognitionRequest object&quot;) &#125; // 6 recognitionRequest.shouldReportPartialResults = true // 7 recognitionTask = speechRecognizer?.recognitionTask(with: recognitionRequest, resultHandler: &#123; (result, error) in var isFinal = false if result != nil &#123; self.textView.text = result?.bestTranscription.formattedString isFinal = (result?.isFinal)! &#125; if error != nil || isFinal &#123; self.audioEngine.stop() inputNode.removeTap(onBus: 0) self.recognitionRequest = nil self.recognitionTask = nil self.microphoneButton.isEnabled = true &#125; &#125;) let recordingFormat = inputNode.outputFormat(forBus: 0) inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) &#123; (buffer, when) in self.recognitionRequest?.append(buffer) &#125; audioEngine.prepare() do &#123; try audioEngine.start() &#125; catch &#123; print(&quot;audioEngine couldn&apos;t start beacause of an error.&quot;) &#125; textView.text = &quot;Say something, I&apos;m listening!&quot;&#125; 1 开始录音时的初始化 2 AVAudioSession提供语音录音，设置一些参数 3 初始化SFSpeechAudioBufferRecognitionRequest 4 核查audioEngine是否可用 5 核查recognitionRequest 7 检测的音频后的回调方法，也就是开始录音后，有音频进入后都调用 语音识别的开关 实现代理方法speechRecognizer(_:availabilityDidChange:)。这个方法在语音识别器可用性发生变化时被调用。 1234567func speechRecognizer(_ speechRecognizer: SFSpeechRecognizer, availabilityDidChange available: Bool) &#123; if available &#123; microphoneButton.isEnabled = true &#125; else &#123; microphoneButton.isEnabled = false &#125;&#125; 点击button时的操作： 1234567891011@IBAction func microphoneTapped(_ sender: AnyObject) &#123; if audioEngine.isRunning &#123; audioEngine.stop() recognitionRequest?.endAudio() microphoneButton.isEnabled = false microphoneButton.setTitle(&quot;Start Recording&quot;, for: .normal) &#125; else &#123; startRecording() microphoneButton.setTitle(&quot;Stop Recording&quot;, for: .normal) &#125; &#125; 总结语音识别在iPhone的自带键盘中有这个功能，中文识别率很高，如果不高兴或不方便打字，很方便使用。 代码SpeechToTextDemo 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 3：Speech Framework的简单使用/]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 2：用Core Image进行面部识别(Swift)]]></title>
    <url>%2F2017%2FiOS-tutorial-2%EF%BC%9A%E7%94%A8Core-Image%E8%BF%9B%E8%A1%8C%E9%9D%A2%E9%83%A8%E8%AF%86%E5%88%AB-Swift%2F</url>
    <content type="text"><![CDATA[参考：Face Detection in iOS Using Core Image 面部识别API不仅可以是识别面部，也可识别面部的特殊细节，例如微笑甚至眨眼睛。 建立初始项目原文建好了初始项目，我自己新建了初始项目 新建项目Detector 删除IB中原本View Controller Scene。 拖动UITabBarController到IB中，得到三个Scene。选择UITabBarController的Is Initial View Controller，使其作为初始控制器。 修改Item 1的title和其Bar Item都为Photo，修改其Class为ViewController。 向Assets中添加几张人物图片 想Photo Scene中添加一个Image View，Content Mode改为Aspect Fit，选择一个图片。在ViewController添加图片对应@IBOutlet：@IBOutlet var personPic: UIImageView! 选中Item 2，点击菜单栏EDitor &gt; Embed In &gt; Navigation Controller，新生成一个与之关联的Scene。 新建CameraViewController类，继承至UIViewController。修改上面生成的Scene的Class属性为CameraViewController。 拖动一个UIBarButtonItem到Camera View Controller Scene的UINavigationItem的右边，并选择System Item为Camera 在CameraViewController中建立outlet和Action 识别照片的面部 在 ViewController.swift中引入CoreImage:import CoreImage 在 ViewController.swift中添加函数detect(): 12345678910111213141516171819202122232425262728293031func detect() &#123; // 1 guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; // 2 let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // 3 for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) let faceBox = UIView(frame: face.bounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) // 4 if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 1 根据UIImage获取CoreImage中图片对象。guard与if功能类似，区别可查看以撸代码的形式学习Swift-5：Control Flow的6 guard 与 if。 2 初始化检测器CIDetector， accuray是检查器配置选项，表示精确度；因为CIDetector可以进行几种类型的检测，所以CIDetectorTypeFace用来表示面部检测；features方法返回具体的检测结果 3 给每个检测到的脸添加红色框 4 检测是否有左眼位置 在viewDidLoad中添加 detect()，运行结果类似： 打印结果，显示检测到的面部位置是不对的：Found bounds are (177.0, 416.0, 380.0, 380.0)这是因为UIKit的坐标系统与Core Image的坐标系统是不同的： 把Core Image的坐标系统转换为UIKit的坐标系统，修改detect()为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func detect() &#123; guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // let ciImageSize = personciImage.extent.size var transform = CGAffineTransform(scaleX: 1, y: -1) transform = transform.translatedBy(x: 0, y: -ciImageSize.height) for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) // Apply the transform to convert the coordinates var faceViewBounds = face.bounds.applying(transform) // Calculate the actual position and size of the rectangle in the image view let viewSize = personPic.bounds.size let scale = min(viewSize.width / ciImageSize.width, viewSize.height / ciImageSize.height) let offsetX = (viewSize.width - ciImageSize.width * scale) / 2 let offsetY = (viewSize.height - ciImageSize.height * scale) / 2 faceViewBounds = faceViewBounds.applying(CGAffineTransform(scaleX: scale, y: scale)) faceViewBounds.origin.x += offsetX faceViewBounds.origin.y += offsetY let faceBox = UIView(frame: faceViewBounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 运行可看到正确识别位置： 相机拍照后的脸部识别之前是项目中照片识别，现在是拍完照再识别，原理是相同的，就是多一个拍完照，取照片的过程。 更新CameraViewController类的代码 1234567891011121314151617181920212223242526272829303132333435363738// 1class CameraViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate &#123; @IBOutlet var imageView: UIImageView! // 2 let imagePicker = UIImagePickerController() override func viewDidLoad() &#123; super.viewDidLoad() imagePicker.delegate = self &#125; @IBAction func takePhoto(_ sender: AnyObject) &#123; // 3 if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; imagePicker.allowsEditing = false imagePicker.sourceType = .camera present(imagePicker, animated: true, completion: nil) &#125; // 4 //MARK: -UIImagePickerControllerDelegate func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage &#123; imageView.contentMode = .scaleAspectFit imageView.image = pickedImage &#125; dismiss(animated: true, completion: nil) self.detect() &#125; // 5 func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil) &#125;&#125; 1 实现UIImagePickerControllerDelegate协议，用于拍照相关代理。 2 初始化UIImagePickerController。UIImagePickerController是照相或摄影界面和功能管理的类。 3 判断设备照相机是否可用。 4 实现一个UIImagePickerControllerDelegate中的代理方法，当拍摄完备确实使用照片时调用。 5 也是UIImagePickerControllerDelegate中的代理方法，取消拍摄时调用。 添加detect()代码，与ViewController中不同的是，不用红色框框处识别出的面部，而是识别出面部的细节，并用UIAlertController弹出显示。 1234567891011121314151617181920212223242526272829303132333435363738394041func detect() &#123; let imageOptions = NSDictionary(object: NSNumber(value: 5) as NSNumber, forKey: CIDetectorImageOrientation as NSString) let personciImage = CIImage(cgImage: imageView.image!.cgImage!) let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage, options: imageOptions as? [String : AnyObject]) if let face = faces?.first as? CIFaceFeature &#123; print(&quot;found bounds are \(face.bounds)&quot;) var message = &quot;有个脸&quot; if face.hasSmile &#123; print(&quot;脸是笑的&quot;) message += &quot;,脸是笑的&quot; &#125; if face.hasMouthPosition &#123; print(&quot;有嘴唇&quot;) message += &quot;,有嘴唇&quot; &#125; if face.hasLeftEyePosition &#123; print(&quot;左眼镜的位置是 \(face.leftEyePosition)&quot;) message += &quot;,左眼镜的位置是 \(face.leftEyePosition)&quot; &#125; if face.hasRightEyePosition &#123; print(&quot;右眼镜的位置是 \(face.rightEyePosition)&quot;) message += &quot;,右眼镜的位置是 \(face.rightEyePosition)&quot; &#125; let alert = UIAlertController(title: &quot;嘿嘿&quot;, message: message, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; else &#123; let alert = UIAlertController(title: &quot;没脸了&quot;, message: &quot;没有检测到脸&quot;, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; &#125; 运行就可以识别照片的面部具体细节CIFaceFeature还提供了其他很多面部细节：1234567891011121314151617181920212223242526272829open var hasLeftEyePosition: Bool &#123; get &#125;open var leftEyePosition: CGPoint &#123; get &#125;open var hasRightEyePosition: Bool &#123; get &#125;open var rightEyePosition: CGPoint &#123; get &#125;open var hasMouthPosition: Bool &#123; get &#125;open var mouthPosition: CGPoint &#123; get &#125;open var hasTrackingID: Bool &#123; get &#125;open var trackingID: Int32 &#123; get &#125;open var hasTrackingFrameCount: Bool &#123; get &#125;open var trackingFrameCount: Int32 &#123; get &#125;open var hasFaceAngle: Bool &#123; get &#125;open var faceAngle: Float &#123; get &#125;open var hasSmile: Bool &#123; get &#125;open var leftEyeClosed: Bool &#123; get &#125;open var rightEyeClosed: Bool &#123; get &#125; 代码Detector 本文作者：AndyRon本文链接：http://andyron.com/2017/]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[swift的文档注释]]></title>
    <url>%2F2017%2Fswift%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[在Xcode中Quick Help 为开发者提供方便快捷的简洁文档查看方式。option+点击查看弹框，option+command+2在检查器中查看。swift的中有两种注释方式，让Xcode在Quick Help中显示。这种注释可以认为是将文档以某种规范的格式嵌入在实际代码的上方，这样就可以通过某些工具自动生成漂亮的文档文件。这种内嵌式的文档在现代编程中是很普遍的。在swift中，这两种注释方式是： /** */ ///这些注释中还可以有其他一些规范 可以支持markdown 关键词 三个关键词：parameter， returns， throws。这三个关键词会在最左边显示。 还有一些关键词会被提取到description中作为一些特殊字段显示，其他都会在description正常显示：author, authors, copyright, date；since, version；attention, important, note, remark, warning；bug, TODO, experiment； complexity； precondition, postcondition, requires, invariant see* 参考http://swifter.tips/documentation/http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/ 本文作者：AndyRon本文链接：http://andyron.com/2017/swift的文档注释/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode中Scene里的名称]]></title>
    <url>%2F2017%2FXcode%E4%B8%ADScene%E9%87%8C%E7%9A%84%E5%90%8D%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[默认的Scene名称 Xcode中新建一个控制器对象后会产生一个Scene，而Scene的名称就与其关联的控制器名称相关，比如默认的View Controller的对象的Scene的名称就是View Controller Scene。 如果把控制器改成SFSafariViewController，那么Scene的名字就会变成Safari View Scene。 如果把控制器改成自建的，Scene名字也会随着变化，比如ASAndyViewController对应的Scene名字是 Andy View Scene 总的来说，apple在程序中代码命名规范，一般是前面连续大写的是框架名称，然后后面使用驼峰命名法。要显示时就把框架前缀去掉，然后根据驼峰命名规则分隔显示。 自定义Scene的名称Scene的名称也是可以自定义的，在其属性检查器中，修改title即可，当然这种修改只是停留在IB中，为了开发时便于查看，不影响代码中的名称。 本文作者：AndyRon本文链接：http://andyron.com/2017/Xcode中Scene里的名称/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 1： 识别二维码（swift3）]]></title>
    <url>%2F2017%2FiOS-tutorial-1-%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%EF%BC%88swift3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这是一篇使用AVFoundation框架识别二维码的文章，原文提供了初始化项目QRCodeReaderStarter，我重新建立项目，图片是从原文提供的初始化项目中copy的。 初始化项目 新建一个名为QRCodeReader的单页项目 删除ViewController.swift文件，在项目目录处右击新建文件，新建一个QRCodeViewController类继承自UIViewController。 点击Main.storyboard，选中View Controller，修改其属性Class为QRCodeViewController，使两者关联。 向Main.storyboard中拖动一个View Controller对象，以1的方法新建一个继承自UIViewController的类QRScannerController，然后与Main.storyboard中新建的View Controller关联。 下载图片。从原文的初始化项目QRCodeReaderStarter复制。 修改Code View Controller Scene的view背景颜色做修改；添加一个label，名称改为Quick Scan，字体，和字体大小也做修改；添加button，删除文本，大小为150150，Type为System，image为focus*，Tint为黄色；添加一些约束。 Scanner Controller Scene： 在顶部添加一个View，在这个View中添加以label和button，button的image为cross；在顶部添加一个label；添加一些约束。 构建 segue 用control-drag从Code View Controller Scene中的button到Scanner Controller Scene，选择Present Modally 在QRCodeViewController中添加代码： 1234@IBAction func unwindToHomeScreen(segue: UIStoryboardSegue) &#123; //去除模态视图 dismiss(animated: true, completion: nil) &#125; 在Scanner Controller Scene 中，用control-drag从button到Exit，选择unwindToHomeScreenWithSegue: 6和7中样式和约束，合适即可。 加载 AVFoundation 框架 在QRScannerController.swift文件中引入AVFoundation Framework：import AVFoundation QRScannerController实现AVCaptureMetadataOutputObjectsDelegate协议：class QRScannerController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {表示当捕获的元数据产生时，需要一些回调方法。 QRScannerController中添加三个变量：123var captureSession: AVCaptureSession?var videoPreviewLayer: AVCaptureVideoPreviewLayer?var qrCodeFrameView: UIView? 实现视频捕获 在QRScannerController的viewDidLoad中添加代码： 123456789101112131415161718192021222324252627// 1let captureDevice = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)do &#123; // 2 let input = try AVCaptureDeviceInput(device: captureDevice) // 3 captureSession = AVCaptureSession() // 4 captureSession?.addInput(input) // 5 let captureMetadataOutput = AVCaptureMetadataOutput() captureSession?.addOutput(captureMetadataOutput) // 6 captureMetadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main) captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode] videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession) videoPreviewLayer?.videoGravity = AVLayerVideoGravityResizeAspectFill videoPreviewLayer?.frame = view.layer.bounds view.layer.addSublayer(videoPreviewLayer!) captureSession?.startRunning()&#125; catch &#123; print(error) return&#125; 1 初始化AVCaptureDevice，它表示物理捕获设备；AVMediaTypeVideo是Media types，表示视频类型，还有AVMediaTypeAudio，AVMediaTypeText等其他类型 2 根据AVCaptureDevice初始化捕获设备的输入数据对象AVCaptureDeviceInput。这边的try是swift中错误处理的标识，对应public init(device: AVCaptureDevice!) throws。 3 AVCaptureSession 用于协调输入与输出之间的数据流。 4 为AVCaptureSession 添加输入数据 5 定义输出数据对象AVCaptureMetaDataOutput，并把它添加给AVCaptureSession 6 设置self为输出数据对象的代理，这就对应了QRScannerController类实现AVCaptureMetadataOutputObjectsDelegate协议。metadataObjectTypes是识别的元数据类型，AVMetadataObjectTypeQRCode表示二维码类型。 在Info.plist中添加key为NSCameraUsageDescription或”Privacy – Camera Usage Description”，值为 为了扫描二维码，需要使用你的相机。 运行应用时，点击scan button后，使用了相机，但messageLabel和tapbar没有了，因为被AVCaptureVideoPreviewLayer覆盖了，加入两行代码就可以显示了：12view.bringSubview(toFront: messageLabel)view.bringSubview(toFront: topbar) 实现二维码读取当检测到二维码时，用绿色框高亮；然后二维码被解码成文本信息展示在messagelabel中。 初始化绿色框。继续在上述代码后添加:12345678qrCodeFrameView = UIView() if let qrCodeFrameView = qrCodeFrameView &#123; qrCodeFrameView.layer.borderColor = UIColor.green.cgColor qrCodeFrameView.layer.borderWidth = 2 view.addSubview(qrCodeFrameView) view.bringSubview(toFront: qrCodeFrameView)&#125; 由于qrCodeFrameView没有设置大小，默认是0，所以不会显示，当之后发现二维码时再让它显示。 解码二维码当AVCaptureMetadataOutput识别出二维码时，AVCaptureMetadataOutputObjectsDelegate中的代理方法将被调用：optional public func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) 回调方法定义：123456789101112131415161718192021222324252627282930313233 func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) &#123; if metadataObjects == nil || metadataObjects.count == 0 &#123; qrCodeFrameView?.frame = CGRect.zero messageLabel.text = &quot;没有二维码/条形码&quot; return &#125; let metadataObj = metadataObjects[0] as! AVMetadataMachineReadableCodeObject if metadataObj.type == AVMetadataObjectTypeQRCode &#123; // 1 let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil &#123; // 2 messageLabel.text = metadataObj.stringValue &#125; &#125; &#125;``` + 第二个参数`metadataObjects`是个数组，就是所有被识别出来的元数据对象。如果这个参数为nil或数组为空数组，就表示没有识别出对象。 + 1 通过`transformedMetadataObject `方法获得`AVMetadataObject`对象，更加这个对象可以获得二维码的位置，然后显示绿框。 + 2 把二维码信息显示在messagelabel上。![](http://upload-images.jianshu.io/upload_images/1678135-815e15ae07a32822.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 识别条形码除了识别二维码以外，还可以识别条形码。只要在`captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode]`添加更多的元数据类型。，然后回调方法中修改检测类型就可以。 let supportedCodeTypes = [AVMetadataObjectTypeUPCECode, AVMetadataObjectTypeCode39Code, AVMetadataObjectTypeCode39Mod43Code, AVMetadataObjectTypeCode93Code, AVMetadataObjectTypeCode128Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeAztecCode, AVMetadataObjectTypePDF417Code, AVMetadataObjectTypeQRCode ] captureMetadataOutput.metadataObjectTypes = supportedCodeTypes // …. if supportedCodeTypes.contains(metadataObj.type) { let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil { messageLabel.text = metadataObj.stringValue } } ``` 代码QRCodeReader 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 1: 识别二维码（swift3）/]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS应用程序的状态]]></title>
    <url>%2F2017%2FiOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[iOS应用程序一共有五种状态： Not Running 程序还没运行 Inactive 程序运行在foreground但没有接收事件 Active 程序运行在foreground接收事件 Background 程序运行在background正在执行代码 Suspended 程序运行在background没有执行代码 iOS应用程序状态变化会回调APPDelegate中的方法，但不是每一种状态变化都会有对应的方法(上图的红框的两个变化就没有对应的方法) application:didFinishLaunchingWithOptions: Not Running -&gt; Inactive applicationDidBecomeActive: Inactive -&gt; Active applicationWillResignActive: Active -&gt; Inactive applicationDidEnterBackground: Background -&gt; Suspended applicationWillEnterForeground: Background -&gt; Inactive applicationWillTerminate: Suspended -&gt; Not Running 常见的应用状态变化场景 程序第一次启动（或者被杀掉以后启动）： Not Running -&gt; Inactive -&gt; Active 点击Home键（没有在Inof.plist中设置Application does not run in background）： Active -&gt; Inactive -&gt; Background -&gt; Suspended 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 挂起重新运行 Suspended -&gt; Background -&gt; Inactive -&gt; Active 内存清除（杀掉应用或删除应用） Suspended -&gt; Not Running 应用之间的切换 Active -&gt; Inactive Inactive -&gt; Active 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 可通过在APPDelegate的回调方法中打印数据，来查看应用状态变化 123456789101112131415161718192021222324252627282930func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; print(&quot;`application:didFinishLaunchingWithOptions:` Not Running -&gt; Inactive&quot;) return true&#125;func applicationWillResignActive(_ application: UIApplication) &#123; print(&quot;`applicationWillResignActive:` Active -&gt; Inactive&quot;)&#125;func applicationDidEnterBackground(_ application: UIApplication) &#123; print(&quot;`applicationDidEnterBackground:` Background -&gt; Suspended&quot;)&#125;func applicationWillEnterForeground(_ application: UIApplication) &#123; print(&quot;`applicationWillEnterForeground:` Background -&gt; Inactive&quot;)&#125;func applicationDidBecomeActive(_ application: UIApplication) &#123; print(&quot;`applicationDidBecomeActive:` Inactive -&gt; Active&quot;)&#125;func applicationWillTerminate(_ application: UIApplication) &#123; print(&quot;`applicationWillTerminate:` Suspended -&gt; Not Running&quot;)&#125; 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS应用程序的状态/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
</search>