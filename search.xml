<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python基础总结]]></title>
    <url>%2F2019%2Fpython-base.html</url>
    <content type="text"><![CDATA[一、类型和运算寻求帮助12dir(obj) # 简单的列出对象obj所包含的方法名称，返回一个字符串列表help(obj.func) # 查询obj.func的具体介绍和用法 测试类型的三种方法推荐第三种 123456if type(L) == type([]): print("L is list")if type(L) == list: print("L is list")if isinstance(L, list): print("L is list") Python数据类型：哈希类型、不可哈希类型 哈希类型，即在原地不能改变的变量类型，不可变类型。可利用hash函数查看其hash值，也可以作为字典的key数字类型：int, float, decimal.Decimal, fractions.Fraction, complex字符串类型：str, bytes元组：tuple冻结集合：frozenset布尔类型：True, FalseNone 不可哈希类型，原地可变类型：list、dict和set。它们不可以作为字典的key。 数字常量123456781234, -1234, 0, 999999999 # 整数1.23, 1., 3.14e-10, 4E210, 4.0e+210 # 浮点数0o177, 0x9ff, 0X9FF, 0b101010 # 八进制、十六进制、二进制数字3+4j, 3.0+4.0j, 3J # 复数常量，也可以用complex(real, image)来创建hex(I), oct(I), bin(I) # 将十进制数转化为十六进制、八进制、二进制表示的“字符串”int(string, base) # 将字符串转化为整数，base为进制数# 2.x中，有两种整数类型：一般整数（32位）和长整数（无穷精度）。可以用l或L结尾，迫使一般整数成为长整数float('inf'), float('-inf'), float('nan') # 无穷大, 无穷小, 非数 数字的表达式操作符1234567891011121314yield x # 生成器函数发送协议lambda args: expression # 生成匿名函数x if y else z # 三元选择表达式x and y, x or y, not x # 逻辑与、逻辑或、逻辑非x in y, x not in y # 成员对象测试x is y, x is not y # 对象实体测试x&lt;y, x&lt;=y, x&gt;y, x&gt;=y, x==y, x!=y # 大小比较，集合子集或超集值相等性操作符1 &lt; a &lt; 3 # Python中允许连续比较x|y, x&amp;y, x^y # 位或、位与、位异或x&lt;&lt;y, x&gt;&gt;y # 位操作：x左移、右移y位+, -, *, /, //, %, ** # 真除法、floor除法：返回不大于真除法结果的整数值、取余、幂运算-x, +x, ~x # 一元减法、识别、按位求补（取反）x[i], x[i:j:k] # 索引、分片、调用int(3.14), float(3) # 强制类型转换 整数可以利用bit_length函数测试所占的二进制位数12a = 1; a.bit_length() # 1a = 1024; a.bit_length() # 11 repr和str显示格式的区别repr格式：默认的交互模式回显，产生的结果看起来它们就像是代码。str格式：打印语句，转化成一种对用户更加友好的格式。 数字相关的模块 math模块 Decimal模块：小数模块 1234import decimalfrom decimal import DecimalDecimal("0.01") + Decimal("0.02") # 返回Decimal("0.03")decimal.getcontext().prec = 4 # 设置全局精度为4 即小数点后边4位 Fraction模块：分数模块 123from fractions import Fractionx = Fraction(4, 6) # 分数类型 4/6x = Fraction("0.25") # 分数类型 1/4 接收字符串类型的参数 集合setset是一个无序不重复元素集, 基本功能包括关系测试和消除重复元素。set支持union(联合), intersection(交), difference(差)和symmetric difference(对称差集)等数学运算。set支持x in set, len(set), for x in set。set不记录元素位置或者插入点, 因此不支持indexing, slicing, 或其它类序列的操作 12345678910111213141516s = set([3,5,9,10]) # 创建一个数值集合，返回&#123;3, 5, 9, 10&#125;t = set("Hello") # 创建一个唯一字符的集合返回&#123;&#125;a = t | s; t.union(s) # t 和 s的并集b = t &amp; s; t.intersection(s) # t 和 s的交集c = t – s; t.difference(s) # 求差集（项在t中, 但不在s中）d = t ^ s; t.symmetric_difference(s) # 对称差集（项在t或s中, 但不会同时出现在二者中）t.add('x'); t.remove('H') # 增加/删除一个items.update([10,37,42]) # 利用[......]更新s集合x in s, x not in s # 集合中是否存在某个值s.issubset(t); s &lt;= t # 测试是否 s 中的每一个元素都在 t 中s.issuperset(t); s &gt;= t # 测试是否 t 中的每一个元素都在 s 中 s.copy(); s.discard(x); # 删除s中xs.clear() # 清空s&#123;x**2 for x in [1, 2, 3, 4]&#125; # 集合解析，结果：&#123;16, 1, 4, 9&#125;&#123;x for x in 'spam'&#125; # 集合解析，结果：&#123;'a', 'p', 's', 'm'&#125; 集合frozenset，不可变对象set是可变对象，即不存在hash值，不能作为字典的键值。同样的还有list等(tuple是可以作为字典key的)frozenset是不可变对象，即存在hash值，可作为字典的键值frozenset对象没有add、remove等方法，但有union/intersection/difference等方法 1234a = set([1, 2, 3])b = set()b.add(a) # error: set是不可哈希类型b.add(frozenset(a)) # ok，将set变为frozenset，可哈希 布尔类型bool123type(True) # 返回&lt;class 'bool'&gt;isinstance(False, int) # bool类型属于整型，所以返回TrueTrue == 1; True is 1 # 输出(True, False) 动态类型简介变量名通过引用，指向对象。Python中的“类型”属于对象，而不是变量，每个对象都包含有头部信息，比如”类型标示符” “引用计数器”等 共享引用及在原处修改：对于可变对象，要注意尽量不要共享引用！共享引用和相等测试： 12L = [1], M = [1], L is M # 返回FalseL = M = [1, 2, 3], L is M # 返回True，共享引用 增强赋值和共享引用：普通+号会生成新的对象，而增强赋值+=会在原处修改 123L = M = [1, 2]L = L + [3, 4] # L = [1, 2, 3, 4], M = [1, 2]L += [3, 4] # L = [1, 2, 3, 4], M = [1, 2, 3, 4] 常见字符串常量和表达式12345678910111213S = '' # 空字符串S = "spam’s" # 双引号和单引号相同S = "s\np\ta\x00m" # 转义字符S = """spam""" # 三重引号字符串，一般用于函数说明S = r'\temp' # Raw字符串，不会进行转义，抑制转义S = b'Spam' # Python3中的字节字符串S = u'spam' # Python2.6中的Unicode字符串s1+s2, s1*3, s[i], s[i:j], len(s) # 字符串操作'a %s parrot' % 'kind' # 字符串格式化表达式'a &#123;1&#125; &#123;0&#125; parrot'.format('kind', 'red')# 字符串格式化方法for x in s: print(x) # 字符串迭代，成员关系[x*2 for x in s] # 字符串列表解析','.join(['a', 'b', 'c']) # 字符串输出，结果：a,b,c 内置str处理函数：1234567891011121314151617181920str1 = "stringobject"str1.upper(); str1.lower(); str1.swapcase(); str1.capitalize(); str1.title() # 全部大写，全部小写、大小写转换，首字母大写，每个单词的首字母都大写str1.ljust(width) # 获取固定长度，左对齐，右边不够用空格补齐str1.rjust(width) # 获取固定长度，右对齐，左边不够用空格补齐str1.center(width) # 获取固定长度，中间对齐，两边不够用空格补齐str1.zfill(width) # 获取固定长度，右对齐，左边不足用0补齐str1.find('t',start,end) # 查找字符串，可以指定起始及结束位置搜索str1.rfind('t') # 从右边开始查找字符串str1.count('t') # 查找字符串出现的次数#上面所有方法都可用index代替，不同的是使用index查找不到会抛异常，而find返回-1str1.replace('old','new') # 替换函数，替换old为new，参数中可以指定maxReplaceTimes，即替换指定次数的old为newstr1.strip(); # 默认删除空白符str1.strip('d'); # 删除str1字符串中开头、结尾处，位于 d 删除序列的字符str1.lstrip();str1.lstrip('d'); # 删除str1字符串中开头处，位于 d 删除序列的字符str1.rstrip();str1.rstrip('d') # 删除str1字符串中结尾处，位于 d 删除序列的字符str1.startswith('start') # 是否以start开头str1.endswith('end') # 是否以end结尾str1.isalnum(); str1.isalpha(); str1.isdigit(); str1.islower(); str1.isupper() # 判断字符串是否全为字符、数字、小写、大写 三重引号编写多行字符串块，并且在代码折行处嵌入换行字符\n1234mantra = """hello world hello python hello my friend"""# mantra为"""hello world \n hello python \n hello my friend""" 索引和分片：12S[0], S[len(S)–1], S[-1] # 索引S[1:3], S[1:], S[:-1], S[1:10:2] # 分片，第三个参数指定步长，如`S[1:10:2]`是从1位到10位没隔2位获取一个字符。 字符串转换工具：12345int('42'), str(42) # 返回(42, '42')float('4.13'), str(4.13) # 返回(4.13, '4.13')ord('s'), chr(115) # 返回(115, 's')int('1001', 2) # 将字符串作为二进制数字，转化为数字，返回9bin(13), oct(13), hex(13) # 将整数转化为二进制/八进制/十六进制字符串，返回('0b1101', '015', '0xd') 另类字符串连接name = &quot;Andy&quot; &quot;Ron&quot; # 单行，name = &quot;AndyRon&quot; name = &quot;Andy&quot; \ &quot;Ron&quot; # 多行，name = &quot;AndyRon&quot; Python中的字符串格式化实现1–字符串格式化表达式基于C语言print模型，并且在大多数的现有的语言中使用。通用结构：%[(name)][flag][width].[precision]typecode 12345678"this is %d %s bird" % (1, 'dead') # 一般的格式化表达式"%s---%s---%s" % (42, 3.14, [1, 2, 3]) # 字符串输出：'42---3.14---[1, 2, 3]'"%d...%6d...%-6d...%06d" % (1234, 1234, 1234, 1234) # 对齐方式及填充："1234... 1234...1234 ...001234"x = 1.23456789"%e | %f | %g" % (x, x, x) # 对齐方式："1.234568e+00 | 1.234568 | 1.23457""%6.2f*%-6.2f*%06.2f*%+6.2f" % (x, x, x, x) # 对齐方式：' 1.23*1.23 *001.23* +1.23'"%(name1)d---%(name2)s" % &#123;"name1":23, "name2":"value2"&#125; # 基于字典的格式化表达式"%(name)s is %(age)d" % vars() # vars()函数调用返回一个字典，包含了所有本函数调用时存在的变量 Python中的字符串格式化实现2–字符串格式化调用方法普通调用 123"&#123;0&#125;, &#123;1&#125; and &#123;2&#125;".format('spam', 'ham', 'eggs') # 基于位置的调用"&#123;motto&#125; and &#123;pork&#125;".format(motto = 'spam', pork = 'ham') # 基于Key的调用"&#123;motto&#125; and &#123;0&#125;".format('ham', motto = 'spam') # 混合调用 添加键 属性 偏移量 (import sys) 123"my &#123;1[spam]&#125; runs &#123;0.platform&#125;".format(sys, &#123;'spam':'laptop'&#125;) # 基于位置的键和属性"&#123;config[spam]&#125; &#123;sys.platform&#125;".format(sys = sys, config = &#123;'spam':'laptop'&#125;) # 基于Key的键和属性"first = &#123;0[0]&#125;, second = &#123;0[1]&#125;".format(['A', 'B', 'C']) # 基于位置的偏移量 具体格式化 12"&#123;0:e&#125;, &#123;1:.3e&#125;, &#123;2:g&#125;".format(3.14159, 3.14159, 3.14159) # 输出'3.141590e+00, 3.142e+00, 3.14159'"&#123;fieldname:format_spec&#125;".format(......) 说明:12345678fieldname是指定参数的一个数字或关键字, 后边可跟可选的".name"或"[index]"成分引用format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type]fill ::= &lt;any character&gt; #填充字符align ::= "&lt;" | "&gt;" | "=" | "^" #对齐方式sign ::= "+" | "-" | " " #符号说明width ::= integer #字符串宽度precision ::= integer #浮点数精度type ::= "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g" | "G" | "n" | "o" | "s" | "x" | "X" | "%" 例子: 123456'=&#123;0:10&#125; = &#123;1:10&#125;'.format('spam', 123.456) # 输出'=spam = 123.456''=&#123;0:&gt;10&#125;='.format('test') # 输出'= test=''=&#123;0:&lt;10&#125;='.format('test') # 输出'=test =''=&#123;0:^10&#125;='.format('test') # 输出'= test =''&#123;0:X&#125;, &#123;1:o&#125;, &#123;2:b&#125;'.format(255, 255, 255) # 输出'FF, 377, 11111111''My name is &#123;0:&#123;1&#125;&#125;.'.format('Fred', 8) # 输出'My name is Fred .' 动态指定参数 常用列表常量和操作1234567891011121314151617L = [[1, 2], 'string', &#123;&#125;] # 嵌套列表L = list('spam') # 列表初始化L = list(range(0, 4)) # 列表初始化list(map(ord, 'spam')) # 列表解析len(L) # 求列表长度L.count(value) # 求列表中某个值的个数L.append(obj) # 向列表的尾部添加数据，比如append(2)，添加元素2L.insert(index, obj) # 向列表的指定index位置添加数据，index及其之后的数据后移L.extend(interable) # 通过添加iterable中的元素来扩展列表，比如extend([2])，添加元素2，注意和append的区别L.index(value, [start, [stop]]) # 返回列表中值value的第一个索引L.pop([index]) # 删除并返回index处的元素，默认为删除并返回最后一个元素L.remove(value) # 删除列表中的value值，只删除第一次出现的value的值L.reverse() # 反转列表L.sort(cmp=None, key=None, reverse=False) # 排序列表a = [1, 2, 3], b = a[10:] # 注意，这里不会引发IndexError异常，只会返回一个空的列表[]a = [], a += [1] # 这里实在原有列表的基础上进行操作，即列表的id没有改变a = [], a = a + [1] # 这里最后的a要构建一个新的列表，即a的id发生了变化 用切片来删除序列的某一段1234a = [1, 2, 3, 4, 5, 6, 7]a[1:4] = [] # a = [1, 5, 6, 7]a = [0, 1, 2, 3, 4, 5, 6, 7]del a[::2] # 去除偶数项(偶数索引的)，a = [1, 3, 5, 7] 常用字典常量和操作12345678910111213141516171819D = &#123;&#125;D = &#123;'spam':2, 'tol':&#123;'ham':1&#125;&#125; # 嵌套字典D = dict.fromkeys(['s', 'd'], 8) # &#123;'s': 8, 'd': 8&#125;D = dict(name = 'tom', age = 12) # &#123;'age': 12, 'name': 'tom'&#125;D = dict([('name', 'tom'), ('age', 12)]) # &#123;'age': 12, 'name': 'tom'&#125;D = dict(zip(['name', 'age'], ['tom', 12])) # &#123;'age': 12, 'name': 'tom'&#125;D.keys(); D.values(); D.items() # 字典键、值以及键值对D.get(key, default) # get函数D.update(D_other) # 合并字典，如果存在相同的键值，D_other的数据会覆盖掉D的数据D.pop(key, [D]) # 删除字典中键值为key的项，返回键值为key的值，如果不存在，返回默认值D，否则异常D.popitem() # pop字典中随机的一项（一个键值对）D.setdefault(k[, d]) # 设置D中某一项的默认值。如果k存在，则返回D[k]，否则设置D[k]=d，同时返回D[k]。del D # 删除字典del D['key'] # 删除字典的某一项if key in D: if key not in D: # 测试字典键是否存在# 字典注意事项：（1）对新索引赋值会添加一项（2）字典键不一定非得是字符串，也可以为任何的不可变对象# 不可变对象：调用对象自身的任意方法，也不会改变该对象自身的内容，这些方法会创建新的对象并返回。# 字符串、整数、tuple都是不可变对象，dict、set、list都是可变对象D[(1,2,3)] = 2 # tuple作为字典的key 字典解析12D = &#123;k:8 for k in ['s', 'd']&#125; # &#123;'s': 8, 'd': 8&#125;D = &#123;k:v for (k, v) in zip(['name', 'age'], ['tom', 12])&#125; # &#123;'age': 12, 'name': tom&#125; 字典的特殊方法missing：当查找找不到key时，会执行该方法1234567class Dict(dict): def __missing__(self, key): self[key] = [] return self[key]dct = Dict()dct["foo"].append(1) # 这有点类似于collections.defalutdictdct["foo"] # [1] 元组和列表的唯一区别在于元组是不可变对象，列表时可变对象1234a = [1, 2, 3] # a[1] = 0, OKa = (1, 2, 3) # a[1] = 0, Errora = ([1, 2]) # a[0][1] = 0, OKa = [(1, 2)] # a[0][1] = 0, Error 元组的特殊语法: 逗号和圆括号D = (12) # 此时D为一个整数 即D = 12 D = (12, ) # 此时D为一个元组 即D = (12, ) 文件基本操作1234567891011121314151617181920212223output = open(r'C:\spam', 'w') # 打开输出文件，用于写input = open('data', 'r') # 打开输入文件，用于读。打开的方式可以为'w', 'r', 'a', 'wb', 'rb', 'ab'等fp.read([size]) # size为读取的长度，以byte为单位fp.readline([size]) # 读一行，如果定义了size，有可能返回的只是一行的一部分fp.readlines([size]) # 把文件每一行作为一个list的一个成员，并返回这个list。其实它的内部是通过循环调用readline()来实现的。如果提供size参数，size是表示读取内容的总长。fp.readable() # 是否可读fp.write(str) # 把str写到文件中，write()并不会在str后加上一个换行符fp.writelines(seq) # 把seq的内容全部写到文件中(多行一次性写入)fp.writeable() # 是否可写fp.close() # 关闭文件。fp.flush() # 把缓冲区的内容写入硬盘fp.fileno() # 返回一个长整型的”文件标签“fp.isatty() # 文件是否是一个终端设备文件（unix系统中的）fp.tell() # 返回文件操作标记的当前位置，以文件的开头为原点fp.next() # 返回下一行，并将文件操作标记位移到下一行。把一个file用于for … in file这样的语句时，就是调用next()函数来实现遍历的。fp.seek(offset[,whence]) # 将文件打操作标记移到offset的位置。whence可以为0表示从头开始计算，1表示以当前位置为原点计算。2表示以文件末尾为原点进行计算。fp.seekable() # 是否可以seekfp.truncate([size]) # 把文件裁成规定的大小，默认的是裁到当前文件操作标记的位置。for line in open('data'): print(line) # 使用for语句，比较适用于打开比较大的文件open('f.txt', encoding = 'latin-1') # Python3.x Unicode文本文件open('f.bin', 'rb') # Python3.x 二进制bytes文件# 文件对象还有相应的属性：buffer closed encoding errors line_buffering name newlines等 其他Python中的真假值含义：1. 数字如果非零，则为真，0为假。 2. 其他对象如果非空，则为真通常意义下的类型分类：1. 数字、序列、映射。 2. 可变类型和不可变类型 二、语法和语句赋值语句的形式1234567spam = 'spam' # 基本形式spam, ham = 'spam', 'ham' # 元组赋值形式[spam, ham] = ['s', 'h'] # 列表赋值形式a, b, c, d = 'abcd' # 序列赋值形式a, *b, c = 'spam' # 序列解包形式（Python3.x中才有）spam = ham = 'no' # 多目标赋值运算，涉及到共享引用spam += 42 # 增强赋值，涉及到共享引用 序列赋值 序列解包123456[a, b, c] = (1, 2, 3) # a = 1, b = 2, c = 3a, b, c, d = "spam" # a = 's', b = 'p', c = 'a', d = 'm'a, b, c = range(3) # a = 0, b = 1, c = 2a, *b = [1, 2, 3, 4] # a = 1, b = [2, 3, 4]*a, b = [1, 2, 3, 4] # a = [1, 2, 3], b = 4a, *b, c = [1, 2, 3, 4] # a = 1, b = [2, 3], c = 4 带有*时 会优先匹配*之外的变量，如1a, *b, c = [1, 2] # a = 1, c = 2, b = [] print函数原型12345678print(value, ..., sep=' ', end='\n', file=sys.stdout, flush=False)# 流的重定向print('hello world') # 等于sys.stdout.write('hello world')temp = sys.stdout # 原有流的保存sys.stdout = open('log.log', 'a') # 流的重定向print('hello world') # 写入到文件log.logsys.stdout.close()sys.stdout = temp # 原有流的复原 and，orPython中and或or总是返回对象(左边的对象或右边的对象) 且具有短路求值的特性 121 or 2 or 3 # 返回 11 and 2 and 3 # 返回 3 if/else三元表达符（if语句在行内）1234A = 1 if X else 2A = 1 if X else (2 if Y else 3)# 也可以使用and-or语句（一条语句实现多个if-else）result = (a &gt; 20 and "big than 20" or a &gt; 10 and "big than 10" or a &gt; 5 and "big than 5") while，forPython的while语句或者for语句可以带else语句 当然也可以带continue/break/pass语句 123456789while a &gt; 1: anythingelse: anything# else语句会在循环结束后执行，除非在循环中执行了break，同样的还有for语句for i in range(5): anythingelse: anything for循环的元组赋值1234for (a, b) in [(1, 2), (3, 4)]: # 最简单的赋值for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: # 自动解包赋值for ((a, b), c) in [((1, 2), 3), ("XY", 6)]: # 自动解包 a = X, b = Y, c = 6for (a, *b) in [(1, 2, 3), (4, 5, 6)]: # 自动解包赋值 列表解析语法123456M = [[1,2,3], [4,5,6], [7,8,9]]res = [sum(row) for row in M] # G = [6, 15, 24] 一般的列表解析 生成一个列表res = [c * 2 for c in 'spam'] # ['ss', 'pp', 'aa', 'mm']res = [a * b for a in [1, 2] for b in [4, 5]] # 多解析过程 返回[4, 5, 8, 10]res = [a for a in [1, 2, 3] if a &lt; 2] # 带判断条件的解析过程res = [a if a &gt; 0 else 0 for a in [-1, 0, 1]] # 带判断条件的高级解析过程 两个列表同时解析：使用zip函数12for teama, teamb in zip(["Packers", "49ers"], ["Ravens", "Patriots"]): print(teama + " vs. " + teamb) 输出：12Packers vs. Ravens49ers vs. Patriots 带索引的列表解析：使用enumerate函数12for index, team in enumerate(["Packers", "49ers", "Ravens", "Patriots"]): print(index, team) 输出： 12340 Packers1 49ers2 Ravens3 Patriots 生成器表达式1234G = (sum(row) for row in M) # 使用小括号可以创建所需结果的生成器generator objectnext(G), next(G), next(G) # 输出(6, 15, 24)G = &#123;sum(row) for row in M&#125; # G = &#123;6, 15, 24&#125; 解析语法还可以生成集合和字典G = &#123;i:sum(M[i]) for i in range(3)&#125; # G = &#123;0: 6, 1: 15, 2: 24&#125; 文档字符串出现在Module的开端以及其中函数或类的开端 使用三重引号字符串 123456789101112131415"""module document"""def func(): """ function document """ print()class Employee: """ class document """ print()print(func.__doc__) # 输出函数文档字符串print(Employee.__doc__) # 输出类的文档字符串 命名惯例以单一下划线开头的变量名(_X)不会被from module import*等语句导入 前后有两个下划线的变量名(__X__)是系统定义的变量名，对解释器有特殊意义 以两个下划线开头但不以下划线结尾的变量名(__X)是类的本地(私有)变量 列表解析 in成员关系测试 map sorted zip enumerate内置函数等都使用了迭代协议1234'first line' in open('test.txt') # in测试 返回True或Falselist(map(str.upper, open('t'))) # map内置函数sorted(iter([2, 5, 8, 3, 1])) # sorted内置函数list(zip([1, 2], [3, 4])) # zip内置函数 [(1, 3), (2, 4)] del语句: 手动删除某个变量1del X 获取列表的子表的方法:123456x = [1,2,3,4,5,6]x[:3] # 前3个[1,2,3]x[1:5] # 中间4个[2,3,4,5]x[-3:] # 最后3个[4,5,6]x[::2] # 奇数项[1,3,5]x[1::2] # 偶数项[2,4,6] 手动迭代：iter和next12345L = [1, 2]I = iter(L) # I为L的迭代器I.next() # 返回1I.next() # 返回2I.next() # Error:StopIteration Python中的可迭代对象&quot;&quot;&quot; 1.range迭代器 2.map、zip和filter迭代器 3.字典视图迭代器：D.keys()), D.items()等 4.文件类型 &quot;&quot;&quot; 三、函数语法规则函数相关的语句和表达式1234567myfunc('spam') # 函数调用def myfunc(): # 函数定义return None # 函数返回值global a # 全局变量(在函数内部使用全局变量)nonlocal x # 在函数或其他作用域中使用外层（非全局）变量yield x # 生成器函数返回lambda # 匿名函数 Python函数变量名解析:LEGB原则local(functin) --&gt; encloseing function locals --&gt; global(module) --&gt; build-in(python) 说明:以下边的函数maker为例 则相对于action而言 X为Local N为Encloseing 嵌套函数举例:工厂函数123456def maker(N): def action(X): return X ** N return actionf = maker(2) # pass 2 to Nf(3) # 9, pass 3 to X 嵌套函数举例:lambda实例12345def maker(N): action = (lambda X: X**N) return actionf = maker(2) # pass 2 to Nf(3) # 9, pass 3 to X nonlocal和global语句的区别123456789101112131415# nonlocal应用于一个嵌套的函数的作用域中的一个名称 例如:start = 100def tester(start): def nested(label): nonlocal start # 指定start为tester函数内的local变量 而不是global变量start print(label, start) start += 3 return nested# global为全局的变量 即def之外的变量def tester(start): def nested(label): global start # 指定start为global变量start print(label, start) start += 3 return nested 函数参数：不可变参数通过“值”传递，可变参数通过“引用”传递1234567def f(a, b, c): print(a, b, c)f(1, 2, 3) # 参数位置匹配f(1, c = 3, b = 2) # 参数关键字匹配def f(a, b=1, c=2): print(a, b, c)f(1) # 默认参数匹配f(1, 2) # 默认参数匹配f(a = 1, c = 3) # 关键字参数和默认参数的混合 Keyword-Only参数:出现在*args之后 必须用关键字进行匹配 123def keyOnly(a, *b, c): print('') # c就为keyword-only匹配 必须使用关键字c = value匹配def keyOnly(a, *, b, c): ...... # b c为keyword-only匹配 必须使用关键字匹配def keyOnly(a, *, b = 1): ...... # b有默认值 或者省略 或者使用关键字参数b = value 可变参数匹配: * 和 **123456def f(*args): print(args) # 在元组中收集不匹配的位置参数f(1, 2, 3) # 输出(1, 2, 3)def f(**args): print(args) # 在字典中收集不匹配的关键字参数f(a = 1, b = 2) # 输出&#123;'a':1, 'b':2&#125;def f(a, *b, **c): print(a, b, c) # 两者混合使用f(1, 2, 3, x=4, y=5) # 输出1, (2, 3), &#123;'x':4, 'y':5&#125; 函数调用时的参数解包: * 和 ** 分别解包元组和字典123func(1, *(2, 3)) &lt;==&gt; func(1, 2, 3)func(1, **&#123;'c':3, 'b':2&#125;) &lt;==&gt; func(1, b = 2, c = 3)func(1, *(2, 3), **&#123;'c':3, 'b':2&#125;) &lt;==&gt; func(1, 2, 3, b = 2, c = 3) 函数属性:(自己定义的)函数可以添加属性123def func():.....func.count = 1 # 自定义函数添加属性print.count = 1 # Error 内置函数不可以添加属性 函数注解: 编写在def头部行 主要用于说明参数范围、参数类型、返回值类型等123456def func(a:'spam', b:(1, 10), c:float) -&gt; int : print(a, b, c)func.__annotations__ # &#123;'c':&lt;class 'float'&gt;, 'b':(1, 10), 'a':'spam', 'return':&lt;class 'int'&gt;&#125;# 编写注解的同时 还是可以使用函数默认值 并且注解的位置位于=号的前边def func(a:'spam'='a', b:(1, 10)=2, c:float=3) -&gt; int : print(a, b, c) 匿名函数:lambda12345f = lambda x, y, z : x + y + z # 普通匿名函数，使用方法f(1, 2, 3)f = lambda x = 1, y = 1: x + y # 带默认参数的lambda函数def action(x): # 嵌套lambda函数 return (lambda y : x + y)f = lambda: a if xxx() else b # 无参数的lambda函数，使用方法f() lambda函数与map filter reduce函数的结合1234list(map((lambda x: x + 1), [1, 2, 3])) # [2, 3, 4]list(filter((lambda x: x &gt; 0), range(-4, 5))) # [1, 2, 3, 4]functools.reduce((lambda x, y: x + y), [1, 2, 3]) # 6functools.reduce((lambda x, y: x * y), [2, 3, 4]) # 24 生成器函数:yield VS return123456789def gensquare(N): for i in range(N): yield i** 2 # 状态挂起 可以恢复到此时的状态for i in gensquare(5): # 使用方法 print(i, end = ' ') # [0, 1, 4, 9, 16]x = gensquare(2) # x是一个生成对象next(x) # 等同于x.__next__() 返回0next(x) # 等同于x.__next__() 返回1next(x) # 等同于x.__next__() 抛出异常StopIteration 生成器表达式:小括号进行列表解析12345678910111213G = (x ** 2 for x in range(3)) # 使用小括号可以创建所需结果的生成器generator objectnext(G), next(G), next(G) # 和上述中的生成器函数的返回值一致#（1）生成器(生成器函数/生成器表达式)是单个迭代对象G = (x ** 2 for x in range(4))I1 = iter(G) # 这里实际上iter(G) = Gnext(I1) # 输出0next(G) # 输出1next(I1) # 输出4#（2）生成器不保留迭代后的结果gen = (i for i in range(4))2 in gen # 返回True3 in gen # 返回True1 in gen # 返回False，其实检测2的时候，1已经就不在生成器中了，即1已经被迭代过了，同理2、3也不在了 本地变量是静态检测的12345678910X = 22 # 全局变量X的声明和定义def test(): print(X) # 如果没有下一语句 则该句合法 打印全局变量X X = 88 # 这一语句使得上一语句非法 因为它使得X变成了本地变量 上一句变成了打印一个未定义的本地变量(局部变量) if False: # 即使这样的语句 也会把print语句视为非法语句 因为: X = 88 # Python会无视if语句而仍然声明了局部变量Xdef test(): # 改进 global X # 声明变量X为全局变量 print(X) # 打印全局变量X X = 88 # 改变全局变量X 函数的默认值是在函数定义的时候实例化的 而不是在调用的时候 例子:12345678910111213141516171819def foo(numbers=[]): # 这里的[]是可变的 numbers.append(9) print(numbers)foo() # first time, like before, [9]foo() # second time, not like before, [9, 9]foo() # third time, not like before too, [9, 9, 9]# 改进:def foo(numbers=None): if numbers is None: numbers = [] numbers.append(9) print(numbers)# 另外一个例子 参数的默认值为不可变的:def foo(count=0): # 这里的0是数字, 是不可变的 count += 1 print(count)foo() # 输出1foo() # 还是输出1foo(3) # 输出4foo() # 还是输出1 四、函数例子数学运算类1234567891011121314151617abs(x) # 求绝对值，参数可以是整型，也可以是复数，若参数是复数，则返回复数的模complex([real[, imag]]) # 创建一个复数divmod(a, b) # 分别取商和余数，注意：整型、浮点型都可以float([x]) # 将一个字符串或数转换为浮点数。如果无参数将返回0.0int([x[, base]]) # 将一个字符串或浮点数转换为int类型，base表示进制long([x[, base]]) # 将一个字符串或浮点数转换为long类型pow(x, y) # 返回x的y次幂range([start], stop[, step]) # 产生一个序列，默认从0开始round(x[, n]) # 四舍五入sum(iterable[, start]) # 对集合求和oct(x) # 将一个数字转化为8进制字符串hex(x) # 将一个数字转换为16进制字符串chr(i) # 返回给定int类型对应的ASCII字符unichr(i) # 返回给定int类型的unicodeord(c) # 返回ASCII字符对应的整数bin(x) # 将整数x转换为二进制字符串bool([x]) # 将x转换为Boolean类型 集合类操作12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273basestring() # str和unicode的超类，不能直接调用，可以用作isinstance判断format(value [, format_spec]) # 格式化输出字符串，格式化的参数顺序从0开始，如“I am &#123;0&#125;,I like &#123;1&#125;”enumerate(sequence[, start=0]) # 返回一个可枚举的对象，注意它有第二个参数iter(obj[, sentinel]) # 生成一个对象的迭代器，第二个参数表示分隔符max(iterable[, args...][key]) # 返回集合中的最大值min(iterable[, args...][key]) # 返回集合中的最小值dict([arg]) # 创建数据字典list([iterable]) # 将一个集合类转换为另外一个集合类set() # set对象实例化frozenset([iterable]) # 产生一个不可变的settuple([iterable]) # 生成一个tuple类型str([object]) # 转换为string类型sorted(iterable[, cmp[, key[, reverse]]]) # 集合排序 L = [('b',2),('a',1),('c',3),('d',4)] sorted(L, key=lambda x: x[1]), reverse=True) # 使用Key参数和reverse参数 sorted(L, key=lambda x: (x[0], x[1])) # 使用key参数进行多条件排序，即如果x[0]相同，则比较x[1]"""逻辑判断"""all(iterable) # 集合中的元素都为真的时候为真，特别的，若为空串返回为Trueany(iterable) # 集合中的元素有一个为真的时候为真，特别的，若为空串返回为Falsecmp(x, y) # 如果x &lt; y ,返回负数；x == y, 返回0；x &gt; y,返回正数"""IO操作"""file(filename [, mode [, bufsize]]) # file类型的构造函数。input([prompt]) # 获取用户输入，推荐使用raw_input，因为该函数将不会捕获用户的错误输入raw_input([prompt]) # 设置输入，输入都是作为字符串处理open(name[, mode[, buffering]]) # 打开文件，与file有什么不同？推荐使用open"""其他"""callable(object) # 检查对象object是否可调用classmethod(func) # 用来说明这个func是个类方法staticmethod(func) # 用来说明这个func为静态方法dir([object]) # 不带参数时，返回当前范围内的变量、方法和定义的类型列表；带参数时，返回参数的属性、方法列表。help(obj) # 返回obj的帮助信息eval(expression) # 计算表达式expression的值，并返回exec(str) # 将str作为Python语句执行execfile(filename) # 用法类似exec()，不同的是execfile的参数filename为文件名，而exec的参数为字符串。filter(function, iterable) # 构造一个序列，等价于[item for item in iterable if function(item)]，function返回值为True或False的函数 list(filter(bool, range(-3, 4)))# 返回[-3, -2, -1, 1, 2, 3], 没有0hasattr(object, name) # 判断对象object是否包含名为name的特性getattr(object, name [, defalut]) # 获取一个类的属性setattr(object, name, value) # 设置属性值delattr(object, name) # 删除object对象名为name的属性globals() # 返回一个描述当前全局符号表的字典hash(object) # 如果对象object为哈希表类型，返回对象object的哈希值id(object) # 返回对象的唯一标识，一串数字isinstance(object, classinfo) # 判断object是否是class的实例 isinstance(1, int) # 判断是不是int类型 isinstance(1, (int, float)) # isinstance的第二个参数接受一个元组类型issubclass(class, classinfo) # 判断class是否为classinfo的子类locals() # 返回当前的变量列表map(function, iterable, ...) # 遍历每个元素，执行function操作 list(map(abs, range(-3, 4))) # 返回[3, 2, 1, 0, 1, 2, 3]next(iterator[, default]) # 类似于iterator.next()property([fget[, fset[, fdel[, doc]]]]) # 属性访问的包装类，设置后可以通过c.x=value等来访问setter和getterreduce(function, iterable[, initializer]) # 合并操作，从第一个开始是前两个参数，然后是前两个的结果与第三个合并进行处理，以此类推 def add(x,y):return x + y reduce(add, range(1, 11)) # 返回55 (注:1+2+3+4+5+6+7+8+9+10 = 55) reduce(add, range(1, 11), 20) # 返回75reload(module) # 重新加载模块repr(object) # 将一个对象变幻为可打印的格式slice(start, stop[, step]) # 产生分片对象type(object) # 返回该object的类型vars([object]) # 返回对象的变量名、变量值得字典 a = Class(); # Class为一个空类 a.name = 'qi', a.age = 9 vars(a) # &#123;'name':'qi', 'age':9&#125;zip([iterable, ...]) # 返回对应数组 list(zip([1, 2, 3], [4, 5, 6])) # [(1, 4), (2, 5), (3, 6)] a = [1, 2, 3], b = ["a", "b", "c"] z = zip(a, b) # 压缩：[(1, "a"), (2, "b"), (3, "c")] zip(*z) # 解压缩：[(1, 2, 3), ("a", "b", "c")]unicode(string, encoding, errors) # 将字符串string转化为unicode形式，string为encoded string。 ​ 五、模块MoudlePython模块搜索路径:(1)程序的主目录 (2)PYTHONPATH目录 (3)标准链接库目录 (4)任何.pth文件的内容 查看全部的模块搜索路径1234567891011import syssys.pathsys.argv # 获得脚本的参数sys.builtin_module_names # 查找内建模块sys.platform # 返回当前平台 出现如： "win32" "linux" "darwin"等sys.modules # 查找已导入的模块sys.modules.keys()sys.stdout # stdout 和 stderr 都是类文件对象，但是它们都是只写的。它们都没有 read 方法，只有 write 方法sys.stdout.write("hello")sys.stderrsys.stdin 模块的使用代码123import module1, module2 # 导入module1 使用module1.printer()from module1 import printer # 导入module1中的printer变量 使用printer()from module1 import * # 导入module1中的全部变量 使用不必添加module1前缀 重载模块reload这是一个内置函数 而不是一条语句 12from imp import reloadreload(module) 模块的包导入使用点号(.)而不是路径(dir1\dir2)进行导入 12import dir1.dir2.mod # d导入包(目录)dir1中的包dir2中的mod模块 此时dir1必须在Python可搜索路径中from dir1.dir2.mod import * # from语法的包导入 init.py包文件每个导入的包中都应该包含这么一个init__.py文件 该文件可以为空 首次进行包导入时， 该文件会自动执行 高级功能:在该文件中使用__all__列表来定义包(目录)以from*的形式导入时 需要导入什么 包相对导入:使用点号(.) 只能使用from语句123from . import spam # 导入当前目录下的spam模块（错误: 当前目录下的模块, 直接导入即可）from .spam import name # 导入当前目录下的spam模块的name属性（错误: 当前目录下的模块, 直接导入即可，不用加.）from .. import spam # 导入当前目录的父目录下的spam模块 包相对导入与普通导入的区别12from string import * # 这里导入的string模块为sys.path路径上的 而不是本目录下的string模块(如果存在也不是)from .string import * # 这里导入的string模块为本目录下的(不存在则导入失败) 而不是sys.path路径上的 模块数据隐藏:最小化from*的破坏12_X # 变量名前加下划线可以防止from*导入时该变量名被复制出去__all__ = ['x', 'x1', 'x2'] # 使用__all__列表指定from*时复制出去的变量名(变量名在列表中为字符串形式) 模块属性可以使用__name__进行模块的单元测试：当模块为顶层执行文件时值为__main__，当模块被导入时为模块名。 12if __name__ == '__main__':doSomething 模块属性中还有其他属性，例如：1234__doc__ # 模块的说明文档__file__ # 模块文件的文件名，包括全路径__name__ # 主文件或者被导入文件__package__ # 模块所在的包 import语句from语句的as扩展import modulename as name from modulename import attrname as name 得到模块属性的几种方法假设为了得到__name__属性的值 1234M.__name__M.__dict__['__name__']sys.modules['M'].__name__getattr(M, '__name__') 六、类与面向对象最普通的类1234567class C1(C2, C3): spam = 42 # 数据属性 def __init__(self, name): # 函数属性:构造函数 self.name = name def __del__(self): # 函数属性:析构函数 print("goodbey ", self.name) I1 = C1('bob') Python的类没有基于参数的函数重载12345class FirstClass: def test(self, string): print(string) def test(self): # 此时类中只有一个test函数 即后者test(self) 它覆盖掉前者带参数的test函数 print("hello world") 子类扩展超类: 尽量调用超类的方法1234class Manager(Person): def giveRaise(self, percent, bonus = .10): self.pay = int(self.pay*(1 + percent + bonus)) # 不好的方式 复制粘贴超类代码 Person.giveRaise(self, percent + bonus) # 好的方式 尽量调用超类方法 类内省工具1234bob = Person('bob')bob.__class__ # &lt;class 'Person'&gt;bob.__class__.__name__ # 'Person'bob.__dict__ # &#123;'pay':0, 'name':'bob', 'job':'Manager'&#125; 返回1中 数据属性spam是属于类 而不是对象123I1 = C1('bob'); I2 = C2('tom') # 此时I1和I2的spam都为42 但是都是返回的C1的spam属性C1.spam = 24 # 此时I1和I2的spam都为24I1.spam = 3 # 此时I1新增自有属性spam 值为2 I2和C1的spam还都为24 类方法调用的两种方式12instance.method(arg...)class.method(instance, arg...) 抽象超类的实现方法123456789101112# (1)某个函数中调用未定义的函数 子类中定义该函数 def delegate(self): self.action() # 本类中不定义action函数 所以使用delegate函数时就会出错# (2)定义action函数 但是返回异常 def action(self): raise NotImplementedError("action must be defined")# (3)上述的两种方法还都可以定义实例对象 实际上可以利用@装饰器语法生成不能定义的抽象超类 from abc import ABCMeta, abstractmethod class Super(metaclass = ABCMeta): @abstractmethod def action(self): pass x = Super() # 返回 TypeError: Can't instantiate abstract class Super with abstract methods action OOP和继承: “is-a”的关系12345678910111213141516171819class A(B): passa = A()isinstance(a, B) # 返回True, A是B的子类 a也是B的一种# OOP和组合: "has-a"的关系pass# OOP和委托: "包装"对象 在Python中委托通常是以"__getattr__"钩子方法实现的, 这个方法会拦截对不存在属性的读取# 包装类(或者称为代理类)可以使用__getattr__把任意读取转发给被包装的对象class wrapper: def __init__(self, object): self.wrapped = object def __getattr(self, attrname): print('Trace: ', attrname) return getattr(self.wrapped, attrname)# 注:这里使用getattr(X, N)内置函数以变量名字符串N从包装对象X中取出属性 类似于X.__dict__[N]x = wrapper([1, 2, 3])x.append(4) # 返回 "Trace: append" [1, 2, 3, 4]x = wrapper(&#123;'a':1, 'b':2&#125;)list(x.keys()) # 返回 "Trace: keys" ['a', 'b'] 类的伪私有属性:使用__attr123456789class C1: def __init__(self, name): self.__name = name # 此时类的__name属性为伪私有属性 原理 它会自动变成self._C1__name = name def __str__(self): return 'self.name = %s' % self.__nameI = C1('tom')print(I) # 返回 self.name = tomI.__name = 'jeey' # 这里无法访问 __name为伪私有属性I._C1__name = 'jeey' # 这里可以修改成功 self.name = jeey 类方法是对象:无绑定类方法对象 / 绑定实例方法对象123456789101112class Spam: def doit(self, message): print(message) def selfless(message) print(message)obj = Spam()x = obj.doit # 类的绑定方法对象 实例 + 函数x('hello world')x = Spam.doit # 类的无绑定方法对象 类名 + 函数x(obj, 'hello world')x = Spam.selfless # 类的无绑定方法是函数 在3.0之前无效x('hello world') 获取对象信息: 属性和方法12345678a = MyObject()dir(a) # 使用dir函数hasattr(a, 'x') # 测试是否有x属性或方法 即a.x是否已经存在setattr(a, 'y', 19) # 设置属性或方法 等同于a.y = 19getattr(a, 'z', 0) # 获取属性或方法 如果属性不存在 则返回默认值0#这里有个小技巧，setattr可以设置一个不能访问到的属性，即只能用getattr获取setattr(a, "can't touch", 100) # 这里的属性名带有空格，不能直接访问getattr(a, "can't touch", 0) # 但是可以用getattr获取 为类动态绑定属性或方法: MethodType方法1234567891011# 一般创建了一个class的实例后, 可以给该实例绑定任何属性和方法, 这就是动态语言的灵活性class Student(object): passs = Student()s.name = 'Michael' # 动态给实例绑定一个属性def set_age(self, age): # 定义一个函数作为实例方法 self.age = agefrom types import MethodTypes.set_age = MethodType(set_age, s) # 给实例绑定一个方法 类的其他实例不受此影响s.set_age(25) # 调用实例方法Student.set_age = MethodType(set_age, Student) # 为类绑定一个方法 类的所有实例都拥有该方法 ​ 七、类的高级话题多重继承“混合类”, 搜索方式”从下到上 从左到右 广度优先” 12class A(B, C): pass 类的继承和子类的初始化123456789101112131415161718# 1.子类定义了__init__方法时，若未显示调用基类__init__方法，python不会帮你调用。# 2.子类未定义__init__方法时，python会自动帮你调用首个基类的__init__方法，注意是首个。# 3.子类显示调用基类的初始化函数：class FooParent(object): def __init__(self, a): self.parent = 'I\'m the Parent.' print('Parent:a=' + str(a)) def bar(self, message): print(message + ' from Parent')class FooChild(FooParent): def __init__(self, a): FooParent.__init__(self, a) print('Child:a=' + str(a)) def bar(self, message): FooParent.bar(self, message) print(message + ' from Child')fooChild = FooChild(10)fooChild.bar('HelloWorld') 实例方法 / 静态方法 / 类方法12345678910111213class Methods: def imeth(self, x): print(self, x) # 实例方法：传入的是实例和数据，操作的是实例的属性 def smeth(x): print(x) # 静态方法：只传入数据 不传入实例，操作的是类的属性而不是实例的属性 def cmeth(cls, x): print(cls, x) # 类方法：传入的是类对象和数据 smeth = staticmethod(smeth) # 调用内置函数，也可以使用@staticmethod cmeth = classmethod(cmeth) # 调用内置函数，也可以使用@classmethodobj = Methods()obj.imeth(1) # 实例方法调用 &lt;__main__.Methods object...&gt; 1Methods.imeth(obj, 2) # &lt;__main__.Methods object...&gt; 2Methods.smeth(3) # 静态方法调用 3obj.smeth(4) # 这里可以使用实例进行调用Methods.cmeth(5) # 类方法调用 &lt;class '__main__.Methods'&gt; 5obj.cmeth(6) # &lt;class '__main__.Methods'&gt; 6 函数装饰器:是它后边的函数的运行时的声明，由@符号以及后边紧跟的”元函数”(metafunction)组成1234567891011@staticmethoddef smeth(x): print(x)# 等同于:def smeth(x): print(x)smeth = staticmethod(smeth)# 同理@classmethoddef cmeth(cls, x): print(x)# 等同于def cmeth(cls, x): print(x)cmeth = classmethod(cmeth) 类修饰器:是它后边的类的运行时的声明，由@符号以及后边紧跟的”元函数”(metafunction)组成123456def decorator(aClass):.....@decoratorclass C:....# 等同于:class C:....C = decorator(C) 限制class属性: slots属性12345class Student: __slots__ = ('name', 'age') # 限制Student及其实例只能拥有name和age属性# __slots__属性只对当前类起作用, 对其子类不起作用# __slots__属性能够节省内存# __slots__属性可以为列表list，或者元组tuple 类属性高级话题: @property123456789101112131415161718192021222324252627282930313233# 假设定义了一个类:C，该类必须继承自object类，有一私有变量_xclass C(object): def __init__(self): self.__x = None# 第一种使用属性的方法 def getx(self): return self.__x def setx(self, value): self.__x = value def delx(self): del self.__x x = property(getx, setx, delx, '')# property函数原型为property(fget=None,fset=None,fdel=None,doc=None)# 使用c = C()c.x = 100 # 自动调用setx方法y = c.x # 自动调用getx方法del c.x # 自动调用delx方法# 第二种方法使用属性的方法 @property def x(self): return self.__x @x.setter def x(self, value): self.__x = value @x.deleter def x(self): del self.__x# 使用c = C()c.x = 100 # 自动调用setter方法y = c.x # 自动调用x方法del c.x # 自动调用deleter方法 定制类: 重写类的方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546# (1)__str__方法、__repr__方法: 定制类的输出字符串# (2)__iter__方法、next方法: 定制类的可迭代性class Fib(object): def __init__(self): self.a, self.b = 0, 1 # 初始化两个计数器a，b def __iter__(self): return self # 实例本身就是迭代对象，故返回自己 def next(self): self.a, self.b = self.b, self.a + self.b if self.a &gt; 100000: # 退出循环的条件 raise StopIteration() return self.a # 返回下一个值for n in Fib(): print(n) # 使用# (3)__getitem__方法、__setitem__方法: 定制类的下标操作[] 或者切片操作sliceclass Indexer(object): def __init__(self): self.data = &#123;&#125; def __getitem__(self, n): # 定义getitem方法 print('getitem:', n) return self.data[n] def __setitem__(self, key, value): # 定义setitem方法 print('setitem:key = &#123;0&#125;, value = &#123;1&#125;'.format(key, value)) self.data[key] = valuetest = Indexer()test[0] = 1; test[3] = '3' # 调用setitem方法print(test[0]) # 调用getitem方法# (4)__getattr__方法: 定制类的属性操作class Student(object): def __getattr__(self, attr): # 定义当获取类的属性时的返回值 if attr=='age': return 25 # 当获取age属性时返回25 raise AttributeError('object has no attribute: %s' % attr) # 注意: 只有当属性不存在时 才会调用该方法 且该方法默认返回None 需要在函数最后引发异常s = Student()s.age # s中age属性不存在 故调用__getattr__方法 返回25# (5)__call__方法: 定制类的'可调用'性class Student(object): def __call__(self): # 也可以带参数 print('Calling......')s = Student()s() # s变成了可调用的 也可以带参数callable(s) # 测试s的可调用性 返回True# (6)__len__方法：求类的长度def __len__(self): return len(self.data) 动态创建类type()1234567891011121314# 一般创建类 需要在代码中提前定义 class Hello(object): def hello(self, name='world'): print('Hello, %s.' % name) h = Hello() h.hello() # Hello, world type(Hello) # Hello是一个type类型 返回&lt;class 'type'&gt; type(h) # h是一个Hello类型 返回&lt;class 'Hello'&gt;# 动态类型语言中 类可以动态创建 type函数可用于创建新类型 def fn(self, name='world'): # 先定义函数 print('Hello, %s.' % name) Hello = type('Hello', (object,), dict(hello=fn)) # 创建Hello类 type原型: type(name, bases, dict) h = Hello() # 此时的h和上边的h一致 八、异常相关捕获异常:12345678910111213 try: except: # 捕获所有的异常 等同于except Exception: except name: # 捕获指定的异常 except name, value: # 捕获指定的异常和额外的数据(实例) except (name1, name2): except (name1, name2), value: except name4 as X: else: # 如果没有发生异常 finally: # 总会执行的部分# 引发异常: raise子句(raise IndexError) raise &lt;instance&gt; # raise instance of a class, raise IndexError() raise &lt;class&gt; # make and raise instance of a class, raise IndexError raise # reraise the most recent exception Python3.x中的异常链raise exception from otherException 12except Exception as X: raise IndexError('Bad') from X assert子句: assert &lt;test&gt;, &lt;data&gt;1assert x &lt; 0, 'x must be negative' with/as环境管理器:作为常见的try/finally用法模式的替代方案12345678910with expression [as variable], expression [as variable]:# 例子: with open('test.txt') as myfile: for line in myfile: print(line)# 等同于: myfile = open('test.txt') try: for line in myfile: print(line) finally: myfile.close() 用户自定义异常: class Bad(Exception):…..1234567891011"""Exception超类 / except基类即可捕获到其所有子类Exception超类有默认的打印消息和状态 当然也可以定制打印显示:"""class MyBad(Exception): def __str__(self): return '定制的打印消息'try: MyBad()except MyBad as x: print(x) 用户定制异常数据1234567891011121314151617181920class FormatError(Exception): def __init__(self, line ,file): self.line = line self.file = filetry: raise FormatError(42, 'test.py')except FormatError as X: print('Error at ', X.file, X.line)# 用户定制异常行为(方法):以记录日志为例class FormatError(Exception): logfile = 'formaterror.txt' def __init__(self, line ,file): self.line = line self.file = file def logger(self): open(self.logfile, 'a').write('Error at ', self.file, self.line)try: raise FormatError(42, 'test.py')except FormatError as X: X.logger() 关于sys.exc_info:允许一个异常处理器获取对最近引发的异常的访问1234567try: ......except: # 此时sys.exc_info()返回一个元组(type, value, traceback) # type:正在处理的异常的异常类型 # value:引发的异常的实例 # traceback:堆栈信息 异常层次1234567891011121314151617181920212223BaseException+-- SystemExit+-- KeyboardInterrupt+-- GeneratorExit+-- Exception +-- StopIteration +-- ArithmeticError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError +-- LookupError +-- MemoryError +-- NameError +-- OSError +-- ReferenceError +-- RuntimeError +-- SyntaxError +-- SystemError +-- TypeError +-- ValueError +-- Warning ​ 九、Unicode和字节字符串Python的字符串类型1234567"""Python2.x"""# 1.str表示8位文本和二进制数据# 2.unicode表示宽字符Unicode文本"""Python3.x"""# 1.str表示Unicode文本（8位或者更宽）# 2.bytes表示不可变的二进制数据# 3.bytearray是一种可变的bytes类型 字符编码方法123456789"""ASCII""" # 一个字节，只包含英文字符，0到127，共128个字符，利用函数可以进行字符和数字的相互转换ord('a') # 字符a的ASCII码为97，所以这里返回97chr(97) # 和上边的过程相反，返回字符'a'"""Latin-1""" # 一个字节，包含特殊字符，0到255，共256个字符，相当于对ASCII码的扩展chr(196) # 返回一个特殊字符：Ä"""Unicode""" # 宽字符，一个字符包含多个字节，一般用于亚洲的字符集，比如中文有好几万字"""UTF-8""" # 可变字节数，小于128的字符表示为单个字节，128到0X7FF之间的代码转换为两个字节，0X7FF以上的代码转换为3或4个字节# 注意：可以看出来，ASCII码是Latin-1和UTF-8的一个子集# 注意：utf-8是unicode的一种实现方式，unicode、gbk、gb2312是编码字符集 查看Python中的字符串编码名称，查看系统的编码1234567import encodingshelp(encoding)import syssys.platform # 'win64'sys.getdefaultencoding() # 'utf-8'sys.getdefaultencoding() # 返回当前系统平台的编码类型sys.getsizeof(object) # 返回object占有的bytes的大小 源文件字符集编码声明: 添加注释来指定想要的编码形式 从而改变默认值 注释必须出现在脚本的第一行或者第二行123"""说明：其实这里只会检查#和coding:utf-8，其余的字符都是为了美观加上的"""# _*_ coding: utf-8 _*_# coding = utf-8 编码，解码编码: 字符串 –&gt; 原始字节 解码: 原始字节 –&gt; 字符串 Python3.x中的字符串应用123456789101112131415161718192021222324s = '...' # 构建一个str对象，不可变对象b = b'...' # 构建一个bytes对象，不可变对象s[0], b[0] # 返回('.', 113)s[1:], b[1:] # 返回('..', b'..')B = B""" xxxx yyyy """# B = b'\nxxxx\nyyyy\n'# 编码，将str字符串转化为其raw bytes形式： str.encode(encoding = 'utf-8', errors = 'strict') bytes(str, encoding)# 编码例子： S = 'egg' S.encode() # b'egg' bytes(S, encoding = 'ascii') # b'egg'# 解码，将raw bytes字符串转化为str形式： bytes.decode(encoding = 'utf-8', errors = 'strict') str(bytes_or_buffer[, encoding[, errors]])# 解码例子： B = b'spam' B.decode() # 'spam' str(B) # "b'spam'"，不带编码的str调用，结果为打印该bytes对象 str(B, encoding = 'ascii')# 'spam'，带编码的str调用，结果为转化该bytes对象 Python2.x的编码问题12345678910u = u'汉'print repr(u) # u'\xba\xba's = u.encode('UTF-8')print repr(s) # '\xc2\xba\xc2\xba'u2 = s.decode('UTF-8')print repr(u2) # u'\xba\xba'# 对unicode进行解码是错误的s2 = u.decode('UTF-8') # UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)# 同样，对str进行编码也是错误的u2 = s.encode('UTF-8') # UnicodeDecodeError: 'ascii' codec can't decode byte 0xc2 in position 0: ordinal not in range(128) bytes对象12345B = b'abc'B = bytes('abc', 'ascii')B = bytes([97, 98, 99])B = 'abc'.encode()# bytes对象的方法调用基本和str类型一致 但:B[0]返回的是ASCII码值97, 而不是b'a' 文本文件，二进制文件文本文件: 根据Unicode编码来解释文件内容，要么是平台的默认编码，要么是指定的编码类型 二进制文件：表示字节值的整数的一个序列 open(&#39;bin.txt&#39;, &#39;rb&#39;) Unicode文件1234567891011121314s = 'A\xc4B\xe8C' # s = 'A?BèC' len(s) = 5#手动编码 l = s.encode('latin-1') # l = b'A\xc4B\xe8C' len(l) = 5 u = s.encode('utf-8') # u = b'A\xc3\x84B\xc3\xa8C' len(u) = 7#文件输出编码 open('latindata', 'w', encoding = 'latin-1').write(s) l = open('latindata', 'rb').read() # l = b'A\xc4B\xe8C' len(l) = 5 open('uft8data', 'w', encoding = 'utf-8').write(s) u = open('uft8data', 'rb').read() # u = b'A\xc3\x84B\xc3\xa8C' len(u) = 7#文件输入编码 s = open('latindata', 'r', encoding = 'latin-1').read() # s = 'A?BèC' len(s) = 5 s = open('latindata', 'rb').read().decode('latin-1') # s = 'A?BèC' len(s) = 5 s = open('utf8data', 'r', encoding = 'utf-8').read() # s = 'A?BèC' len(s) = 5 s = open('utf8data', 'rb').read().decode('utf-8') # s = 'A?BèC' len(s) = 5 十、其他Python实现任意深度的赋值123a[0] = 'value1'a[1][2] = 'value2'a[3][4][5] = 'value3' 1234567891011121314151617181920class MyDict(dict): def __setitem__(self, key, value): # 该函数不做任何改动 这里只是为了输出 print('setitem:', key, value, self) super().__setitem__(key, value) def __getitem__(self, item): # 主要技巧在该函数 print('getitem:', item, self) # 输出信息 # 基本思路: a[1][2]赋值时 需要先取出a[1] 然后给a[1]的[2]赋值 if item not in self: # 如果a[1]不存在 则需要新建一个dict 并使得a[1] = dict temp = MyDict() # 新建的dict: temp super().__setitem__(item, temp) # 赋值a[1] = temp return temp # 返回temp 使得temp[2] = value有效 return super().__getitem__(item) # 如果a[1]存在 则直接返回a[1]# 例子: test = MyDict() test[0] = 'test' print(test[0]) test[1][2] = 'test1' print(test[1][2]) test[1][3] = 'test2' print(test[1][3]) Python中的多维数组12345678lists = [0] * 3 # 扩展list，结果为[0, 0, 0]lists = [[]] * 3 # 多维数组，结果为[[], [], []]，但有问题，往下看lists[0].append(3) # 期望看到的结果[[3], [], []]，实际结果[[3], [3], [3]]，原因：list*n操作，是浅拷贝，如何避免？往下看lists = [[] for i in range(3)] # 多维数组，结果为[[], [], []]lists[0].append(3) # 结果为[[3], [], []]lists[1].append(6) # 结果为[[3], [6], []]lists[2].append(9) # 结果为[[3], [6], [9]]lists = [[[] for j in range(4)] for i in range(3)] # 3行4列，且每一个元素为[] 参考xianhu/LearnPython Python编程 : 从入门到实践]]></content>
      <categories>
        <category>Python</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读《百年孤独》 —— 孤独才是寂寞的唯一出口]]></title>
    <url>%2F2019%2F%E7%99%BE%E5%B9%B4%E5%AD%A4%E7%8B%AC.html</url>
    <content type="text"><![CDATA[有句开玩笑的话，大概是这样说的：“经典就是买的人很多，读的人却很少的作品”，而《百年孤独》可能就是这样的经典作品，读完真的是史诗般的孤独体验，可能我以后还会再去品味这部经典，但我确信近几年我不想，也不能再都去读了。🤦‍♀️ 内容概要作者马尔克斯在小说的叙述中采用了大量象征、隐喻、意识流等魔幻现实主义手法，融入神话传说、民间故事、宗教典故等神秘因素，将现实与虚幻巧妙糅合，展现出一个虚构的真实世界。 加勒比海岸马孔多小镇布恩迪亚家族一百年来的兴衰，实际上隐喻了拉丁美洲人民遭受西方殖民入侵时期一百年来的历史。他们试图融入外部世界的先进文明，渴望抛下保守落后的本土传统，但是最终所有的努力和挣扎，都像奥雷里亚诺上校发动的三十二场战争一样成为徒劳。恰如布恩迪亚家族七代人都无法摆脱的宿命一般的孤独。 神秘而充满智慧的吉卜赛人梅尔基亚德斯用梵文在羊皮卷上写下了布恩迪亚家族七代人的宿命：家族的第一个人被捆在树上，最后一个人正在被蚂蚁吃掉。 布恩迪亚家族的男性后代，几乎都是家族第一代先祖何塞·阿尔卡蒂奥·布恩迪亚精神和人格的延续，他们要么生性癫狂，精力旺盛，最后死于非命；要么则是孤僻冷漠，聪明过人又在孤独中离世。布恩迪亚家族的女性后代，则是家族第一代先祖乌尔苏拉和第二代先祖庇拉尔·特尔内拉的精神延续，乌尔苏拉代表了家族含蓄内敛，勤劳向上的优秀人格，庇拉尔·特尔内拉则代表了家族放荡奢靡，不知节制的低劣人格。 小说一开始，马尔克斯写了马孔多人患上失眠症和遗忘症后的种种荒诞，喻示人们不可忘记历史。 小说最后，马尔克斯写道：“羊皮卷上所载一切自永远至永远不会再重复，因为注定经受百年孤独的家族不会有第二次机会在大地上出现。” 既表达了马尔克斯对西方文明入侵拉美本土文明的愤懑和抗议，又表达了他与浴火重生的拉美人民重建家园的期待。 布恩迪亚家族的历史，无疑是个悲剧，这样的悲剧在文明世界不应该被重演。 人物关系和介绍 男性角色就是重复着用“奥雷里亚诺”“何塞”“阿尔卡蒂奥”命名，女性角色就是用“阿玛兰妲”“蕾梅黛丝”命名。 人物的性格与名字有关联。 “阿尔卡蒂奥”大多都是纵欲的、随性的。这里的欲望有对生活的控制征服欲，也有情欲、物质欲。比如作为布恩迪亚家族的创始人，阿尔卡蒂奥1.0（xxx1.0，表示第几代）就是一个有控制征服欲的人，极富创造力，不满足于自己落后的生活。阿尔卡蒂奥5.0十分贪恋财产，最后找到了祖上留下的金币，但也因金币而死。 “奥雷里亚诺”多是执着坚韧、性格孤僻、沉闷压抑，且基本没有后代。比如奥雷里亚诺上校（也就是奥雷里亚诺2.0）在娘胎里就会哭，出生的时候睁着眼睛，从小就有预见事物的本领，参加过多次内战，一生遭遇过14次暗杀，73次埋伏和1次枪决，但均能未卜先知，幸免于难（主角光环可以说是非常强烈了）。奥雷里亚诺6.0从小无父无母，被姑妈抚养长大，特别孤独沉闷，唯一的爱好就是研究羊皮卷。 “阿玛兰妲”大多对爱情比较执着，喜欢自己的侄子。比如阿玛兰妲2.0曾与姐姐同时喜欢上一位意大利技师，特别执着，最后因误毒死了自己的嫂子而停手，但是后来又与侄子搅和在一起。阿玛兰妲6.0也与自己的侄子搅和在一起，生了一个长着猪尾巴的婴儿，难产而死。 “蕾梅黛丝”大多退场比较早，上面提到的上校的妻子蕾梅黛丝2.0就因意外被毒死而早早退场。后来的美人儿蕾梅黛丝4.0二十多岁的时候，变得极其苍白，几近透明，一阵风吹过，和床单一起升天了。（哼，一定是上天嫉妒美人儿蕾梅黛丝的美貌） 详细的人物介绍：维基百科 原文摘录 “世界上正发生着不可思议的事情，在河的另一边各种魔法机器应有尽有，而我们却还像驴子一样生活。”何塞·阿尔卡蒂奥·布恩迪亚对他的妻子乌尔苏拉这样说到。 所有人都显得很寂寞，用自己的方式想尽办法排遣寂寞，事实上仍是延续自己的寂寞。寂寞是造化对群居者的诅咒，孤独才是寂寞的唯一出口。 失眠症最可怕之处不在于让人毫无倦意不能入睡，而是会不可逆转地恶化到更严重的境地：遗忘。也就是说，患者慢慢习惯了无眠的状态，就开始淡忘童年的记忆，继之以事物的名称和概念，最后是各人的身份，以至失去自我，沦为没有过往的白痴。 孤独是一个陪伴人一生的伙伴，是一个既定事实，与其否认，与其抗争，与其无谓的逃避，不如接受它，拥挤的人群里让它保护你回家，周六的上午让它陪你吃早餐，整理阳光。 她辛苦多年忍受折磨好不容易赢得的孤独特权，绝不肯用来换取一个被虚假迷人的怜悯打扰的晚年。 不论在什么地方都要记住，过去都是假的，回忆没有归路，春天总是一去不返，最疯狂执著的爱情也终究是过眼云烟。 儿子对母亲： “现在不要告别。”他镇静地结束了谈话，“不要乞求任何人，也不要向任何人低头。您就当我早被枪毙了。” 母亲对儿子： “只要上帝还让我们活着，我们就还是母亲；不管你们有多么革命，只要没规矩，我们就有权脱了你们的裤子打一顿。” “答应我，你如果在那边碰上难缠的事，就想想你母亲。” 这个女人是这个家的守护神 “只要上帝还让我活着，这个净出疯子的家里就缺不了钱。” 革命 “你记住，老兄，”他说，“不是我要枪毙你。是革命要枪毙你。” 战争侵蚀人心 “留神你的心，奥雷里亚诺，”赫里内勒多·马尔克斯上校对他说，“你正在活活腐烂。” 结束一场战争要比发动它艰难得多。 当初怎样为胜利而战，如今便怎样为失败而战。 你那么憎恨军人，跟他们斗了那么久，琢磨了他们那么久，最终却变得和他们一样。人世间没有任何理想值得以这样的沉沦作为代价。 爱情 他们俩就仿佛一双敌对的情侣在清澈的水塘深处寻求和解。 最后双方都意识到彼此既是对手又是同谋。 爱情或许可以是一种比夜晚幽会中疯狂而短暂的快乐更平和深沉的感觉。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-并查集]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%B9%B6%E6%9F%A5%E9%9B%86.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Union-Find 并查集(Union-Find) 并查集是一种数据结构，可以跟踪一组元素，它们分布在几个不相交（非重叠）子集合中。 它也被称为不相交集数据结构。 这是什么意思呢？ 例如，并查集数据结构可以跟踪以下集合： [ a, b, f, k ] [ e ] [ g, d, c ] [ i, j ] 这些集合是不相交的，因为它们没有共同的成员。 并查集支持三个基本操作： Find(A)：确定元素A所在的子集。例如，find(d)将返回子集 [ g, d, c ]。 Union(A, B)：将包含 A 和 B 的两个子集合并为一个子集。 例如，union(d, j) 表示将 [g, d, c] 和 [i, j] 组合成更大的集合 [g, d, c, i, j]。 AddSet(A)：添加仅包含元素A的新子集合 。 例如，addSet(h)会添加一个新的集合[ h ]。 该数据结构的最常见应用是跟踪无向图的连通分量。 它还用于实现Kruskal算法的有效版本，以查找图的最小生成树。 实施并查集可以通过多种方式实现，但我们将看一个高效且易于理解的实现：Weighted Quick Union。 PS：并查集 的多个实现已包含在playground . 12345public struct UnionFind&lt;T: Hashable&gt; &#123; private var index = [T: Int]() private var parent = [Int]() private var size = [Int]()&#125; 我们的并查集数据结构实际上是一个森林，其中每个子集由树表示。 基于我们的目的，我们只需要跟踪每个树节点的父节点，而不是子节点。 为此，我们使用数组parent，那么parent[i]是节点i的父节点索引。 示例：如果parent看起来像这样， parent [ 1, 1, 1, 0, 2, 0, 6, 6, 6 ] i 0 1 2 3 4 5 6 7 8 然后树结构看起来像： 1 6 / \ / \ 0 2 7 8 / \ / 3 5 4 这片森林中有两棵树，每棵树对应一组元素。 （注意：由于ASCII的限制，树在这里显示为二叉树，但情况不一定如此。） 我们为每个子集提供唯一的编号以识别它。 该数字是该子集树的根节点的索引。 在示例中，节点1是第一棵树的根节点，6是第二棵树的根节点。 所以在这个例子中我们有两个子集，第一个带有标签1，第二个带有标签6。 Find操作实际上返回了set的标签，而不是其内容。 请注意，根节点的parent[]指向自身。 所以parent[1] = 1 和 parent [6] = 6。 这就是我们如何判断那些是根节点的方法。 添加集合让我们看一下这些基本操作的实现，从开始添加新集。 12345public mutating func addSetWith(_ element: T) &#123; index[element] = parent.count // 1 parent.append(parent.count) // 2 size.append(1) // 3&#125; 添加新元素时，实际上会添加一个仅包含该元素的新子集。 我们在index字典中保存新元素的索引。 这让我们可以在以后快速查找元素。 然后我们将该索引添加到parent数组中，为该集合构建一个新树。这里，parent[i]指向自身，因为表示新集合的树只包含一个节点，当然这是该树的根节点。 size[i]是树的节点数，其根位于索引i。 对于新集合，这是1，因为它只包含一个元素。 我们将在Union操作中使用size数组。 查找通常我们想确定我们是否已经有一个包含给定元素的集合。 这就是Find操作所做的。 在我们的UnionFind数据结构中，它被称为setOf()： 1234567public mutating func setOf(_ element: T) -&gt; Int? &#123; if let indexOfElement = index[element] &#123; return setByIndex(indexOfElement) &#125; else &#123; return nil &#125;&#125; 这会在index字典中查找元素的索引，然后使用辅助方法来查找此元素所属的集合： 12345678private mutating func setByIndex(_ index: Int) -&gt; Int &#123; if parent[index] == index &#123; // 1 return index &#125; else &#123; parent[index] = setByIndex(parent[index]) // 2 return parent[index] // 3 &#125;&#125; 因为我们正在处理树结构，所以这边使用的是递归方法。 回想一下，每个集合由树表示，并且根节点的索引用作标识集合的数字。 我们将找到我们要搜索的元素所属的树的根节点，并返回其索引。 首先，我们检查给定索引是否代表根节点（即“父”指向节点本身的节点）。 如果是这样，我们就完成了。 否则，我们以递归方式在当前节点的父节点上调用此方法。然后我们做了一个非常重要的事情：我们用根节点的索引覆盖当前节点的父节点，实际上将节点直接重新连接到树的根节点。下次我们调用此方法时，它将执行得更快，因为树的根路径现在要短得多。 如果没有这种优化，这种方法的复杂性就是O(n)，但现在结合尺寸优化（在Union部分中说明）它几乎是O(1)。 我们返回根节点的索引作为结果。 这是我说明的意思。 现在树看起来像这样： 我们调用setOf(4)。 要找到根节点，我们必须首先转到节点2然后转到节点7。 （元素的索引标记为红色。） 在调用setOf(4)期间，树被重组为如下所示： 现在如果我们需要再次调用setOf(4)，我们就不再需要通过节点2再到根节点了。 因此，当您使用Union-Find数据结构时，它会优化自身。 太酷了！ 还有一个辅助方法来检查两个元素是否在同一个集合中： 1234567public mutating func inSameSet(_ firstElement: T, and secondElement: T) -&gt; Bool &#123; if let firstSet = setOf(firstElement), let secondSet = setOf(secondElement) &#123; return firstSet == secondSet &#125; else &#123; return false &#125;&#125; 这会调用setOf()，也会优化树。 Union (Weighted)最后的操作是 Union，它将两集合并为一组更大的集合。 12345678910111213public mutating func unionSetsContaining(_ firstElement: T, and secondElement: T) &#123; if let firstSet = setOf(firstElement), let secondSet = setOf(secondElement) &#123; // 1 if firstSet != secondSet &#123; // 2 if size[firstSet] &lt; size[secondSet] &#123; // 3 parent[firstSet] = secondSet // 4 size[secondSet] += size[firstSet] // 5 &#125; else &#123; parent[secondSet] = firstSet size[firstSet] += size[secondSet] &#125; &#125; &#125;&#125; 下面是它的工作原理： 我们找到每个元素所属的集合。请记住，这给了我们两个整数：parent数组中根节点的索引。 检查这些集合是否相等，如果相等，合并就没有意义。 这是大小优化的来源（加权）。我们希望保持树尽可能浅，所以我们总是将较小的树附加到较大树的根部。为了确定哪个是较小的树，我们按照它们的大小比较树。 这里我们将较小的树附加到较大树的根部。 更新较大树的大小，因为它只添加了一堆节点。 插图可能有助于更好地理解这一点。 假设我们有这两个集合，每个都有自己的树： 现在我们调用 unionSetsContaining(4, and:3)。 较小的树与较大的树相连： 请注意，因为我们在方法的开头调用setOf()，所以在该过程中也对树进行了优化 - 节点3现在直接挂在根之上。 具有优化的Union只需要几乎 O(1) 时间。 路径压缩1234567private mutating func setByIndex(_ index: Int) -&gt; Int &#123; if index != parent[index] &#123; // Updating parent index while looking up the index of parent. parent[index] = setByIndex(parent[index]) &#125; return parent[index]&#125; 路径压缩有助于保持树非常平坦，因此查找操作可能只需要O(1) 。 复杂度总结处理N个对象 Data Structure Union Find Quick Find N 1 Quick Union Tree height Tree height Weighted Quick Union lgN lgN Weighted Quick Union + Path Compression very close, but not O(1) very close, but not O(1) 在N个对象上处理M的union命令 Algorithm Worst-case time Quick Find M N Quick Union M N Weighted Quick Union N + M lgN Weighted Quick Union + Path Compression (M + N) lgN 扩展阅读有关如何使用此便捷数据结构的更多示例，请参阅 playground。 并查集的维基百科 作者：Artur Antonov ，Yi Ding翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>并查集</tag>
        <tag>Union-Find</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-选取样本]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E9%80%89%E5%8F%96%E6%A0%B7%E6%9C%AC.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Selection Sampling 选取样本（Selection Sampling） 目标：从n个项的集合中随机选择k个项。 假设你有一副52张牌，你需要随机抽取10张牌。 这个算法可以让你达成。 这是一个非常快的版本： 12345678910func select&lt;T&gt;(from a: [T], count k: Int) -&gt; [T] &#123; var a = a for i in 0..&lt;k &#123; let r = random(min: i, max: a.count - 1) if i != r &#123; swap(&amp;a[i], &amp;a[r]) &#125; &#125; return Array(a[0..&lt;k])&#125; 正如洗牌算法经常发生的那样，它将数组划分为两个区域。 第一个区域包含所选项; 第二个区域是所有剩余的项。 一个例子。 假设一个数组是： [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot; ] 我们想选择3个项目，所以k = 3。 在循环中，i最初为0，因此它指向&quot;a&quot;。 [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot; ] i 我们计算i和数组的大小a.count之间的随机数。 假设这个随机数是4。 现在我们将&quot;a&quot;与索引为4的&quot;e&quot;交换，然后向前移动i： [ &quot;e&quot; | &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;f&quot;, &quot;g&quot; ] i |栏表示两个区域之间的分割。 &quot;e&quot;是我们选择的第一个元素。 我们继续需要关注|栏右侧的所有内容。 再一次，我们要求i和a.count之间的随机数，但因为i已经移位，随机数永远不会小于1。所以我们再也不会交换&quot;e&quot;了。 假设随机数为6，我们将&quot;b&quot;与&quot;g&quot;交换： [ &quot;e&quot; , &quot;g&quot; | &quot;c&quot;, &quot;d&quot;, &quot;a&quot;, &quot;f&quot;, &quot;b&quot; ] i 还有一个随机数，假设它是4。 我们将&quot;c&quot;与&quot;a&quot;交换，最终左边已经选择的项为： [ &quot;e&quot;, &quot;g&quot;, &quot;a&quot; | &quot;d&quot;, &quot;c&quot;, &quot;f&quot;, &quot;b&quot; ] 就是这样。 十分简单。 这个函数的性能是O(k)，因为只要我们选择了k元素，就结束了。 下面是一种替代算法，称为“水库抽样”(Reservoir Sampling)： 12345678910111213141516func reservoirSample&lt;T&gt;(from a: [T], count k: Int) -&gt; [T] &#123; precondition(a.count &gt;= k) var result = [T]() // 1 for i in 0..&lt;k &#123; result.append(a[i]) &#125; for i in k..&lt;a.count &#123; // 2 let j = random(min: 0, max: i) if j &lt; k &#123; result[j] = a[i] &#125; &#125; return result&#125; 有两个步骤： 使用原始数组中的第一个k元素填充result数组。 这被称为“水库”。 用剩余池中的元素随机替换水库中的元素。 该算法的性能为 O(n)，因此它比第一算法慢一点。但是，它的最大优点是它可以用于太大而无法容纳在内存中的数组，即使你不知道数组的大小是多少（在Swift中这可能类似于读取文件元素的懒惰生成器）。 前两种算法有一个缺点：它们不保留原始顺序的元素。在输入数组中，&quot;a&quot;出现在&quot;e&quot;之前，但现在却是另一种顺序。如果要顺序不变，则无法使用上面的方法。 下面这种替代方法，可以保持原始顺序的完整性，但需要更多空间参与： 1234567891011121314151617181920func select&lt;T&gt;(from a: [T], count requested: Int) -&gt; [T] &#123; var examined = 0 var selected = 0 var b = [T]() while selected &lt; requested &#123; // 1 let r = Double(arc4random()) / 0x100000000 // 2 let leftToExamine = a.count - examined // 3 let leftToAdd = requested - selected if Double(leftToExamine) * r &lt; Double(leftToAdd) &#123; // 4 selected += 1 b.append(a[examined]) &#125; examined += 1 &#125; return b&#125; 该算法使用概率来决定是否在选择中包括一个数字。 循环从头到尾逐步完成数组。 它一直持续到我们从n的集合中选择k个项。 这里，k是requested而n是a.count。 计算0到1之间的随机数。我们想要0.0 &lt;= r &lt; 1.0。 上限是排他性的; 我们从不希望它是1。这就是为什么我们将结果从arc4random()除以0x100000000而不是更常见的0xffffffff。 leftToExamine是我们还没有看过的项数目。 leftToAdd是我们在完成之前还需要选择的项数。 这就是魔术发生的地方。 基本上，我们正在翻转一枚硬币。 如果是heads，我们将当前数组元素添加到选择中; 如果是tails，我们就跳过。 有趣的是，即使我们使用概率，这种方法总是保证我们最终得到输出数组中的k项。 让我们再次讨论相同的例子。 输入数组是： [ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot; ] 循环依次查看每个元素，因此我们从&quot;a&quot;开始。 我们得到一个介于0和1之间的随机数，假设它是0.841。 // 4处的公式将要检查的项目数乘以此随机数。 还有7个元素需要检查，结果是： 7 * 0.841 = 5.887 我们将此与3进行比较，因为我们想要选择3个项目。 由于5.887大于3，我们跳过&quot;a&quot;并继续移动动&quot;b&quot;。 再一次，我们得到一个随机数，比方说0.212。 现在只剩下6个要检查的元素，因此公式结果是： 6 * 0.212 = 1.272 小于3，我们在选择中添加&quot;b&quot;。 这是我们选择的第一个项，所以还剩下两个。 到下一个元素，&quot;c&quot;。 随机数为0.264，得出结果： 5 * 0.264 = 1.32 只要再选择2个项，因此这个数字必须小于2。它是，我们还在选择中加入&quot;c&quot;。 总选择是[&quot;b&quot;，&quot;c&quot;]。 只要再选择1个项，但仍有4个候选项要查看。 假设下一个随机数是0.718。 该公式现在给出： 4 * 0.718 = 2.872 要选择此元素，数字必须小于1，因为只剩下1个项要选择。 2.872不是，所以我们跳过&quot;d&quot;。 只剩下三种可能性 - 我们会在耗尽元素之前选到它吗？ 随机数为0.346。 该公式给出： 3 * 0.346 = 1.038 有点太高了。 我们跳过&quot;e&quot;。 只有两名候选项了…… 请注意，现在字面上我们正在处理抛硬币：如果随机数小于0.5，我们选择&quot;f&quot;，我们就完成了。 如果它大于0.5，我们继续最后的元素。 假设我们得到0.583： 2 * 0.583 = 1.166 我们跳过&quot;f&quot;并查看最后一个元素。 无论我们在这里得到什么随机数，它应该总是选择&quot;g&quot;或者我们不会选择足够的元素而算法不起作用！ 假设我们的最终随机数是0.999（记住，它永远不会是1.0或更高）。 实际上，无论我们在这里选择什么，公式总是会给出小于1的值： 1 * 0.999 = 0.999 因此，如果我们还没有足够多的选择，那么总是会选择最后一个元素。最后的选择是[ &quot;b&quot;, &quot;c&quot;, &quot;g&quot; ]。请注意，元素仍处于原始顺序，因为我们是从左到右查询数组。 也许你还不相信……如果我们总是将0.999作为随机值（最大可能值），那还能选择3项吗？ 好吧，让我们做数学： 7 * 0.999 = 6.993 小于3吗? no 6 * 0.999 = 5.994 小于3吗? no 5 * 0.999 = 4.995 小于3吗? no 4 * 0.999 = 3.996 小于3吗? no 3 * 0.999 = 2.997 小于3吗? YES 2 * 0.999 = 1.998 小于2吗? YES 1 * 0.999 = 0.999 小于1吗? YES 它总是有效！ 但这是否意味着靠近数组末尾的元素比一开始的元素更有可能被选中？ 不，所有元素同样可能被选中。 （如果不相信我的话：在playground 看一下快速测试，在实践中证明了这一点。） 以下是如何测试此算法的示例： 1234567891011let input = [ "there", "once", "was", "a", "man", "from", "nantucket", "who", "kept", "all", "of", "his", "cash", "in", "a", "bucket", "his", "daughter", "named", "nan", "ran", "off", "with", "a", "man", "and", "as", "for", "the", "bucket", "nan", "took", "it",]let output = select(from: input, count: 10)print(output)print(output.count) 第二种算法的性能是O(n)，因为它可能需要遍历整个输入数组。 注意： 如果k &gt; n / 2，那么以相反的方式执行它并选择要删除的a.count - k项更有效。 代码基于发表于1993年10月Dobb博士的杂志的Algorithm Alley。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>选取样本</tag>
        <tag>Selection Sampling</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-第k大元素问题]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E7%AC%ACk%E5%A4%A7%E5%85%83%E7%B4%A0%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Kth Largest Element 第k大元素问题(k-th Largest Element Problem) 你有一个整数数组a。 编写一个算法，在数组中找到第k大的元素。 例如，第1个最大元素是数组中出现的最大值。 如果数组具有n个元素，则第n最大元素是最小值。 中位数是第n/2最大元素。 朴素的解决方案以下是半朴素的解决方案。 它的时间复杂度是 O(nlogn)，因为它首先对数组进行排序，因此也使用额外的 O(n) 空间。 123456789func kthLargest(a: [Int], k: Int) -&gt; Int? &#123; let len = a.count if k &gt; 0 &amp;&amp; k &lt;= len &#123; let sorted = a.sorted() return sorted[len - k] &#125; else &#123; return nil &#125;&#125; kthLargest() 函数有两个参数：由整数组成的数组a，已经整数k。 它返回第k大元素。 让我们看一个例子并运行算法来看看它是如何工作的。 给定k = 4和数组： 1[ 7, 92, 23, 9, -1, 0, 11, 6 ] 最初没有找到第k大元素的直接方法，但在对数组进行排序之后，它非常简单。 这是排完序的数组： 1[ -1, 0, 6, 7, 9, 11, 23, 92 ] 现在，我们所要做的就是获取索引a.count - k的值： 1a[a.count - k] = a[8 - 4] = a[4] = 9 当然，如果你正在寻找第k个最小的元素，你会使用a [k-1]。 更快的解决方案有一种聪明的算法结合了二分搜索和快速排序的思想来达到O(n)解决方案。 回想一下，二分搜索会一次又一次地将数组分成两半，以便快速缩小您要搜索的值。 这也是我们在这里所做的。 快速排序还会拆分数组。它使用分区将所有较小的值移动到数组的左侧，将所有较大的值移动到右侧。在围绕某个基准进行分区之后，该基准值将已经处于其最终的排序位置。 我们可以在这里利用它。 以下是它的工作原理：我们选择一个随机基准，围绕该基准对数组进行分区，然后像二分搜索一样运行，只在左侧或右侧分区中继续。这一过程重复进行，直到我们找到一个恰好位于第k位置的基准。 让我们再看看初始的例子。 我们正在寻找这个数组中的第4大元素： [ 7, 92, 23, 9, -1, 0, 11, 6 ] 如果我们寻找第k个最小项，那么算法会更容易理解，所以让我们采用k = 4并寻找第4个最小元素。 请注意，我们不必先对数组进行排序。 我们随机选择其中一个元素作为基准，假设是11，并围绕它分割数组。 我们最终会得到这样的结论： [ 7, 9, -1, 0, 6, 11, 92, 23 ] &lt;------ smaller larger --&gt; 如您所见，所有小于11的值都在左侧; 所有更大的值都在右边。基准值11现在处于最终排完序的位置。基准的索引是5，因此第4个最小元素肯定位于左侧分区中的某个位置。从现在开始我们可以忽略数组的其余部分： [ 7, 9, -1, 0, 6, x, x, x ] 再次让我们选择一个随机的枢轴，让我们说6，然后围绕它划分数组。 我们最终会得到这样的结论： [ -1, 0, 6, 9, 7, x, x, x ] 基准值6在索引2处结束，所以显然第4个最小的项必须在右侧分区中。 我们可以忽略左侧分区： [ x, x, x, 9, 7, x, x, x ] 我们再次随机选择一个基准值，假设是9，并对数组进行分区： [ x, x, x, 7, 9, x, x, x ] 基准值9的索引是4，这正是我们正在寻找的 k。 我们完成了！ 注意这只需要几个步骤，我们不必先对数组进行排序。 以下函数实现了这些想法： 12345678910111213141516171819202122232425262728293031323334353637383940public func randomizedSelect&lt;T: Comparable&gt;(_ array: [T], order k: Int) -&gt; T &#123; var a = array func randomPivot&lt;T: Comparable&gt;(_ a: inout [T], _ low: Int, _ high: Int) -&gt; T &#123; let pivotIndex = random(min: low, max: high) a.swapAt(pivotIndex, high) return a[high] &#125; func randomizedPartition&lt;T: Comparable&gt;(_ a: inout [T], _ low: Int, _ high: Int) -&gt; Int &#123; let pivot = randomPivot(&amp;a, low, high) var i = low for j in low..&lt;high &#123; if a[j] &lt;= pivot &#123; a.swapAt(i, j) i += 1 &#125; &#125; a.swapAt(i, high) return i &#125; func randomizedSelect&lt;T: Comparable&gt;(_ a: inout [T], _ low: Int, _ high: Int, _ k: Int) -&gt; T &#123; if low &lt; high &#123; let p = randomizedPartition(&amp;a, low, high) if k == p &#123; return a[p] &#125; else if k &lt; p &#123; return randomizedSelect(&amp;a, low, p - 1, k) &#125; else &#123; return randomizedSelect(&amp;a, p + 1, high, k) &#125; &#125; else &#123; return a[low] &#125; &#125; precondition(a.count &gt; 0) return randomizedSelect(&amp;a, 0, a.count - 1, k)&#125; 为了保持可读性，功能分为三个内部函数： randomPivot()选择一个随机数并将其放在当前分区的末尾（这是Lomuto分区方案的要求，有关详细信息，请参阅快速排序上的讨论）。 randomizedPartition()是Lomuto的快速排序分区方案。 完成后，随机选择的基准位于数组中的最终排序位置。它返回基准值的数组索引。 randomizedSelect()做了所有困难的工作。 它首先调用分区函数，然后决定下一步做什么。 如果基准的索引等于我们正在寻找的k元素，我们就完成了。 如果k小于基准索引，它必须回到左分区中，我们将在那里递归再次尝试。 当第k数在右分区中时，同样如此。 很酷，对吧？ 通常，快速排序是一种 O(nlogn) 算法，但由于我们只对数组中较小的部分进行分区，因此randomizedSelect()的运行时间为 O(n)。 注意： 此函数计算数组中第k最小项，其中k从0开始。如果你想要第k最大项，请用a.count - k。 作者：Daniel Speiser，Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>第k大元素问题</tag>
        <tag>k-th Largest Element</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2-网络分层的真实含义是什么？]]></title>
    <url>%2F2019%2FNetworkProtocol-02.html</url>
    <content type="text"><![CDATA[这是我学习《趣谈网络协议》的一篇笔记。 计算机网络是不仅需要背诵，而且特别需要将原理烂熟于胸的学科。 1.几个问题网络分层不恰当的比喻：一家公司也是分“层次”的，分总经理、经理、组长、员工。总经理之间有他们的沟通方式，经理和经理之间也有沟通方式，同理组长和员工。 TCP 在进行三次握手的时候，IP层和 MAC层对应都有什么操作呢？ 第三层网络层中设计路由协议，说路由就像中转站，我们从原始地址 A 到目标地址D，中间经过两个中转站 A-&gt;B-&gt;C-&gt;D，是通过路由转发的。 A 知道自己的下一个中转站是 B，那从 A 发出来的包，应该把 B 的 IP 地址放在哪里呢？B 知道自己的下一个中转站是 C，从 B 发出来的包，应该把 C 的 IP 地址放在哪里呢？如果放在 IP 协议中的目标地址，那包到了中转站，怎么知道最终的目的地址是 D 呢？ 你一定经常听说二层设备、三层设备。二层设备处理的通常是 MAC层的东西。那我发送一个 HTTP 的包，是在第七层工作的，那是不是不需要经过二层设备？或者即便经过了，二层设备也不处理呢？或者换一种问法，二层设备处理的包里，有没有 HTTP 层的内容呢？ 一个综合的问题：从你的电脑，通过 SSH 登录到公有云主机里面，都需要经历哪些过程？或者说你打开一个电商网站，都需要经历哪些过程？说得越详细越好。 2.网络为什么要分层？因为是个复杂的程序都要分层。 理解计算机网络中的概念，一个很好的角度是，想象网络包就是一段 Buffer，或者一块内存，是有格式的。同时，想象自己是一个处理网络包的程序，而且这个程序可以跑在电脑上，可以跑在服务器上，可以跑在交换机上，也可以跑在路由器上。你想象自己有很多的网口，从某个口拿进一个网络包来，用自己的程序处理一下，再从另一个网口发送出去。 当然网络包的格式很复杂，这个程序也很复杂。复杂的程序都要分层，这是程序设计的要求。比如，复杂的电商还会分数据库层、缓存层、Compose层、Controller层和接入层，每一层专注做本层的事情。 3.程序是如何工作的？ 当一个网络包从一个网口经过的时候，你看到了，首先先看看要不要请进来，处理一把。有的网口配置了混杂模式，凡是经过的，全部拿进来。 获取的过程 拿进来以后，就要交给一段程序来处理。于是，你调用process_layer2(buffer)。当然，这是一个假的函数。但是你明白其中的意思，知道肯定是有这么个函数的。那这个函数是干什么的呢？从 Buffer 中，摘掉二层的头，看一看，应该根据头里面的内容做什么操作。 假设你发现这个包的 MAC 地址和你的相符，那说明就是发给你的，于是需要调用process_layer3(buffer)。这个时候，Buffer 里面往往就没有二层的头了，因为已经在上一个函数的处理过程中拿掉了，或者将开始的偏移量移动了一下。在这个函数里面，摘掉三层的头，看看到底是发送给自己的，还是希望自己转发出去的。 如何判断呢？如果 IP地址不是自己的，那就应该转发出去；如果 IP 地址是自己的，那就是发给自己的。根据 IP 头里面的标示，拿掉三层的头，进行下一层的处理，到底是调用 process_tcp(buffer) 呢，还是调用 process_udp(buffer) 呢？ 假设这个地址是 TCP 的，则会调用process_tcp(buffer)。这时候，Buffer 里面没有三层的头，就需要查看四层的头，看这是一个发起，还是一个应答，又或者是一个正常的数据包，然后分别由不同的逻辑进行处理。如果是发起或者应答，接下来可能要发送一个回复包；如果是一个正常的数据包，就需要交给上层了。交给谁呢？是不是有 process_http(buffer) 函数呢？ 没有的，如果你是一个网络包处理程序，你不需要有 process_http(buffer)，而是应该交给应用去处理。交给哪个应用呢？在四层的头里面有端口号，不同的应用监听不同的端口号。如果发现浏览器应用在监听这个端口，那你发给浏览器就行了。至于浏览器怎么处理，和你没有关系。 发送的过程 浏览器自然是解析 HTML，显示出页面来。电脑的主人看到页面很开心，就点了鼠标。点击鼠标的动作被浏览器捕获。浏览器知道，又要发起另一个 HTTP 请求了，于是使用端口号，将请求发给了你。 你应该调用send_tcp(buffer)。不用说，Buffer 里面就是 HTTP 请求的内容。这个函数里面加一个 TCP 的头，记录下源端口号。浏览器会给你目的端口号，一般为 80 端口。 然后调用send_layer3(buffer)。Buffer 里面已经有了 HTTP 的头和内容，以及 TCP 的头。在这个函数里面加一个 IP 的头，记录下源 IP 的地址和目标 IP 的地址。 然后调用send_layer2(buffer)。Buffer 里面已经有了 HTTP 的头和内容、TCP 的头，以及 IP 的头。这个函数里面要加一下 MAC 的头，记录下源 MAC 地址，得到的就是本机器的 MAC 地址和目标的 MAC 地址。不过，这个还要看当前知道不知道，知道就直接加上；不知道的话，就要通过一定的协议处理过程，找到 MAC 地址。反正要填一个，不能空着。 万事俱备，只要 Buffer 里面的内容完整，就可以从网口发出去了，你作为一个程序的任务就算告一段落了。 更清晰的图示（来自《图解TCP/IP》）： 4.揭秘层与层之间的关系首先是分层的比喻。所有不能表示出层层封装含义的比喻，都是不恰当的。总经理握手，不需要员工在吧，总经理之间谈什么，不需要员工参与吧，但是网络世界不是这样的。正确的应该是，总经理之间沟通的时候，经理将总经理放在自己兜里，然后组长把经理放自己兜里，员工把组长放自己兜里，像套娃娃一样。那员工直接沟通，不带上总经理，就不恰当了。 现实生活中，往往是员工说一句，组长补充两句，然后经理补充两句，最后总经理再补充两句。但是在网络世界，应该是总经理说话，经理补充两句，组长补充两句，员工再补充两句。 那 TCP 在三次握手的时候，IP 层和 MAC 层在做什么呢？当然是 TCP 发送每一个消息，都会带着 IP 层和 MAC 层了。因为，TCP 每发送一个消息，IP 层和 MAC 层的所有机制都要运行一遍。而你只看到 TCP 三次握手了，其实，IP 层和 MAC 层为此也忙活好久了。 这里要记住一点：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。 所以，对 TCP 协议来说，三次握手也好，重试也好，只要想发出去包，就要有 IP 层和 MAC 层，不然是发不出去的。 经常有人会问这样一个问题，我都知道那台机器的 IP 地址了，直接发给他消息呗，要 MAC地址干啥？这里的关键就是，没有 MAC地址消息是发不出去的。 所以如果一个 HTTP 协议的包跑在网络上，它一定是完整的。无论这个包经过哪些设备，它都是完整的。 所谓的二层设备、三层设备，都是这些设备上跑的程序不同而已。一个 HTTP 协议的包经过一个二层设备，二层设备收进去的是整个网络包。这里面 HTTP、TCP、 IP、 MAC 都有。什么叫二层设备呀，就是只把 MAC 头摘下来，看看到底是丢弃、转发，还是自己留着。那什么叫三层设备呢？就是把 MAC 头摘下来之后，再把 IP 头摘下来，看看到底是丢弃、转发，还是自己留着。 5.小结和补充 理解网络协议的工作模式的两个小窍门： 始终想象自己是一个处理网络包的程序，如何拿到网络包，如何根据规则进行处理，如何发出去； 始终牢记一个原则：只要是在网络上跑的包，都是完整的。可以有下层没上层，绝对不可能有上层没下层。 网络的构成要素图示例： 关于通信协议，更恰当的比喻有，通信协议就像没有天桥的双子楼，要从A座的24层到达B座24层就得先下楼梯再上楼梯，其他协议也是如此，比如4G。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>《趣谈网络协议》学习笔记</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1-为什么要学习网络协议？]]></title>
    <url>%2F2019%2FNetworkProtocol-01.html</url>
    <content type="text"><![CDATA[这是我学习《趣谈网络协议》的一篇笔记。 协议如同人与人的对话，语言不通，无法沟通。 12345public class HelloWorld &#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125; 上面这段文字表现的是人类和计算机沟通的协议，只有通过这种协议，计算机才知道我们想让它做什么。 而网络协议是计算机与计算机之间通过网络实现通信时事先达成的一种“约定”。 1.协议三要素这种协议还是更接近人类语言，机器不能直接读懂，需要进行翻译，翻译的工作教给编译器（compile）。 编译过程的简单表示： 计算机语言作为程序员控制一台计算机工作的协议，具备了协议的三要素。 语法，就是这一段内容要符合一定的规则和格式。例如，括号要成对，结束要使用分号等。 语义，就是这一段内容要代表某种意义。例如数字减去数字是有意义的，数字减去文本一般来说就没有意义。 顺序，就是先干啥，后干啥。例如，可以先加上某个数值，然后再减去某个数值。 只有通过网络协议，才能使一大片机器互相协作、共同完成一件事。 用网易考拉的HTTP一段，来描述协议的三要素： 12345678910HTTP/1.1 200 OKDate: Tue, 27 Mar 2018 16:50:26 GMTContent-Type: text/html;charset=UTF-8Content-Language: zh-CN &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;base href="https://pages.kaola.com/" /&gt;&lt;meta charset="utf-8"/&gt; &lt;title&gt; 网易考拉 3 周年主会场 &lt;/title&gt; 首先，符合语法，也就是说，只有按照上面那个格式来，浏览器才认。例如，上来是状态，然后是首部，然后是内容。 第二，符合语义，就是要按照约定的意思来。例如，状态 200，表述的意思是网页成功返回。如果不成功，就是我们常见的“404”。 第三，符合顺序，你一点浏览器，就是发送出一个 HTTP 请求，然后才有上面那一串 HTTP 返回的东西。 2.常用的网络协议通过一个电商网站下单过程，看涉及的网络协议： 在浏览器里面输入网易考拉的URL https://www.kaola.com； 然后通过DNS（地址簿协议）或HTTPDNS（更精准的地址簿协议）； 最终得到互联网的“门牌号”，IP地址106.114.138.24 ； 知道地址，浏览器开始打包发送请求，普通请求使用HTTP协议，购物等需要加密传输的使用HTTPS协议； ​ DNS、HTTP、HTTPS 所在的层我们称为应用层。 应用层封装后，浏览器会将包传输给传输层； 传输层有两种协议，一种是无连接的协议UDP，一种是面向连接的协议TCP。对于支付来讲，往往使用 TCP 协议。所谓的面向连接就是，TCP 会保证这个包能够到达目的地。如果不能到达，就会重新发送，直至到达。 TCP 协议里面会有两个端口，一个是浏览器监听的端口，一个是电商的服务器监听的端口。操作系统往往通过端口来判断，它得到的包应该给哪个进程。 传输层层封装后，浏览器会将包传输给网络层（也叫IP层）。这层涉及IP协议，IP协议会封装浏览器所在机器的 IP 地址(源IP地址)和电商网站所在服务器的 IP 地址（目标IP地址）。 ​ 操作系统既然知道了目标 IP 地址，就开始想如何根据这个门牌号找到目标机器。操作系统往往会判断，这个目标 IP 地址是本地人，还是外地人。如果是本地人，从门牌号就能看出来，但是显然电商网站不在本地，而在遥远的地方。 ​ 操作系统知道要离开本地去远方。虽然不知道远方在何处，但是可以这样类比一下：如果去国外要去海关，去外地就要去网关。而操作系统启动的时候，就会被DHCP协议配置 IP地址，以及默认的网关的 IP地址 192.168.1.1。 ​ 操作系统如何将 IP地址发给网关呢？在本地通信基本靠吼，于是操作系统大吼一声，谁是 192.168.1.1 啊？网关会回答它，我就是，我的本地地址在村东头。这个本地地址就是MAC地址，而大吼的那一声是ARP协议。 于是操作系统将 IP 包交给了下一层，也就是MAC层(也叫数据链路层)。网卡再将包发出去。由于这个包里面是有 MAC地址的，因而它能够到达最近的网关。 网关收到包之后，会根据自己的知识，判断下一步应该怎么走。网关往往是一个路由器，它有一个路由表，指导到某个 IP 地址应该怎么走。 路由器有点像玄奘西行路过的一个个国家的一个个城关。每个城关都连着两个国家，每个国家相当于一个局域网，在每个国家内部，都可以使用本地的地址MAC进行通信。 一旦跨越城关，就需要拿出 IP 头来，里面写着贫僧来自东土大唐（就是源 IP 地址），欲往西天拜佛求经（指的是目标 IP 地址）。路过宝地，借宿一晚，明日启行，请问接下来该怎么走啊？ ​ 城关往往是知道这些“知识”的，因为城关和临近的城关也会经常沟通。到哪里应该怎么走，这种沟通的协议称为路由协议，常用的有OSPF(开放式最短路径优先，Open Shortest Path First)和BGP(边界网关协议，Border Gateway Protocol)。 城关与城关之间是一个国家，当网络包知道了下一步去哪个城关，还是要使用国家内部的MAC地址，通过下一个城关的 MAC地址，找到下一个城关，然后再问下一步的路怎么走，一直到走出最后一个城关。 最后一个城关知道这个网络包要去的地方。于是，对着这个国家吼一声，谁是目标 IP啊？目标服务器就会回复一个 MAC地址。网络包过关后，通过这个 MAC 地址就能找到目标服务器。 目标服务器发现 MAC 地址对上了，取下 MAC 头来，发送给操作系统的网络层。发现 IP 也对上了，就取下 IP 头。IP 头里会写上一层封装的是 TCP 协议，然后将其交给传输层，即TCP层。 在这一层里，对于收到的每个包，都会有一个回复的包说明收到了。这个回复的包绝非这次下单请求的结果，例如购物是否成功，扣了多少钱等，而仅仅是 TCP 层的一个说明，即收到之后的回复。当然这个回复，会沿着刚才来的方向走回去，报个平安。 因为一旦出了国门，西行路上千难万险，如果在这个过程中，网络包走丢了，例如进了大沙漠，或者被强盗抢劫杀害怎么办呢？因而到了要报个平安。 如果过一段时间还是没到，发送端的 TCP层会重新发送这个包，还是上面的过程，直到有一天收到平安到达的回复。这个重试绝非你的浏览器重新将下单这个动作重新请求一次。对于浏览器来讲，就发送了一次下单请求，TCP 层不断自己闷头重试。除非 TCP这一层出了问题，例如连接断了，才轮到浏览器的应用层重新发送下单请求。 当网络包平安到达 TCP层之后，TCP头中有目标端口号，通过这个端口号，可以找到电商网站的进程正在监听这个端口号，假设一个 Tomcat，将这个包发给电商网站。 电商网站的进程得到 HTTP 请求的内容，知道了要买东西，买多少。往往一个电商网站最初接待请求的这个 Tomcat 只是个接待员，负责统筹处理这个请求，而不是所有的事情都自己做。例如，这个接待员要告诉专门管理订单的进程，登记要买某个商品，买多少，要告诉管理库存的进程，库存要减少多少，要告诉支付的进程，应该付多少钱，等等。 如何告诉相关的进程呢？往往通过 RPC调用，即远程过程调用的方式来实现。远程过程调用就是当告诉管理订单进程的时候，接待员不用关心中间的网络互连问题，会由 RPC框架统一处理。RPC 框架有很多种，有基于 HTTP 协议放在 HTTP 的报文里面的，有直接封装在 TCP 报文里面的。 当接待员发现相应的部门都处理完毕，就回复一个 HTTPS 的包，告知下单成功。这个 HTTPS 的包，会像来的时候一样，经过千难万险到达你的个人电脑，最终进入浏览器，显示支付成功。 3.小结和补充 网络协议分层图示 mac地址是唯一的，为什么可以修改? 类比身份证，身份证号是唯一的，不能改变的，但是可以造假。mac地址全球唯一，它是固化在网卡里的。网卡毕竟是个硬件，需要软件支持，既操作系统识别。而操作系统识别出来的mac地址是可以更改的，它只不过是一个字符串。我们常说的修改mac指的是修改电脑中记录的既注册表中的记录。 有了mac地址为什么还要有IP地址？ 这两个相当于出生地（身份证号）和现居地址。身份证号是你的唯一标识，不会重复，一落户就有（网卡一出厂就有mac）。现在我要和你通信（写信给你），地址用你的姓名+身份证，信能送到你手上吗?明显不能！身份证号前六位能定位你出生的县。mac地址前几位也可以定位生产厂家。但是你出生后会离开这个县（哪怕在这个县，也不能具体找到你）。所以一般写个人信息就要有出生地和现居地址了。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>《趣谈网络协议》学习笔记</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Xcode中图标含义总结]]></title>
    <url>%2F2019%2Fxcode-icon-summary.html</url>
    <content type="text"><![CDATA[Xcode中不少有点图标和符号，平常使用不怎么注意，仔细思考🤔一下，有的还不清楚啥意思，这边我做个小小的归纳。 按照显示位置，大概分为以下四类： 一、文件后面的字母或符号 这些字母或符合对应版本控制（Git，Xcode10已经不再支持SVN），如果没有使用Git，也可大概看看那些文件修改了或者是新加的。 M —— modified，已被修改，需要 commitA —— added，文件是新添加的，已经add，需要 commitR —— 文件被重命名? —— 文件是新添加的，还没有addD —— deleted，文件在服务器上已被删除，这时update的话，可删除本地的文件C —— conflict，冲突 二、调试时调用栈里的图标 这些图标用于框架的分类，具体有一下十几种： 三、控制台中一些图标的意思 四、编辑窗口导航栏中的图标 这边的图标和开发者文档中的类似。 这些大部分都好理解，我以Swift来说明一下（OC类似，因为语法不同有的叫法不同）。 C: 类 S: 结构体 f: 函数 M: 方法 P: 属性 E: 枚举 K: 枚举值(Enumeration Case) Ex: 扩展 Pr: 协议 T: 别名(typealias) V: 全局变量 {}: 代码例子 #: 宏 文章 框架 //MARK: -的位置 参考 xcode开发环境中字母图标和debug navigator中的小图标的含义 Debugging with Xcode Xcode Debugger中的Icon符号的意义 Xcode Symbology Challenge! Find examples, identify icons, gain fame and glory]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-最小生成树（未加权图）]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E6%9C%AA%E5%8A%A0%E6%9D%83%E5%9B%BE%EF%BC%89.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Minimum Spanning Tree(Unweighted)) 最小生成树（未加权图）（Minimum Spanning Tree (Unweighted Graph)） 最小生成树描述了包含访问图中每个节点所需的最小数目边的路径。 看下图： 如果我们从节点a开始并想要访问每个其他节点，那么最有效的路径是什么？ 我们可以使用最小生成树算法来计算它。 这是图的最小生成树。 它由粗体边表示： 绘制为更一般形式的树，它看起来像这样： 要计算未加权图上的最小生成树，我们可以使用广度优先搜索 算法。广度优先搜索从源节点开始，并在移动到下一级邻居之前首先通过探索直接邻居节点来遍历图。如果我们通过选择性地删除边来调整此算法，那么它可以将图转换为最小生成树。 让我们逐步完成这个例子。 我们从源节点a开始，将其添加到队列中并将其标记为已访问。 12queue.enqueue(a)a.visited = true 队列现在是[a]。 与广度优先搜索一样，我们将队列前面的节点a出队，并将其直接邻居节点b和h入队。 将它们标记为访问过。 12345queue.dequeue() // aqueue.enqueue(b)b.visited = truequeue.enqueue(h)h.visited = true 队列现在是[b, h]。 将b出队并将邻居节点c入队。 将其标记为已访问。 将b到h边移除，因为已经访问过h。 1234queue.dequeue() // bqueue.enqueue(c)c.visited = trueb.removeEdgeTo(h) 队列现在是[h, c]。 将h出队并将邻居节点g和i入队，并将它们标记为已访问。 12345queue.dequeue() // hqueue.enqueue(g)g.visited = truequeue.enqueue(i)i.visited = true 队列现在是[c, g, i]。 将c出队并将邻居节点d和f入队，并将它们标记为已访问。 删除c和i之间的边，因为已经访问了i。 123456queue.dequeue() // cqueue.enqueue(d)d.visited = truequeue.enqueue(f)f.visited = truec.removeEdgeTo(i) 队列现在是[g, i, d, f]。 出队g。 它的所有邻居都已经被发现了，所以没有什么可以入队的。 删除g到f的边，以及g到i的边，因为已经发现了f和i。 123queue.dequeue() // gg.removeEdgeTo(f)g.removeEdgeTo(i) 队列现在是[i, d, f]。 出队i。 这个节点没有别的办法。 1queue.dequeue() // i 队列现在是[d, f]。 将d出队并将邻居节点e入队。 将其标记为已访问。 删除d到f的边，因为已经访问了f。 1234queue.dequeue() // dqueue.enqueue(e)e.visited = trued.removeEdgeTo(f) 队列现在是[f, e]。 出列f。 删除f和e之间的边，因为已经访问过e。 12queue.dequeue() // ff.removeEdgeTo(e) 队列现在是[e]。 出队e。 1queue.dequeue() // e 队列为空，这意味着已计算出最小生成树。 代码如下： 12345678910111213141516171819202122func breadthFirstSearchMinimumSpanningTree(graph: Graph, source: Node) -&gt; Graph &#123; let minimumSpanningTree = graph.duplicate() var queue = Queue&lt;Node&gt;() let sourceInMinimumSpanningTree = minimumSpanningTree.findNodeWithLabel(source.label) queue.enqueue(sourceInMinimumSpanningTree) sourceInMinimumSpanningTree.visited = true while let current = queue.dequeue() &#123; for edge in current.neighbors &#123; let neighborNode = edge.neighbor if !neighborNode.visited &#123; neighborNode.visited = true queue.enqueue(neighborNode) &#125; else &#123; current.remove(edge) &#125; &#125; &#125; return minimumSpanningTree&#125; 此函数返回一个新的Graph对象，该对象仅描述最小生成树。 在图中，这将是仅包含粗体边的图。 将此代码放在playground上，进行测试： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748let graph = Graph()let nodeA = graph.addNode("a")let nodeB = graph.addNode("b")let nodeC = graph.addNode("c")let nodeD = graph.addNode("d")let nodeE = graph.addNode("e")let nodeF = graph.addNode("f")let nodeG = graph.addNode("g")let nodeH = graph.addNode("h")let nodeI = graph.addNode("i")graph.addEdge(nodeA, neighbor: nodeB)graph.addEdge(nodeA, neighbor: nodeH)graph.addEdge(nodeB, neighbor: nodeA)graph.addEdge(nodeB, neighbor: nodeC)graph.addEdge(nodeB, neighbor: nodeH)graph.addEdge(nodeC, neighbor: nodeB)graph.addEdge(nodeC, neighbor: nodeD)graph.addEdge(nodeC, neighbor: nodeF)graph.addEdge(nodeC, neighbor: nodeI)graph.addEdge(nodeD, neighbor: nodeC)graph.addEdge(nodeD, neighbor: nodeE)graph.addEdge(nodeD, neighbor: nodeF)graph.addEdge(nodeE, neighbor: nodeD)graph.addEdge(nodeE, neighbor: nodeF)graph.addEdge(nodeF, neighbor: nodeC)graph.addEdge(nodeF, neighbor: nodeD)graph.addEdge(nodeF, neighbor: nodeE)graph.addEdge(nodeF, neighbor: nodeG)graph.addEdge(nodeG, neighbor: nodeF)graph.addEdge(nodeG, neighbor: nodeH)graph.addEdge(nodeG, neighbor: nodeI)graph.addEdge(nodeH, neighbor: nodeA)graph.addEdge(nodeH, neighbor: nodeB)graph.addEdge(nodeH, neighbor: nodeG)graph.addEdge(nodeH, neighbor: nodeI)graph.addEdge(nodeI, neighbor: nodeC)graph.addEdge(nodeI, neighbor: nodeG)graph.addEdge(nodeI, neighbor: nodeH)let minimumSpanningTree = breadthFirstSearchMinimumSpanningTree(graph, source: nodeA)print(minimumSpanningTree) // [node: a edges: ["b", "h"]] // [node: b edges: ["c"]] // [node: c edges: ["d", "f"]] // [node: d edges: ["e"]] // [node: h edges: ["g", "i"]] 注意： 在未加权的图上，任何生成树始终是最小生成树。 这意味着您还可以使用深度优先搜索来查找最小生成树。 作者：Chris Pilcher， Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>最小生成树（未加权图）</tag>
        <tag>Minimum Spanning Tree (Unweighted Graph)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-最小生成树（加权图）]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88%E5%8A%A0%E6%9D%83%E5%9B%BE%EF%BC%89.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Minimum Spanning Tree 最小生成树（加权图）（Minimum Spanning Tree (Weighted Graph)） 这个主题有一篇辅导文章 连接的无向加权图的最小生成树（MST）具有来自原始图的边的子集，其将所有顶点连接在一起，没有任何循环并尽可能减少总边权重。 图中可以有多个MST。 有两种流行的算法来计算图形的MST - Kruskal算法和Prim算法。 两种算法的总时间复杂度为O(ElogE)，其中E是原始图的边数。 Kruskal算法Sort the edges base on weight. Greedily select the smallest one each time and add into the MST as long as it doesn’t form a cycle.根据权重对边进行排序。每次贪婪地选择最小的一个并且只要它不形成循环就加入MST。Kruskal的算法使用并查集 数据结构来检查是否有任何其他边导致循环。逻辑是将所有连接的顶点放在同一个集合中（在并查集的概念中）。如果来自新边的两个顶点不属于同一个集合，那么将该边添加到MST中是安全的。 下图演示了这个步骤： 准备12345678910// Initialize the values to be returned and Union Find data structure.var cost: Int = 0var tree = Graph&lt;T&gt;()var unionFind = UnionFind&lt;T&gt;()for vertex in graph.vertices &#123;// Initially all vertices are disconnected.// Each of them belongs to it's individual set. unionFind.addSetWith(vertex)&#125; 排序边：1let sortedEdgeListByWeight = graph.edgeList.sorted(by: &#123; $0.weight &lt; $1.weight &#125;) 一次取一个边并尝试将其插入MST。123456789101112131415for edge in sortedEdgeListByWeight &#123; let v1 = edge.vertex1 let v2 = edge.vertex2 // Same set means the two vertices of this edge were already connected in the MST. // Adding this one will cause a cycle. if !unionFind.inSameSet(v1, and: v2) &#123; // Add the edge into the MST and update the final cost. cost += edge.weight tree.addEdge(edge) // Put the two vertices into the same set. unionFind.unionSetsContaining(v1, and: v2) &#125;&#125; Prim算法Prim算法不会对所有边进行预排序。相反，它使用优先队列来维护正在运行的已排序的下一个可能的顶点。从一个顶点开始，循环遍历所有未访问的邻居，并为每个邻居入队一对值 —— 顶点和将当前顶点连接到邻居的边的权重。每次贪婪地选择优先队列的顶部（权重值最小的那个）顶点，如果尚未访问已入队的邻居，则将边添加到最终的MST中。 下图演示了这个步骤： 准备12345678// Initialize the values to be returned and Priority Queue data structure.var cost: Int = 0var tree = Graph&lt;T&gt;()var visited = Set&lt;T&gt;()// In addition to the (neighbour vertex, weight) pair, parent is added for the purpose of printing out the MST later.// parent is basically current vertex. aka. the previous vertex before neigbour vertex gets visited.var priorityQueue = PriorityQueue&lt;(vertex: T, weight: Int, parent: T?)&gt;(sort: &#123; $0.weight &lt; $1.weight &#125;) 排序顶点：1priorityQueue.enqueue((vertex: graph.vertices.first!, weight: 0, parent: nil)) 123456789101112131415161718192021222324// Take from the top of the priority queue ensures getting the least weight edge.while let head = priorityQueue.dequeue() &#123; let vertex = head.vertex if visited.contains(vertex) &#123; continue &#125; // If the vertex hasn't been visited before, its edge (parent-vertex) is selected for MST. visited.insert(vertex) cost += head.weight if let prev = head.parent &#123; // The first vertex doesn't have a parent. tree.addEdge(vertex1: prev, vertex2: vertex, weight: head.weight) &#125; // Add all unvisted neighbours into the priority queue. if let neighbours = graph.adjList[vertex] &#123; for neighbour in neighbours &#123; let nextVertex = neighbour.vertex if !visited.contains(nextVertex) &#123; priorityQueue.enqueue((vertex: nextVertex, weight: neighbour.weight, parent: vertex)) &#125; &#125; &#125;&#125; 翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>最小生成树（加权图）</tag>
        <tag>Minimum Spanning Tree (Weighted Graph)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中optionals使用总结]]></title>
    <url>%2F2019%2Fswift-optionals.html</url>
    <content type="text"><![CDATA[Github链接：https://github.com/andyRon/LearnSwift/blob/master/Tips/Swift中optionals使用总结.md 变量声明 1234let optional: String? = "unicorn"var optional2: Int?let optionals: [String?] = ["unicorn", nil, "dragon"]var optionals2: [Int]? if let 1234567if let value = optional &#123;// 多变量if let value = optional, let value2 = optional2 &#123;// 布尔值判断从句（boolean clause）if let value = optional, value.hasSuffix("saurus") &#123; guard 123guard let value = optional else &#123; return&#125; while 1while let value = optional &#123; 空合运算（(Nil Coalescing） 1let value = optional ?? "nil" 强制解析 1let value = optional! switch 123456switch optional &#123;case .some(let value): print(value)case .none: print("nil")&#125; map() 1let value = optional.map(String.init(describing:)) flatMap() 1let value = optional.flatMap(URL.init(string:)) compactMap() 1let values = optionals.compactMap &#123; $0 &#125; 类型转换 1let value = optional as! String 可选链 1let value = optional?.uppercased() for 12for element in optionals &#123; if let value = element &#123; for case let 1for case let optional? in optionals &#123; forEach 1optionals?.forEach &#123; value in 错误转换成optional 12try? aThrowingCall()try! aThrowingCall() 参考： https://www.optionals.org]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
        <tag>optionals</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-最短路径算法]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Shortest Path(Unweighted)) 最短路径算法（Shortest Path(Unweighted Graph)） 目标：找到图中从一个节点到另一个节点的最短路径。 假设我们以下图为例： 我们可能想知道从节点A到节点F的最短路径是什么。 如果图是未加权的，那么找到最短路径很容易：我们可以使用广度优先搜索算法。 对于加权图，我们可以使用Dijkstra算法。 未加权图：广度优先搜索广度优先搜索是遍历树或图数据结构的方法。 它从源节点开始，在移动到下一级邻居之前首先探索直接邻居节点。 方便的副作用是，它会自动计算源节点与树或图中其他每个节点之间的最短路径。 广度优先搜索的结果可以用树表示： 树的根节点是广度优先搜索开始的节点。 为了找到从节点A到任何其他节点的距离，我们只计算树中边的数目。 所以我们发现A和F之间的最短路径是2.树不仅告诉你路径有多长，而且还告诉你如何实际从A到F（或者任何一个其他节点）。 让我们将广度优先搜索付诸实践，并计算从A到所有其他节点的最短路径。 我们从源节点A开始，并将其添加到队列中，距离为0。 12queue.enqueue(element: A)A.distance = 0 队列现在是[A]。 我们将A出列并将其两个直接邻居节点B和C入列，并设置距离1。 12345queue.dequeue() // Aqueue.enqueue(element: B)B.distance = A.distance + 1 // result: 1queue.enqueue(element: C)C.distance = A.distance + 1 // result: 1 队列现在是[B, C]。 将B出列，并将B的邻居节点D和E入列，距离为2。 12345queue.dequeue() // Bqueue.enqueue(element: D)D.distance = B.distance + 1 // result: 2queue.enqueue(element: E)E.distance = B.distance + 1 // result: 2 队列现在是[C, D, E]。 将C出列并将C的邻居节点F和G入队，距离为2。 12345queue.dequeue() // Cqueue.enqueue(element: F)F.distance = C.distance + 1 // result: 2queue.enqueue(element: G)G.distance = C.distance + 1 // result: 2 这么一直持续到队列为空，同时我们访问了所有节点。 每次我们发现一个新节点时，它会获得其父节点的distance加1.正如您所看到的，这正是广度优先搜索算法的作用， 除此之外，我们现在还知道距离寻找的路径。 这是代码： 1234567891011121314151617181920func breadthFirstSearchShortestPath(graph: Graph, source: Node) -&gt; Graph &#123; let shortestPathGraph = graph.duplicate() var queue = Queue&lt;Node&gt;() let sourceInShortestPathsGraph = shortestPathGraph.findNodeWithLabel(label: source.label) queue.enqueue(element: sourceInShortestPathsGraph) sourceInShortestPathsGraph.distance = 0 while let current = queue.dequeue() &#123; for edge in current.neighbors &#123; let neighborNode = edge.neighbor if !neighborNode.hasDistance &#123; queue.enqueue(element: neighborNode) neighborNode.distance = current.distance! + 1 &#125; &#125; &#125; return shortestPathGraph&#125; 在playground中进行测试： 12let shortestPathGraph = breadthFirstSearchShortestPath(graph: graph, source: nodeA)print(shortestPathGraph.nodes) 输出结果： Node(label: a, distance: 0), Node(label: b, distance: 1), Node(label: c, distance: 1), Node(label: d, distance: 2), Node(label: e, distance: 2), Node(label: f, distance: 2), Node(label: g, distance: 2), Node(label: h, distance: 3) 注意：这个版本的breadthFirstSearchShortestPath()实际上并不生成树，它只计算距离。 有关如何通过去除边缘将图转换为树，请参见最小生成树/)。 作者：Chris Pilcher，Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>最短路径算法</tag>
        <tag>Shortest Path(Unweighted Graph)</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-深度优先搜索]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Depth-First Search 深度优先搜索(DFS，Depth-First Search) 这个主题已经有辅导文章 深度优先搜索（DFS）是用于遍历或搜索树或图数据结构的算法。它从源节点开始，并在回溯之前尽可能地沿着每个分支进行探索。 深度优先搜索可以用于有向图和无向图。 动画示例以下是深度优先搜索在图上的工作方式： 假设我们从节点A开始搜索。 在深度优先搜索中，我们查看起始节点的第一个邻居并访问它，在这个示例中是节点B。然后我们查找节点B的第一个邻居并访问它，它是节点D。由于D没有自己的任何未访问的邻居节点，我们回溯到节点B并转到其另外的邻居节点E。依此类推，直到我们访问了图中的所有节点。 每当我们访问第一个邻居节点并继续前进，直到无处可去，然后我们回溯到之前访问的节点。 当我们一直回溯到节点A时，搜索就完成了。 对于上面的例子，是按照A，B，D，E，H，F，G，C的顺序访问节点的。 深度优先搜索过程也可以显示为树： 节点的父节点是“发现”该节点的节点。 树的根是您开始深度优先搜索的节点。 每当有一个分支时，那就是我们回溯的地方。 代码深度优先搜索的简单递归实现： 1234567891011func depthFirstSearch(_ graph: Graph, source: Node) -&gt; [String] &#123; var nodesExplored = [source.label] source.visited = true for edge in source.neighbors &#123; if !edge.neighbor.visited &#123; nodesExplored += depthFirstSearch(graph, source: edge.neighbor) &#125; &#125; return nodesExplored&#125; 广度优先搜索首先访问所有直接邻居，而深度优先搜索尝试尽可能地深入树或图。 在 playground 里测试： 1234567891011121314151617181920212223let graph = Graph()let nodeA = graph.addNode("a")let nodeB = graph.addNode("b")let nodeC = graph.addNode("c")let nodeD = graph.addNode("d")let nodeE = graph.addNode("e")let nodeF = graph.addNode("f")let nodeG = graph.addNode("g")let nodeH = graph.addNode("h")graph.addEdge(nodeA, neighbor: nodeB)graph.addEdge(nodeA, neighbor: nodeC)graph.addEdge(nodeB, neighbor: nodeD)graph.addEdge(nodeB, neighbor: nodeE)graph.addEdge(nodeC, neighbor: nodeF)graph.addEdge(nodeC, neighbor: nodeG)graph.addEdge(nodeE, neighbor: nodeH)graph.addEdge(nodeE, neighbor: nodeF)graph.addEdge(nodeF, neighbor: nodeG)let nodesExplored = depthFirstSearch(graph, source: nodeA)print(nodesExplored) 打印结果是： [&quot;a&quot;, &quot;b&quot;, &quot;d&quot;, &quot;e&quot;, &quot;h&quot;, &quot;f&quot;, &quot;g&quot;, &quot;c&quot;] DFS有什么用？深度优先搜索可用于解决许多问题，例如： 查找稀疏图的连通分量 图中节点的拓扑排序 查找图的桥梁（参见：Bridges#Bridge-finding_algorithm)） 还有很多其它应用！ 作者：Paulo Tanaka，Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>深度优先搜索</tag>
        <tag>Depth-First Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-广度优先搜索]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Breadth-First Search 广度优先搜索(BFS，Breadth-First Search) 这个话题已经有个辅导文章 广度优先搜索（BFS，Breadth-First Search）是用于遍历、搜索树或图数据结构的算法。它从源节点开始，在移动到下一级邻居之前首先探索直接邻居节点。 广度优先搜索可以用于有向图和无向图。 动画示例以下是广度优先搜索在图上的工作原理： 当我们访问节点时，将其着色为黑色。 还将其邻居节点放入队列。 在动画中，入队但尚未访问的节点以灰色显示。 让我们按照动画示例进行操作。 我们从源节点A开始，并将其添加到队列中。 在动画中，这显示为节点A变为灰色。 1queue.enqueue(A) 队列现在是[A]。 我们的想法是，只要队列中有节点，我们就会访问位于队列前端的节点，如果尚未访问它们，则将其相邻的邻居节点入队。 要开始遍历图，我们将第一个节点从队列中推出A，并将其着色为黑色。 然后我们将它的两个邻居节点B和C入队。 它们的颜色变成灰色。 123queue.dequeue() // Aqueue.enqueue(B)queue.enqueue(C) 队列现在是[B, C]。 我们将B出列，并将B的邻居节点D和E排入队列。 123queue.dequeue() // Bqueue.enqueue(D)queue.enqueue(E) 队列现在是[C, D, E]。 将C出列，并将C的邻居节点F和G入队。 123queue.dequeue() // Cqueue.enqueue(F)queue.enqueue(G) 队列现在是[D, E, F, G]。 出列D，它没有邻居节点。 1queue.dequeue() // D 队列现在是[E, F, G]。 将E出列并将其单个邻居节点H排队。 注意B也是E的邻居，但我们已经访问了B，所以我们不再将它添加到队列中。 12queue.dequeue() // Equeue.enqueue(H) 队列现在是[F, G, H]。 出队F，它没有未访问的邻居节点。 1queue.dequeue() // F 队列现在是[G, H]。 出列G，它没有未访问的邻居节点。 1queue.dequeue() // G 队列现在是[H]。 出列H，它没有未访问的邻居节点。 1queue.dequeue() // H 队列现在为空，这意味着已经探索了所有节点。 探索节点的顺序是A，B，C，D，E，F，G，H。 我们可以将其显示为树： 节点的父节点是”发现”该节点的节点。 树的根是广度优先搜索开始的节点。 对于未加权的图，此树定义从起始节点到树中每个其他节点的最短路径。 广度优先搜索是在图中找到两个节点之间的最短路径的一种方法。 代码使用队列简单实现广度优先搜索： 1234567891011121314151617181920func breadthFirstSearch(_ graph: Graph, source: Node) -&gt; [String] &#123; var queue = Queue&lt;Node&gt;() queue.enqueue(source) var nodesExplored = [source.label] source.visited = true while let node = queue.dequeue() &#123; for edge in node.neighbors &#123; let neighborNode = edge.neighbor if !neighborNode.visited &#123; queue.enqueue(neighborNode) neighborNode.visited = true nodesExplored.append(neighborNode.label) &#125; &#125; &#125; return nodesExplored&#125; 虽然队列中有节点，但我们访问第一个节点，然后将其尚未被访问的直接邻居节点入队。 将此代码放在 playground中， 并进行如下测试： 1234567891011121314151617181920212223let graph = Graph()let nodeA = graph.addNode("a")let nodeB = graph.addNode("b")let nodeC = graph.addNode("c")let nodeD = graph.addNode("d")let nodeE = graph.addNode("e")let nodeF = graph.addNode("f")let nodeG = graph.addNode("g")let nodeH = graph.addNode("h")graph.addEdge(nodeA, neighbor: nodeB)graph.addEdge(nodeA, neighbor: nodeC)graph.addEdge(nodeB, neighbor: nodeD)graph.addEdge(nodeB, neighbor: nodeE)graph.addEdge(nodeC, neighbor: nodeF)graph.addEdge(nodeC, neighbor: nodeG)graph.addEdge(nodeE, neighbor: nodeH)graph.addEdge(nodeE, neighbor: nodeF)graph.addEdge(nodeF, neighbor: nodeG)let nodesExplored = breadthFirstSearch(graph, source: nodeA)print(nodesExplored) 结果输出： [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;] BFS有什么用？广度优先搜索可用于解决许多问题。 例如： 计算源节点和其他每个节点之间的最短路径/)（仅适用于未加权的图形）。 在未加权的图表上计算最小生成树/)。 作者：Chris Pilcher， Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>广度优先搜索</tag>
        <tag>Breadth-First Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-图]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%9B%BE.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Graph 图(Graph) 这个话题已经有个辅导文章 图看上去像下图： 在计算机科学中，图形被定义为一组点和与之配对的一组边。 点用圆圈表示，边是它们之间的线。 边链接点与点。 注意： 点有时称为“节点”，边称为“链接”。 图可以代表社交网络。 每个人都是一个点，彼此认识的人通过边链接。 下面是一个有点历史不准确的例子： 图具有各种形状和大小。 当为每个边分配正数或负数，边可以具有权重。 考虑一个代表飞机航班的图示例。 城市用点表示，而航班用边表示。 然后，边权重可以描述航班时间或票价。 有了这个假想的航线，从旧金山(San Francisco)飞往莫斯科(Moscow)，经过纽约(New York)这条航线是最便宜的。 边也可以有向的。 在上面提到的例子中，边是无向的。 例如，如果阿达（Ada）可以到达查尔斯（Charles），那么查尔斯也可以到达阿达。 另一方面，有向边意味着单向关系。 从点X到点Y的有向边链接X到Y，但Y不能到X. 从航班的例子来看，从旧金山到阿拉斯加的朱诺( Juneau, Alaska)的有向的边表明从旧金山到朱诺的航班，但不是从朱诺到旧金山（我想这意味着你正在走回头路）的航班。 以下也是图： 左边是树结构，右边是链表。 它们可以被视为形式更简单的图。 它们都有点（节点）和边（链接）。 第一个图（译注：文章的第一个图）包括循环，您可以从点开始，沿着路径，然后返回到原始点。 树是没有这种循环的图。 另一种常见类型的图是有向无环图(DAG, directed acyclic graph)： 像树一样，这个图没有任何循环（无论你从哪里开始，都没有回到起始点的路径），但是这个图的定向边的形状不一定形成层次结构。 为什么使用图？也许你耸耸肩膀思考，有什么大不了的？ 好吧，事实证明图是一种有用的数据结构。 如果您遇到编程问题，您可以将数据表示为点和边，那么您可以将你的问题绘制为图形并使用众所周知的图算法，例如广度优先搜索或深度优先搜索找到解决方案。 例如，假设您有一个任务列表，其中某些任务必须先等待其他任务才能开始。 您可以使用非循环有向图对此进行建模： 每个点代表一个任务。 两个点之间的边意味着必须在目标任务开始之前必须完成源任务。 例如，任务C在B和D完成之前无法启动，B和D可以在A完成之前启动。 现在使用图表表示问题，您可以使用深度优先搜索来执行拓扑排序。 这将使任务处于最佳顺序，以便最大限度地减少等待任务完成所花费的时间。 （这里可能的一个顺序是A，B，D，E，C，F，G，H，I，J，K。） 无论何时遇到困难的编程问题，请问自己，“如何使用图表示此问题？” 图是你所有数据之间特定关系。 诀窍在于如何定义“关系”。 如果您是音乐家，您可能会喜欢这张图： 这些点是C大调的和弦。 边 —— 和弦之间的关系 —— 代表可能一个和弦跟随另一个和弦。 这是一个有向图，因此箭头的方向显示了如何从一个和弦转到下一个和弦。 它也是一个权重图，其中边的权重 —— 这里用线条粗细描绘 —— 显示了两个和弦之间的强关系。 正如你所看到的，G7和弦很可能后跟一个C和弦，也可能是一个Am和弦。 您可能在不知道图时，已经使用过图了。 您的数据模型也是图（来自Apple的Core Data文档）： 程序员使用的另一个常见图是状态机(state machine)，其中边描述了状态之间转换的条件。 这是一个模拟我的猫的状态机： 图很棒。 Facebook从他们的社交图中赚了大钱。 如果要学习任何数据结构，则必须选择图和大量标准图算法。 哦，我的点和边！理论上，图只是一堆点和边对象，但是如何在代码中描述它？ 有两种主要策略：邻接表和邻接矩阵。 邻接表(Adjacency List)。在邻接表实现中，每个点存储一个从这个点出发的所有边的列表。例如，如果点A具有到点B，C和D的边，则点A将具有包含3个边的列表。 邻接表描述了传出边。 A具有到B的边，但是B没有返回到A的边，因此A不出现在B的邻接表中。在两个点之间找到边或权重成本可能很高，因为没有随机访问边。 您必须遍历邻接表，直到找到它为止。 邻接矩阵(Adjacency Matrix)。 在邻接矩阵实现中，具有表示顶点的行和列的矩阵存储权重以指示顶点是否连接以及权重。 例如，如果从点A到点B有一个权重为5.6的有向边，那么点A行和B列交叉的值为5.6： 向图添加另一个点是成本很高，因为必须创建一个新的矩阵结构，并有足够的空间来容纳新的行/列，并且必须将现有结构复制到新的矩阵结构中。 那么你应该使用哪一个？ 大多数情况下，邻接表是正确的方法。 以下是两者之间更详细的比较。 设 V 是图中点的数量，E 是边数。 然后我们有： 操作 邻接列表 邻接矩阵 存储空间 O(V + E) O(V^2) 添加点 O(1) O(V^2) Add Edge O(1) O(1) 添加边 O(1) O(1) 检查邻接 O(V) O(1) “检查邻接”意味着我们试图确定给定点是另一个点的直接邻居。 检查邻接表的邻接的时间是 O(V)，因为在最坏的情况下，点需要连接到每个其他点。 在稀疏图的情况下，每个点仅链接到少数其他点，邻接表是存储边的最佳方式。 如果图是密集的，其中每个点连接到大多数其他点，则优选矩阵。 以下是邻接表和邻接矩阵的示例实现： 代码：边和点每个点的邻接表由Edge对象组成： 12345678public struct Edge&lt;T&gt;: Equatable where T: Equatable, T: Hashable &#123; public let from: Vertex&lt;T&gt; public let to: Vertex&lt;T&gt; public let weight: Double?&#125; 此结构描述了“from”和“to”点以及权重值。 请注意，Edge对象始终是有向的，单向连接（如上图中的箭头所示）。 如果需要无向连接，还需要在相反方向添加Edge对象。 每个Edge可选地存储权重，因此它们可用于描述权重和无权重图。 Vertex看起来像这样： 123456public struct Vertex&lt;T&gt;: Equatable where T: Equatable, T: Hashable &#123; public var data: T public let index: Int&#125; 它存储了一个可以表示任意数据泛型T，它是Hashable以强制唯一性，还有Equatable。 点本身也是Equatable。 代码：图 注意： 有很多方法可以实现图。 这里给出的代码只是一种可能的实现。 您可能希望根据为您尝试解决的每个问题定制图代码。 例如，您的边可能不需要weight属性，或者您可能不需要区分有向边和无向边。 这是简单图的例子： 我们可以将其表示为邻接矩阵或邻接表。 实现这些概念的类都从AbstractGraph继承了一个通用API，因此它们可以以相同的方式创建，在幕后具有不同的优化数据结构。 让我们使用每个表示创建一些有向权重图来存储示例： 123456789101112131415for graph in [AdjacencyMatrixGraph&lt;Int&gt;(), AdjacencyListGraph&lt;Int&gt;()] &#123; let v1 = graph.createVertex(1) let v2 = graph.createVertex(2) let v3 = graph.createVertex(3) let v4 = graph.createVertex(4) let v5 = graph.createVertex(5) graph.addDirectedEdge(v1, to: v2, withWeight: 1.0) graph.addDirectedEdge(v2, to: v3, withWeight: 1.0) graph.addDirectedEdge(v3, to: v4, withWeight: 4.5) graph.addDirectedEdge(v4, to: v1, withWeight: 2.8) graph.addDirectedEdge(v2, to: v5, withWeight: 3.2)&#125; 如前所述，要创建无向边，您需要制作两个有向边。 对于无向图，我们改为使用以下方法： 12345graph.addUndirectedEdge(v1, to: v2, withWeight: 1.0)graph.addUndirectedEdge(v2, to: v3, withWeight: 1.0)graph.addUndirectedEdge(v3, to: v4, withWeight: 4.5)graph.addUndirectedEdge(v4, to: v1, withWeight: 2.8)graph.addUndirectedEdge(v2, to: v5, withWeight: 3.2) 在任何一种情况下，我们都可以提供nil作为withWeight参数的值来制作无权重图。 代码：邻接表为了维护邻接表，有一个类将边列表映射到点。 该图只是维护这些对象的数组，并根据需要修改它们。 1234567891011121314private class EdgeList&lt;T&gt; where T: Equatable, T: Hashable &#123; var vertex: Vertex&lt;T&gt; var edges: [Edge&lt;T&gt;]? = nil init(vertex: Vertex&lt;T&gt;) &#123; self.vertex = vertex &#125; func addEdge(_ edge: Edge&lt;T&gt;) &#123; edges?.append(edge) &#125;&#125; 它们被实现为一个类而不是结构，所以我们可以通过引用来修改它们，就像将边添加到新点一样，源点已经有一个边列表： 123456789101112131415open override func createVertex(_ data: T) -&gt; Vertex&lt;T&gt; &#123; // check if the vertex already exists let matchingVertices = vertices.filter() &#123; vertex in return vertex.data == data &#125; if matchingVertices.count &gt; 0 &#123; return matchingVertices.last! &#125; // if the vertex doesn't exist, create a new one let vertex = Vertex(data: data, index: adjacencyList.count) adjacencyList.append(EdgeList(vertex: vertex)) return vertex&#125; 该示例的邻接表如下所示： 1234v1 -&gt; [(v2: 1.0)]v2 -&gt; [(v3: 1.0), (v5: 3.2)]v3 -&gt; [(v4: 4.5)]v4 -&gt; [(v1: 2.8)] 一般形式a -&gt; [(b: w), ...]，表示从a到b的边是存在的，权重为w（可能有更多a出去的边）。 代码：邻接矩阵我们将在二维[[Double?]]数组中追踪邻接矩阵。 nil表示没有边，而任何其他值表示给定权重的边。 如果adjacencyMatrix[i][j]不是nil，则从点i到点j有一条边。 要使用点索引矩阵，我们使用Vertex中的index属性，该属性是在通过图对象创建点时分配的。 创建新点时，图必须调整矩阵的大小： 1234567891011121314151617181920212223242526open override func createVertex(_ data: T) -&gt; Vertex&lt;T&gt; &#123; // check if the vertex already exists let matchingVertices = vertices.filter() &#123; vertex in return vertex.data == data &#125; if matchingVertices.count &gt; 0 &#123; return matchingVertices.last! &#125; // if the vertex doesn't exist, create a new one let vertex = Vertex(data: data, index: adjacencyMatrix.count) // Expand each existing row to the right one column. for i in 0 ..&lt; adjacencyMatrix.count &#123; adjacencyMatrix[i].append(nil) &#125; // Add one new row at the bottom. let newRow = [Double?](repeating: nil, count: adjacencyMatrix.count + 1) adjacencyMatrix.append(newRow) _vertices.append(vertex) return vertex&#125; 然后邻接矩阵看起来像这样： [[nil, 1.0, nil, nil, nil] v1 [nil, nil, 1.0, nil, 3.2] v2 [nil, nil, nil, 4.5, nil] v3 [2.8, nil, nil, nil, nil] v4 [nil, nil, nil, nil, nil]] v5 v1 v2 v3 v4 v5 扩展阅读本文描述了图是什么，以及如何实现基本数据结构。 我们还有关于图实际用途的其他文章，所以也要查看一下！ 作者：Donald Pinckney， Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>图</tag>
        <tag>Graph</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-最大公约数算法]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Greatest Common Divisor 最大公约数算法（Greatest Common Divisor） 两个数字a和b的 最大公约数（或最大公因数）是将a和b整除都没有余数的最大正整数。 例如，gcd(39, 52) = 13，因为13除以39(39/13 = 3)以及52(52/13 = 4)，而且没有比13更大的数字。 在某些时候你可能不得不在学校里了解这一点。:-) 找到两个数字的GCD的费力方法是先找出两个数字的因子，然后取其共同的最大数。 问题在于分解数字是非常困难的，特别是当它们变大时。 （从好的方面来说，这种困难也是保证您的在线支付安全的原因。） 有一种更聪明的方法来计算GCD：欧几里德的算法。 这个算法主要观点是， gcd(a, b) = gcd(b, a % b) 其中a％b是a除以b的余数。 以下是Swift中这个想法的实现： 12345678func gcd(_ a: Int, _ b: Int) -&gt; Int &#123; let r = a % b if r != 0 &#123; return gcd(b, r) &#125; else &#123; return b &#125;&#125; 在 playground 上，试试一些例子： 123gcd(52, 39) // 13gcd(228, 36) // 12gcd(51357, 3819) // 57 让我们分步完成第三个例子： gcd(51357, 3819) 根据欧几里德的规则，这相当于， gcd(3819, 51357 % 3819) = gcd(3819, 1710) 因为51357 ％ 3819的余数是1710。 详细计算为51357 = (13 * 3819) + 1710，但我们只关心余数部分。 所以gcd(51357, 3819)与gcd(3819, 1710)相同。 这很有用，因为我们可以继续简化： gcd(3819, 1710) = gcd(1710, 3819 % 1710) = gcd(1710, 399) = gcd(399, 1710 % 399) = gcd(399, 114) = gcd(114, 399 % 114) = gcd(114, 57) = gcd(57, 114 % 57) = gcd(57, 0) 现在不能再进一步划分了。 114 / 57的余数为零，因为114 = 57 * 2。 这意味着我们找到了答案： gcd(3819, 51357) = gcd(57, 0) = 57 因此，在欧几里德算法的每个步骤中，数字变得更小，并且在某个点上，当它们中的一个变为零时它结束。 顺便说一下，两个数字的GCD也可能为1.它们被认为是 互素（译注：也叫互质）。 当没有数字将它们整除时会发生这种情况，例如： 1gcd(841, 299) // 1 下面是欧几里德算法略微不同的一种实现。 与第一个版本不同，它不使用递归，而只使用基本的while循环。 123456789101112func gcd(_ m: Int, _ n: Int) -&gt; Int &#123; var a = 0 var b = max(m, n) var r = min(m, n) while r != 0 &#123; a = b b = r r = a % b &#125; return b&#125; 函数顶部的 max() 和 min() 确保我们总是用较大的数字除以较小的数字。 最小公倍数与GCD相关的想法是 最小公倍数 或叫做LCM。 两个数字a和b的最小公倍数是两者的倍数中最小的正整数。 换句话说，LCM可以被a和b整除。 例如：lcm(2, 3) = 6，因为6可以被2整除，也可以被3整除。 我们也可以使用欧几里德算法计算LCM： a * b lcm(a, b) = --------- gcd(a, b) 代码： 123func lcm(_ m: Int, _ n: Int) -&gt; Int &#123; return m / gcd(m, n) * n&#125; 在playground中测试： 1lcm(10, 8) // 40 您可能不需要在任何实际问题中使用GCD或LCM，但是使用这种古老的算法很酷。 它首先由欧几里德在公元前300年左右他的书籍元素中描述。 有传言说他在攻击他的Commodore 64时，发现了这个算法。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>最大公约数算法</tag>
        <tag>Greatest Common Divisor</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-四叉树]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%9B%9B%E5%8F%89%E6%A0%91.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/QuadTree 四叉树（QuadTree） 四叉树是一种树，其中每个内部（非叶节点）节点有四个子节点。 问题考虑以下问题：您需要存储多个点（每个点是一对X和Y坐标），然后您需要回答哪些点位于某个矩形区域。一个天真的解决方案是将点存储在一个数组中，然后迭代这些点并分别检查每个点。 该解决方案花费O(n)。 更好的方法四叉树最常用于通过递归地将其细分为四个区域（象限）来划分二维空间。 让我们看看如何使用四叉树来存储点数。 树中的每个节点代表一个矩形区域，并存储所有位于其区域中的有限数量（maxPointCapacity）点。 12345678910111213141516171819202122232425262728class QuadTreeNode &#123; enum NodeType &#123; case leaf case `internal`(children: Children) &#125; struct Children &#123; let leftTop: QuadTreeNode let leftBottom: QuadTreeNode let rightTop: QuadTreeNode let rightBottom: QuadTreeNode ... &#125; var points: [Point] = [] let rect: Rect var type: NodeType = .leaf static let maxPointCapacity = 3 init(rect: Rect) &#123; self.rect = rect &#125; ...&#125; 一旦达到叶节点的限制，就会向节点添加四个子节点，它们代表节点rect的topLeft，topRight，bottomLeft，bottomRight象限;rect中的每个结果点都将传递给其中一个子节点。 因此，总是将新点添加到叶节点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647extension QuadTreeNode &#123; @discardableResult func add(point: Point) -&gt; Bool &#123; if !rect.contains(point: point) &#123; return false &#125; switch type &#123; case .internal(let children): // pass the point to one of the children for child in children &#123; if child.add(point: point) &#123; return true &#125; &#125; return false // should never happen case .leaf: points.append(point) // if the max capacity was reached, become an internal node if points.count == QuadTreeNode.maxPointCapacity &#123; subdivide() &#125; &#125; return true &#125; private func subdivide() &#123; switch type &#123; case .leaf: type = .internal(children: Children(parentNode: self)) case .internal: preconditionFailure("Calling subdivide on an internal node") &#125; &#125;&#125;extension Children &#123; init(parentNode: QuadTreeNode) &#123; leftTop = QuadTreeNode(rect: parentNode.rect.leftTopRect) leftBottom = QuadTreeNode(rect: parentNode.rect.leftBottomRect) rightTop = QuadTreeNode(rect: parentNode.rect.rightTopRect) rightBottom = QuadTreeNode(rect: parentNode.rect.rightBottomRect) &#125;&#125; 为了找到位于给定区域中的点，我们现在可以从上到下遍历树并从节点收集合适的点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344class QuadTree &#123; ... let root: QuadTreeNode public func points(inRect rect: Rect) -&gt; [Point] &#123; return root.points(inRect: rect) &#125;&#125;extension QuadTreeNode &#123; func points(inRect rect: Rect) -&gt; [Point] &#123; // if the node's rect and the given rect don't intersect, return an empty array, // because there can't be any points that lie the node's (or its children's) rect and // in the given rect if !self.rect.intersects(rect: rect) &#123; return [] &#125; var result: [Point] = [] // collect the node's points that lie in the rect for point in points &#123; if rect.contains(point: point) &#123; result.append(point) &#125; &#125; switch type &#123; case .leaf: break case .internal(children: let children): // recursively add children's points that lie in the rect for childNode in children &#123; result.append(contentsOf: childNode.points(inRect: rect)) &#125; &#125; return result &#125;&#125; 在最坏的情况下，添加点和搜索仍然可以占用O(n)，因为树不以任何方式平衡。 但是，平均而言，它的运行速度明显更快（与O(log n)相当）。 扩展阅读在MapView中显示大量对象 - 四叉树的一个很好的用例（Thoughtbot Article） 四叉树的维基百科 作者：Timur Galimov翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>四叉树</tag>
        <tag>QuadTree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-八叉树]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%85%AB%E5%8F%89%E6%A0%91.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Octree 八叉树（Octree） 八叉树是树，其中每个内部（非叶节点）节点有八个子节点。 例如，通常用于游戏中的碰撞检测。 问题考虑以下问题：您需要在3D空间中存储多个对象（每个对象在某个位置使用X，Y和Z坐标表示）然后您需要回答哪些对象位于某个3D区域。 一个天真的解决方案是将点存储在一个数组中，然后迭代这些点并分别检查每个点。 该解决方案花费O(n)。 更好的方法八叉树最常用于通过递归地将其细分为8个区域来划分三维空间。 让我们看看我们如何使用八叉树来存储一些值。 树中的每个节点代表一个类似盒子的区域。 叶节点在该区域中存储单个点，并为该点分配一组对象。 一旦添加了同一区域内（但在不同点）的对象，叶节点就会变成一个内部节点，并向它添加8个子节点（叶节点）。 先前包含在节点中的所有点都将传递给其对应的子节点并进行存储。 因此，只有叶子包含实际的点和值。 为了找到位于给定区域中的点，我们现在可以从上到下遍历树并从节点收集合适的点。 在最坏的情况下，添加点和搜索仍然可以占用O(n)，因为树不以任何方式平衡。 但是，平均而言，它的运行速度明显更快（与O(log n)相当）。 扩展阅读八叉树的维基百科苹果公司的八叉树实现GKOctree 作者：Jaap Wijnen灵感来自于Timur Galimov和苹果公司的八叉树实现翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>八叉树</tag>
        <tag>Octree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-字典树]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%AD%97%E5%85%B8%E6%A0%91.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Trie 字典树（Trie） 这个话题已经有个辅导文章 什么是字典树Trie（在一些其他实现中也称为前缀树或基数树）是用于存储关联数据结构的特殊类型的树。 Trie作为一个字典可能如下所示： 存储英语是Trie的主要用处。 Trie中的每个节点都代表一个单词的单个字符。 然后，一系列节点组成一个单词。 为什么需要字典树？字典树对某些情况非常有用。 以下是一些优点： 查找值通常具有更好的最坏情况时间复杂度。 与哈希映射不同，Trie不需要担心键冲突。 不使用散列来保证元素的唯一路径。 Trie结构默认按字母顺序排列。 常用算法包含（或任何常规查找方法）Trie结构非常适合查找操作。 对于模拟英语语言的Trie结构，找到一个特定的单词就是几个指针遍历的问题： 12345678910111213141516171819202122232425func contains(word: String) -&gt; Bool &#123; guard !word.isEmpty else &#123; return false &#125; // 1 var currentNode = root // 2 var characters = Array(word.lowercased().characters) var currentIndex = 0 // 3 while currentIndex &lt; characters.count, let child = currentNode.children[characters[currentIndex]] &#123; currentNode = child currentIndex += 1 &#125; // 4 if currentIndex == characters.count &amp;&amp; currentNode.isTerminating &#123; return true &#125; else &#123; return false &#125;&#125; contains方法相当简单： 创建对root的引用。 此引用将允许您沿着节点链向下走。 跟踪你想要匹配的单词的字符。 将指针向下移动节点。 isTerminating是一个布尔标志，表示该节点是否是单词的结尾。 如果满足此if条件，则意味着您可以在trie中找到该单词。 插入插入Trie需要您遍历节点，直到您停止必须标记为terminating的节点，或者到达需要添加额外节点的点。 123456789101112131415161718192021222324252627func insert(word: String) &#123; guard !word.isEmpty else &#123; return &#125; // 1 var currentNode = root // 2 for character in word.lowercased().characters &#123; // 3 if let childNode = currentNode.children[character] &#123; currentNode = childNode &#125; else &#123; currentNode.add(value: character) currentNode = currentNode.children[character]! &#125; &#125; // Word already present? guard !currentNode.isTerminating else &#123; return &#125; // 4 wordCount += 1 currentNode.isTerminating = true&#125; 再次，您创建对根节点的引用。 您将此引用沿着节点链移动。 逐字逐句地逐字逐句 有时，要插入的节点已存在。 这是Trie里面两个共享字母的词（即“Apple”，“App”）。如果一个字母已经存在，你将重复使用它，并简单地遍历链条。 否则，您将创建一个表示该字母的新节点。 一旦结束，将isTerminating标记为true，将该特定节点标记为单词的结尾。 删除从字典树中删除键有点棘手，因为还有一些情况需要考虑。 Trie中的节点可以在不同的单词之间共享。 考虑两个词“Apple”和“App”。 在Trie中，代表“App”的节点链与“Apple”共享。 如果你想删除“Apple”，你需要注意保持“App”链。 123456789101112131415161718func remove(word: String) &#123; guard !word.isEmpty else &#123; return &#125; // 1 guard let terminalNode = findTerminalNodeOf(word: word) else &#123; return &#125; // 2 if terminalNode.isLeaf &#123; deleteNodesForWordEndingWith(terminalNode: terminalNode) &#125; else &#123; terminalNode.isTerminating = false &#125; wordCount -= 1&#125; findTerminalNodeOf遍历字典树，找到代表word的最后一个节点。 如果它无法遍历字符串，则返回nil。 deleteNodesForWordEndingWith遍历后缀，删除word表示的节点。 时间复杂度设n是Trie中某个值的长度。 contains - 最差情况O(n) insert - O(n) remove - O(n) 其他值得注意的操作 count：返回Trie中的键数 —— O(1) words：返回包含Trie中所有键的列表 —— O(1) isEmpty：如果Trie为空则返回true，否则返回false —— O(1) 扩展阅读字典树的维基百科 作者：Christian Encarnacion， Kelvin Lau翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>字典树</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-线段树]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E7%BA%BF%E6%AE%B5%E6%A0%91.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Segment Tree 线段树（Segment Tree） 有关懒惰传播的示例，请参阅此文章。 我很高兴向您介绍线段树（Segment Tree）。 它实际上是我最喜欢的数据结构之一，因为它非常灵活且实现简单。 假设你有一个某种类型的数组a和一些关联函数f。 例如，函数可以是求和，乘法，最小，最大，最大公约数等。 你的任务是： 回答由l和r给出的间隔的查询，即执行 f(a[l], a[l+1], ..., a[r-1], a[r]) 支持替换某个索引的一个项目a[index] = newItem 例如，如果我们有一个数字数组： 1var a = [ 20, 3, -1, 101, 14, 29, 5, 61, 99 ] 我们想查询这个数组3到7区间，并执行函数”sum”。 这意味着我们执行以下操作： 101 + 14 + 29 + 5 + 61 = 210 因为101在数组的索引3处，而61在索引7处。所以我们将101和61之间的所有数字传递给sum函数，这将它们全部加起来。 如果我们使用了“min”函数，结果将为5，因为这是3到7之间的最小数字。 如果我们的数组的类型是Int并且f只是两个整数的求和，这是原始的方法： 1234567func query(array: [Int], l: Int, r: Int) -&gt; Int &#123; var sum = 0 for i in l...r &#123; sum += array[i] &#125; return sum&#125; 在最坏的情况下，该算法的运行时间为O(n)，即当l = 0, r =n-1（其中n是数组的元素数量）。 如果我们有m次查询，我们得到O(m*n)复杂度。 如果我们有一个包含100,000个项的数组(n = 10^5并且我们必须执行100个查询 (m = 100)，那么我们的算法将执行 10^7单位工作。 哎哟，这听起来不太好。 让我们来看看我们如何改进它。 线段树允许我们应答查询并用 O(log n)时间替换。 这不是魔术吗？✨ 线段树的主要思想很简单：我们预先计算数组中的一些段，然后我们可以使用它们而不重复计算。 线段树的结构线段树只是一个二叉树，其中每个节点都是SegmentTree类的一个实例： 12345678public class SegmentTree&lt;T&gt; &#123; private var value: T private var function: (T, T) -&gt; T private var leftBound: Int private var rightBound: Int private var leftChild: SegmentTree&lt;T&gt;? private var rightChild: SegmentTree&lt;T&gt;?&#125; 每个节点都有以下数据： leftBound和rightBound 描述了一个间隔 leftChild和rightChild 是指向子节点的指针 value是函数 f(a[leftBound], a[leftBound+1], ..., a[rightBound-1], a[rightBound]) 的结果。 如果我们的数组是[1, 2, 3, 4]，函数 f = a + b ，则线段树看起来像这样： 每个节点的leftBound和rightBound标记为红色。 构建线段树以下是我们如何创建线段树的节点： 1234567891011121314151617public init(array: [T], leftBound: Int, rightBound: Int, function: @escaping (T, T) -&gt; T) &#123; self.leftBound = leftBound self.rightBound = rightBound self.function = function if leftBound == rightBound &#123; // 1 value = array[leftBound] &#125; else &#123; let middle = (leftBound + rightBound) / 2 // 2 // 3 leftChild = SegmentTree&lt;T&gt;(array: array, leftBound: leftBound, rightBound: middle, function: function) rightChild = SegmentTree&lt;T&gt;(array: array, leftBound: middle+1, rightBound: rightBound, function: function) value = function(leftChild!.value, rightChild!.value) // 4 &#125; &#125; 请注意，这是一个递归方法。 你给它一个数组，如[1, 2, 3, 4]，它构建整个树，从根节点到所有子节点。 如果leftBound和rightBound相等，则递归终止。这样的SegmentTree实例表示叶节点。对于输入数组[1,2,3,4]，这个过程将创建四个这样的叶节点：1，2，3和4。我们只用数组中的数字填充value属性。 但是，如果rightBound仍然大于leftBound，我们创建两个子节点。我们将当前段划分为两个相等的段（至少，如果长度是偶数;如果它是奇数，则一个段将略大）。 递归地为这两个段构建子节点。 左子节点覆盖区间[leftBound, middle]，右子节点覆盖[middle + 1, rightBound]。 在构造了我们的子节点之后，我们可以计算自己的值，因为f(leftBound, rightBound) = f(f(leftBound, middle), f(middle+1, rightBound))。 这是数学！ 构建这个树的操作是O(n)。 获得查询结果我们经历了所有这些麻烦，因此我们可以有效地查询树。 代码： 123456789101112131415161718192021222324public func query(withLeftBound: leftBound: Int, rightBound: Int) -&gt; T &#123; // 1 if self.leftBound == leftBound &amp;&amp; self.rightBound == rightBound &#123; return self.value &#125; guard let leftChild = leftChild else &#123; fatalError("leftChild should not be nil") &#125; guard let rightChild = rightChild else &#123; fatalError("rightChild should not be nil") &#125; // 2 if leftChild.rightBound &lt; leftBound &#123; return rightChild.query(withLeftBound: leftBound, rightBound: rightBound) // 3 &#125; else if rightChild.leftBound &gt; rightBound &#123; return leftChild.query(withLeftBound: leftBound, rightBound: rightBound) // 4 &#125; else &#123; let leftResult = leftChild.query(withLeftBound: leftBound, rightBound: leftChild.rightBound) let rightResult = rightChild.query(withLeftBound: rightChild.leftBound, rightBound: rightBound) return function(leftResult, rightResult) &#125;&#125; 同样，这是一种递归方法。 它检查四种不同的可能性。 1) 首先，我们检查查询段是否等于当前节点负责的段。 如果是，我们只返回此节点的值。 2) 查询段是否完全位于右子节点中？ 如果是这样，则递归地对右子节点执行查询。 3) 查询段是否完全位于左子节点内？ 如果是这样，则递归地对左子节点执行查询。 4) 如果不是上述任何一个，则意味着我们的查询部分存在于两个子节点中，因此我们将查询结果组合在两个子节点上。 在playground 测试： 12345678let array = [1, 2, 3, 4]let sumSegmentTree = SegmentTree(array: array, function: +)sumSegmentTree.query(withLeftBound: 0, rightBound: 3) // 1 + 2 + 3 + 4 = 10sumSegmentTree.query(withLeftBound: 1, rightBound: 2) // 2 + 3 = 5sumSegmentTree.query(withLeftBound: 0, rightBound: 0) // just 1sumSegmentTree.query(withLeftBound: 3, rightBound: 3) // just 4 查询树需要O(log n)时间。 更换选项线段树中节点的值取决于它下面的节点。 因此，如果我们想要更改叶节点的值，我们也需要更新其所有父节点。 代码: 123456789101112public func replaceItem(at index: Int, withItem item: T) &#123; if leftBound == rightBound &#123; value = item &#125; else if let leftChild = leftChild, rightChild = rightChild &#123; if leftChild.rightBound &gt;= index &#123; leftChild.replaceItem(at: index, withItem: item) &#125; else &#123; rightChild.replaceItem(at: index, withItem: item) &#125; value = function(leftChild.value, rightChild.value) &#125;&#125; 像往常一样，这适用于递归。 如果节点是叶子，我们只需更改其值。 如果节点不是叶子，那么我们递归调用 replaceItem(at: ) 来更新它的子节点。 之后，我们重新计算节点自己的值，以便它再次更新。 更换项目需要O(log n)时间。 有关如何使用线段树的更多示例，请参阅 playground。 扩展阅读懒惰传播的执行和说明。 线段树在PEGWiki的百科 作者：Artur Antonov翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>线段树</tag>
        <tag>Segment Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-伸展树]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E4%BC%B8%E5%B1%95%E6%A0%91.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Splay Tree 伸展树/分裂树（Splay Tree） 伸展树是一种数据结构，在结构上与平衡二叉搜索树相同。 在伸展树上执行的每个操作都会导致重新调整，以便快速访问最近运行的值。 在每次访问时，树被重新排列，并且使用一组特定的旋转将访问的节点移动到树的根，这些旋转一起被称为Splaying。 旋转有3种类型的旋转可以形成Splaying： ZigZig ZigZag Zig Zig-Zig给定节点a，如果a不是根节点，a具有子节点b，并且a和b都是左子节点或右子节点，则按 Zig-Zig 执行。 案例两个节点都是右节点 案例两个节点都是左节点 重要的是要注意 ZigZig 首先执行中间节点与其父节点的旋转（称之为祖父节点），然后执行剩余节点（孙子节点）的旋转。 这样做有助于保持树平衡，即使它是通过插入一系列递增值来首次创建的（参见下面的最坏情况场景，然后解释为什么ZigZig首先旋转到祖父母）。 Zig-Zag给定节点a，如果a不是根节点，并且a具有子节点b，并且b是a的左子节点，a本身是右子节点（相反的节点），则执行 Zig-Zag。 案例 右-左 译注： 上图中9是a，7是b 案例 左-右 重要的是ZigZag首先执行孙子节点的旋转，然后再次执行与其新父节点相同的节点。 Zig当要旋转的节点a父节点是根节点时，执行Zig。 伸展伸展 包括根据需要进行如此多的旋转，直到受操作影响的节点位于顶部并成为树的根节点。 123while (node.parent != nil) &#123; operation(forNode: node).apply(onNode: node)&#125; 操作返回要应用的所需旋转。 12345678910public static func operation&lt;T&gt;(forNode node: Node&lt;T&gt;) -&gt; SplayOperation &#123; if let parent = node.parent, let _ = parent.parent &#123; if (node.isLeftChild &amp;&amp; parent.isRightChild) || (node.isRightChild &amp;&amp; parent.isLeftChild) &#123; return .zigZag &#125; return .zigZig &#125; return .zig&#125; 在应用阶段，算法根据要应用的旋转确定涉及哪些节点，并继续用其父节点重新排列节点。 1234567891011121314151617public func apply&lt;T&gt;(onNode node: Node&lt;T&gt;) &#123; switch self &#123; case .zigZag: assert(node.parent != nil &amp;&amp; node.parent!.parent != nil, &quot;Should be at least 2 nodes up in the tree&quot;) rotate(child: node, parent: node.parent!) rotate(child: node, parent: node.parent!) case .zigZig: assert(node.parent != nil &amp;&amp; node.parent!.parent != nil, &quot;Should be at least 2 nodes up in the tree&quot;) rotate(child: node.parent!, parent: node.parent!.parent!) rotate(child: node, parent: node.parent!) case .zig: assert(node.parent != nil &amp;&amp; node.parent!.parent == nil, &quot;There should be a parent which is the root&quot;) rotate(child: node, parent: node.parent!) &#125;&#125; 伸展树上的操作插入要插入值： 将其插入二叉搜索树中 将值显示到根目录 删除删除值： 在二叉搜索树中删除 将已删除节点的父节点放到根节点 搜索要搜索值： 在二叉搜索树中搜索它 将包含值的节点放到根目录 如果未找到，则展开将成为搜索值的父节点的节点 最小和最大 在树中搜索所需的值 将节点放到根节点 例子例子 1The sequence of steps will be the following:让我们假设执行find(20)操作，现在需要将值20显示到根节点。步骤顺序如下： 当我们使用ZigZig时，我们需要旋转9到4。 第一次旋转后，我们得到下面树： 最后把20旋转到9 例子 2现在假设执行了insert(7)操作，我们处于ZigZag情况。 首先7旋转到9 结果为： 最后7旋转到4 优点伸展树提供了一种快速访问经常请求的元素的有效方法。这个特性让下面实现有了一个很好的选择，例如高速缓存或垃圾收集算法，或涉及从数据集频繁访问特定数量的元素的任何其他问题。 缺点伸展树总是不完美平衡，因此在以递增顺序访问树中的所有元素的情况下，树的高度变为n。 时间复杂度 Case Performance 平均 O(log n) 最差 n n是树中的项数。 最糟糕案例表现的一个例子假设在伸展树中插入了一系列连续值。我们以[1,2,3,4,5,6,7,8]为例。 树的结构如下： 插入数字 1 插入 2 伸展 2 到根节点 插入 3 伸展 3 到根节点 插入 4 插入其余值后，树将如下所示： 如果我们按照相同的顺序保持插入编号，则该树变得不平衡并且高度为n，n是插入的值的数量。获取此树后，find(1)操作将采用O(n) ZigZig旋转顺序：首先祖父节点但是由于伸展树 的属性和find(1)操作后的ZigZig旋转，树再次变得平衡。只有当我们考虑ZigZig旋转的顺序，并且首先发生对祖父节点的旋转时，才会发生这种情况。 ZigZigs 旋转的顺序如下所示： Rotate 2 to 3 Rotate 1 to 2 Rotate 4 to 5 Rotate 1 to 4 最后将1伸展到根节点之后，树将如下所示： 基于上面的例子，我们可以看出为什么首先旋转祖父节点是很重要的。 我们从一棵 height = 8 的初始树得到一棵 height = 6 的树。如果树高了，我们通过伸展操作后，可以几乎得到初始高度一半的树。 ZigZig错误的旋转顺序如果旋转首先是父节点而不是祖父节点，我们将完成以下不平衡的树，只是反转原树元素。 扩展阅读伸展树的维基百科 加州大学伯克利分校的伸展树课程CS 61B Lecture 34 作者：Martina Rodeker翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>伸展树</tag>
        <tag>Splay Tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-环形缓冲区]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E7%8E%AF%E5%BD%A2%E7%BC%93%E5%86%B2%E5%8C%BA.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Ring Buffer 环形缓冲区（Ring Buffer） 也称为循环缓冲区。 基于数组的队列的问题是在队列后面添加新项目很快，O(1)，但是从队列前面删除项目很慢，O(n)。删除速度很慢，因为它需要在内存中移动剩余的数组元素。 实现队列的更有效方法是使用环形缓冲区或循环缓冲区。 这是一个概念性地回绕到开头的数组，因此您永远不必删除任何项目。 所有操作都是O(1)。 原则上它是如何工作的。 我们有一个固定大小的数组，比如5项： [ , , , , ] r w 最初，数组为空，读（r）和写（w）指针位于开头。 让我们为这个数组添加一些数据。 我们将写入或叫“入队”，数字123： [ 123, , , , ] r ---&gt; w 每次添加数据时，写指针都向前移动一步。 让我们添加更多元素： [ 123, 456, 789, 666, ] r -------------&gt; w 现在数组中还有一个空点，但是应用程序决定读取一些数据，而不是将另一个项送入队列。这是可能的，因为写指针位于读指针之前，这意味着数据可用于读取。 读取指针随着读取可用数据而前进： [ 123, 456, 789, 666, ] ---&gt; r w 让我们再读两项： [ 123, 456, 789, 666, ] --------&gt; r w 现在应用程序决定再次写入并再入队两个数据项333和555： [ 123, 456, 789, 666, 333 ] r ---&gt; w 哎呀，写指针已到达数组的末尾，因此对象555没有更多的空间。现在怎么办？好吧，这就是为什么它是循环缓冲区：我们将写指针包装回到开头并写入剩余数据： [ 555, 456, 789, 666, 333 ] ---&gt; w r 我们现在可以阅读剩余的三个项目，666，333和555。 [ 555, 456, 789, 666, 333 ] w --------&gt; r 当然，当读指针到达缓冲区的末尾时，它也会回绕： [ 555, 456, 789, 666, 333 ] w ---&gt; r 现在缓冲区再次为空，因为读指针已经赶上了写指针。 这是Swift中一个非常基本的实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445public struct RingBuffer&lt;T&gt; &#123; fileprivate var array: [T?] fileprivate var readIndex = 0 fileprivate var writeIndex = 0 public init(count: Int) &#123; array = [T?](repeating: nil, count: count) &#125; public mutating func write(_ element: T) -&gt; Bool &#123; if !isFull &#123; array[writeIndex % array.count] = element writeIndex += 1 return true &#125; else &#123; return false &#125; &#125; public mutating func read() -&gt; T? &#123; if !isEmpty &#123; let element = array[readIndex % array.count] readIndex += 1 return element &#125; else &#123; return nil &#125; &#125; fileprivate var availableSpaceForReading: Int &#123; return writeIndex - readIndex &#125; public var isEmpty: Bool &#123; return availableSpaceForReading == 0 &#125; fileprivate var availableSpaceForWriting: Int &#123; return array.count - availableSpaceForReading &#125; public var isFull: Bool &#123; return availableSpaceForWriting == 0 &#125;&#125; RingBuffer对象有一个数组用于实际存储数据，readIndex和writeIndex变量用于指向数组的“指针”。 write()函数将新元素放入writeIndex中的数组中，read()函数返回readIndex中的元素。 但是，你说，如何继续工作下去？ 有几种方法可以实现这一点，我选择了一个稍微有争议的方法。 在这个实现中，writeIndex和readIndex总是递增，永远不会实际回绕。 相反，我们执行以下操作来查找数组的实际索引： 1array[writeIndex % array.count] and: 1array[readIndex % array.count] 换句话说，我们分别获取读取索引和写入索引除以底层数组的大小的模数（或余数）。 这有点争议的原因是writeIndex和readIndex总是递增，所以理论上这些值可能变得太大而不适合整数，应用程序将崩溃。然而，快速的卫生巾计算应该可以消除这些担忧。 writeIndex和readIndex都是64位整数。 如果我们假设它们每秒递增1000次，这是很多，那么连续一年这样做需要ceil（log_2（365 * 24 * 60 * 60 * 1000））= 35位。 这留下了28位，因此在遇到问题之前应该给你大约2 ^ 28年。 那是很长一段时间。:-) 要使用此环形缓冲区，请将代码复制到playground并执行以下操作以模仿上面的示例： 123456789101112131415161718var buffer = RingBuffer&lt;Int&gt;(count: 5)buffer.write(123)buffer.write(456)buffer.write(789)buffer.write(666)buffer.read() // 123buffer.read() // 456buffer.read() // 789buffer.write(333)buffer.write(555)buffer.read() // 666buffer.read() // 333buffer.read() // 555buffer.read() // nil 您已经看到环形缓冲区可以创建更优的队列，但它也有一个缺点：包装使得调整队列大小变得棘手。但如果一个固定大小的队列适合你的目的，那么你就牛掰了。 当数据生产者以不同于数据使用者读取数据的速率写入数组时，环形缓冲区也非常有用。这通常发生在文件或网络I/O上。环形缓冲区也是高优先级线程（例如音频渲染回调）与系统其他较慢部分之间通信的首选方式。 这里给出的实现不是线程安全的。它仅作为环形缓冲区如何工作的示例。也就是说，通过使用OSAtomicIncrement64()来改变读写指针，使单个读写器和单个编写器的线程安全应该是相当简单的。 制作一个非常快的环形缓冲区的一个很酷的技巧是使用操作系统的虚拟内存系统将相同的缓冲区映射到不同的内存页面。疯狂的东西，但值得研究是否需要在高性能环境中使用环形缓冲区。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>环形缓冲区</tag>
        <tag>Ring Buffer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-有界优先队列]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%9C%89%E7%95%8C%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Bounded Priority Queue 有界优先队列（Bounded Priority queue） 有界优先级队列类似于常规优先队列，除了可以存储的元素数量有固定的上限。在队列处于满容量时，将新元素添加到队列时，具有最高优先级值的元素将从队列中弹出。 例子假设我们有一个最大大小为5的有界优先级队列，它具有以下值和优先级： 12Value: [ A, B, C, D, E ]Priority: [ 4.6, 3.2, 1.33, 0.25, 0.1 ] 在这里，我们认为具有最高优先级值的对象是最重要的（因此这是max-priority队列）。 优先级值越大，我们关注的对象就越多。 所以A比B更重要，B比C更重要，依此类推。 现在我们要将优先级为0.4的元素F插入到这个有界优先级队列中。 因为队列大小最大为5，所以这将插入元素F，然后逐出最低优先级元素（E），产生更新的队列： 12Value: [ A, B, C, F, D ]Priority: [ 4.6, 3.2, 1.33, 0.4, 0.25 ] 由于其优先级值，在C和D之间插入F。它不如C重要，但比D更重要。 假设我们希望将优先级为0.1的元素G插入到此BPQ中。因为G的优先级值小于队列中的最小优先级元素，所以在插入G时它将立即被驱逐。换句话说，将元素插入优先级小于BPQ的最小优先级元素的BPQ中没有任何效果。 实施虽然heap可能是优先级队列的一个非常简单的实现，但排序的链表允许 O(k) 插入和 O(1) 删除，其中 k 是元素的边界数。 以下是在Swift中的实现： 12345678910111213141516171819public class BoundedPriorityQueue&lt;T: Comparable&gt; &#123; private typealias Node = LinkedListNode&lt;T&gt; private(set) public var count = 0 fileprivate var head: Node? private var tail: Node? private var maxElements: Int public init(maxElements: Int) &#123; self.maxElements = maxElements &#125; public var isEmpty: Bool &#123; return count == 0 &#125; public func peek() -&gt; T? &#123; return head?.value &#125; BoundedPriorityQueue类包含LinkedListNode对象的双向链表。 这里没什么特别的。 有趣的东西发生在enqueue()方法中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public func enqueue(_ value: T) &#123; if let node = insert(value, after: findInsertionPoint(value)) &#123; // If the newly inserted node is the last one in the list, then update // the tail pointer. if node.next == nil &#123; tail = node &#125; // If the queue is full, then remove an element from the back. count += 1 if count &gt; maxElements &#123; removeLeastImportantElement() &#125; &#125;&#125;private func insert(_ value: T, after: Node?) -&gt; Node? &#123; if let previous = after &#123; // If the queue is full and we have to insert at the end of the list, // then there's no reason to insert the new value. if count == maxElements &amp;&amp; previous.next == nil &#123; print("Queue is full and priority of new object is too small") return nil &#125; // Put the new node in between previous and previous.next (if exists). let node = Node(value: value) node.next = previous.next previous.next?.previous = node previous.next = node node.previous = previous return node &#125; else if let first = head &#123; // Have to insert at the head, so shift the existing head up once place. head = Node(value: value) head!.next = first first.previous = head return head &#125; else &#123; // This is the very first item in the queue. head = Node(value: value) return head &#125;&#125;/* Find the node after which to insert the new value. If this returns nil, the new value should be inserted at the head of the list. */private func findInsertionPoint(_ value: T) -&gt; Node? &#123; var node = head var prev: Node? = nil while let current = node where value &lt; current.value &#123; prev = node node = current.next &#125; return prev&#125;private func removeLeastImportantElement() &#123; if let last = tail &#123; tail = last.previous tail?.next = nil count -= 1 &#125; // Note: Instead of using a tail pointer, we could just scan from the new // node until the end. Then nodes also don't need a previous pointer. But // this is much slower on large lists.&#125; 我们首先检查队列是否已经具有最大元素数。 如果是这样，并且新的优先级值小于tail元素的优先级值，那么这个新元素没有空间，我们返回时不插入它。 如果新值是可接受的，那么我们搜索列表以找到正确的插入位置并更新next和previous指针。 最后，如果队列现在已达到最大元素数，那么我们dequeue()具有最大优先级值。 通过将最重要的元素保留在列表的前面，它使得出列非常容易： 123456789101112131415public func dequeue() -&gt; T? &#123; if let first = head &#123; count -= 1 if count == 0 &#123; head = nil tail = nil &#125; else &#123; head = first.next head!.previous = nil &#125; return first.value &#125; else &#123; return nil &#125;&#125; 这只是从列表中删除head元素并返回它。 作者：John Gill, Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>有界优先队列</tag>
        <tag>Bounded Priority Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-哈希集合]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%93%88%E5%B8%8C%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Hash Set 哈希集合（Hash Set） 集合是元素的集合，有点像数组但有两个重要的区别：集合中元素的顺序不重要，每个元素只能出现一次。 如果以下是数组，它们都会有所不同。 但是，它们都代表相同的集合： 1234[1 ,2, 3][2, 1, 3][3, 2, 1][1, 2, 2, 3, 1] 因为每个元素只能出现一次，所以将元素写入的次数并不重要 —— 只有其中一个元素有效。 注意：当我有一组对象但不关心它们的顺序时，我经常更喜欢使用数组上的集合。使用集合与程序员通信，元素的顺序并不重要。 如果你正在使用数组，那么你不能假设同样的事情。 典型集合操作： 插入元素 删除元素 检查集合是否包含元素 与另一组合并 与另一组交叉 计算与另一组的差异 并集，交集和差集是将两个集合组合成一个集合的方法： 从Swift 1.2开始，标准库包含一个内置的Set类型，但在这里我将展示如何制作自己的类型。您不会在生产代码中使用它，但了解如何实现集合是有益的。 使用简单数组实现集合是可能的，但这不是最有效的方法。 相反，我们将使用字典。由于Swift的字典是使用哈希表构建的，因此我们自己的集合将是一个哈希集。 代码以下是Swift中HashSet的开头： 12345678910111213141516171819202122232425262728293031public struct HashSet&lt;T: Hashable&gt; &#123; fileprivate var dictionary = Dictionary&lt;T, Bool&gt;() public init() &#123; &#125; public mutating func insert(_ element: T) &#123; dictionary[element] = true &#125; public mutating func remove(_ element: T) &#123; dictionary[element] = nil &#125; public func contains(_ element: T) -&gt; Bool &#123; return dictionary[element] != nil &#125; public func allElements() -&gt; [T] &#123; return Array(dictionary.keys) &#125; public var count: Int &#123; return dictionary.count &#125; public var isEmpty: Bool &#123; return dictionary.isEmpty &#125;&#125; 代码非常简单，因为我们依靠Swift的内置Dictionary来完成所有的艰苦工作。 我们使用字典的原因是字典键必须是唯一的，就像集合中的元素一样。 此外，字典在其大多数操作中具有O(1)时间复杂度，使得该集合实现非常快。 因为我们使用的是字典，所以通用类型T必须符合Hashable。 您可以将任何类型的对象放入我们的集合中，只要它可以进行哈希处理即可。 （对于Swift自己的Set也是如此。） 通常，您使用字典将键与值关联，但对于一个集合，我们只关心键。 这就是为什么我们使用Bool作为字典的值类型，即使我们只将它设置为true，而不是false。 （我们本可以选择任何东西，但布尔占用的空间最小。） 将代码复制到 playground 并添加一些测试： 12345678910111213var set = HashSet&lt;String&gt;()set.insert("one")set.insert("two")set.insert("three")set.allElements() // ["one, "three", "two"]set.insert("two")set.allElements() // still ["one, "three", "two"]set.contains("one") // trueset.remove("one")set.contains("one") // false allElements()函数将集合的内容转换为数组。请注意，该数组中元素的顺序可能与添加项目的顺序不同。正如我所说，一个集合并不关心元素的顺序（也不是字典）。 合并集合集合的很多用处在于如何合并它们。（如果你曾经使用像Sketch或Illustrator这样的矢量绘图程序，你会看到Union，Subtract，Intersect选项来组合形状。这边也是同样的事情。） 这是union操作的代码： 123456789101112extension HashSet &#123; public func union(_ otherSet: HashSet&lt;T&gt;) -&gt; HashSet&lt;T&gt; &#123; var combined = HashSet&lt;T&gt;() for obj in self.dictionary.keys &#123; combined.insert(obj) &#125; for obj in otherSet.dictionary.keys &#123; combined.insert(obj) &#125; return combined &#125;&#125; 两个集合的 union 创建一个新集合，它由集合A中的所有元素加上集合B中的所有元素组成。当然，如果存在重复元素，它们只计算一次。 示例: 1234567891011121314var setA = HashSet&lt;Int&gt;()setA.insert(1)setA.insert(2)setA.insert(3)setA.insert(4)var setB = HashSet&lt;Int&gt;()setB.insert(3)setB.insert(4)setB.insert(5)setB.insert(6)let union = setA.union(setB)union.allElements() // [5, 6, 2, 3, 1, 4] 如您所见，两个集合的并集现在包含所有元素。 值3和4仍然只出现一次，即使它们都在两组中。 两个集合的intersection仅包含它们共有的元素。 这是代码： 1234567891011extension HashSet &#123; public func intersect(_ otherSet: HashSet&lt;T&gt;) -&gt; HashSet&lt;T&gt; &#123; var common = HashSet&lt;T&gt;() for obj in dictionary.keys &#123; if otherSet.contains(obj) &#123; common.insert(obj) &#125; &#125; return common &#125;&#125; 测试: 12let intersection = setA.intersect(setB)intersection.allElements() 这打印 [3, 4] 因为那些是集合A中也是集合B的唯一对象。 最后，两组之间的difference删除了它们共有的元素。 代码如下： 1234567891011extension HashSet &#123; public func difference(_ otherSet: HashSet&lt;T&gt;) -&gt; HashSet&lt;T&gt; &#123; var diff = HashSet&lt;T&gt;() for obj in dictionary.keys &#123; if !otherSet.contains(obj) &#123; diff.insert(obj) &#125; &#125; return diff &#125;&#125; 它实际上与intersect()相反。 试试看： 12345let difference1 = setA.difference(setB)difference1.allElements() // [2, 1]let difference2 = setB.difference(setA)difference2.allElements() // [5, 6] Where to go from here?如果你看一下Swift自己的Set的文档，你会发现它有更多的功能。 一个明显的扩展是使HashSet符合SequenceType，这样你就可以用for …in循环迭代它。 您可以做的另一件事是将Dictionary替换为实际的哈希表，但是只存储键并且不将它们与任何东西相关联。 所以你不再需要Bool值了。 如果您经常需要查找元素是否属于集合并执行并集，那么并查集数据结构可能更合适。它使用树结构而不是字典来使查找和并集操作非常有效。 注意：我想让HashSet符合ArrayLiteralConvertible，这样你就可以编写let setA: HashSet&lt;Int&gt; = [1, 2, 3, 4]但是目前这会使编译器崩溃。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>哈希集合</tag>
        <tag>Hash Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-有序集]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%9C%89%E5%BA%8F%E9%9B%86.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Ordered Set 有序集（Ordered Set） 我们来看看苹果如何实现有序集。 Here is the example about how it works以下是有关其工作原理的示例： 123456789101112131415161718192021let s = AppleOrderedSet&lt;Int&gt;()s.add(1)s.add(2)s.add(-1)s.add(0)s.insert(4, at: 3)print(s.all()) // [1, 2, -1, 4, 0]s.set(-1, at: 0) // 已经有-1在index: 2，因此这个操作不做任何事情print(s.all()) // [1, 2, -1, 4, 0]s.remove(-1)print(s.all()) // [1, 2, 4, 0]print(s.object(at: 1)) // 2print(s.object(at: 2)) // 4 显着的区别是数组没有排序。 插入时，数组中的元素是相同的。 将数组映像为不重复且具有 O(logn) 或 O(1) 搜索时间。 这里的想法是使用数据结构来提供 O(1) 或 O(logn) 时间复杂度，因此很容易考虑哈希表。 12var indexOfKey: [T: Int]var objects: [T] indexOfKey is used to track the index of the element. objects is array holding elements.indexOfKey 用于跟踪元素的索引。 objects是数组保持元素。 我们将在这里详细介绍一些关键功能。 添加更新indexOfKey并在objects的末尾插入元素 123456789// O(1)public func add(_ object: T) &#123; guard indexOfKey[object] == nil else &#123; return &#125; objects.append(object) indexOfKey[object] = objects.count - 1&#125; 插入在数组的随机位置插入将花费 O(n) 时间。 123456789101112131415// O(n)public func insert(_ object: T, at index: Int) &#123; assert(index &lt; objects.count, "Index should be smaller than object count") assert(index &gt;= 0, "Index should be bigger than 0") guard indexOfKey[object] == nil else &#123; return &#125; objects.insert(object, at: index) indexOfKey[object] = index for i in index+1..&lt;objects.count &#123; indexOfKey[objects[i]] = i &#125;&#125; 设置如果object已存在于OrderedSet中，则什么也不做。 否则，我们需要更新indexOfkey和objects。 12345678910111213// O(1)public func set(_ object: T, at index: Int) &#123; assert(index &lt; objects.count, "Index should be smaller than object count") assert(index &gt;= 0, "Index should be bigger than 0") guard indexOfKey[object] == nil else &#123; return &#125; indexOfKey.removeValue(forKey: objects[index]) indexOfKey[object] = index objects[index] = object&#125; 删除删除数组中的元素将花费 O(n)。 同时，我们需要在删除元素后更新所有元素的索引。 123456789101112// O(n)public func remove(_ object: T) &#123; guard let index = indexOfKey[object] else &#123; return &#125; indexOfKey.removeValue(forKey: object) objects.remove(at: index) for i in index..&lt;objects.count &#123; indexOfKey[objects[i]] = i &#125;&#125; 作者：Kai Chen翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>有序集</tag>
        <tag>Ordered Set</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-多重集合]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%A4%9A%E9%87%8D%E9%9B%86%E5%90%88.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Multiset 多重集合（Multiset） 多重集合（也称为bag，简称多重集）是一种类似于常规集的数据结构，但它可以存储同一元素的多个实例。 例如，如果我将元素1,2,2添加到常规集中，则该集将仅包含两个项，因为第二次添加2无效。 1234var set = Set&lt;Int&gt;()set.add(1) // set is now [1]set.add(2) // set is now [1, 2]set.add(2) // set is still [1, 2] 相比之下，在将元素1,2,2添加到多重集之后，它将包含三个项目。 1234var set = Multiset&lt;Int&gt;()set.add(1) // set is now [1]set.add(2) // set is now [1, 2]set.add(2) // set is now [1, 2, 2] 你可能会认为这看起来很像一个数组。 那你为什么要用多重集呢？ 让我们考虑两者之间的差异…… 排序：数组维护添加到它们的项目的顺序，多重集合没有 测试成员资格：测试元素是否其成员，数组是O(N)，而多重集合的O(1)。 测试子集：测试集合X是否是集合Y的子集，对于多重集而言是一个简单的操作，但对于数组来说是复杂的 多重集的典型操作是： 添加元素 删除元素 获取元素的计数（添加的次数） 获取整个集合的计数（已添加的项数） 检查它是否是另一个多重集的子集 在实际使用中，可使用多重集合来确定一个字符串是否是另一个字符串的部分。例如，“cacti”这个词是“tactical”的部分。（换句话说，我可以重新整理“tactical”字母来得到“cacti”，以及余下的一些字母。） 123var cacti = Multiset&lt;Character&gt;("cacti")var tactical = Multiset&lt;Character&gt;("tactical")cacti.isSubSet(of: tactical) // true! 实施在幕后，Multiset的实现使用字典来存储元素到它们被添加的次数的映射。 这是它的本质： 1234public struct Multiset&lt;Element: Hashable&gt; &#123; private var storage: [Element: UInt] = [:] public init() &#123;&#125; 以下是如何使用此类创建多重集的字符串： 1var set = Multiset&lt;String&gt;() 添加元素是递增该元素的计数器，或者如果它尚不存在则将其设置为1： 123public mutating func add (_ elem: Element) &#123; storage[elem, default: 0] += 1&#125; 以下是使用此方法添加到我们之前创建的集合的方法： 123set.add("foo")set.add("foo") set.allItems // returns ["foo", "foo"] 我们的集合现在包含两个元素，字符串“foo”。 删除元素与添加元素的工作方式大致相同; 递减元素的计数器，或者如果在删除之前其值为1，则将其从基础字典中删除。 123456789public mutating func remove (_ elem: Element) &#123; if let currentCount = storage[elem] &#123; if currentCount &gt; 1 &#123; storage[elem] = currentCount - 1 &#125; else &#123; storage.removeValue(forKey: elem) &#125; &#125;&#125; 获取项目的计数很简单：我们只返回内部字典中给定项目的值。 123public func count(for key: Element) -&gt; UInt &#123; return storage[key] ?? 0&#125; 作者：Simon Whitaker翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>多重集合</tag>
        <tag>Multiset</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-布隆过滤器]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Bloom Filter 布隆过滤器(Bloom Filter) 介绍布隆过滤器是一种节省空间的数据结构，可以告诉您元素是否存在于集合中。 这是一个概率数据结构：对布隆过滤器的查询返回false，意味着该元素肯定不在集合中，或者是true，这意味着元素可能在集合中。 误报的可能性很小，即使查询返回true，元素实际上也可能不在集合中。 但是永远不会有任何漏报：如果查询返回false，你可以保证，那么元素确实不在集合中。 所以布隆过滤器告诉你，“绝对不是”或“可能是的”。 起初，这似乎不太有用。 但是，它在缓存过滤和数据同步等应用程序中很重要。 布隆过滤器优于哈希表的一个优点是前者保持恒定的内存使用和恒定时间插入和搜索。 对于具有大量元素的集合，哈希表和布隆过滤器之间的性能差异很大，如果您不需要保证不存在误报，则它是可行的选项。 注意：与哈希表不同，布隆过滤器不存储实际对象。 它只会记住你看过的对象（有一定程度的不确定性）以及你没有看过的对象。 将对象插入集合中布隆过滤器本质上是一个固定长度的位向量，一个位数组。 当我们插入对象时，我们将其中一些位设置为1，当我们查询对象时，我们检查某些位是0还是1。 两个操作都使用哈希函数。 要在过滤器中插入元素，可以使用多个不同的哈希函数对元素进行哈希。 每个哈希函数返回一个我们映射到数组中索引的值。 然后，我们将这些索引处的位设置为1或true。 例如，假设这是我们的位数组。 我们有17位，最初它们都是0或false： [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] 现在我们要在布隆过滤器中插入字符串&quot;Hello world!&quot;。 我们对此字符串应用两个哈希函数。第一个给出值1999532104120917762。我们通过取数组长度的模数将此哈希值映射到数组的索引：1999532104120917762 % 17 = 4。 这意味着我们将索引4处的位设置为1或者true： [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ] 然后我们再次散列原始字符串，但这次使用不同的散列函数。 它给出哈希值9211818684948223801。取17的模数为12，我们也将索引12处的位设置为1： [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0 ] 这两个1位足以告诉布隆过滤器它现在包含字符串 &quot;Hello world!&quot;。 当然，它不包含实际的字符串，所以你不能要求布隆过滤器，“给我一个你包含的所有对象的列表”。 所有它都是一堆1和0。 查询集合类似于插入，查询是通过首先对期望值进行哈希来实现的，该期望值给出几个数组索引，然后检查这些索引处的所有位是否为1。 如果其中一个位不是1，则无法插入该元素，并且查询返回false。 如果所有位都是1，则查询返回true。 例如，如果我们查询字符串&quot;Hello WORLD&quot;，那么第一个哈希函数返回5383892684077141175，其中取17的模是12。该位是1。但是第二个哈希函数给出5625257205398334446，它映射到数组索引9。该位为0。 这意味着字符串&quot;Hello WORLD&quot;不在过滤器中，查询返回false。 第一个哈希函数映射到1位的事实是巧合（它与两个字符串以&quot;Hello &quot;开头的事实无关）。 太多这样的巧合可能导致“碰撞”。 如果存在冲突，即使未插入元素，查询也可能错误地返回true - 导致前面提到的误报问题。 假设我们插入了一些其他元素，&quot;Bloom Filterz&quot;，它设置了第7位和第9位。现在数组看起来像这样： [ 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0 ] 如果再次查询&quot;Hello WORLD&quot;，则过滤器会看到第12位为true，第9位现在也为true。 它报告说&quot;Hello WORLD&quot;确实出现在集合中，即使它不是……因为我们从未插入过那个特定的字符串。这是误报。这个例子说明了为什么布隆过滤器永远不会说“绝对是”，只有“可能是”。 您可以通过使用具有更多位的数组并使用其他哈希函数来解决此类问题。 当然，使用的哈希函数越多，布隆过滤器就越慢。 所以你必须取得平衡。 使用布隆过滤器无法删除，因为任何一个位都可能属于多个元素。 一旦你添加了一个元素，它就在那里。 布隆过滤器的性能是O(k)，其中 k是哈希函数的数量。 代码代码非常简单。 内部位数组在初始化时设置为固定长度，初始化后不能进行突变。 1234public init(size: Int = 1024, hashFunctions: [(T) -&gt; Int]) &#123; self.array = [Bool](repeating: false, count: size) self.hashFunctions = hashFunctions&#125; 应在初始化时指定几个哈希函数。 您使用哪些哈希函数将取决于您将添加到集合的元素的数据类型。 你可以在playground测试中看到一些例子 - 字符串的djb2和sdbm哈希函数。 插入只是将所需的位翻转为true： 12345public func insert(_ element: T) &#123; for hashValue in computeHashes(element) &#123; array[hashValue] = true &#125;&#125; 这使用computeHashes()函数，它循环遍历指定的hashFunctions并返回索引数组： 123private func computeHashes(_ value: T) -&gt; [Int] &#123; return hashFunctions.map() &#123; hashFunc in abs(hashFunc(value) % array.count) &#125;&#125; 并查询检查以确保哈希值处的位为true： 123456public func query(_ value: T) -&gt; Bool &#123; let hashValues = computeHashes(value) let results = hashValues.map() &#123; hashValue in array[hashValue] &#125; let exists = results.reduce(true, &#123; $0 &amp;&amp; $1 &#125;) return exists&#125; 如果你来自另一种命令式语言，你可能会注意到exists赋值中的不寻常语法。 当Swift使代码更加简洁和可读时，Swift使用函数范例，在这种情况下，reduce是一种更加简洁的方法来检查所有必需的位是否为true而不是用for循环。 作者：Jamil Dhanani，Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>布隆过滤器</tag>
        <tag>Bloom Filter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《培根随笔》摘录]]></title>
    <url>%2F2019%2FFrancis-Bacon-Essays.html</url>
    <content type="text"><![CDATA[作者和本书概要弗兰西斯·培根(Francis Bacon，1561–1626)是英国文艺复兴时期最伟大的哲学家和文学家，“英国唯物主义和整个现代实验科学的真正鼻祖”。 豆瓣：《培根随笔》 内容论真理真正可怕的，并不是那种人人都难以避免的一念之差，而是那种深入习俗、盘踞于人心深处的谬误与偏见。 论死亡“死亡是大自然赐给人类的一种恩惠。” 一个坚定执著、有信念的心灵不会因对死亡的畏惧而陷入恐怖。 论逆境幸福中并非没有忧虑和烦恼，而逆境中也不乏慰藉和希望。 论婚姻在人生中，妻子是青年时代的情人，中年时代的伴侣，暮年时代的守护。 论嫉妒人的心灵如若不能从自身的优点中取得养料，就必定要找别人的缺点作为养料。 一个人可以允许陌生人的发迹，却不能容忍一个身边人的上升。 论爱情即使最骄傲的人，也甘愿在情人面前自轻自贱。 如果不能得到回爱，就会得到一种深藏于心的轻蔑。 论权位身处权位的人只能通过别人的眼睛来确认自己是否幸福。 “讲私情没有好处。它使人为了得到一块面包而破坏法律。” 宁可在他们不想会见时会见他们，也不要在他们想求见时拒绝他们。 论叛乱从历史上看，谣言确实常常是政治动乱的前奏曲。 人性的愚昧，常常会使民众辨别不清究竟什么是对自己真正有益的事物。 “痛苦是有限制的，而恐惧是无限制的” 论无神论和迷信一知半解的哲学思考把人导向无神论，但是对宇宙与哲学的深刻思考，必然使人皈依于上帝。 “真正亵渎神灵的，并不是那种否认世俗所见神灵的人，而是那些把世俗观念强加于神灵之上的人！”—— 伊壁鸠鲁 对于神，与其陷入一种错误的信仰，倒换不如没有任何信仰。因为后者只是对神的无知，而前者却是对神的亵渎，迷信神实质上就是亵渎神。 论拖延拖延一件事情比做错一件事前更可怕。 论友谊如果你把快乐告诉一个朋友，你将得到两份快乐；而如果你把忧愁向一个朋友倾诉，你将被分掉一半忧愁。 任何一种平心静气的讨论都能把搅扰你心头的一团乱麻，整理得井然有序。 讨论犹如砺石，思想好比锋刃，两相砥砺将使思想更加锐利。 论天性人不能过分相信可以完全克服一种天性。 只有在面对自我的时候，人的真性才能最容易显露出来。 天性好比种子，它既能长成鲜花，也可能长成毒草。 论习惯一切天性与诺言都不如习惯更有力。 社会的习惯具有一种更可怕的力量。 论幸运幸运是每个人都想拥有的，也是每个人都能碰到的，然而我们千万不要和别人比幸运，做事件靠运气是永远都不会成功的。 意外的幸运会使人冒失、狂妄，然而来之不易的幸运却使人成英才。 论贷款没有债务的国度充其量不过是地道的乌托邦罢了。 论青年和老年热情炽烈且情绪敏感的人往往要在中年以后方成大器；少年老成、性格稳健的人往往青春时代就可成大器。 青年长于创造而短于思考，长于蛮干而短于讨论，长于革新而短于守成。老年人则正相反。他们常常满足于困守已成之局，思考多于行动，议论多于决断。最好的额办法就是把青年的特点与老年的特点在事业上结合起来。 论读书读书可以作为消遣，可以增添情趣，也可以增长才识。 狡诈者轻鄙学问，愚鲁者羡慕学问，聪明者则运用学问。 论党派历史上党争激烈之时，往往是王权衰落的象征。 论礼貌“礼貌乃是一封通行四方的推荐书”。 表示一种赞同的时候，不要忘记提出先决条件，一表明这种赞同并非阿谀，而是经过思考。 在面临大事之际，不要过于计较形式。 论愤怒“可以激动，但不可犯罪；可以愤怒，但不可含愤终日。” 易被激怒是一种卑贱的情感，受它摆布的往往是生活中的弱者，如儿童、妇女、老人、病人。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《爱默生随笔》摘录]]></title>
    <url>%2F2019%2FRalph-Waldo-Emerson-Essays.html</url>
    <content type="text"><![CDATA[作者和本书概要爱默生（Ralph Waldo Emerson）， 美国思想家、文学家，诗人。爱默生是确立美国文化精神的代表人物。 豆瓣：《爱默生随笔》 内容论爱情成熟的年龄和迂腐的学识会使人类的花样年华逐渐凋零。 在思想或是真理的天空下，看任何事物都是美好的。在记忆的天空下，看每一段人生经历中的任何事物，则总是苦涩的。仔细地体味总是充满伤感，而热情的计划总是让人充满希望，感觉崇高。 真挚情感的最初流露与和谐仁爱是人的天性中最为迷人的风景。 爱的世界永远是人创造的，如果不尝试着去收回那些违背人性、诋毁社会本能的言语，理性而无情的哲学家们决不可能描述出每一个彷徨于此的年轻心灵所蒙受到的爱情恩惠。 世间的一切，无论已知还是未知，都已巧妙地融入男人和女人这一对机体当中了。 心灵和思想年复一年的净化和升华，才是真正的婚姻。 论礼物送必需品总是稳妥的。其次，是赠送与受礼人气质相符的礼物，使人能有礼物联想到他的思想或他本人。 一个正直的人会在无意中到处施恩，对别人的感激却还浑然不觉。 论友谊从至高的真挚爱情，到普通人的与人为善，正是这些情感造就了生活如此丰富和甜美。 我们的智力和活力因情感的丰富而提升。 倘若我从一场不平等的比赛中退缩，那么从其余的比赛中获得乐趣都会变得卑下和怯懦。 独处的人都是真诚的。第二个人一旦加入，便开始萌生虚伪。 不要因为你的不耐烦而对花的完美抱有成见。我们首先必须成为自己的朋友，才能成为他人的朋友。 相逢时我们仿佛素未平生，离别时有仿佛从未分开。 论园在自然中，每一分钟都是崭新的；过去永远被吞没，被遗忘，未来永远是神圣的。除了生命、不息的变迁、使人奋发的精神之外，没有任何东西是绝对可靠的。 “当一个人不知道他正走向何处时，他就达到了最高点。” —— 克伦威尔 论自助自然赋予人类的力量是奇妙的，除了本人，谁也不知道他的本事有多大，如果不尝试一下，连他自己也不知道。 一个人只有竭尽所能、全心全意地付出，才能获得宽慰与快乐。 社会钟爱的不是现实和创新者，而是虚名和陋俗。 在神圣的东西说到底也比不上你刚正不阿的头脑。 心灵存在的地方便存在光阴；心灵消逝的地方便是黑暗。 论自然只有内心和感觉协调一致的人，才真正热爱自然；他们直到成年仍然保有儿童的纯真。 论美美，是智慧借以探究世界的一种方式，一种愉悦的方式。 “美的事物是神秘自然法则的外显，若不是此种表现，我们便永远不可能发现美的存在。” ——歌德 对任何一种有机结构来说，越是符合自身的目的，它的美感就越强。 论历史“历史是什么？”拿破仑说，“不过是一则意见一致的寓言而已。” 大自然是一朵变幻不定的云，它永远一样，又从不一样。 历史的同一性都是内在的，而多样性则是外在的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-Boyer-Moore字符串搜索]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-Boyer-Moore%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。 Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。 🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。 本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Boyer-Moore String Search Boyer-Moore字符串搜索(Boyer-Moore String Search) 这个主题已经有教程 here 目标：在纯Swift中编写字符串搜索算法，而无需导入Foundation或使用NSString的rangeOfString()方法。 换句话说，我们想在String上实现一个indexOf(pattern：String)扩展，它返回在字符串里面第一次出现搜索模式的String.Index，如果找不到模式则返回nil 。 例子： 12345678910111213// Input:let s = "Hello, World"s.indexOf(pattern: "World")// Output:&lt;String.Index?&gt; 7// Input:let animals = "🐶🐔🐷🐮🐱"animals.indexOf(pattern: "🐮")// Output:&lt;String.Index?&gt; 6 注意： 牛的索引是6，而不是你想象的3，因为字符串为表情符号使用更多的存储空间。String.Index的实际值并不那么重要，只是它指向字符串中的正确字符。 暴力方法工作正常，但效率不高，尤其是在大块文本上。 事实证明，您不需要从源字符串中查看 _每个_ 字符 —— 通常可以跳过多个字符。 这种跳过算法被称为Boyer-Moore算法，它已存在很长时间了。它被认为是所有字符串搜索算法的基准。 以下是您在Swift中编写它的方法： 123456789101112131415161718192021222324252627282930313233343536373839404142extension String &#123; func index(of pattern: String) -&gt; Index? &#123; let patternLength = pattern.count guard patternLength &gt; 0, patternLength &lt;= self.count else &#123; return nil &#125; var skipTable = [Character: Int]() for (i, c) in pattern.enumerated() &#123; skipTable[c] = patternLength - i - 1 &#125; let p = pattern.index(before: pattern.endIndex) let lastChar = pattern[p] var i = index(startIndex, offsetBy: patternLength - 1) func backwards() -&gt; Index? &#123; var q = p var j = i while q &gt; pattern.startIndex &#123; j = index(before: j) q = index(before: q) if self[j] != pattern[q] &#123; return nil &#125; &#125; return j &#125; while i &lt; endIndex &#123; let c = self[i] if c == lastChar &#123; if let k = backwards() &#123; return k &#125; i = index(after: i) &#125; else &#123; i = index(i, offsetBy: skipTable[c] ?? patternLength, limitedBy: endIndex) ?? endIndex &#125; &#125; return nil &#125;&#125; 该算法的工作原理如下。 让源字符与搜索模式字符头部对齐排列，并查看字符串中的哪个字符与搜索模式的 _最后_ 字符匹配： 123source string: Hello, Worldsearch pattern: World ^ 有三种可能性： 这两个字符是相同的。 你找到了可能的匹配。 字符不相等，但源字符确实有出现在搜索模式其他位置中。 源字符完全没有出现在搜索模式中。 在示例中，字符o和d不匹配，但o确实出现在搜索模式中。 这意味着我们可以跳过几个位置： 123source string: Hello, Worldsearch pattern: World ^ 注意两个o字符现在是如何对齐的。 再次，您将搜索模式的最后一个字符与搜索文本进行比较：W vsd。 它们是不相同的，但W确实出现在搜索模式中。 因此，再次跳过一个位置，让两个W字符在相同位置： 123source string: Hello, Worldsearch pattern: World ^ 这次两个字符相等并且可能匹配。 要验证匹配，您需要进行暴力搜索，但是从搜索模式的末尾开始向前搜索。 这就是它的全部。 在任何给定时间跳过的数量由“跳过表”确定，“跳过表”是搜索模式中所有字符的字典和跳过的数量。 示例中的跳过表如下所示： 12345W: 4o: 3r: 2l: 1d: 0 字符越接近模式的末尾，跳过量越小。 如果某个字符在模式中出现多次，则最接近该模式结尾的字符将确定该字符的跳过值。 注意： 如果搜索模式只包含几个字符，则执行暴力搜索会更快。 在构建跳过表与为短模式执行暴力搜索之间需要进行权衡。 致谢：此代码基于1989年7月Dr Dobb’s杂志发表的文章“Faster String Searches” by Costas Menico —— 对 ，1989年！ 有时保留那些旧杂志是有用的。 扩展阅读：这个算法的详细分析 Boyer-Moore-Horspool 算法上面算法的一个变体是Boyer-Moore-Horspool 算法。 像常规的Boyer-Moore算法一样，它使用skipTable来跳过许多字符。 不同之处在于我们如何检查局部匹配。在上面的版本中，如果找到了部分匹配，但不是完全匹配，我们只跳过一个字符。在这个修订版本中，我们也在那种情况下使用跳过表。 这是Boyer-Moore-Horspool算法的一个实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051extension String &#123; func index(of pattern: String, usingHorspoolImprovement: Bool = false) -&gt; Index? &#123; let patternLength = pattern.count guard patternLength &gt; 0, patternLength &lt;= self.count else &#123; return nil &#125; var skipTable = [Character: Int]() for (i, c) in pattern.enumerated() &#123; skipTable[c] = patternLength - i - 1 &#125; let p = pattern.index(before: pattern.endIndex) let lastChar = pattern[p] var i = index(startIndex, offsetBy: patternLength - 1) func backwards() -&gt; Index? &#123; var q = p var j = i while q &gt; pattern.startIndex &#123; j = index(before: j) q = index(before: q) if self[j] != pattern[q] &#123; return nil &#125; &#125; return j &#125; while i &lt; endIndex &#123; let c = self[i] if c == lastChar &#123; if let k = backwards() &#123; return k &#125; if !usingHorspoolImprovement &#123; i = index(after: i) &#125; else &#123; let jumpOffset = max(skipTable[c] ?? patternLength, 1) i = index(i, offsetBy: jumpOffset, limitedBy: endIndex) ?? endIndex &#125; &#125; else &#123; i = index(i, offsetBy: skipTable[c] ?? patternLength, limitedBy: endIndex) ?? endIndex &#125; &#125; return nil &#125;&#125; 在实践中，Horspool版本的算法往往比原始版本略好一些。 但是，这取决于你愿意做出什么样的权衡。 致谢：此代码基于论文：R. N. Horspool (1980). “Practical fast searching in strings”. Software - Practice &amp; Experience 10 (6): 501–506. 作者：Matthijs Hollemans，Andreas Neusüß，Matías Mazzei翻译：Andy Ron校对：Andy Ron 译注： 阮一峰老师的文章 字符串匹配的Boyer-Moore算法 讲的比较清晰。]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>Boyer-Moore字符串搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-暴力字符串搜索]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%9A%B4%E5%8A%9B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%90%9C%E7%B4%A2.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。 Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。 🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。 本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Brute-Force String Search 暴力字符串搜索(Brute-Force String Search) 如果不允许导入Foundation并且不能使用NSString的rangeOfString()方法，那么如何在纯Swift中编写字符串搜索算法呢？目标是在String上实现indexOf(pattern: String)扩展，返回第一次出现的搜索模式的String.Index，如果在字符串中找不到模式，则返回nil。 例子： 12345678910111213// Input: let s = "Hello, World"s.indexOf("World")// Output:&lt;String.Index?&gt; 7// Input:let animals = "🦍🐢🐡🐮🦖🐋🐶🐬🐠🐔🐷🐙🐮🦟🦂🦜🦢🐨🦇🐐🦓"animals.indexOf("🐮")// Output:&lt;String.Index?&gt; 6 注意： 牛的索引是6，而不是你想象的3，因为字符串为表情符号使用更多的存储空间。 String.Index的实际值并不那么重要，只要它指向字符串中的正确字符。 这是暴力解决方案： 123456789101112131415161718192021extension String &#123; func indexOf(_ pattern: String) -&gt; String.Index? &#123; for i in self.indices &#123; var j = i var found = true for p in pattern.indices &#123; if j == self.endIndex || self[j] != pattern[p] &#123; found = false break &#125; else &#123; j = self.index(after: j) &#125; &#125; if found &#123; return i &#125; &#125; return nil &#125;&#125; 这将依次查看源字符串中的每个字符。 如果字符等于搜索模式的第一个字符，则内部循环检查模式的其余部分是否匹配，如果未找到匹配项，则外循环将从中断处继续。 重复此过程直到找到完全匹配或到达源字符串的结尾。 暴力方法运行正常，但效率不高（或漂亮）。 不过，暴力方法应该可以在小字符串上正常工作。 对于使用大块文本更好的智能算法，请查看Boyer-Moore字符串搜索。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>暴力字符串搜索</tag>
        <tag>Brute-Force String Search</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-堆排序]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%A0%86%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。 Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。 🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。 本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Heap Sort 堆排序(Heap Sort) 使用堆将数组从低到高排序。( 译注： 也可以从高到低排序) 堆是一个部分排序的二叉树，存储在数组中。 堆排序算法利用堆的结构来执行快速排序。 要从最低到最高排序，堆排序首先将未排序的数组转换为max-heap，让数组中的第一个元素是最大的。 假设，需要排序的数组为： [ 5, 13, 2, 25, 7, 17, 20, 8, 4 ] 首先变成了一个如下所示的max-heap： 这个堆的数组是： [ 25, 13, 20, 8, 7, 17, 2, 5, 4 ] 这几乎不是想要的从低到高排序！ 现在开始排序：我们将第一个元素（索引0）与索引n-1的最后一个元素交换，得到： [ 4, 13, 20, 8, 7, 17, 2, 5, 25 ] * * 现在新的根节点4小于其子节点，因此我们使用shift down或“堆化(heapify)”将0到n-2元素修复成max-heap。 修复堆后，新的根节点现在是数组中的第二大项： [20, 13, 17, 8, 7, 4, 2, 5 | 25] 重要提示：当我们修复堆时，我们忽略索引为n-1的最后一项。 最后一项是数组中的最大值，因此它已经在最终排序的位置了。 |栏表示数组的已排序部分的开始位置。 从现在开始，我们将单独除了数组余下的部分（|前面的部分）。 同样，我们将第一个元素与最后一个元素交换（这次是在索引n-2）： [5, 13, 17, 8, 7, 4, 2, 20 | 25] * * 并修复堆以使其再次成为有效的max-heap： [17, 13, 5, 8, 7, 4, 2 | 20, 25] 正如您所看到的，最大项正在向后移动。 我们重复这个过程，直到到达根节点，也就对整个数组进行了排序。 注意： 此过程与选择排序 非常相似，它重复查找数组其余部分中的最小项。 提取最小值或最大值是堆擅长做的。 堆排序的性能最佳，最差和平均情况下都是O(n lg n)。 因为我们直接修改数组，所以可以就地执行堆排序。 但它不是一个稳定的类型：不保留相同元素的相对顺序。 以下是在Swift中实现堆排序的方法： 123456789extension Heap &#123; public mutating func sort() -&gt; [T] &#123; for i in stride(from: (elements.count - 1), through: 1, by: -1) &#123; swap(&amp;elements[0], &amp;elements[i]) shiftDown(0, heapSize: i) &#125; return elements &#125;&#125; 为堆实现添加了一个sort()函数。 这个函数的使用方式： 12var h1 = Heap(array: [5, 13, 2, 25, 7, 17, 20, 8, 4], sort: &gt;)let a1 = h1.sort() 因为我们需要一个max-heap来从低到高排序，你需要给Heap提供sort函数的反向排序。 要对&lt;进行排序，必须使用&gt;作为sort函数创建Heap对象。 换句话说，从低到高的排序会创建一个max-heap并将其转换为min-heap（ 译注： 这边的意思就是排完序以后就变成了一个从小到大的特殊的min-heap）。 我们可以为此编写一个方便的辅助函数： 12345public func heapsort&lt;T&gt;(_ a: [T], _ sort: @escaping (T, T) -&gt; Bool) -&gt; [T] &#123; let reverseOrder = &#123; i1, i2 in sort(i2, i1) &#125; var h = Heap(array: a, sort: reverseOrder) return h.sort()&#125; 使用方式： 12let a2 = heapsort([5, 13, 2, 25, 7, 17, 20, 8, 4], &lt;)print(a2) 作者： Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>堆排序</tag>
        <tag>Heap Sort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习iOS动画之五：使用UIViewPropertyAnimator]]></title>
    <url>%2F2019%2FiOS-Animation-5-UIViewPropertyAnimator.html</url>
    <content type="text"><![CDATA[本文是我学习《iOS Animations by Tutorials》 笔记中的一篇。文中详细代码都放在我的Github上 andyRon/LearniOSAnimations。 UIViewPropertyAnimator是从iOS10开始引入，它能够创建易于交互，可中断和/或可逆的视图动画。 这个类让某些类型的视图动画更容易创建，值得学习。 UIViewPropertyAnimator可以在同一个类中方便地将许多API包装在一起，这样更容易使用。 此外，这个新类不能完全取代了UIView.animate(withDuration...)API集。 内容预览： 20-UIViewPropertyAnimator入门 21-深入UIViewPropertyAnimator 22-用UIViewPropertyAnimator进行交互式动画 23-用UIViewPropertyAnimator自定义视图控制器转场 本文的四个章节都是使用同一个项目 LockSearch 20-UIViewPropertyAnimator入门在iOS10之前，创建基于视图的动画的唯一选择是UIView.animate(withDuration: ...)I，但这组API没有为开发人员提供暂停或停止已经运行的动画的处理方式。此外，对于反转，加速或减慢动画，开发人员只能使用基于图层的CAAnimation（核心动画）。 UIViewPropertyAnimator就是为了解决上述问题而出现的，它是一个允许保持运行动画的类，允许开发者调整当前运行的动画，并提供有关动画当前状态的详细信息。 当然，简单单一的视图动画直接使用UIView.animate(withDuration: ...)就可以了。 基础动画本章的开始项目 LockSearch 。 类似于iOS锁屏时的屏幕。 初始视图控制器有搜索栏，单个窗口小部件和编辑按钮等： 开始项目 已经实现了一些与动画无关的功能。 例如，如果点击Show More按钮，窗口小部件将展开并显示更多项目。 如果点击编辑，会转到另一个视图控制器，这是一个简单的TableView。 当然，该项目只是模拟iOS中的锁定屏幕，用来学习动画，没有实际的功能，。 打开LockScreenViewController.swift并向该视图控制器添加一个新的viewWillAppear(_:)方法： 1234override func viewWillAppear(_ animated: Bool) &#123; tableView.transform = CGAffineTransform(scaleX: 0.67, y: 0.67) tableView.alpha = 0&#125; 为了创建简单的缩放和淡入淡出视图动画，首先缩小整个表视图并使其透明。 接下来，在视图控制器的视图出现在屏幕上时创建一个动画师。 将以下内容添加到LockScreenViewController： 1234override func viewDidAppear(_ animated: Bool) &#123; let scale = UIViewPropertyAnimator.init(duration: 0.33, curve: .easeIn) &#123; &#125;&#125; 在这里，您使用UIViewPropertyAnimator的一个便利构造器：UIViewPropertyAnimator.init(duration:curve:animations:)。 通过构造器创建动画实例并设置动画的总持续时间和时间曲线。 后一个参数的类型为UIViewAnimationCurve，这是一个枚举类型，有四个类型：easeInOut、easeIn、easeOut、linear。这与UIView.animate(withDuration:...)中的option是类似的。 添加动画在viewDidAppear(_:)中添加： 123scale.addAnimations &#123; self.tableView.alpha = 1.0&#125; 使用addAnimations添加动画代码块，就像UIView.animate(withDuration...)的闭包参数animations。 使用动画师的不同之处在于可以添加多个动画块。 除了能够有条件地构建复杂的动画外，还可以添加具有不同延迟的动画。 另一个版本的addAnimations，有两个参数：animation 动画代码delayFactor 动画开始前的延迟 delayFactor与UIView.animate(withDuration...)中delay不同，它介于0.0到1.0，不是绝对时间是相对时间。 在同一个动画师添加第二个动画，但有一些延迟。继续在上面的代码后添加： 123scale.addAnimations(&#123; self.tableView.transform = .identity&#125;, delayFactor: 0.33) 实际延迟时间是delayFactor乘以动画师的剩余持续时间(remaining duration)。 目前尚未启动动画，因此剩余持续时间等于总持续时间。所以在上面的情况： 1delayFactor(0.33) * remainingDuration(=duration 0.33) = delay of 0.11 seconds 为什么第二个参数不是一个简单的秒数值？想象动画师已经在运行了，你决定在中途添加一些新的动画。 在这种情况下，剩余持续时间不会等于总持续时间，因为自启动动画以来已经过了一段时间。 在这种情况下，delayFactor将允许开发者根据剩余可用时间设置延迟动画。 此外，这样设计也确保了不能将延迟设置为长于剩余运行时间。 添加完成闭包在viewDidAppear(_:)中添加： 123scale.addCompletion &#123; (_) in print("ready")&#125; addCompletion(_:)就是动画完成闭包，当然，它也可多次调用，来完成多了处理程序。 下面要启动动画，在viewWillAppear(_:)的末尾添加： 1scale.startAnimation() 提取动画为了代码的清晰，可以把动画代码集中放到一个类中。 创建一个名为AnimatorFactory.swift的新文件，并将其默认内容替换为： 12345import UIKitclass AnimatorFactory &#123; &#125; 然后添加一个类型方法，其中包含刚刚编写的动画代码，但默认情况下不运行动画，而是返回动画师： 1234567891011121314151617static func scaleUp(view: UIView) -&gt; UIViewPropertyAnimator &#123; let scale = UIViewPropertyAnimator(duration: 0.33, curve: .easeIn) scale.addAnimations &#123; view.alpha = 1.0 &#125; scale.addAnimations(&#123; view.transform = .identity &#125;, delayFactor: 0.33) scale.addCompletion &#123; (_) in print("ready") &#125; return scale&#125; 该方法将视图作为参数，并在该视图上创建所有动画，最后它返回准备好的动画师。 将LockScreenViewController中的viewDidAppear(_:)替换为： 123override func viewDidAppear(_ animated: Bool) &#123; AnimatorFactory.scaleUp(view: tableView).startAnimation()&#125; 这样看上去代码更加简洁，清晰，把动画代码从视图控制器移出。 这个动画师工厂🏭类AnimatorFactory集中处理动画代码，这是设计模式中的工厂模式的一个简单应用。😀 运行动画师当用户使用搜索栏时，将淡入模糊图层（blurView），并在用户完成搜索时将其淡出。 向LockScreenViewController类添加一个新方法： 12345func toggleBlur(_ blurred: Bool) &#123; UIViewPropertyAnimator.runningPropertyAnimator(withDuration: 0.5, delay: 0.1, options: .curveEaseOut, animations: &#123; self.blurView.alpha = blurred ? 1 : 0 &#125;, completion: nil)&#125; UIViewPropertyAnimator.runningPropertyAnimator(withDuration:...)与UIView.animate(withDuration:...)有完全相同的参数，使用也相同。 虽然看起来这可能是一种“即发即忘”(“fire-and-forget” )的API，但请注意它确实会返回一个动画实例。 因此，您可以添加更多动画，更多完成块，并且通常与当前正在运行的动画进行交互。 现在让我们看看淡入淡出动画的样子。 LockScreenViewController已设置为搜索栏的委托，因此您只需实现所需的方法即可在正确的时间触发动画。 以扩展的方式为LockScreenViewController遵守搜索栏的代理协议： 12345678910extension LockScreenViewController: UISearchBarDelegate &#123; func searchBarTextDidBeginEditing(_ searchBar: UISearchBar) &#123; toggleBlur(true) &#125; func searchBarTextDidEndEditing(_ searchBar: UISearchBar) &#123; toggleBlur(false) &#125;&#125; 要为用户提供取消搜索的功能，还要添加以下两种方法： 123456789func searchBarResultsListButtonClicked(_ searchBar: UISearchBar) &#123; searchBar.resignFirstResponder()&#125;func searchBar(_ searchBar: UISearchBar, textDidChange searchText: String) &#123; if searchText.isEmpty&#123; searchBar.resignFirstResponder() &#125;&#125; 这将允许用户通过点击右侧按钮解除搜索。 运行，效果： 点按搜索栏文本字段，小部件在模糊效果视图下消失；点击搜索栏右侧的按钮时，模糊视图会淡出。 基础关键帧动画UIViewPropertyAnimator也可以使用UIView.addKeyframe(5-视图的关键帧动画)。下面创建一个简单的图标抖动动画来展示。 在AnimatorFactory中添加类型方法： 12345678910111213141516static func jiggle(view: UIView) -&gt; UIViewPropertyAnimator &#123; return UIViewPropertyAnimator.runningPropertyAnimator(withDuration: 0.33, delay: 0 , animations: &#123; UIView.addKeyframe(withRelativeStartTime: 0.0, relativeDuration: 0.25, animations: &#123; view.transform = CGAffineTransform(rotationAngle: -.pi/8) &#125;) UIView.addKeyframe(withRelativeStartTime: 0.25, relativeDuration: 0.75, animations: &#123; view.transform = CGAffineTransform(rotationAngle: +.pi/8) &#125;) UIView.addKeyframe(withRelativeStartTime: 0.75, relativeDuration: 1.0, animations: &#123; view.transform = CGAffineTransform.identity &#125;) &#125;, completion: &#123; (_) in &#125;)&#125; 第一个关键帧向左旋转，第二个关键帧向右旋转，最后第三个关键帧回到原点 。 要确保图标保持在其初始位置，在完成闭包中添加： 1view.transform = .identity 下面就可以在想要运行这个动画的视图上添加动画了。 打开IconCell.swift（该文件位于Widget子文件夹中）。这是自定义单元类，对应于窗口小部件视图中的每个图标。在IconCell中添加： 123func iconJiggle() &#123; AnimatorFactory.jiggle(view: icon)&#125; 现在Xcode抱怨AnimatorFactory.jiggle方法返回一个结果没有被使用，这是Xcode善意的提醒😊。 这个问题很容易解决，只需要在jiggle方法前添加@discardableResult，让Xcode知道这个方法的结果我不要了😏。 discardableResult的官方解释： Apply this attribute to a function or method declaration to suppress the compiler warning when the function or method that returns a value is called without using its result. 12@discardableResultstatic func jiggle(view: UIView) -&gt; UIViewPropertyAnimator &#123; 要最终运行动画，在WidgetView.swift 的collectionView(_:didSelectItemAt:)中添加： 123if let cell = collectionView.cellForItem(at: indexPath) as? IconCell &#123; cell.iconJiggle()&#125; 效果： 提取模糊动画把前面的模糊动画也提取到AnimatorFactory中。 123456@discardableResultstatic func fade(view: UIView, visible: Bool) -&gt; UIViewPropertyAnimator &#123; return UIViewPropertyAnimator.runningPropertyAnimator(withDuration: 0.5, delay: 0.1, options: .curveEaseOut, animations: &#123; view.alpha = visible ? 1.0 : 0.0 &#125;, completion: nil)&#125; 替代LockScreenViewController中的toggleBlur（_:）方法： 123func toggleBlur(_ blurred: Bool) &#123; AnimatorFactory.fade(view: blurView, visible: blurred)&#125; 防止动画重叠如何检查动画师当前是否正在执行其动画？ 如果在同一个图标上快速连续点击，会发现抖动动画没有结束就重新开始了。 解决这个问题，就需要检测视图是否有动画正在运行。 为IconCell添加一个属性，并修改iconJiggle()： 123456789var animator: UIViewPropertyAnimator?func iconJiggle() &#123; if let animator = animator, animator.isRunning &#123; return &#125; animator = AnimatorFactory.jiggle(view: icon)&#125; 对比可以发现有所不同： 21-深入UIViewPropertyAnimator上一章节学习了UIViewPropertyAnimator的基本使用，这一章节学习更多关于UIViewPropertyAnimator的知识。 本章的开始项目 使用上一章节完成的项目。 自定义动画计时前文已经多次提到：easeInOut、easeIn、easeOut、linear（可以理解为物体运动轨迹的曲线类型）。可以参考视图动画中的动画缓动 或者图层动画中的动画缓动，这边就不再介绍了。 内置时间曲线目前，当您激活搜索栏时，您会在窗口小部件顶部的模糊视图中淡入淡出。 在此示例中，您将删除该淡入淡出动画并为模糊效果本身设置动画。 之前，激活搜索栏时，就会有一个模糊视图中淡入淡出效果。这个部分删除这个效果，修改成对模糊效果本身设置动画。什么意思呢？ 看完下面的操作，应该能明白。 向LockScreenViewController类添加一个新方法： 1234567func blurAnimations(_ blured: Bool) -&gt; () -&gt; Void &#123; return &#123; self.blurView.effect = blured ? UIBlurEffect(style: .dark) : nil self.tableView.transform = blured ? CGAffineTransform(scaleX: 0.75, y: 0.75) : .identity self.tableView.alpha = blured ? 0.33 : 1.0 &#125;&#125; 删除viewDidLoad()中的两行代码： 12blurView.effect = UIBlurEffect(style: .dark)blurView.alpha = 0 替代toggleBlur(_:)内容为： 123func toggleBlur(_ blurred: Bool) &#123; UIViewPropertyAnimator(duration: 0.55, curve: .easeOut, animations: blurAnimations(blurred)).startAnimation()&#125; 运行，效果： 请注意模糊不仅仅是淡入或淡出，实际上它会在效果视图中插入模糊量。 贝塞尔曲线有时想要对动画的时间非常具体时，使用这些曲线简单地“开始减速”或“慢慢结束”是不够的。 在10-动画组和时间控制 中学习了使用CAMediaTimingFunction控制图层动画的时间。 之前没有了解背后的原理贝塞尔曲线，这边介绍一下它。这边的内容也可应用到图层动画中。 贝塞尔曲线是什么？ 让我们从简单的事情开始 —— 一条线。它非常简洁，需要在屏幕上画一条线，只需要定义它的两个点的坐标，开始 (A) 和结束 (B)： 现在让我们来看看曲线。曲线比线条更有趣，因为它们可以在屏幕上绘制任何东西。例如： 在上面看到的是四条曲线放在一起;它们的两端在小白方块的地方相遇。图中有趣的是小绿圈，它们定义了每条曲线。 所以曲线不是随机的。它们也有一些细节，就像线条一样，可以帮助我们通过坐标定义它们。 您可以通过向线条添加控制点来定义曲线。 让我们在之前的行中添加一个控制点： 可以想象由连接到线的铅笔绘制的曲线，其起点沿着线AC移动，其终点沿着线CB移动： 网上找了一个动图： 具有一个控制点的Bézier曲线称为 二次曲线。有两个控制点的Bézier曲线叫做 三次曲线（立方贝塞尔曲线）。我们使用的内置曲线就是三次曲线。 核心动画使用始终以坐标（0,0）开始的三次曲线，它表示动画持续时间的开始。 当然，这些时间曲线的终点始终是（1,1），表示 动画的持续时间和进度的结束。 让我们来看看 ease-in 曲线： 随着时间的推移（在坐标空间中从左向右水平移动），曲线在垂直轴上的进展非常小，然后大约在动画持续时间的一半时间后，曲线在垂直轴上的进展非常大，最终在(1, 1)处结束。 ease-out 和 ease-in-out曲线分别是： 现在已了解Bézier曲线的工作原理，剩下的问题是如何在视觉上设计一些曲线并获得控制点的坐标，方便可以将它们用于iOS动画。 可以使用网站：http://cubic-bezier.com。 这是计算机科学研究员和演讲者Lea Verou的非常方便的网站。 它可以拖动立方Bézier的两个控制点并查看即时动画预览，非常nice😊😊。 上面贝塞尔的原理说的不够深刻🤦‍♀️，现在只需了解曲线，通过两个控制点可以画曲线。 接下来，向项目中添加自定义计时动画。 把LockScreenViewController中的toggleBlur()的现有动画替换为： 123func toggleBlur(_ blurred: Bool) &#123; UIViewPropertyAnimator(duration: 0.55, controlPoint1: CGPoint(x: 0.57, y: -0.4), controlPoint2: CGPoint(x: 0.96, y: 0.87), animations: blurAnimations(blurred)).startAnimation()&#125; 这边的controlPoint1 和controlPoint2两个点，就是我们自定义三次曲线的控制点。 可以通过 http://cubic-bezier.com 网站来选着控制点。 弹簧动画另一个便利构造器UIViewPropertyAnimator(duration:dampingRatio:animations:)，用于定义弹簧动画。 这与UIView.animate(withDuration: delay: usingSpringWithDamping: initialSpringVelocity: options: animations: completion:)类似，只不过初始速度为0。 自定义时间曲线UIViewPropertyAnimator类还有一个构造器UIViewPropertyAnimator(duration:timingParameters:)。 参数timingParameters必须遵守UITimingCurveProvider协议，有两个类可供我们使用：UICubicTimingParameters和UISpringTimingParameters。 下面看看这个构造器的使用方式。 阻尼和速度添加阻尼和速度的方式如下： 123let spring = UISpringTimingParameters(dampingRatio:0.5, initialVelocity: CGVector(dx: 1.0, dy: 0.2))let animator = UIViewPropertyAnimator(duration: 1.0, timingParameters: spring) 注意初始速度initialVelocity是矢量类型，这个参数是一个可选参数。 自定义弹簧动画如果想对弹簧动画更加具体的设置，可以UISpringTimingParameters的另一个构造器init(mass:stiffness:damping:initialVelocity:)，代码如下： 123let spring = UISpringTimingParameters(mass: 10.0, stiffness: 5.0, damping: 30, initialVelocity: CGVector(dx: 1.0, dy: 0.2))let animator = UIViewPropertyAnimator(duration: 1.0, timingParameters: spring) 上面这些参数的工作原理，可以查看之前的文章11-图层弹簧动画。 自动布局动画前面的文章系统学习iOS动画之二：自动布局动画 学习了自动布局动画。 使用UIViewPropertyAnimator的布局约束动画与使用UIView.animate(withDuration: ...)创建它们的方式非常相似。 诀窍是更新约束，在动画块中调用layoutIfNeeded()。 在AnimatorFactory中添加一个新的工厂方法： 1234567891011@discardableResultstatic func animateConstraint(view: UIView, constraint: NSLayoutConstraint, by: CGFloat) -&gt; UIViewPropertyAnimator &#123; let spring = UISpringTimingParameters(dampingRatio: 0.55) let animator = UIViewPropertyAnimator(duration: 1.0, timingParameters: spring) animator.addAnimations &#123; constraint.constant += by view.layoutIfNeeded() &#125; return animator&#125; 在LockScreenViewController中viewWillAppear里添加： 12dateTopConstraint.constant -= 100view.layoutIfNeeded() 在viewDidAppear里添加： 1AnimatorFactory.animateConstraint(view: view, constraint: dateTopConstraint, by: 150).startAnimation() 这让时间标签的位置，在应用打开时有一个动画。 接下来，在添加一个约束动画。当点击“Show more”时，窗口小部件会加载内容，并需要更改其高度约束。 重新定义WidgetCell.swift中的toggleShowMore(_:)方法： 1234567891011121314151617@IBAction func toggleShowMore(_ sender: UIButton) &#123; self.showsMore = !self.showsMore let animations = &#123; self.widgetHeight.constant = self.showsMore ? 230 : 130 if let tableView = self.tableView &#123; tableView.beginUpdates() tableView.endUpdates() tableView.layoutIfNeeded() &#125; &#125; let spring = UISpringTimingParameters(mass: 30, stiffness: 10, damping: 300, initialVelocity: CGVector(dx: 5, dy: 0)) toggleHeightAnimator = UIViewPropertyAnimator(duration: 0.0, timingParameters: spring) toggleHeightAnimator?.addAnimations(animations) toggleHeightAnimator?.startAnimation()&#125; 在toggleShowMore(_:)方法的底部，添加以下代码用来加载窗口小部件中的图标： 12widgetView.expanded = showsMorewidgetView.reload() 视图过渡在视图动画的3-过渡动画，学习了视图过渡。现在用UIViewPropertyAnimator做视图过渡。 显示更多按钮的title，”Show More” 和 “Show Less” 两者相互淡入淡出动画。 在toggleShowMore（_ :)的toggleHeightAnimator定义之前添加这段代码： 12345let textTransition = &#123; UIView.transition(with: sender, duration: 0.25, options: .transitionCrossDissolve, animations: &#123; sender.setTitle(self.showsMore ? "Show Less" : "Show More", for: .normal) &#125;, completion: nil)&#125; 在toggleHeightAnimator开始之前添加： 1toggleHeightAnimator?.addAnimations(textTransition, delayFactor: 0.5) 这将改变按钮标题，具有很好的交叉淡入淡出效果： 效果也可以尝试.transitionFlipFromTop等 22-用UIViewPropertyAnimator进行交互式动画前面两个章节介绍了许多UIViewPropertyAnimator 的使用，例如基本动画，自定义计时和弹簧动画，以及动画的提取。但是，与以前视图动画 “即发即忘”(“fire-and-forget”)API相比，尚未研究使UIViewPropertyAnimator真正有趣的地方。 UIView.animate(withDuration:...)提供了动画的设置方法，但是一旦定义动画结束状态，那么动画就会开始执行，而无法控制。 但是如果我们想在动画运行时与之交互，怎么办？ 细说，就是动画不是静态的，而是由用户手势或麦克风输入驱动的，就像在前面图层动画 系统学习iOS动画之三：图层动画 所学的一样。 使用UIViewPropertyAnimator 创建的动画是完全交互式的：可以启动，暂停，改变速度，甚至可以直接调整进度。 由于UIViewPropertyAnimator可以同时驱动预设动画和交互式动画，因而在描述动画师当前的状态时，就有点复杂了😵。下面就看看如何处理动画师的状态。 本章的开始项目 使用上一章节完成的项目。 动画状态机UIViewPropertyAnimator可以检查动画是否已启动(isRunning)，是否已暂停或完全停止(state)，或动画是否已颠倒(isReversed)。 UIViewPropertyAnimator有三个描述当前状态的属性： isRunning（只读）：动画当前是否处于运动状态。 默认为false，在调用startAnimation()时变为true，如果暂停或停止动画，或者动画自然完成，它将再次变为false。 isReversed：默认为false，因为我们总是向前开始动画，即动画从开始状态播放到结束状态。 如果更改为true，则动画将颠倒，即从介绍状态到开始状态。 state （只读）： state默认为inactive，这通常意味着刚刚创建了动画师，并且还没有调用任何方法。请注意，这与将isRunning设置为false不同，isRunning实际上只关注正在进行的动画，而当state处于inactive时，这实际上意味着动画师还没有做任何事情。 state 变成 active的情况有： 调用startAnimation()来启动动画 在没有开始动画的情况下调用pauseAnimation() 设置fractionComplete属性以将动画“倒回”到某个位置 动画自然完成后，state切换回.inactive。 如果在动画师上调用stopAnimation()，它会将其state属性设置为.stopped。在这种状态下，你唯一能做的就是完全放弃动画师或者调用finishAnimation(at:)来完成动画并让动画师回到.inactive。 正如你可能想到的那样，UIViewPropertyAnimator只能按特定顺序在状态之间切换。 它不能直接从inactive到stopped，也不能从stopped直接转为active。 如果设置了pausesOnCompletion，一旦动画师完成了动画的运行而不是自动停止，而是暂停。 这将使我们有机会在暂停状态下继续使用它。 状态流程图： 可能有点绕，之后的使用中，如果有疑问，可以再回到这个部分查看。 交互式3D touch动画从这个部分开始，将学习创建类似于3D touch交互的交互式动画： 注意：对于本章项目，需要兼容3D touch的iOS设备（没记错的话是6S+）。 听闻👂，3D touch这个技术会被在iPhone上取消，好吧，这边是学习类似3D touch 的动画，它的未来如何，就不过问了。 3D touch的动画，可以这样描述：当我们手指按压屏幕上的图标时，动画交互式开始，背景越来越模糊，从图标旁渐渐呈现一个菜单，这个过程会随着手指按压的力度变化而前后变化。 放慢的效果为： WidgetView.swift中，WidgetView通过扩展遵守UIPreviewInteractionDelegate协议。这个协议中就包括了3D touch过程中一些委托方法。 为了让您开始开发动画本身，UIPreviewInteractionDelegate方法已经连接到LockScreenViewController上调用相关方法。WidgetView中的代码如下： 3D Touch开始时调用LockScreenViewController.startPreview(for:)。 当用户按下的过程中，可能更硬（或更柔和）时，反复调用LockScreenViewController.updatePreview(percent:)。 当peek交互成功完成时，调用LockScreenViewController.finishPreview()。 最后，如果用户在未完成预览手势的情况下抬起手指，则调用LockScreenViewController.cancelPreview()。 在LockScreenViewController中添加这三个属性，您需要这些属性来创建窥视交互： 123var startFrame: CGRect?var previewView: UIView?var previewAnimator: UIViewPropertyAnimator? startFrame 来跟踪动画的开始位置。 previewView 图标的快照视图，动画期间暂时使用它。previewAnimator 将成为驱动预览动画的交互式动画师。 再添加一个属性以保持模糊效果以显示图标框： 1let previewEffectView = IconEffectView(blur: .extraLight) IconEffectView是自定义的UIVisualEffectView的子类，它包含单个标签的简单模糊视图，使用它来模拟从按下的图标弹出的菜单： 在LockScreenViewController遵守WidgetsOwnerProtocol协议的扩展中，实现startPreview(for:)方法： 12345func startPreview(for forView: UIView) &#123; previewView?.removeFromSuperview() previewView = forView.snapshotView(afterScreenUpdates: false) view.insertSubview(previewView!, aboveSubview: blurView)&#125; WidgetsOwnerProtocol协议是一个自定义协议。 只要用户开始按下图标，WidgetView就会调用startPreview(for:)。 参数for是用户开始手势的集合单元格图像。 首先删除任何现有的previewView视图，以防万一在屏幕上留下之前的视图。 然后，您可以创建集合视图图标的快照，最后将其添加到模糊效果视图上方的屏幕上。 运行，按压图标。发现图标出现在左上角！😰 因为尚未设置其位置。 继续添加： 123previewView?.frame = forView.convert(forView.bounds, to: view)startFrame = previewView?.frameaddEffectView(below: previewView!) 现在图标副本位置正确了，完全覆盖在原有图标上。 startFrame用来存储起始frame，以供之后使用。 函数addEffectView(below:)添加图标快照下方的模糊框。代码为： 123456func addEffectView(below forView: UIView) &#123; previewEffectView.removeFromSuperview() previewEffectView.frame = forView.frame forView.superview?.insertSubview(previewEffectView, belowSubview: forView)&#125; 下面创建动画本身，在AnimatorFactory中添加类方法： 123456789static func grow(view: UIVisualEffectView, blurView: UIVisualEffectView) -&gt; UIViewPropertyAnimator &#123; view.contentView.alpha = 0 view.transform = .identity let animator = UIViewPropertyAnimator(duration: 0.5, curve: .easeIn) return animator&#125; 两个参数，view是动画视图，blurView 是动画的模糊背景。 在返回动画师之前，为动画师添加动画和完成闭包： 12345678animator.addAnimations &#123; blurView.effect = UIBlurEffect(style: .dark) view.transform = CGAffineTransform(scaleX: 1.5, y: 1.5)&#125;animator.addCompletion &#123; (_) in blurView.effect = UIBlurEffect(style: .dark)&#125; 动画代码为blurView创建了模糊过渡，为view创建一个普通的转换。 之后，在LockScreenViewController.swift的startPreview()中完成调用： 1previewAnimator = AnimatorFactory.grow(view: previewEffectView, blurView: blurView) 现在运行，还没有效果，还需要实现updatePreview(percent:)方法： 123func updatePreview(percent: CGFloat) &#123; previewAnimator?.fractionComplete = max(0.01, min(0.99, percent))&#125; 当WidgetView被按压时，上面个方法会被重复调用。fractionComplete在0.01和0.99范围内，因为我不希望在动画才这段结束，我另外指定的方法完成或取消动画。 运行，效果（放慢）： 你会（惊喜！）需要更多的动画师。 打开AnimatorFactory.swift并添加一个动画师，它可以解除你的“成长”动画师所做的一切。您需要此动画师的一种情况是用户取消手势。 当您需要清理UI时，另一个是成功交互的最后阶段。 在AnimatorFactory中添加方法： 12345678910static func reset(frame: CGRect, view: UIVisualEffectView, blurView: UIVisualEffectView) -&gt; UIViewPropertyAnimator &#123; return UIViewPropertyAnimator(duration: 0.5, dampingRatio: 0.7, animations: &#123; view.transform = .identity view.frame = frame view.contentView.alpha = 0 blurView.effect = nil &#125;)&#125; 此方法的三个参数分别是原始动画的起始帧，动画视图和背景模糊视图。 动画块将重置交互开始之前状态中的所有属性。 在LockScreenViewController.swift中，实现WidgetsOwnerProtocol协议的另一个方法： 123456func cancelPreview() &#123; if let previewAnimator = previewAnimator &#123; previewAnimator.isReversed = true previewAnimator.startAnimation() &#125;&#125; cancelPreview()是WidgetView被按压后，突然抬起手指时调用的方法，取消正在进行的手势。 到目前为止，你还没有开始你的动画师。 您一直在重复设置fractionComplete，这会以交互方式驱动动画。但是，一旦用户取消交互，您就无法继续以交互方式驱动动画，因为您没有更多输入。 相反，通过将isReversed设置为true并调用startAnimation()，可以将动画播放到其初始状态。 现在这是UIView.animate(withDuration: ...)无法做到的事情！ 再试一次互动。按下动画的一半，然后开始测试cancelPreview()。 当您抬起手指时动画会正确播放，但最终黑暗模糊会突然重新出现。 这个问题植根于你的成长动画师的代码。切换回AnimatorFactory.swift并查看grow中的代码（view：UIVisualEffectView，blurView：UIVisualEffectView） - 更具体地说，这部分： 123animator.addCompletion &#123; (_) in blurView.effect = UIBlurEffect(style: .dark)&#125; 动画可以向前或向后播放，需要在完成闭包中处理。 addCompletion() 的闭包的参数用_省略掉了，它其实是一个枚举类型UIViewAnimatingPosition，表示动画当前进行的情况。它的值可有三个，可以是.start，.end或.current。 将完成闭包替代为： 12345678910animator.addCompletion &#123; (position) in switch position &#123; case .start: blurView.effect = nil case .end: blurView.effect = UIBlurEffect(style: .dark) default: break &#125;&#125; 如果动画被返回，则删除模糊效果。 如果成功完成，则明确将效果调整为暗模糊效果。 现在有一个新问题。 如果取消对某个图标上的按压，则无法再按下它！这是因为图标快照仍然位于原始图标上方，挡住按压手势操作。 要解决该问题，值需要在重置动画完成后立即删除快照。 在LockScreenViewController.swift的cancelPreview()中继续添加： 123456789previewAnimator.addCompletion &#123; (position) in switch position &#123; case .start: self.previewView?.removeFromSuperview() self.previewEffectView.removeFromSuperview() default: break &#125;&#125; 注意：，addCompletion(_:)可以调用多次，不会被下一个替代。 让我们再添加一个动画师来显示图标菜单。 切换到AnimatorFactory.swift并添加到它： 1234567891011static func complete(view: UIVisualEffectView) -&gt; UIViewPropertyAnimator &#123; return UIViewPropertyAnimator(duration: 0.3, dampingRatio: 0.7, animations: &#123; view.contentView.alpha = 1 view.transform = .identity view.frame = CGRect(x: view.frame.minX - view.frame.minX/2.5, y: view.frame.maxY - 140, width: view.frame.width + 120, height: 60) &#125;)&#125; 这一次你创建了一个简单的弹簧动画师。 对于动画师，您可以执行以下操作： 淡入“自定义操作”菜单项。 重置转换。 将视图框架直接设置为图标正上方的位置。 菜单的位置根据用户按下的图标而变化。 您将水平位置设置为 view.frame.minX - view.frame.minX/2.5，如果图标位于屏幕左侧，则显示右侧菜单，如果图标位于左侧，则显示左侧菜单在屏幕的右侧。请参阅以下差异： 动画师准备好了，所以打开LockScreenViewController.swift并在WidgetsOwnerProtocol扩展中添加最后一个必需的方法： 12345678func finishPreview() &#123; previewAnimator?.stopAnimation(false) previewAnimator?.finishAnimation(at: .end) previewAnimator = nil&#125; 当您感觉到触觉反馈时，用户按下3D触摸手势时会调用finishPreview（）。 stopAnimation(_:)是停止当前在屏幕上运行的动画。参数为false，动画师状态为stopped；参数为true，动画师状态为inactive并清除所有动画，而且不调用完成闭包。 一旦你将动画师置于停止状态，你就有了一些选择。你在finishPreview（）中追求的是告诉动画师完成它的最终状态。因此，您调用finishAnimation（at：.end）;这将使用计划动画的目标值更新所有视图并调用您的完成。 此手势不再需要previewAnimator，因此您可以将其删除。 您可以使用以下方法之一调用finishAnimation（at :)： start：将动画重置为初始状态。current：从动画的当前进度更新视图的属性并完成。 调用finishAnimation(at:)后，您的动画师处于inactive。 回到Widgets项目。由于你摆脱了预览动画师，你可以运行完整的动画师来显示菜单。将以下内容附加到finishPreview（）的末尾： 1AnimatorFactory.complete(view: previewEffectView).startAnimation() 运行，按压图标： 关闭模糊视图目前，菜单弹出，模糊视图显示后，还没有回到原来视图的操作，下面添加这个操作。 在finishPreview()中添加以下代码,以准备交互式模糊： 123blurView.effect = UIBlurEffect(style: .dark)blurView.isUserInteractionEnabled = trueblurView.addGestureRecognizer(UITapGestureRecognizer(target: self, action: #selector(dismissMenu))) 先确保将模糊效果设置为.dark，然后模糊视图本身上启用用户交互，并未模糊视图添加点击手势操作，允许用户点击图标周围的任何位置用来关闭菜单。 dismissMenu()代码为： 123456789@objc func dismissMenu() &#123; let reset = AnimatorFactory.reset(frame: startFrame!, view: previewEffectView, blurView: blurView) reset.addCompletion &#123; (_) in self.previewEffectView.removeFromSuperview() self.previewView?.removeFromSuperview() self.blurView.isUserInteractionEnabled = false &#125; reset.startAnimation()&#125; 交互式关键帧动画在20-UIViewPropertyAnimator入门学习了 用UIViewPropertyAnimator制作关键帧动画，现在再给关键帧动画添加交互式操作。 为了尝试一下，你将为成长动画添加一个额外的元素 - 在用户按下图标时以交互方式擦洗的元素。 删除AnimatorFactory的grow()方法中的代码： 1234animator.addAnimations &#123; blurView.effect = UIBlurEffect(style: .dark) view.transform = CGAffineTransform(scaleX: 1.5, y: 1.5)&#125; 替换为： 1234567891011121314animator.addAnimations &#123; UIView.animateKeyframes(withDuration: 0.5, delay: 0.0, animations: &#123; UIView.addKeyframe(withRelativeStartTime: 0.0, relativeDuration: 1.0, animations: &#123; blurView.effect = UIBlurEffect(style: .dark) view.transform = CGAffineTransform(scaleX: 1.5, y: 1.5) &#125;) UIView.addKeyframe(withRelativeStartTime: 0.5, relativeDuration: 0.5, animations: &#123; view.transform = view.transform.rotated(by: -.pi/8) &#125;) &#125;)&#125; 第一个关键帧运行您之前的相同动画。第二个关键帧是简单旋转，效果： 23-用UIViewPropertyAnimator自定义视图控制器转场在系统学习iOS动画之四：视图控制器的转场动画中，学习了如何创建自定义视图控制器转场。这个章节学习使用UIViewPropertyAnimator来自定义视图控制器转场。 本章的开始项目 使用上一章节完成的项目。 静态视图控制器转场现在，点击”Edit“按钮时，体验非常糟糕😰。 首先创建一个新文件PresentTransition.swift，从名字也能看出这个类是用来转场的。 将其默认内容替换为： 123456789101112import UIKitclass PresentTransition: NSObject, UIViewControllerAnimatedTransitioning &#123; func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return 0.75 &#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; &#125;&#125; UIViewControllerAnimatedTransitioning协议已经在系统学习iOS动画之四：视图控制器的转场动画中学过。 我将创建一个转场动画：原视图逐渐模糊图，新视图慢慢移动出来。 在PresentTransition中添加一个新方法： 12345678func transitionAnimator(using transitionContext: UIViewControllerContextTransitioning) -&gt; UIViewImplicitlyAnimating &#123; let duration = transitionDuration(using: transitionContext) let container = transitionContext.containerView let to = transitionContext.view(forKey: .to)! container.addSubview(to)&#125; 在上面的代码中，为视图控制器转场做了一些必要的准备工作。 首先获取动画持续时间，然后获取目标视图控制器的视图，最后将此视图添加到过渡容器中。 接下来，可以设置动画并运行它。 将下面代码添加到上面的方法transitionAnimator(using:)中： 12to.transform = CGAffineTransform(scaleX: 1.33, y: 1.33).concatenating(CGAffineTransform(translationX: 0.0, y: 200))to.alpha = 0 这会向上伸展，然后向下移动目标视图控制器的视图，最后将其淡出。 在to.alpha = 0之后添加动画师来运行转换： 123456789let animator = UIViewPropertyAnimator(duration: duration, curve: .easeOut)animator.addAnimations(&#123; to.transform = CGAffineTransform(translationX: 0.0, y: 100)&#125;, delayFactor: 0.15)animator.addAnimations(&#123; to.alpha = 1.0&#125;, delayFactor: 0.5) 动画师中有两个动画：将目标视图控制器的视图移动到最终位置和淡入。 最后添加完成闭包： 12345animator.addCompletion &#123; (_) in transitionContext.completeTransition(!transitionContext.transitionWasCancelled)&#125;return animator 在animateTransition(using:)中调用上面的方法transitionAnimator(using:)： 1transitionAnimator(using: transitionContext).startAnimation() 在LockScreenViewController中定义常量属性： 1let presentTransition = PresentTransition() 让LockScreenViewController遵守UIViewControllerTransitioningDelegate协议： 1234567// MARK: - UIViewControllerTransitioningDelegateextension LockScreenViewController: UIViewControllerTransitioningDelegate &#123; func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; return presentTransition &#125;&#125; UIViewControllerTransitioningDelegate协议在 系统学习iOS动画之四：视图控制器的转场动画 中学习过。 animationController(forPresented:presents:source:)方法是告诉UIKit，我想自定义视图控制器转场。 在LockScreenViewController中，找到点击Edit按钮的ActionpresentSettings(_:)，添加代码： 123settingsController = storyboard?.instantiateViewController(withIdentifier: "SettingsViewController") as! SettingsViewControllersettingsController.transitioningDelegate = selfpresent(settingsController, animated: true, completion: nil) 运行，点击Edit按钮，SettingsViewController有点问题： 在Main.storyboard中将视图的背景更改为Clear Color。 运行，变成： 下面向动画师添加新属性，为了可以将任何自定义动画注入转场动画， 使用相同的转场类来生成略有不同的动画。 在PresentTransition中添加两个新属性： 12var auxAnimations: (() -&gt; Void)?var auxAnimationsCancel: (() -&gt; Void)? 在transitionAnimator(using:)方法中动画师返回之前添加： 123if let auxAnimations = auxAnimations &#123; animator.addAnimations(auxAnimations)&#125; 这样可以根据具体情况在转换中添加自定义动画。 例如，要为当前转场添加模糊动画。 打开LockScreenViewController并在presentSettings()的开始处插入： 1presentTransition.auxAnimations = blurAnimations(true) 再试一次过渡，看看这一行如何改变它： 模糊动画重复使用了。 另外，当用户解除控制器时，还需要隐藏模糊视图。 在presentSettings(_:)中的present(_:animated:completion:)前添加： 123settingsController.didDismiss = &#123; [unowned self] in self.toggleBlur(false)&#125; 现在，运行，点击SettingsViewController视图中的Cancel或其他选项，先有的模糊视图，然后恢复到第一个视图控制器： 交互视图控制器转场这个部分通过下拉的手势来时学习实现交互视图控制器转场。 首先，让我们使用强大的UIPercentDrivenInteractionTransition类来启用视图控制器转场的交互性。 打开PresentTransition.swift把下面： 1class PresentTransition: NSObject, UIViewControllerAnimatedTransitioning 替换为： 1class PresentTransition: UIPercentDrivenInteractiveTransition, UIViewControllerAnimatedTransitioning &#123; UIPercentDrivenInteractiveTransition是一个定义基于“百分比”的转场方法的类，例如有三个方法： update(_:) 回退转场。 cancel() 取消视图控制器转场。 finish() 播放转场直到完成。 之前学习的19-交互式导航控制器转场中也提到相关内容。 UIPercentDrivenInteractiveTransition的一些属性： timingCurve：如果以交互方式驱动转场，并且是播放转场时直到结束，就可以通过设置此属性为动画提供自定义时序曲线。 wantsInteractiveStart：默认是true，是否使用交互式转场。 pause() ：调用此方法暂停非交互式转场并切换到交互模式。 向PresentTransition添加一个新方法： 123func interruptibleAnimator(using transitionContext: UIViewControllerContextTransitioning) -&gt; UIViewImplicitlyAnimating &#123; return transitionAnimator(using: transitionContext)&#125; 这是UIViewControllerAnimatedTransitioning协议的一个方法。 它允许我们UIKit提供可中断的动画师。 转场动画师类现在有两种不同的行为： 如果以非交互方式使用它（当用户按下编辑按钮时），UIKit将调用animateTransition(using:)来设置转场动画。 如果以交互方式使用它，UIKit将调用interruptibleAnimator(using:)，获取动画师，并使用它来推动这种转场。 切换到LockScreenViewController.swift， 在UIViewControllerTransitioningDelegate扩展中添新方法： 123func interactionControllerForPresentation(using animator: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123; return presentTransition&#125; 接下来，在LockScreenViewController中添加两个新属性，用来跟踪用户的手势： 12var isDragging = falsevar isPresentingSettings = false 当用户向下拉时，将isDragging标志设置为true，当拉得足够远，也将将isPresentingSettings设置为true。 实现UISearchBarDelegate的一个方法： 123func scrollViewWillBeginDragging(_ scrollView: UIScrollView) &#123; isDragging = true&#125; 这可能看起来有点多余，因为UITableView已经有一个属性来跟踪它当前是否被拖动，但现在要自己做一些自定义跟踪。 接下来继续实现UISearchBarDelegate协议的另一个方法，用来跟踪用户的进度： 12345678910func scrollViewDidScroll(_ scrollView: UIScrollView) &#123; guard isDragging else &#123; return &#125; if !isPresentingSettings &amp;&amp; scrollView.contentOffset.y &lt; -30 &#123; isPresentingSettings = true presentTransition.wantsInteractiveStart = true presentSettings() return &#125;&#125; 接下来，需要添加代码以交互方式更新。 将以下内容追加到上面方法的末尾： 1234if isPresentingSettings &#123; let progess = max(0.0, min(1.0, ((-scrollView.contentOffset.y) - 30) / 90.0)) presentTransition.update(progess)&#125; 根据拉出TableView的距离计算0.0到1.0范围内的进度，并在转场动画师上调用update(_:)以将动画定位到当前进度。运行，当向下拖动时，将看到表格视图逐渐模糊。 还需要注意完成取消转场，实现UISearchBarDelegate协议的另一个方法： 123456789101112func scrollViewWillEndDragging(_ scrollView: UIScrollView, withVelocity velocity: CGPoint, targetContentOffset: UnsafeMutablePointer&lt;CGPoint&gt;) &#123; let progress = max(0.0, min(1.0, ((-scrollView.contentOffset.y) - 30) / 90.0)) if progress &gt; 0.5 &#123; presentTransition.finish() &#125; else &#123; presentTransition.cancel() &#125; isPresentingSettings = false isDragging = false&#125; 这段代码看起来与19-交互式导航控制器转场中相似。如果用户下拉已经超过距离的一半，则认为转场成功；如果用户未下拉超过一半，则取消转场。 把transitionAnimator(using:)方法中的addCompletion代码块替换为： 12345678animator.addCompletion &#123; (position) in switch position &#123; case .end: transitionContext.completeTransition(!transitionContext.transitionWasCancelled) default: transitionContext.completeTransition(false) &#125;&#125; 运行，上下拉动，可能会出现下面这种像素化问题情况（iOS10可能会出现，iOS11之后应该修复了）： 使用之前在PresentTransition中添加的auxAnimationsCancel属性。在transitionAnimator(using:)中找到animator.addCompletion的调用，并在default:添加： 1self.auxAnimationsCancel?() 到LockScreenViewController的presentSettings(_:)方法。在设置auxAnimations属性后，添加： 1presentTransition.auxAnimationsCancel = blurAnimations(false) 运行，像素化问题应该已经消失。 但是还有另一个问题。点击Edit按钮的非交互式转场没反应了！😱 只要用户点击Edit按钮，就需要更改代码以将视图控制器转场设置为非交互式。 到LockScreenViewController的tableView(_:cellForRowAt:)，在self.presentSettings()之前插入： 1self.presentTransition.wantsInteractiveStart = false 运行，效果: 可中断的转场动画接下来，要考虑转场期间在非交互模式和交互模式之间切换。 在这一部分，将实现点击Edit按钮后开始执行显示设置控制器的动画，但如果用户在动画期间再次点击屏幕，则暂停转场。 切换到PresentTranstion.swift。需要稍微改变动画师，不仅要分别处理交互式和非交互式模式，还要同时处理相同的过渡。在PresentTranstion中再添加两个属性： 12var context: UIViewControllerContextTransitioning?var animator: UIViewPropertyAnimator? 使用这两个属性来跟踪动画的上下文以及动画师。在transitionAnimator(using:)方法的return animator前插入： 12self.animator = animatorself.context = transitionContext 每次为转场创建新的动画师时，也会存储对它的引用。 转场完成后释放这些资源也很重要。 继续添加： 1234animator.addCompletion &#123; [unowned self] _ in self.animator = nil self.context = nil&#125; 在PresentTranstion中再添加一个方法： 12345func interruptTransition() &#123; guard let context = context else &#123; return &#125; context.pauseInteractiveTransition() pause()&#125; 在transitionAnimator(using:)方法的return animator前插入： 1animator.isUserInteractionEnabled = true 确保转场动画是交互式的，这样用户可以在暂停后继续与屏幕进行交互。 允许用户向上或向下滚动以分别完成或取消转场。 为此，在LockScreenViewController中添加一个新属性： 1var touchesStartPointY: CGFloat? 如果用户在转场期间触摸屏幕，可以将其暂停并存储第一次触摸的位置： 12345678override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; guard presentTransition.wantsInteractiveStart == false, presentTransition.animator != nil else &#123; return &#125; touchesStartPointY = touches.first!.location(in: view).y presentTransition.interruptTransition()&#125; 跟踪用户触摸并查看用户是向上还是向下平移，添加： 12345678910111213141516 override func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; guard let startY = touchesStartPointY else &#123; return &#125; let currentPoint = touches.first!.location(in: view).y if currentPoint &lt; startY - 40 &#123; touchesStartPointY = nil presentTransition.animator?.addCompletion(&#123; (_) in self.blurView.effect = nil &#125;) presentTransition.cancel() &#125; else if currentPoint &gt; startY + 40 &#123; touchesStartPointY = nil presentTransition.finish() &#125;&#125; 运行，点击Edit按钮后，立即点击屏幕，这个时候转场会暂停，此时向下滑动会完成转场，向上滑动会取消转场，效果如下：]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
        <tag>UIViewPropertyAnimator</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-堆]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%A0%86.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。 Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。 🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。 本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Heap 堆(Heap) 这个话题已经有个辅导文章 堆是数组内的二叉树，因此它不使用父/子指针。 堆基于“堆属性”进行排序，“堆属性”确定树中节点的顺序。 堆的一般用途： 构建优先队列。 支持堆排序。 快速计算集合中最大（或最小）值。 给你的非程序员朋友留下深刻影响。 堆属性有两种堆：max-heap 和 min-heap，它们存储树节点的顺序不同。 在max-heap中，每个父节点的值大于其子节点。 在min-heap中，每个父节点的值都小于其子节点。 这称为“堆属性”，对于树中的每个节点都是如此。 一个例子： 这是一个max-heap，因为每个父节点都大于其子节点。 (10)大于(7)和(2)。 (7)大于(5)和(1)。 堆属性的结果是，max-heap始终将其最大项存储在树的根节点中。 对于min-heap，根节点始终是树中的最小项。 堆属性很有用，因为堆通常用作优先队列来快速访问“最重要的”（译注：最大或最小）元素。 注意： 堆的根节点是最大或最小元素，但其他元素的排序顺序是不可预测的。例如，最大元素始终位于max-heap中的索引0处，但最小元素不一定是最后一个元素。 —— 唯一的保证是，最小元素是叶节点之一，但不知道是哪一个。 堆与常规树对比堆不是二叉搜索树的替代品，它们之间存在相似之处和不同之处。 以下是一些主要差异： 节点的顺序。在二叉搜索树（BST）中，左子节点必须小于其父节点，右子节点必须更大。 堆不是这样。 在max-heap中，两个子节点必须小于父节点，而在min-heap中，子节点必须大于父节点。 内存。传统的树比它们存储的数据占用更多的内存。 需要为节点对象和指向左/右子节点的指针分配额外的存储空间。 堆只使用普通数组进行存储，不使用指针。 平衡。 二叉搜索树（BST）必须“平衡”，以便大多数操作具有O(log n)性能。 您可以按随机顺序插入和删除数据，也可以使用AVL树或红黑树，但 我们实际上并不需要对整个树进行排序。 我们只是希望实现堆属性，因此平衡不是问题。 由于堆的结构方式，堆可以保证 O(log n) 的性能。 搜索。 虽然在二叉树中搜索速度很快，但在堆中搜索速度很慢。 搜索不是堆中的最高优先级，因为堆的目的是将最大（或最小）节点放在前面并允许相对快速的插入和删除。 数组中的树用数组实现树状结构似乎比较奇怪，但它在时间和空间上都很高效的。 上面例子中的树用数组存储为： [ 10, 7, 2, 5, 1 ] 这里的所有了！ 我们不需要比这个简单数组更多的存储空间了。 那么，如果不允许使用任何指针，我们如何知道哪些节点是父节点，哪些节点是子节点？ 好问题！树节点的数组索引与其父节点和子节点的数组索引之间存在明确定义的关系。 如果i是节点的索引，则以下公式给出其父节点和子节点的数组索引： parent(i) = floor((i - 1)/2) left(i) = 2i + 1 right(i) = 2i + 2 注意right(i)只是left(i)+ 1。 左侧和右侧子节点始终紧挨着存储。 对上面的例子使用这些公式。 填写数组索引，我们应该得到数组中父节点和子节点的位置： 节点 数组中的索引(i) 父节点索引 左子节点索引 右子节点索引 10 0 -1 1 2 7 1 0 3 4 2 2 0 5 6 5 3 1 7 8 1 4 1 9 10 验证这些数组索引确实对应于上面树的图片。 注意： 根节点(10)没有父节点，因为-1不是有效的数组索引。 同样，节点(2)，(5)和(1)没有子节点，因为那些索引大于数组大小，所以用它们之前我们总是要确保我们计算的索引实际上是有效的。 回想一下，在max-heap中，父节点的值总是大于（或等于）其子节点的值。 这意味着对于所有数组索引i必须满足以下条件： 1array[parent(i)] &gt;= array[i] 验证此堆属性是否适用于示例堆中的数组。 如您所见，这些等式允许我们在不需要指针的情况下找到任何节点的父索引或子索引。 这样消除了使用指针的复杂，这是一种权衡：我们节省了内存空间，但需要额外的计算。 幸运的是，计算速度很快，只需要 O(1) 时间。 理解树中数组索引和位置之间的这种关系很重要。 下面👇是一个更大的堆，有15个节点分为四个级别： 此图片中的数字不是节点的值，而是存储节点的数组索引！ 下面👇是数组索引对应树的不同级别： 要使公式起作用，父节点必须出现在数组中的子节点之前。 你可以在上面的图片中看到。 请注意，此方案有局限性。 您可以使用常规二叉树执行以下操作，但不能使用堆执行以下操作： 除非当前最低级别已满，否则无法开启新级别，因此堆总是具有这种形状： 注意： 您可以使用堆模拟常规二叉树，但这会浪费空间，您需要将一些数组索引标记为空。 突击测验！ 假设我们有数组： [ 10, 14, 25, 33, 81, 82, 99 ] 这是一个有效的堆吗？ 答案是肯定的！ 从低到高的排序数组是有效的min-heap。 我们可以按如下方式绘制这个堆： 堆属性适用于每个节点，因为父节点始终小于其子节点。 （自己验证从高到低排序的数组始终是有效的max-heap。） 注意：但并非每个min-heap都必须是一个排序数组！ 排序数组只是一种特殊情况。 要将堆重新转换为已排序的数组，需要使用堆排序。 更多数学！如果你很好奇，这里有一些描述堆的某些属性的公式。 你不需要知道这些，但它们有时会派上用场。 可以跳过此部分！ 树的height定义为从根节点到最低叶节点所需的步数，或者更正式：height是节点之间的最大边数。 高度h的堆具有h + 1级别。 这个堆的高度为3，所以它有4个级别： 具有n个节点的堆具有高度h = floor(log2(n))。 这是因为我们总是在添加新级别之前完全填满最低级别。 该示例有15个节点，因此高度为 floor(log2(15)) = floor(3.91) = 3。 如果最低级别已满，则该级别包含 2^h 个节点。 它上面的树的其余部分包含 2^h - 1 个节点。 上面示例就是：最低级别有8个节点，实际上是 2^3 = 8 。 前三个级别包含总共7个节点，即2^3 - 1 = 8 - 1 = 7。 因此，整个堆中的节点总数n 为 2^(h+1) - 1。 在示例中，2^4 - 1 = 16 - 1 = 15。 在n个元素堆中，高度为h的最多有 ceil(n/2^(h+1)) 个的节点。（译注：示例中h为0时，ceil(15/2^(0+1)) = 8，h为1时,ceil(15/2^(1+1)) = 4） 叶节点总是位于数组索引 floor(n/2) 到 n-1。(译注： 7 ~ 14) 我们将利用这一事实从数组中快速构建堆。 如果您不相信，请验证此示例。;-) 只是一些数学就能照亮你的一天。☀️ 你能用堆做什么？在插入或删除元素之后，有两个必要的原始操作来确保堆是有效的max-heap或min-heap： shiftUp()：如果元素比其父元素更大（max-heap）或更小（min-heap），则需要与父元素交换， 这使元素向上移动。 shiftDown()。 如果元素比子元素小（max-heap）或更大（min-heap），这个操作使元素向下移动，也称为“堆化(heapify)”。 向上或向下移动是一个递归过程，需要O(log n)时间。 以下是基于原始操作的其他操作： insert(value)：将新元素添加到堆的末尾，然后使用shiftUp()来修复堆。 remove()：删除并返回最大值(max-heap）或最小值(min-heap）。为了填充元素删除后留下的位置，让最后一个元素移动到根位置，然后使用shiftDown()修复堆。 (有时称为“提取最小值”或“提取最大值”。） removeAtIndex(index)：类似remove()，不仅可以删除根节点，也可以从堆中删除任何节点。如果新元素与其子元素不规整，则调用shiftDown();如果元素与其父元素不规整，则调用shiftUp()。 replace(index, value)：为节点分配一个较小(min-heap）或较大(max-heap）的值。因为这会使堆属性失效，所以它使用shiftUp()来修复。 (也称为“减少键”和“增加键”。） 以上所有操作都需要时间O(log n)因为向上或向下移动是昂贵的。还有一些操作需要更多时间： search(value)。堆不是为高效搜索而构建的，但replace()和removeAtIndex()操作需要节点的数组索引，因此您需要找到该索引。时间：O(n)。 buildHeap(array)：通过重复调用insert()将数组(未排序的）转换为堆。如果您对此很聪明，可以在O(n)时间内完成。 堆排序。由于堆是一个数组，我们可以使用它的唯一属性将数组从低到高排序。时间：O(n lg n)。 堆还有一个peek()函数，它返回最大(max-heap）或最小(min-heap）元素，而不从堆中删除它。时间：O(1)。 注意： 到目前为止，您将使用堆执行的最常见操作是使用insert()插入新值，并使用remove()删除最大值或最小值。 两者都需要O(log n)时间。 其他操作用来支持更高级的使用，例如构建优先队列，其中项目的“重要性”在添加到队列后可以改变。 向堆中插入元素我们来看一个插入示例，详细了解其工作原理。 我们将值16插入此堆： 这个堆的数组是[10, 7, 2, 5, 1]。 插入新项目的第一步是将其附加到数组的末尾。 该数组变为： [ 10, 7, 2, 5, 1, 16 ] 树结构如下： (16)被添加到最后一行的第一个可用空间。 不幸的是，堆属性不再满足，因为(2)高于(16)，我们希望更高的数字高于低的数字。 (这是max-heap。) 要恢复堆属性，我们交换(16)和(2)。 我们还没有完成，因为(10)也小于(16)。 我们继续将其插入值与其父项交换，直到父项更大或到达树的顶部。 这称为shift-up 或 sifting ，并在每次插入后完成。 它会使一个太大或太小的数字“浮起”树。 最后，我们得到： 现在每个父节点都比其子节点更大了。 上移所需的时间与树的高度成正比，需要O(log n)时间。（将节点附加到数组末尾所需的时间仅为O(1)，因此不会降低它的速度。） 删除根节点从树中移除(10)： 顶部的空白怎么办？ 插入时，我们将新值放在数组的末尾。 在这里，我们做相反的事情：我们采用我们拥有的最后一个对象，将其直接移动到树的顶部，然后恢复堆属性。 让我们来看看如何shift-down(1)。 要维护此max-heap的堆属性，我们希望顶部为最大数。 我们有两个交换位置的候选者：(7)和(2)。 选择这三个节点之间的最高数字位于顶部，那是(7)，所以交换(1)和(7)，得到下面👇的树： 继续向下移动，直到节点没有任何子节点，或者它比两个子节点都大。 对于这个堆，只需要一个交换来恢复堆属性： 完全向下移动所需的时间与树的高度成正比，这需要O(log n)时间。 注意： shiftUp()和shiftDown()一次只能修复一个异常元素。 如果错误的位置有多个元素，则需要为每个元素调用一次这些函数。 删除任意节点绝大多数情况下，将删除的是堆根节点，因为这是堆设计的目的。 但是，删除任意元素可能很有用。 这是remove()的一般版本，可能涉及shiftDown()或shiftUp()。 让我们再次采用前面的示例树，删除(7)： 提醒一下，数组是： [ 10, 7, 2, 5, 1 ] 如您所知，删除元素可能会使max-heap或min-heap属性失效。 要解决这个问题，我们将要移除的节点与最后一个元素交换： [ 10, 1, 2, 5, 7 ] 最后一个元素是我们将返回的元素; 我们将调用removeLast()将其从堆中删除。 (1)现在是乱序的，因为它小于它的子节点，(5)是在树中应该更高。 我们调用shiftDown()来修复它。 但是，向下移动并不是我们需要处理的唯一情况。 也可能发生新元素必须向上移动。 考虑如果从以下堆中删除(5)会发生什么： 译注：这个的树对应的数组是[10, 7, 9, 5, 1, 2, 8]。 现在(5)与(8)交换。 因为(8)比它的父节点((7))大，我们需要调用shiftUp()。 用数组创建堆将数组转换为堆可以很方便。 只是对数组元素进行洗牌，直到满足堆属性。 在代码中它看起来像这样： 12345private mutating func buildHeap(fromArray array: [T]) &#123; for value in array &#123; insert(value) &#125;&#125; 我们只要为数组中的每个值调用insert()。 简单但不是很高效。 这总共需要O(n log n)时间，因为有n个元素，每个插入需要log n时间。 如果你没有跳过前面数学部分，你已经看到，对于任何堆，数组索引n / 2到n-1的元素都是树的叶节点。 我们可以简单地跳过那些叶子。 我们只需要处理其他节点，因为它们是有一个或多个子节点的父节点，因此可能是错误的顺序。 代码: 123456private mutating func buildHeap(fromArray array: [T]) &#123; elements = array for i in stride(from: (nodes.count/2-1), through: 0, by: -1) &#123; shiftDown(index: i, heapSize: elements.count) &#125;&#125; 这里，elements是堆自己的数组。 我们从第一个非叶节点开始向后遍历这个数组，并调用shiftDown()。 这个简单的循环以正确的顺序放置这些节点以及我们跳过的叶节点。 这被称为Floyd算法，只需要O(n)时间。 ✌️ 搜索堆堆不能用于快速搜索，但如果要使用removeAtIndex()删除任意元素或使用replace()更改元素的值，则需要获取该元素的索引。搜索堆速度很慢。 在二叉搜索树中，根据节点的顺序，可以保证快速搜索。 由于堆以不同方式对其节点进行排序，因此二叉搜索不起作用，您需要检查树中的每个节点。 再给出上面堆示例： 如果我们想要搜索节点(1)的索引，我们可以通过线性搜索分步搜索数组[10, 7, 2, 5, 1]。 即使堆属性没有考虑到搜索，我们仍然可以利用它。 我们知道在max-heap中父节点总是比它的子节点大，所以如果父节点已经小于我们要查找的值，我们可以忽略那些子节点(及其子节点等等）。 假设我们想要查看堆是否包含值8(没有包含)。 我们从根(10)开始。 这不是我们想要的，所以我们递归地看看它的左右子节点。 左边的孩子是(7)。 这也不是我们想要的，但由于这是一个max-heap，我们知道查看(7)的子节点是没有意义的，它们总是小于7，因此左侧不会找到8。 同样，对于右节点，(2)，也找不到。 尽管有一点优化，搜索仍然是O(n)操作。 注意： 有一种方法可以通过保留一个将节点值映射到索引的附加字典来将查找转换为O(1)操作。 如果你经常需要调用replace()来改变构建在堆上的优先队列中对象的“优先级”，这可能是值得做的。 代码有关用Swift代码实现，请参见Heap.swift。 大多数代码都很简单。 唯一棘手的是shiftUp()和shiftDown()。 您已经知道有两种类型的堆：max-heap和min-heap。 它们之间的唯一区别在于它们如何对节点进行排序：首先是最大值或最小值。 不是创建两个不同的版本，MaxHeap和MinHeap，而只有一个Heap对象，它需要一个isOrderedBefore闭包。 此闭包包含确定两个值的顺序的逻辑。 你之前可能已经看过了，因为它也是Swift的sort()的工作原理。 要创建一个max-heap整数堆： 1var maxHeap = Heap&lt;Int&gt;(sort: &gt;) 要创建一个min-heap整数堆： 1var minHeap = Heap&lt;Int&gt;(sort: &lt;) I just wanted to point this out, because where most heap implementations use the &lt; and &gt; operators to compare values, this one uses the isOrderedBefore() closure.我只想指出这一点，因为大多数堆实现使用&lt;和&gt;运算符来比较值，这个使用isOrderedBefore()闭包。 扩展阅读Heap的维基百科 作者：Kevin Randrup， Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>堆</tag>
        <tag>Heap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-双端队列]]></title>
    <url>%2F2019%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Deque 双端队列(Deque) 出于某种原因，双端队列也被称为“deck”。 常规队列元素在后面添加（入队），从前面删除（出队）。 除了这些，双端队列还可以在后面出队，从前面入队，并且两端都可查看。 Swift中双端队列的一个非常基本的实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243public struct Deque&lt;T&gt; &#123; private var array = [T]() public var isEmpty: Bool &#123; return array.isEmpty &#125; public var count: Int &#123; return array.count &#125; public mutating func enqueue(_ element: T) &#123; array.append(element) &#125; public mutating func enqueueFront(_ element: T) &#123; array.insert(element, atIndex: 0) &#125; public mutating func dequeue() -&gt; T? &#123; if isEmpty &#123; return nil &#125; else &#123; return array.removeFirst() &#125; &#125; public mutating func dequeueBack() -&gt; T? &#123; if isEmpty &#123; return nil &#125; else &#123; return array.removeLast() &#125; &#125; public func peekFront() -&gt; T? &#123; return array.first &#125; public func peekBack() -&gt; T? &#123; return array.last &#125;&#125; 这个实现的内部使用数组。 入队和出列只是在数组的前面或后面，添加或删除元素。 在 playground 中使用： 1234567891011var deque = Deque&lt;Int&gt;()deque.enqueue(1)deque.enqueue(2)deque.enqueue(3)deque.enqueue(4)deque.dequeue() // 1deque.dequeueBack() // 4deque.enqueueFront(5)deque.dequeue() // 5 Deque的这种实现很简单但效率不高。几个操作是 O(n)，特别是enqueueFront()和dequeue()。这个实现只是为了说明双端队列的作用原理。 更高效的版本dequeue()和enqueueFront()的时间复杂度是O(n)，原因是它们在数组的前面（开始）工作。如果删除数组前面的元素，那么所有剩余的元素都需要在内存中移位。 假设双端队列的数组包含以下元素： [ 1, 2, 3, 4 ] 然后dequeue()将从数组中删除1，元素2，3和4将向前移动一个位置： [ 2, 3, 4 ] 这是一个O(n)操作，因为所有数组元素都需要在内存中移动一个位置。 同样，在数组的前面插入一个元素也是昂贵的，因为它要求所有其他元素必须向后移动一个位置。 因此enqueueFront(5)会将数组更改为： [ 5, 2, 3, 4 ] 首先，将元素2，3和4在内存中向后移动一个位置，然后将新元素5插入到曾经是2的位置。 为什么enqueue()和dequeueBack()没有这样的问题？好吧，这些操作是在数组末尾操作的。在Swift中数组默认都是可调整大小的，它的实现方式是，在数组后面预留一定量的可用空间。 我们的初始数组[1, 2, 3, 4]实际上在内存中看起来像这样： [ 1, 2, 3, 4, x, x, x ] 其中x表示数组中尚未使用的空间。 调用enqueue(6)只是将新元素复制到下一个未使用的空间： [ 1, 2, 3, 4, 6, x, x ] dequeueBack()函数使用array.removeLast()删除元素。这不会缩小数组的内存，只会将array.count减1。这里没有涉及昂贵的内存拷贝。因此在数组末尾的操作很快，复杂度是O(1)。 数组可能会用尽末尾预留的未使用空间。 在这种情况下，Swift将分配一个新的更大的数组，并复制所有数据。这是一个O(n)操作，但因为它只是偶尔发生一次，所以在数组末尾添加新元素的平均值仍然是O(1)。 当然，我们可以在数组的开头使用相同的技巧。 这将使我们的双端队列在 开头 的操作也高效。 我们的数组将如下所示： [ x, x, x, 1, 2, 3, 4, x, x, x ] 现在在数组的开头还有一大块可用空间，这样，在数组前面添加或删除元素的操作也是O(1)。 这是Deque的新版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public struct Deque&lt;T&gt; &#123; private var array: [T?] private var head: Int private var capacity: Int private let originalCapacity:Int public init(_ capacity: Int = 10) &#123; self.capacity = max(capacity, 1) originalCapacity = self.capacity array = [T?](repeating: nil, count: capacity) head = capacity &#125; public var isEmpty: Bool &#123; return count == 0 &#125; public var count: Int &#123; return array.count - head &#125; public mutating func enqueue(_ element: T) &#123; array.append(element) &#125; public mutating func enqueueFront(_ element: T) &#123; // this is explained below &#125; public mutating func dequeue() -&gt; T? &#123; // this is explained below &#125; public mutating func dequeueBack() -&gt; T? &#123; if isEmpty &#123; return nil &#125; else &#123; return array.removeLast() &#125; &#125; public func peekFront() -&gt; T? &#123; if isEmpty &#123; return nil &#125; else &#123; return array[head] &#125; &#125; public func peekBack() -&gt; T? &#123; if isEmpty &#123; return nil &#125; else &#123; return array.last! &#125; &#125; &#125; 这看起来与之前的代码基本相同 —— enqueue() 和 dequeueBack() 没有改变 —— 但也有一些重要的区别。 数组现在存储类型为T？的对象而不是T，因为我们数组元素可能会被标记为空。 init方法分配一个包含一定数量的nil值的新数组。 在数组开头处添加了空白空间，默认情况下，会创建10个空白空间。 head是数组中最前面对象的索引。 由于队列当前是空的，head指向数组末尾后面的索引。 [ x, x, x, x, x, x, x, x, x, x ] | head 为了将对象放在前面，我们将head向左移动一个位置，然后将新对象复制到索引head处。 例如，enqueueFront(5)结果： [ x, x, x, x, x, x, x, x, x, 5 ] | head enqueueFront(7)的结果: [ x, x, x, x, x, x, x, x, 7, 5 ] | head 等等……head继续向左移动并始终指向队列中的第一个元素。enqueueFront()现在的操作是O(1)，因为它只涉及将元素复制到数组中，这是一个恒定时间操作。 代码： 1234public mutating func enqueueFront(element: T) &#123; head -= 1 array[head] = element&#125; 向队列后面添加元素方式没有改变（与之前的代码完全相同）。 例如，enqueue(1)结果： [ x, x, x, x, x, x, x, x, 7, 5, 1, x, x, x, x, x, x, x, x, x ] | head 如果您将另一个对象入队，它将被添加到后面的下一个空白空间。 例如，enqueue(2)： [ x, x, x, x, x, x, x, x, 7, 5, 1, 2, x, x, x, x, x, x, x, x ] | head 注意： 当你print(deque.array)时，你不会在数组后面看到那些空白空间。 这是因为Swift会将它们隐藏起来。 只显示数组前面的空白空间。 dequeue()方法与enqueueFront()是相反操作，它读取head处的元素，将设置为nil，然后将head移动到右边的一个位置： 12345678public mutating func dequeue() -&gt; T? &#123; guard head &lt; array.count, let element = array[head] else &#123; return nil &#125; array[head] = nil head += 1 return element&#125; 有一个很小的问题……如果在前面添加了很多对象，会在某些时候用尽前面的空白空间。 当这发生在数组的后面时，Swift会自动调整它的大小。 但是在数组的前面我们必须自己处理这种情况，在enqueueFront()中有一些额外的逻辑： 1234567891011public mutating func enqueueFront(element: T) &#123; if head == 0 &#123; capacity *= 2 let emptySpace = [T?](repeating: nil, count: capacity) array.insert(contentsOf: emptySpace, at: 0) head = capacity &#125; head -= 1 array[head] = element&#125; 如果head等于0，则前面没有剩余空间。 当发生这种情况时，我们在数组中添加了一大堆新的nil元素。 这是一个O(n)操作，但由于这个操作不是在每次enqueueFront()调用时都会发生，所以每次对enqueueFront()单独调用的时间复杂度，仍然可以认为是O(1)。 注意： 每次发生这种情况时，我们会将容量乘以2，因此如果您的队列会越来越大，调整大小的次数也就越少。 这也是Swift数组在后面自动执行的操作方式。 我们必须为dequeue()做类似的事情。 如果你大部分时间将很多元素从前面入队，并且大多数时候也从前面出队，那么你最终可能会得到一个如下所示的数组： [ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, 1, 2, 3 ] | head 当你调用enqueueFront()时，只会使用前面的空白空间。 但是如果在前面入队的操作很少发生，那么就会有很多闲置的空白空间。 所以让我们在dequeue()中添加一些代码来清理它： 1234567891011121314public mutating func dequeue() -&gt; T? &#123; guard head &lt; array.count, let element = array[head] else &#123; return nil &#125; array[head] = nil head += 1 if capacity &gt;= originalCapacity &amp;&amp; head &gt;= capacity*2 &#123; let amountToRemove = capacity + capacity/2 array.removeFirst(amountToRemove) head -= amountToRemove capacity /= 2 &#125; return element&#125; 回想一下capacity是队列前面的空白空间的原始数量。 如果head向右移动的次数超过了容量的两倍(译注：head &gt;= capacity*2)，那么就该修剪掉这些空白空间了。 我们将它降低到约25%。 注意： 通过将capacity与originalCapacity进行比较，双端队列将至少保持其原始容量。 例如： [ x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, 1, 2, 3 ] | | capacity head 修剪后： [ x, x, x, x, x, 1, 2, 3 ] | head capacity 通过这种方式，我们可以在前面的快速入队、出队与保持合理的内存空间之间取得平衡。 注意： 我们不对非常小的数组执行修剪，仅保存几个字节的内存是没有必要的。 扩展阅读其它可以实现双端队列的方法：双向链表，环形缓冲区，或方法相反的两个栈。 双端队列功能齐全的Swift实现 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>双端队列</tag>
        <tag>Deque</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-有序数组]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Ordered Array 有序数组(Ordered Array) 这是一个始终从低到高排序的数组。 每当您向此数组添加新元素时，它都会插入到其排序位置。 当您希望对数据进行排序并且相对较少地插入新元素时，有序数组非常有用。在这种情况下，它比排序整个数组更快。但是，如果您需要经常更改数组，则使用常规数组并手动对其进行排序可能会更快。 实现是非常基础的。 它只是Swift内置数组的包装器： 123456789101112131415161718192021222324252627282930313233public struct OrderedArray&lt;T: Comparable&gt; &#123; fileprivate var array = [T]() public init(array: [T]) &#123; self.array = array.sorted() &#125; public var isEmpty: Bool &#123; return array.isEmpty &#125; public var count: Int &#123; return array.count &#125; public subscript(index: Int) -&gt; T &#123; return array[index] &#125; public mutating func removeAtIndex(index: Int) -&gt; T &#123; return array.remove(at: index) &#125; public mutating func removeAll() &#123; array.removeAll() &#125;&#125;extension OrderedArray: CustomStringConvertible &#123; public var description: String &#123; return array.description &#125;&#125; 如您所见，所有这些方法只是在内部array变量上调用相应的方法。 剩下的是insert()函数。 这是对它的初步尝试： 1234567891011121314public mutating func insert(_ newElement: T) -&gt; Int &#123; let i = findInsertionPoint(newElement) array.insert(newElement, at: i) return i&#125;private func findInsertionPoint(_ newElement: T) -&gt; Int &#123; for i in 0..&lt;array.count &#123; if newElement &lt;= array[i] &#123; return i &#125; &#125; return array.count // insert at the end&#125; 辅助函数findInsertionPoint()只是遍历整个数组，寻找插入新元素的正确位置。 注意： array.insert(... atIndex: array.count) 将新对象添加到数组的末尾，所以如果没有找到合适的插入点，我们可以简单地返回array.count作为索引。 在playground中测试： 123456789var a = OrderedArray&lt;Int&gt;(array: [5, 1, 3, 9, 7, -1])a // [-1, 1, 3, 5, 7, 9]a.insert(4) // inserted at index 3a // [-1, 1, 3, 4, 5, 7, 9]a.insert(-2) // inserted at index 0a.insert(10) // inserted at index 8a // [-2, -1, 1, 3, 4, 5, 7, 9, 10] 数组的内容将始终从低到高排序。 不幸的是，当前的findInsertionPoint()函数有点慢。 在最坏的情况下，它需要扫描整个数组。 我们可以通过使用二分搜索查找插入点来加快速度。 新的版本： 12345678910111213141516private func findInsertionPoint(_ newElement: T) -&gt; Int &#123; var startIndex = 0 var endIndex = array.count while startIndex &lt; endIndex &#123; let midIndex = startIndex + (endIndex - startIndex) / 2 if array[midIndex] == newElement &#123; return midIndex &#125; else if array[midIndex] &lt; newElement &#123; startIndex = midIndex + 1 &#125; else &#123; endIndex = midIndex &#125; &#125; return startIndex&#125; 与常规二分搜索的最大区别在于，当找不到值时，不会返回nil，而是返回元素本身所在的数组索引。 这就是我们插入新对象的地方。 请注意，使用二分搜索不会改变insert()的最坏情况运行时复杂性。二分搜索本身只需要O(log n)时间，但在数组中间插入一个新对象仍然需要移动内存中的所有剩余元素。 总的来说，时间复杂度仍然是O(n)。但实际上这个新版本肯定要快得多，特别是在大型数组上。 更完整的代码可以查看Ole Begemann的排序数组。 对应的文章解释了优势和权衡。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>有序数组</tag>
        <tag>Ordered Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-固定大小数组]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%9B%BA%E5%AE%9A%E5%A4%A7%E5%B0%8F%E6%95%B0%E7%BB%84.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Fixed-Size Arrays 固定大小数组(Fixed-Size Arrays) 早期的编程语言没有非常奇特的数组。 您将创建具有固定大小的数组，从那时起它将永远不会增长或缩小。 甚至C和Objective-C中的标准数组仍然是这种类型。 当您定义这样的数组时， int myArray[10]; 编译器分配一个可以容纳40个字节的连续内存块（假设int是4个字节）： 那就是你的数组。 它总是这么大。 如果你需要超过10个元素，那你就不幸了……没有空间。 要获得一个在装满时增容的数组，你需要使用动态数组对象，比如在Objective-C中的NSMutableArray或在C ++中的std::vector。当然，像Swift这样的语言，其数组本身可以根据需要增加容量。 旧式数组的一个主要缺点是它们空间需求太大或者空间不足。 如果它们太大你就会浪费内存。 并且您需要注意由于缓冲区溢出导致的安全漏洞和崩溃。 总之，固定大小数组不灵活，但不会留下错误。 也就是说，我喜欢固定大小的数组因为它们简单，快速且可预测。 以下典型的数组操作： 在最后附加一个新元素 在开头或中间某处插入一个新元素 删除元素 按索引查找元素 计算数组的大小 对于固定大小的数组，只要数组尚未满，则添加很容易： 按索引查找也很简单： 这两个操作复杂度是O(1)，这意味着执行它们所花费的时间与数组的大小无关。 对于可以增长的数组，关于添加：如果数组已满，则必须分配新内存并将旧内容复制到新的内存缓冲区。 平均而言，添加仍然是O(1)操作，但是在之后发生的事情是不太可预测的。 昂贵的操作是插入和删除。 当你在一个不在末尾的某个地方插入一个元素时，它需要将数组的其余部分往后移动一个位置。 这涉及相对昂贵的内存复制操作。 例如，在数组的中间插入值7： 如果您的代码使用的索引超过了插入点，但这些索引现在引用了错误的对象。 删除需要相反的操作： 顺便说一下，对于NSMutableArray或Swift数组也是如此。 插入和删除是O(n)操作 —— 数组越大，所需的时间越长。 固定大小数组是一个很好的解决方案： 您事先知道您需要的最大元素数量。 在游戏中，这可能是一次可以激活的精灵数量。 对此加以限制并非没有道理。 （对于游戏，最好事先分配你需要的所有对象。） 数组没有必要排序，即元素的顺序无关紧要。 如果数组不需要排序，则不需要insertAt(index)操作。 您可以简单地将任何新元素附加到末尾，直到数组已满。 添加元素的代码变为： 123456func append(_ newElement: T) &#123; if count &lt; maxSize &#123; array[count] = newElement count += 1 &#125;&#125; count变量跟踪数组的大小，可以认为是最后一个元素之后的索引。 这也就是您将插入新元素的索引。 确定数组中元素的数量只是读取count变量，O(1)操作。 删除元素的代码同样简单： 1234func removeAt(index: Int) &#123; count -= 1 array[index] = array[count]&#125; 这会将最后一个元素复制到删除的元素的位置，然后减小数组的大小。 这就是数组不排序的原因。 为了避免昂贵的数组复制，我们只复制一个元素，但这确实改变了元素的顺序。 现在在数组中有两个元素6的副本，但之前的最后一个元素不再是活动数组的一部分。 它只是垃圾数据 —— 下次添加新元素时，这个旧的6将被覆盖。 在这两个约束条件下 —— 元素数量和不排序数组的限制 —— 固定大小的数组仍然非常适合在现代软件中使用。 这是Swift中的一个实现： 1234567891011121314151617181920212223242526272829303132333435363738394041struct FixedSizeArray&lt;T&gt; &#123; private var maxSize: Int private var defaultValue: T private var array: [T] private (set) var count = 0 init(maxSize: Int, defaultValue: T) &#123; self.maxSize = maxSize self.defaultValue = defaultValue self.array = [T](repeating: defaultValue, count: maxSize) &#125; subscript(index: Int) -&gt; T &#123; assert(index &gt;= 0) assert(index &lt; count) return array[index] &#125; mutating func append(_ newElement: T) &#123; assert(count &lt; maxSize) array[count] = newElement count += 1 &#125; mutating func removeAt(index: Int) -&gt; T &#123; assert(index &gt;= 0) assert(index &lt; count) count -= 1 let result = array[index] array[index] = array[count] array[count] = defaultValue return result &#125; mutating func removeAll() &#123; for i in 0..&lt;count &#123; array[i] = defaultValue &#125; count = 0 &#125;&#125; 创建数组时，指定最大大小和默认值： 1var a = FixedSizeArray(maxSize: 10, defaultValue: 0) 注意removeAt(index: Int)用这个defaultValue覆盖最后一个元素来清理留下的“垃圾”对象。 通常将重复的对象留在数组中并不重要，但是如果它是一个类或结构，它可能具有对其他对象的强引用，将这些对象归零是很好的做法。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>固定大小数组</tag>
        <tag>Fixed-Size Arrays</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-快速排序]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Quicksort 快速排序(Quicksort) 目标：将数组从低到高（或从高到低）排序。 快速排序是历史上最着名的算法之一。 它是由Tony Hoare于1959年发明的，当时递归仍然是一个相当模糊的概念。 这是Swift中的一个实现，应该很容易理解： 12345678910func quicksort&lt;T: Comparable&gt;(_ a: [T]) -&gt; [T] &#123; guard a.count &gt; 1 else &#123; return a &#125; let pivot = a[a.count/2] let less = a.filter &#123; $0 &lt; pivot &#125; let equal = a.filter &#123; $0 == pivot &#125; let greater = a.filter &#123; $0 &gt; pivot &#125; return quicksort(less) + equal + quicksort(greater)&#125; 译注：pivot 中心点，枢轴，基准。本文的pivot都翻译成“基准”。 将此代码放在playground 进行测试： 12let list = [ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ]quicksort(list) 谈一谈工作原理。 给定一个数组时，quicksort()根据“基准”变量将它分成三部分。这里，基准被视为数组中间的元素（稍后您将看到选择基准的其他方法）。 比基准元素小的所有元素都进入一个名为less的新数组。 所有等于基准元素都进入equal数组。你猜对了，所有比基准更大的元素进入第三个数组，greater。 这就是泛型类型T必须符合Comparable协议的原因，因为我们需要将元素与&lt;，==和&gt;进行比较。 一旦我们有了这三个数组，quicksort()递归地对less数组和more数组进行排序，然后将那些已排序的子数组与equal数组组合在一起，得到最终结果。 一个例子让我们来看看这个例子。 数组最初是： [ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ] 首先，我们选择基准8，因为它在数组的中间。 现在我们将数组拆分为少，相等和大的部分： less: [ 0, 3, 2, 1, 5, -1 ] equal: [ 8, 8 ] greater: [ 10, 9, 14, 27, 26 ] 这是一个很好的拆分，因为less和greater大致包含相同数量的元素。 所以我们选择了一个很好的基准，将数组从中间分开。 请注意，less和greater数组尚未排序，因此我们再次调用quicksort()来排序这两个子数组。这与之前完全相同：选择一个中间元素并将子数组分成三个更小的部分。 来看看less数组： [ 0, 3, 2, 1, 5, -1 ] 基准元素是中间的1（你也可以选择2，这没关系）。我们再次围绕基准元素创建了三个子数组： less: [ 0, -1 ] equal: [ 1 ] greater: [ 3, 2, 5 ] 我们还没有完成，quicksort()再次在less和more数组上被递归调用。 让我们再看一下less： [ 0, -1 ] 这次基准元素选择-1。 现在的子数组是： less: [ ] equal: [ -1 ] greater: [ 0 ] less数组是空的，因为没有小于-1的值; 其他数组各包含一个元素。 这意味着我们已经完成了递归，现在我们返回以对前一个greater数组进行排序。 greater数组是: [ 3, 2, 5 ] 这与以前的工作方式相同：我们选择中间元素2作为基准元素，子数组为： less: [ ] equal: [ 2 ] greater: [ 3, 5 ] 请注意，如果在这里选择3作为基准会更好 —— 会早点完成。 然而现在我们必须再次递归到greater数组以确保它被排序。这就体现，选择好的基准有多重要了。当你选择太多“bad”基准时，快速排序实际上变得非常慢。 之后会有更多说明。 当对greater子数组进行分区时，我们发现： less: [ 3 ] equal: [ 5 ] greater: [ ] 现在我们已经完成了这层递归，因为我们无法进一步拆分数组。 重复此过程，直到所有子数组都已排序。 过程图： 现在，如果您从左到右阅读彩色框，则会获得已排序的数组： [ -1, 0, 1, 2, 3, 5, 8, 8, 9, 10, 14, 26, 27 ] 这表明8是一个很好的初始基准，因为它也出现在排好序数组的中间。 我希望这已经清楚地表明快速排序的工作原理了。 不幸的是，这个版本的快速排序不是很快，因为我们对相同的数组使用filter()三次。有更聪明的方法分割数组。 分区围绕数据块划分数组称为 分区，并且存在一些不同的分区方案。如果一个数组是， [ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ] 然后我们选择中间元素8作为一个数据块，然后分区后数组如下： [ 0, 3, 2, 1, 5, -1, 8, 8, 10, 9, 14, 27, 26 ] ----------------- ----------------- all elements &lt; 8 all elements &gt; 8 要实现上面操作的关键是，在分区之后，基准元素已经处于其最终排序位置。 其余的数字尚未排序，它们只是以基准数分区了。 快速排序对数组进行多次分区，直到所有值都在最终位置。 无法保证每次分区将元素保持在相同的相对顺序中，因此在使用基准“8”进行分区之后，也可能得到类似这样的内容： [ 3, 0, 5, 2, -1, 1, 8, 8, 14, 26, 10, 27, 9 ] 唯一可以保证的是在基准元素左边是所有较小的元素，而右边是所有较大的元素。 因为分区改变相等元素的原始顺序，所以快速排序不会产生“稳定”排序（与归并排序不同）。 这大部分时间都不是什么大不了的事。 Lomuto的分区方案在快速排序的第一个例子中，我告诉你，分区是通过调用Swift的filter()函数三次来完成的。 这不是很高效。 因此，让我们看一个更智能的分区算法，它可以 in place，即通过修改原始数组。 这是在Swift中实现Lomuto的分区方案： 1234567891011121314func partitionLomuto&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) -&gt; Int &#123; let pivot = a[high] var i = low for j in low..&lt;high &#123; if a[j] &lt;= pivot &#123; (a[i], a[j]) = (a[j], a[i]) i += 1 &#125; &#125; (a[i], a[high]) = (a[high], a[i]) return i&#125; 在playground中测试： 123var list = [ 10, 0, 3, 9, 2, 14, 26, 27, 1, 5, 8, -1, 8 ]let p = partitionLomuto(&amp;list, low: 0, high: list.count - 1)list // show the results 注意list需要是var，因为partitionLomuto()直接改变数组的内容（使用inout参数传递）。 这比分配新的数组对象更有效。 low和high参数是必要的，因为当在快速排序时并不一定排序整个数组，可能只是在某个区间。 以前我们使用中间数组元素作为基准，现在Lomuto方案的基准总是使用最后元素，a [high] 。 因为之前我们一直在以8作为基准，所以我在示例中交换了8和26的位置，以便8位于数组的最后并且在这里也用作枢基准。 经过Lomuto方案分区后，数组如下所示： [ 0, 3, 2, 1, 5, 8, -1, 8, 9, 10, 14, 26, 27 ] * 变量p是partitionLomuto()的调用的返回值，是7。这是新数组中的基准元素的索引（用星号标记）。 左分区从0到p-1，是[0,3,2,1,5,8，-1]。 右分区从p + 1到结尾，并且是[9,10,14,26,27]（右分区已经排序的实属是巧合）。 您可能会注意到一些有趣的东西……值8在数组中出现不止一次。 其中一个8并没有整齐地在中间，而是在左分区。 这是Lomuto算法的一个小缺点，如果存在大量重复元素，它会使快速排序变慢。 那么Lomuto算法实际上是如何工作的呢？ 魔术发生在for循环中。 此循环将数组划分为四个区域： a [low ... i] 包含 &lt;= pivot 的所有值 a [i + 1 ... j-1] 包含 &gt; pivot 的所有值 a [j ... high-1] 是我们“未查看”的值 a [high]是基准值 In ASCII art the array is divided up like this:用ASCII字符表示，数组按如下方式划分： [ values &lt;= pivot | values &gt; pivot | not looked at yet | pivot ] low i i+1 j-1 j high-1 high 循环依次查看从low到high-1的每个元素。 如果当前元素的值小于或等于基准，则使用swap将其移动到第一个区域。 注意： 在Swift中，符号(x, y) = (y, x)是在x和y的值之间执行交换的便捷方式。 你也可以使用swap（＆x，＆y）。 循环结束后，基准仍然是数组中的最后一个元素。 所以我们将它与第一个大于基准的元素交换。 现在，基准位于&lt;=和&gt;区域之间，并且数组已正确分区。 让我们逐步完成这个例子。 我们开始的数组是： [| 10, 0, 3, 9, 2, 14, 26, 27, 1, 5, 8, -1 | 8 ] low high i j 最初，“未查看”区域从索引0延伸到11。基准位于索引12。“values &lt;= pivot”和“values&gt; pivot”区域为空，因为我们还没有查看任何值。 看第一个值，10。 这比基准小吗？ 不，跳到下一个元素。 [| 10 | 0, 3, 9, 2, 14, 26, 27, 1, 5, 8, -1 | 8 ] low high i j 现在“未查看”区域从索引1到11，“values&gt; pivot”区域包含数字“10”，“values &lt;= pivot”仍为空。 看第二个值，0。 这比基准小吗？ 是的，所以将10与0交换，然后将i向前移动一个。 [ 0 | 10 | 3, 9, 2, 14, 26, 27, 1, 5, 8, -1 | 8 ] low high i j 现在“未查看”区域从索引2到11，“values&gt; pivot”仍然包含“10”，“values &lt;= pivot”包含数字“0”。 看第三个值，3。 这比基准小，所以用10换掉它得到： [ 0, 3 | 10 | 9, 2, 14, 26, 27, 1, 5, 8, -1 | 8 ] low high i j “values &lt;= pivot”区域现在是[0,3]。 让我们再做一次……9大于枢轴，所以简单地向前跳： [ 0, 3 | 10, 9 | 2, 14, 26, 27, 1, 5, 8, -1 | 8 ] low high i j 现在“values&gt; pivot”区域包含[10,9]。 如果我们继续这样做，那么我们最终会得到： [ 0, 3, 2, 1, 5, 8, -1 | 27, 9, 10, 14, 26 | 8 ] low high i j 最后要做的是通过将a[i]与a[high]交换来将基准放到特定位置： [ 0, 3, 2, 1, 5, 8, -1 | 8 | 9, 10, 14, 26, 27 ] low high i j 然后我们返回i，基准元素的索引。 注意： 如果您仍然不完全清楚算法是如何工作的，我建议您在playground 试验一下，以确切了解循环如何创建这四个区域。 让我们使用这个分区方案来构建快速排序。 这是代码： 1234567func quicksortLomuto&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) &#123; if low &lt; high &#123; let p = partitionLomuto(&amp;a, low: low, high: high) quicksortLomuto(&amp;a, low: low, high: p - 1) quicksortLomuto(&amp;a, low: p + 1, high: high) &#125;&#125; 现在这非常简单。 我们首先调用partitionLomuto()来以基准元素（它始终是数组中的最后一个元素）重新排序数组。 然后我们递归调用quicksortLomuto()来对左右分区进行排序。 试试看： 12var list = [ 10, 0, 3, 9, 2, 14, 26, 27, 1, 5, 8, -1, 8 ]quicksortLomuto(&amp;list, low: 0, high: list.count - 1) Lomuto方案不是唯一的分区方案，但它可能是最容易理解的。 它不如Hoare的方案有效，后者需要的交换操作更少。 Hoare的分区方案这种分区方案是由快速排序的发明者Hoare完成的。 下面是代码： 12345678910111213141516func partitionHoare&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) -&gt; Int &#123; let pivot = a[low] var i = low - 1 var j = high + 1 while true &#123; repeat &#123; j -= 1 &#125; while a[j] &gt; pivot repeat &#123; i += 1 &#125; while a[i] &lt; pivot if i &lt; j &#123; a.swapAt(i, j) &#125; else &#123; return j &#125; &#125;&#125; 在playground中测试： 123var list = [ 8, 0, 3, 9, 2, 14, 10, 27, 1, 5, 8, -1, 26 ]let p = partitionHoare(&amp;list, low: 0, high: list.count - 1)list // show the results 注意，使用Hoare的方案，基准总是数组中的 first 元素，a [low]。 同样，我们使用8作为基准元素。结果是： [ -1, 0, 3, 8, 2, 5, 1, 27, 10, 14, 9, 8, 26 ] 请注意，这次基准根本不在中间。 与Lomuto的方案不同，返回值不一定是新数组中基准元素的索引。 结果，数组被划分为区域[low ... p]和[p + 1 ... high]。 这里，返回值p是6，因此两个分区是[-1,0,3,8,2,5,1]和[27,10,14,9,8,26]。 由于存在这些差异，Hoare快速排序的实施略有不同： 1234567func quicksortHoare&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) &#123; if low &lt; high &#123; let p = partitionHoare(&amp;a, low: low, high: high) quicksortHoare(&amp;a, low: low, high: p) quicksortHoare(&amp;a, low: p + 1, high: high) &#125;&#125; Hoare的分区方案是如何工作的？我将把它作为练习让读者自己弄清楚。:-) 选择一个好的基准Lomuto的分区方案总是为基准选择最后一个数组元素。 Hoare的分区方案使用第一个元素。 但这都不能保证这些基准是好的。 以下是为基准选择错误值时会发生的情况。 如果一个数组是： [ 7, 6, 5, 4, 3, 2, 1 ] 我们使用Lomuto的方案。 基准是最后一个元素，1。 分区后： less than pivot: [ ] equal to pivot: [ 1 ] greater than pivot: [ 7, 6, 5, 4, 3, 2 ] 现在以递归方式对“更大的”子数组进行分区，得到： less than pivot: [ ] equal to pivot: [ 2 ] greater than pivot: [ 7, 6, 5, 4, 3 ] 再次： less than pivot: [ ] equal to pivot: [ 3 ] greater than pivot: [ 7, 6, 5, 4 ] 等等。。。 这并不好，因为这样的快速排序可能比插入排序更慢。 为了使快速排序高效，需要将数组分成两个大约相等的部分。 这个例子的最佳基准是4，所以我们得到： less than pivot: [ 3, 2, 1 ] equal to pivot: [ 4 ] greater than pivot: [ 7, 6, 5 ] 您可能认为这意味着我们应该始终选择中间元素而不是第一个或最后一个，但想象在以下情况下会发生什么： [ 7, 6, 5, 1, 4, 3, 2 ] 现在，中间元素是1，它给出了与前一个例子相同的糟糕结果。 理想情况下，基准是您要分区的数组的 中位数（译注：大小在中间的） 元素，即位于排玩序数组中间的元素。当然，在你对数组进行排序之前，你不会知道中位数是什么，所以这就回到 鸡蛋和鸡 问题了。然而，有一些技巧可以改进。 一个技巧是“三个中间值”，您可以在找到数组中第一个，中间和最后一个的中位数。 从理论上讲，这通常可以很好地接近真实的中位数。 另一种常见的解决方案是随机选择基准。 有时这可能会选择次优的基准，但平均而言，这会产生非常好的结果。 以下是如何使用随机选择的基准进行快速排序： 1234567891011func quicksortRandom&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) &#123; if low &lt; high &#123; let pivotIndex = random(min: low, max: high) // 1 (a[pivotIndex], a[high]) = (a[high], a[pivotIndex]) // 2 let p = partitionLomuto(&amp;a, low: low, high: high) quicksortRandom(&amp;a, low: low, high: p - 1) quicksortRandom(&amp;a, low: p + 1, high: high) &#125;&#125; 与之前有两个重要的区别： random(min:max:)函数返回min...max范围内的整数，这是我们基准的索引。 因为Lomuto方案期望a[high]成为基准，我们将a[pivotIndex]与a[high]交换，将基准元素放在末尾，然后再调用partitionLomuto()。 在类似排序函数中使用随机数似乎很奇怪，但让快速排序在所有情况下都能有效地运行，这是有必要的。 坏的基准，快速排序的表现可能非常糟糕，O(n^2)。 但是如果平均选择好的基准，例如使用随机数生成器，预期的运行时间将变为O(nlogn)，这是好的排序算法。 荷兰国旗🇳🇱分区还有更多改进！ 在我向您展示的第一个快速排序示例中，我们最终得到了一个像这样分区的数组： [ values &lt; pivot | values equal to pivot | values &gt; pivot ] 但是正如您在Lomuto分区方案中看到的那样，如果多次出现基准元素，则重复项最后会在左分区。 而通过Hoare方案，重复基准元素可以遍布任意分区。 解决这个问题的方法是“荷兰国旗”分区，以荷兰国旗有三个频段命名，就像我们想拥有三个分区一样。 该方案的代码是： 123456789101112131415161718192021func partitionDutchFlag&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int, pivotIndex: Int) -&gt; (Int, Int) &#123; let pivot = a[pivotIndex] var smaller = low var equal = low var larger = high while equal &lt;= larger &#123; if a[equal] &lt; pivot &#123; swap(&amp;a, smaller, equal) smaller += 1 equal += 1 &#125; else if a[equal] == pivot &#123; equal += 1 &#125; else &#123; swap(&amp;a, equal, larger) larger -= 1 &#125; &#125; return (smaller, larger)&#125; 这与Lomuto方案的工作方式非常相似，只是循环将数组划分为四个（可能为空）区域： [low ... smaller-1] 包含&lt; pivot 的所有值 [less ... equal-1] 包含 == pivot 的所有值 [equal ... larger]包含 &gt; pivot 的所有值 [large ... high] 是我们“未查看”的值 Note that this doesn’t assume the pivot is in a[high]. Instead, you have to pass in the index of the element you wish to use as a pivot.请注意，这并不假设基准处于a[high]。 而是，必须传入要用作基准的元素的索引。 如何使用它的一个例子： 123var list = [ 10, 0, 3, 9, 2, 14, 8, 27, 1, 5, 8, -1, 26 ]partitionDutchFlag(&amp;list, low: 0, high: list.count - 1, pivotIndex: 10)list // show the results 只是为了好玩，我们这次给它的另一个8的索引。 结果是： [ -1, 0, 3, 2, 5, 1, 8, 8, 27, 14, 9, 26, 10 ] 注意两个8现在是如何在中间的。 partitionDutchFlag()的返回值是一个元组，(6,7)。 这是包含基准的范围。 以下是如何在快速排序中使用它： 12345678func quicksortDutchFlag&lt;T: Comparable&gt;(_ a: inout [T], low: Int, high: Int) &#123; if low &lt; high &#123; let pivotIndex = random(min: low, max: high) let (p, q) = partitionDutchFlag(&amp;a, low: low, high: high, pivotIndex: pivotIndex) quicksortDutchFlag(&amp;a, low: low, high: p - 1) quicksortDutchFlag(&amp;a, low: q + 1, high: high) &#125;&#125; 如果数组包含许多重复元素，则使用荷兰国旗分区可以提高效率。 （而且我不只是这么说，因为我是荷兰人！） 注意： partitionDutchFlag()的上述实现使用自定义swap()来交换两个数组元素的内容。 与Swift自带的swapAt()不同，当两个索引引用相同的数组元素时，这不会产生错误。 123456&gt; public func swap&lt;T&gt;(_ a: inout [T], _ i: Int, _ j: Int) &#123;&gt; if i != j &#123;&gt; a.swapAt(i, j)&gt; &#125;&gt; &#125;&gt; 扩展阅读快速排序的维基百科 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>快速排序</tag>
        <tag>Quicksort</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习iOS动画之七：其它类型的动画]]></title>
    <url>%2F2018%2FiOS-Animation-7-other-Animations.html</url>
    <content type="text"><![CDATA[本文是我学习《iOS Animations by Tutorials》 笔记中的一篇。文中详细代码都放在我的Github上 andyRon/LearniOSAnimations。 前面学习很多动画方面的知识，但有两个更专业的主题不适合前面的任何部分。 预览： 26-粒子发射器 —— 学习如何创建粒子发射器并创建以下降雪效果。 27-UIImageView的帧动画 —— 通过将帧动画与传统视图动画相结合，创建类似卡通的效果。 26-粒子发射器瀑布，火，烟和雨的影响都涉及大量的视觉项目 —— 粒子 —— 它们具有共同的物理特征，但仍然可能有自己独特的大小，方向，旋转和轨迹。 粒子可以很好地创建逼真的效果，因为每个粒子都可以是随机的和不可预测的，就像物体在自然界中一样。例如，雷暴中的每个雨滴可能具有独特的大小，形状和速度。 以下是粒子发射器(Particle Emitters)可以实现的视觉效果的几个示例： 在系统学习iOS动画之一：视图动画的第4、5章节的Flight Info项目中使用过雪花❄️的效果，但没有说明怎么使用，本章将单独学习雪花❄️效果的制作。 创建发射器层本章节将使用CALayer的子类CAEmitterLayer来创建粒子效果。 注意：有许多用于创建粒子效果的第三方类，但它们通常的目标是与游戏框架集成。 对于UIKit应用程序中的粒子动画，CAEmitterLayer是一个很好的选择，因为它内置并且易于使用。 本章节的开始项目 Snow Scene。 打开ViewController.swift并将以下代码添加到viewDidLoad()的底部： 1234let rect = CGRect(x: 0.0, y: 100.0, width: view.bounds.width, height: 50.0)let emitter = CAEmitterLayer()emitter.frame = rectview.layer.addSublayer(emitter) 此代码创建一个新的CAEmitterLayer，将图层的框架设置为占据屏幕的整个宽度，并将图层定位在屏幕顶部附近。接下来，需要设置要与粒子效果一起使用的发射器类型。将以下代码添加到viewDidLoad()： 1emitter.emitterShape = kCAEmitterLayerRectangle 发射器的形状通常会影响创建新粒子的区域，但在您创建类似3D的粒子系统的情况下，它也会影响它们的z位置。以下是三种最简单的发射器形状： 1.点形状kCAEmitterLayerPoint的发射器形状会导致所有粒子在同一点创建：发射器的位置。对于涉及火花或烟花的效果，这是一个不错的选择。 例如，可以通过在同一点创建所有粒子，并使它们在消失前沿不同方向飞行来创建火花效果。 2.线条形状kCAEmitterLayerLine发射器形状，是沿发射器框架顶部线创建所有粒子。 这是一种可用于瀑布效果的发射器形状，水粒子出现在瀑布的顶部并向下移动： 3.矩形形状最后，kCAEmitterLayerRectangle，通过在给定的矩形区域随机创建粒子： 这种发射器形状非常适合许多不同的效果，包括碳酸饮料和爆米花中的气泡。 由于积雪从整个天空随机出现，矩形发射器形状是本章项目的不错选择。 注意：还有一些发射器形状 - 长方体，圆形和球形 - 但这些超出了本章的范围。 有关详细信息，请查看Apple文档中的CAEmitterLayer类的官方文档Emitter Shape参考。 添加发射器帧将以下代码添加到viewDidLoad()的末尾： 12emitter.emitterPosition = CGPoint(x: rect.width/2, y: rect.height/2)emitter.emitterSize = rect.siz 组合形状，位置和尺寸属性定义了发射器框架。 在这里，可以将发射器的位置设置为图层的中心，并将发射器大小设置为等于图层的大小。这意味着发射器占用整个层帧，如下所示： 创建发射器单元现在已配置了发射器的位置和大小，可以继续添加发射器单元。 发射器单元是表示一个粒子源的数据模型。 它与CAEmitterLayer是一个单独的类，因为单个发射器层可以包含一个或多个单元。 例如，在爆米花动画中，你可以有三个不同的单元来表示爆米花的不同状态：完全炸开，半炸开和那些顽固的未炸开： 之后将使用不同的形状的❄️图片代表不同的发射器单元 将以下代码添加到viewDidLoad()的底部： 12let emitterCell = CAEmitterCell()emitterCell.contents = UIImage(named: "flake.png")?.cgImage 在上面的代码中，您创建一个新单元格并将flake.png设置为其内容。 contents属性包含将从中创建新粒子的模板。下面是深色背景上的放大的flake.png屏幕截图： 发射器将创建此图像的多个不同副本以模仿真实的雪花。 将以下代码添加到viewDidLoad()的底部： 123emitterCell.birthRate = 20emitterCell.lifetime = 3.5emitter.emitterCells = [emitterCell] 上面的代码表示每秒创建20个雪花，并将它们保持在屏幕上3.5秒。 这意味着在任何给定时间屏幕上将有70个雪花，除了动画的最初几秒之前，最旧的粒子开始消失。 最后，使用所有发射器单元的数组设置emitterCells属性。 请记住，可以拥有多个发射器单元，目前只有一个。 一旦设置了发射器单元列表，发射器就会开始创建粒子。 运行，看到效果： flake.png的多个副本在3.5秒后显示并消失。 然而，雪是奇怪的静态 —— ❄️没有移动。 控制粒子目前，雪粒出现，在空中漂浮几秒钟，然后消失。 那令人难以置信的无聊 ！ 下一个任务是让这些漫无目的的粒子移动起来。 改变粒子方向将以下代码添加到viewDidLoad()的底部： 1emitterCell.yAcceleration = 70.0 这将在y方向上增加一点加速度，因此粒子会像真雪一样向下漂移。 运行效果： 这看起来有点像雪 —— 但雪很少直线下降。 要解决此问题，就要向粒子添加以下水平加速度： 1emitterCell.xAcceleration = 10.0 运行， 雪花朝向对角线方向移动： 为了产生温和的坠落效果，添加以下代码： 12emitterCell.velocity = 20.0emitterCell.emissionLongitude = .pi * -0.5 velocity是初始速度。 发射经度（emissionLongitude）是粒子的初始角度，速度参数设置粒子的初始速度，如下所示： 再次运行，效果： 每次更改时，动画看起来越来越好。 但是这些粒子看起来像雪花大小的杀戮机器人一致地移动。 这是因为每个粒子具有完全相同的初始角度，速度和加速度。 需要为粒子创建过程添加一些随机性。 为粒子添加随机性将以下代码添加到viewDidLoad()： 1emitterCell.velocityRange = 200.0 这告诉发射器随机范围的值。 由于粒子动画的随机范围在本章中经常使用，因此值得花些时间来解释它们是如何工作的。所有粒子的初始速度都是20; 添加速度范围为每个粒子分配随机速度，如下所示： 每个粒子的速度将是（20-200）= -180和（20 + 200）= 220之间的随机值。具有负初始速度的粒子根本不会飞起来; 一旦它们出现在屏幕上，它们就会开始飘落。 具有正速度的粒子将首先飞起，然后向下飘落。 运行，效果： 好吧，雪花是随机的：一些雪花跳到屏幕的顶部边缘，而其他雪花则出现，徘徊一会儿，然后向下飘落。 让初始粒子方向也随机化。将以下代码添加到viewDidLoad()： 1emitterCell.emissionRange = .pi * 0.5 最初，所有粒子初始发射角度是-π/ 2。 上面的代码行表明发射器初始角度为（-π/ 2 - π/ 2）= 180度和（-π/ 2 +π/ 2）= 0度范围内的一个随机角度，如下图所示： 运行，效果： 现在这是随机的！ 虚拟暴风雪真的变得生动起来。 改变粒子颜色CAEmitterLayer的还有一个便利功能是能够为粒子设置颜色。 例如，可以将雪花淡蓝色而不是鲜明的白色，因为蓝色通常与雨，水，雪或冰有关。 将以下代码添加到viewDidLoad()的底部： 1emitterCell.color = UIColor(red: 0.9, green: 1.0, blue: 1.0, alpha: 1.0).cgColor 这种变化看起来很有趣，但所有的雪花都是统一蓝色调。 如果可以随机化每个雪花的颜色，这不是很好吗？ 需要做的就是为粒子颜色定义三个独立的范围：红色，绿色和蓝色各一个。将以下代码添加到viewDidLoad()的末尾： 123emitterCell.redRange = 0.3emitterCell.greenRange = 0.3emitterCell.blueRange = 0.3 上面的代码很好理解：绿色和蓝色是0.7到1.3之间的随机值，也就是0.7到1.0。 类似，红色介于0.6和1.0之间。 运行，看到五彩❄️： 0.3的范围有点大了，这是为了展示效果，之后可以改为0.1。 随机化粒子外观即使在添加了所有自定义之后，雪花外观看起来是一样的，现实中不会是这样的。 下面将使每个粒子都成为一个美丽而独特的雪花。 让每个雪花大小是随机的，将以下代码添加到viewDidLoad()： 12emitterCell.scale = 0.8emitterCell.scaleRange = 0.8 将基本粒子大小设置为原始大小的80％，大小范围在 0.0 - 1.6之间。 不仅可以设置雪花的初始大小，还可以在雪花落下时修改雪花的大小。在接近地面时，❄️在温暖的雾气中会融化。 将以下行添加到viewDidLoad()： 1emitterCell.scaleSpeed = -0.15 scaleSpeed属性表示，粒子按比例每秒缩小原始大小的15％。 大粒子在从视线中消失之前会大幅收缩，而小粒子会在它们结束前完全消失。不要心疼，这只是生活的雪花圈。 运行，效果，观察单个雪花大小的变化： ❄️看上去有点少，修改birthRate： 1emitterCell.birthRate = 150 设置❄️的透明度，将以下内容添加到viewDidLoad()的底部： 12emitterCell.alphaRange = 0.75emitterCell.alphaSpeed = -0.15 设置了一个alpha范围，从0.25到1.0的上限值。 alphaSpeed与scaleSpeed非常相似，可以随时间更改粒子的alpha值。 运行，查看效果： 目前已经涵盖了CAEmitterCell提供的大部分内容，下面内容是关于❄️的一些细节。 雪花的细节在viewDidLoad()中找到设置emissionLongitude并将其更改为以下内容的行： 1emitterCell.emissionLongitude = -.pi 请记住，发射经度是粒子的起始角度。 这种变化会让雪花旋转一下，仿佛被风吹一下一样。接下来，在找到声明rect的行并按如下方式修改它： 1let rect = CGRect(x: 0.0, y: -70.0, width: view.bounds.width, height: 50.0) 这会将发射器移出屏幕，用户将无法看到粒子来自何处。之前让粒子发射在屏幕中，是为了展示说明。 最后，将以下位代码添加到viewDidLoad()以随机化雪花在屏幕上保留的时间长度： 1emitterCell.lifetimeRange = 1.0 这会将每个雪花的生命周期设置为2.5到4.5秒之间的随机值。 虽然本章是一CAEmitterLayer为基础，说明了制作粒子效果的很多细节，但是每个概念都完全适用于其他粒子系统。无论是SpriteKit，Unity还是任何其他自定义粒子发射器，原理都基本上差不多。 本章目前效果： 添加更多单元这一部分只是为了学习更多粒子系统的知识，真实的雪景不是这样的，😏。 我又添加了三种不同❄️单元： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657//cell #2let cell2 = CAEmitterCell()cell2.contents = UIImage(named: "flake2.png")?.cgImagecell2.birthRate = 50cell2.lifetime = 2.5cell2.lifetimeRange = 1.0cell2.yAcceleration = 50cell2.xAcceleration = 50cell2.velocity = 80cell2.emissionLongitude = .picell2.velocityRange = 20cell2.emissionRange = .pi * 0.25cell2.scale = 0.8cell2.scaleRange = 0.2cell2.scaleSpeed = -0.1cell2.alphaRange = 0.35cell2.alphaSpeed = -0.15cell2.spin = .picell2.spinRange = .pi//cell #3let cell3 = CAEmitterCell()cell3.contents = UIImage(named: "flake3.png")?.cgImagecell3.birthRate = 20cell3.lifetime = 7.5cell3.lifetimeRange = 1.0cell3.yAcceleration = 20cell3.xAcceleration = 10cell3.velocity = 40cell3.emissionLongitude = .picell3.velocityRange = 50cell3.emissionRange = .pi * 0.25cell3.scale = 0.8cell3.scaleRange = 0.2cell3.scaleSpeed = -0.05cell3.alphaRange = 0.5cell3.alphaSpeed = -0.05//cell #4let cell4 = CAEmitterCell()cell4.contents = UIImage(named: "flake4.png")?.cgImagecell4.birthRate = 10cell4.lifetime = 5.5cell4.lifetimeRange = 1.0cell4.yAcceleration = 25cell4.xAcceleration = 30cell4.velocity = 20cell4.emissionLongitude = .picell4.velocityRange = 30cell4.emissionRange = .pi * 0.25cell4.scale = 0.8cell4.scaleRange = 0.2cell4.scaleSpeed = -0.05cell4.alphaRange = 0.5cell4.alphaSpeed = -0.05emitter.emitterCells = [emitterCell, cell2, cell3, cell4] 注：可能需要在真机才能看到流畅的效果 效果： 27-UIImageView的帧动画最后一章学习如何创建一种非常特殊的动画了。帧动画(Frame Animation)是我们小时候喜欢的动画类型，今天可能仍然很喜欢；迪斯尼的Duck Tales，Hanna-Barbera的Tom和Jerry以及Flintstones漫画都是这种创作方式。 帧动画也是用来为游戏中的角色制作动画的动画。仅仅将静态游戏角色从一个位置转换为另一个位置是不够的。需要移动角色的脚或旋转飞机的螺旋桨以给出逼真的运动感。 要创建角色移动的效果，可以将动画分解为帧，这些帧是表示动作不同阶段的静止图像。当快速显示帧时，一个接一个地显示帧，看起来角色正在移动： 开始项目本章节的开始项目 是SouthPoleFun，打开Main.storyboard查看最初的游戏场景： 结构很简单，一个背景图片，向左、向右两个按钮，一个滑动按钮，一个企鹅图像视图。 ViewController.swift中actionLeft(_:)，actionRight(_:)分别连接左右两个按钮，actionSlide(_:)连接滑动按钮。penguin和slideButton分别是企鹅图像和滑动按钮的接口。 Images.xcassets中包括企鹅🐧两张滑动图片和四张走动图片： 设置帧动画将以下代码添加到ViewController中的loadWalkAnimation()方法： 123penguin.animationImages = walkFramespenguin.animationDuration = animationDuration / 3penguin.animationRepeatCount = 3 animationImages：存储帧动画的所有帧图像。 animationDuration：这告诉UIKit动画的一次迭代应该持续多长时间；因为您将重复动画三次（见下文），所以将其设置为总animationDuration的三分之一。 animationRepeatCount：控制动画的重复次数。 之后，需要从视图控制器中的viewDidLoad()调用loadWalkAnimation()，以便每当玩家点击左箭头按钮时图像视图就会准备就绪。将以下代码添加到viewDidLoad()的底部： 1loadWalkAnimation() 哦 - 点击左箭头按钮时没有任何反应。 你做错了什么吗？ 没有; 您只为帧动画配置了图像视图，但您从未启动过动画。 如果不启动帧动画，图像视图将继续显示其图像属性的内容。是时候让这只企鹅蹒跚了。将以下代码添加到actionLeft(_:)： 1isLookingRight = false 这是左右方向的判断。由于每次更改企鹅的方向时都需要更新企鹅的转换和按钮的转换，因此需要向isLookingRight添加属性观察器： 1234567var isLookingRight: Bool = true &#123; didSet &#123; let xScale: CGFloat = isLookingRight ? 1 : -1 penguin.transform = CGAffineTransform(scaleX: xScale, y: 1) slideButton.transform = penguin.transform &#125;&#125; 上面代码将企鹅按钮图片的x轴刻度设置为1或-1，具体取决于isLookingRight的值。 然后设置该转换，来实现翻转视图，让企鹅可以面向正确的方向： 现在需要调用动画代码。 在actionLeft(_:)中继续添加： 1penguin.startAnimating() 当调用startAnimating()时，图像视图会在配置动画时播放动画：animationImages数组中的每个帧按顺序显示，总共超过1秒。运行， 点击左箭头按钮，查看企鹅在行动： 设置视图动画将以下代码添加到actionLeft(_:)： 123UIView.animate(withDuration: animationDuration, delay: 0, options: .curveEaseOut, animations: &#123; self.penguin.center.x -= self.walkSize.width&#125;, completion: nil) 使用步行图像的宽度来确定企鹅在动画播放时间内移动的距离。 运行，效果： 向右按钮差不多，将以下代码添加到actionRight(_:)： 123456isLookingRight = truepenguin.startAnimating()UIView.animate(withDuration: animationDuration, delay: 0, options: .curveEaseOut, animations: &#123; self.penguin.center.x += self.walkSize.width&#125;, completion: nil) 滑动帧动画与之前左右移动的动画类似。 将以下代码添加到loadSlideAnimation()以加载新的帧序列： 123penguin.animationImages = slideFramespenguin.animationDuration = animationDurationpenguin.animationRepeatCount = 1 将以下代码添加到actionSlide(_:)： 12loadSlideAnimation()penguin.startAnimating() 运行，可以看到企鹅跳到自己肚子上滑动。 但动画有一点奇怪，因为两个动画之间的帧图像不同： 开始帧图像为108 x 96，而滑动时图像为93 x 75.如果它们的大小相同，则每个图像中的空白空间最终会变大。想象一个具有五个，六个或更多帧动画的角色;你最终会得到巨大的图像尺寸，以适应所有可能的动画帧。 注意：此问题的一个简单解决方案是将图像视图的内容模式从其默认值“Aspect Fill”设置为“Center”或“Top Left”。但这不是好的解决方案，下面实现一个稍微不同且更灵活的解决方案。 手动调整图像视图的大小并重新定位，以创建漂亮流动的精美动画。 首先，需要在播放任何动画之前设置所需的图像视图帧; 这可以确保框架在屏幕上可见时尺寸正确。将以下代码添加到actionSlide(_:)，就在您开始动画的位置之前： 1234penguin.frame = CGRect(x: penguin.frame.origin.x, y: penguinY + (walkSize.height - slideSize.height), width: slideSize.width, height: slideSize.height) 此代码将企鹅图像视图向下移动一点以补偿幻灯片动画的较短帧，并调整图像视图的大小以匹配slideSize。slideSize包含slide01.png的大小；viewDidLoad()已包含获取图像的代码。 现在将以下代码添加到actionSlide(_:)的底部： 12345UIView.animate(withDuration: animationDuration - 0.02, delay: 0.0, options: .curveEaseOut, animations: &#123; self.penguin.center.x += self.isLookingRight ? self.slideSize.width : -self.slideSize.width&#125;, completion: &#123; _ in&#125;) 在上面的代码中，创建一个视图动画来移动企鹅图像视图并模拟跳转动作。 在上面的额完成动画闭包中添加： 12345self.penguin.frame = CGRect(x: self.penguin.frame.origin.x, y: self.penguinY, width: self.walkSize.width, height: self.walkSize.height)self.loadWalkAnimation() 最后，运行，效果： 使用UIImageView的帧动画很简单，但这是我们动画技能的一个很好的补充。 到此，算是比较系统地学习了iOS动画大部分知识，下面就需要练习和更深入的研究了，Good Luck☺。]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习iOS动画之六：3D动画]]></title>
    <url>%2F2018%2FiOS-Animation-6-3D-Animations.html</url>
    <content type="text"><![CDATA[本文是我学习《iOS Animations by Tutorials》 笔记中的一篇。文中详细代码都放在我的Github上 andyRon/LearniOSAnimations。 到目前为止，之前的文章只使用了二维动画——这是在平面设备屏幕上动画元素的最自然方式。 毕竟，从iOS 7扁平化后的世界中的按钮，文本字段，开关和图像没有了第三维; 这些元素存在于由X和Y轴定义的平面中： 核心动画可以帮助我们摆脱这个二维世界; 虽然它不是真正的3D框架，但核心动画有很多好的方法可以帮助我们在3D空间中描绘二维对象。 换句话说，图层和动画仍然以二维方式进行描绘，但可以在3D空间中旋转和定位每个元素的2D平面，如下所示： 上面显示的是在3D空间中旋转的两个2D图像。 透视变形使我们可以从渲染器的角度了解它们的位置。 本文将学习如何在3D空间中定位和旋转图层。CATransform3D类似于CGAffineTransform，但除了在x和y方向上缩放，倾斜和平移之外，它还带来了第三维：z。 z轴直接从设备屏幕朝向您的眼睛。 请考虑以下几个示例，以更好地了解透视的工作原理。 将相机设置得非常靠近屏幕会相应地扭曲图层的视角： 如果将相机离物体比较远时的视角： 最后，如果你在相机和屏幕之间设置了很大的距离： 预览： 24-简单的3D动画 —— 尝试新发现的有关相机距离和视角的知识。设置图层的透视图，处理图层的变换以旋转，平移和缩放三维图层。 25-中级3D动画 —— 在前一章的基础上，既然知道了m34和相机距离的秘密，就可以创建具有多个视图的各种3D动画。 24-简单3D动画本章将尝新发现的有关相机距离和视角的知识。 开始项目 Office Buddy是一个办公室帮助应用程序，供员工访问有关日常公司生活的分类信息。这个应用很简单就是点击左上角的按钮或者左右滑到，然后左边侧栏出现。下面👇将向这个开始项目中添加一些3D元素。 开始项目预览： 创造3Dtransformations打开ContainerViewController.swift，ContainerViewController在屏幕上显示菜单视图控制器和内容视图控制器。 它还处理平移手势，以便用户可以打开和关闭菜单。 您的第一个任务是构建一个类方法，该方法为侧面菜单的给定百分比“开放性”创建相应的3D变换。将以下方法声明添加到ContainerViewController： 123func menuTransform(percent: CGFloat) -&gt; CATransform3D &#123;&#125; 上述方法接受菜单当前进度的单个参数，该参数由handleGesture(_ :)中的代码计算，并返回CATransform3D的实例。 您将直接将此方法的结果分配给菜单图层的transform属性。 将以下代码添加到上面方法中： 12var identity = CATransform3DIdentityidentity.m34 = -1.0/1000 这段代码可能看起来有点令人惊讶; 到目前为止，您只使用函数来创建或修改变换。 但是，这一次，您正在修改其中一个类的属性。 注意：CATransform3D和CGAffineTransform分表表示4*4和3*3的数学矩阵，在Swift和OC中都是用结构体表示的。 属性m34指矩阵的第3行第4列，这个属性比较常用，表示透视效果，m34 = -1 / D，D可以理解为相机距离，D越小，透视效果越明显，必须在有旋转效果的前提下，才会看到透视效果。 相机距离对于普通应用程序中的UI元素，相机距离大概可以表示：0.1 … 500：非常接近，透视失真。750 … 2,000：视角不错，内容清晰可见。2000+：几乎没有透视失真。 对于Office Buddy应用程序，1000点的距离将为菜单提供一个非常微妙的视角。 将以下代码添加到menuTransform(percent:)的底部： 12let remainingPercent = 1.0 - percentlet angle = remainingPercent * .pi * -0.5 将以下代码添加到menuTransform(percent:)的底部： 123let rotationTransform = CATransform3DRotate(identity, angle, 0.0, 1.0, 0.0)let translationTransform = CATransform3DMakeTranslation(menuWidth * percent, 0, 0)return CATransform3DConcat(rotationTransform, translationTransform) 在这里，使用rotationTransform将图层绕y轴旋转。 菜单从左侧移动，因此还需要创建平移变换以沿x轴移动它，最终将菜单宽度设置为100％。 最后，连接两个转换并返回结果。 从setMenu(toPercent:)中删除下面： 1menuViewController.view.frame.origin.x = menuWidth * CGFloat(percent) - menuWidth 替代为： 1menuViewController.view.layer.transform = menuTransform(percent: percent) 菜单栏的位置通过转换来控制了。 运行项目， 向右平移查看菜单如何围绕其y轴旋转： 菜单以3D形式旋转，但它围绕其水平中心旋转，菜单与内容视图控制器中间有间隙。 移动图层的锚点默认情况下，图层的锚点的x坐标为0.5，表示它位于中心。 将锚点的x设置为1.0，就不会出现上面的那种间隙，如下所示： 所有变换都是围绕图层的锚点计算的。 在viewDidLoad()中找到以下行： 1menuViewController.view.frame = CGRect(x: -menuWidth, y: 0, width: menuWidth, height: view.frame.height) 现在在该行上方插入以下代码（在设置视图帧之前插入行非常重要，否则设置锚点将偏移视图）： 1menuViewController.view.layer.anchorPoint.x = 1.0 这会使菜单围绕其右边缘旋转。 运行效果： 这看起来好多了！ 通过阴影创建远景阴影为3D动画带来了很多真实感。这里不需要使用任何先进的着色技术，只要旋转时更改alpha。 将以下代码添加到setMenu(toPercent:)： 1menuViewController.view.alpha = CGFloat(max(0.2, percent)) 0.2让菜单最小还可见，百分比让菜单越小透明度越低。 由于此应用程序的背景为黑色，因此降低菜单视图的alpha值会使菜单中显示黑色并模拟阴影效果。 运行效果： 这是一个让3D效果更加真实的小细节。 如果仔细观察，会发现第一次点击按钮时，菜单不是以3D效果展示，以后才是。这是因为第一次切换菜单之前，设置3D动画参数和图层转换。在viewDidLoad()中添加： 1setMenu(toPercent: 0.0) 光栅化的效率让动画更加“完美”。如果在来回平移时盯着菜单足够长，会注意到菜单项的边框看起来像素化，如下所示： 核心动画不断重绘菜单视图控制器的所有内容，并在所有元素移动时重新计算所有元素的透视失真，这个过程中会出现锯齿状边缘。 最好让Core Animation知道我们不会在动画期间更改菜单内容，以便它可以渲染菜单一次并简单地旋转渲染和缓存的图像。这听起来很复杂，但很容易实现。 找到handleGesture()中的.began代码块，此代码在用户平移操作时执行。 将以下代码添加到.began代码块的末尾： 12menuViewController.view.layer.shouldRasterize = truemenuViewController.view.layer.rasterizationScale = UIScreen.main.scale shouldRasterize让核心动画将图层内容缓存为图像。 然后设置rasterizationScale以匹配当前的屏幕比例。 运行，效果： 为避免在使用应用程序时进行任何不必要的缓存，应该在动画完成后立即关闭光栅化。在.failed代码块找到动画完成闭包并添加以下代码： 1self.menuViewController.view.layer.shouldRasterize = false 现在，只在动画期间激活光栅化。提高了效率！😊 菜单按钮的3D旋转动画菜单展示时，菜单按钮也进行自身的旋转。具体来说，您将围绕x轴和y轴创建旋转，以使菜单按钮在其对角线上翻转。 在ContainerViewController的setMenu(toPercent:)中添加： 1234let centerVC = centerViewController.viewControllers.first as? CenterViewControllerif let menuButton = centerVC?.menuButton &#123; menuButton.imageView.layer.transform = buttonTransform(percent: percent)&#125; buttonTransform函数为： 123456789func buttonTransform(percent: CGFloat) -&gt; CATransform3D &#123; var identity = CATransform3DIdentity identity.m34 = -1.0/1000 let angle = percent * .pi let rotationTransform = CATransform3DRotate(identity, angle, 1.0, 1.0, 0.0) return rotationTransform&#125; 效果如下： 25-中级3D动画在上一章24-简单3D动画中，学习了将透视应用到单个视图制作出简单的3D效果的动画； 事实上，一旦我们知道m34和相机距离的秘密，就可以创建各种3D动画。 本章以前面的内容为基础，学习如何使用多个视图创建有意思的3D动画。 本章的开始项目 ImageGallery是一个简单的飓风图库。 探索开始项目本章的开始项目是： 只是一个空白屏幕，顶部有两个按钮。 打开ViewController.swift，会看到一个名为images的数组，此数组就是一些图片信息。 ImagViewCard类继承自UIImageView并且有一个字符串属性title来保存飓风标题，有一个名为didSelect的属性，以便您可以轻松地在图像上设置点击处理程序。 第一个任务是将所有图像添加到视图控制器的视图中。 将以下代码添加到viewDidAppeae(_:)的末尾： 123456for image in images &#123; image.layer.anchorPoint.y = 0.0 image.frame = view.bounds view.addSubview(image)&#125; 在上面的代码中，循环遍历所有图像，在y轴上将每个图像的锚点设置为0.0，并调整每个图像的大小，使其占据整个屏幕。 设置锚点可让图像围绕其上边缘而不是中心的默认值旋转，如下图所示： 运行只会看到最后一张图片Hurricane Irene，因为图片位置相同，叠加在一起来 显示飓风图像的名字，在viewDidAppear(_:)的末尾添加以下行： 1navigationItem.title = images.last?.title 注意，目前没有在图像上设置任何透视转换;之后将直接在视图控制器的视图上设置透视图。 在上一章中，在单个视图上调整了transform属性，然后在3D空间中旋转它。但是，由于您当前的项目有更多的个人视图，需要在3D中操作，您可以设置其父视图的透视图，从而节省大量工作。 将以下代码添加到viewDidAppear(_:)： 123var perspective = CATransform3DIdentityperspective.m34 = -1.0/250.0view.layer.sublayerTransform = perspective 在这里，您可以使用图层属性sublayerTransform来设置视图控制器图层的所有子图层的透视图。 然后将子层转换与每个单独层的自身变换组合。 这使您可以专注于管理子视图的旋转或平移，而无需担心透视。 您将在下一节中更详细地了解它的工作原理。 改变图库toggleGallery(_:)连接着右上方的“浏览”按钮，在此处将3D变换应用于四个图像。 将以下变量添加到toggleGallery(_:)： 1234567var imageYOffset: CGFloat = 50.0for subview in view.subviews &#123; guard let image = subview as? ImageViewCard else &#123; continue &#125;&#125; 由于您不只是将所有图像旋转到原位而只是移动它们以产生”扇形“动画，因此您可以使用imageYOffset来设置每个图像的偏移。接下来，您需要遍历所有图像并运行其各自的动画。 在这里，您循环浏览视图控制器视图的所有子视图，并仅对作为ImageViewCard实例的子视图执行操作。在上面添加的guard块之后添加以下代码，以替换此处的更多代码注释： 1234567var imageTransform = CATransform3DIdentity// 1imageTransform = CATransform3DTranslate(imageTransform, 0.0, imageYOffset, 0.0)// 2imageTransform = CATransform3DScale(imageTransform, 0.95, 0.6, 1.0)// 3imageTransform = CATransform3DRotate(imageTransform, .pi/8, -1.0, 0.0, 0.0) 首先将标识转换分配给imageTransform，然后对其添加一系列调整。 这是每个单独的调整对图像的作用： // 1 使用CATransform3DTranslate在y轴上移动图像; 这会使图像偏离其默认的0.0 y坐标，如下所示： 之后，将要分别计算每个图像的imageYOffset，否则图片还是叠加在一起。 // 2 通过使用CATransform3DScale调整转换的比例分量来缩放图像。 可以在x轴上稍微缩小图像，但是在y轴上将其缩小到60％以丰富旋转3D效果： // 3 最后，使用CATransform3DRotate将图像旋转22.5度，使其具有一些透视变形，如下所示： 请记住，之前已经设置了锚点，因此图像围绕其顶部边缘旋转。 现在你看到通过view.layer.sublayerTransform设置上面的m34值的值; 您的旋转变换只需重新使用子层变换中的m34值，而无需在此处应用它。 那很方便！ 现在剩下的就是将转换应用于每个图像。 添加以下行（仍在for代码块中）： 1image.layer.transform = imageTransform 将以下行添加到for块的末尾，修改每个图像的位置： 1imageYOffset += view.frame.height / CGFloat(images.count) 这会调整每个图像的y偏移量，具体取决于它在堆栈中的位置。 将屏幕高度除以图像数量，以便它们在屏幕上均匀分布。运行后效果： 下面让它动起来！ 动画图库在上面的image.layer.transform = imageTransform的前面添加： 12345let animation = CABasicAnimation(keyPath: "transform")animation.fromValue = NSValue(caTransform3D: image.layer.transform)animation.toValue = NSValue(caTransform3D: imageTransform)animation.duration = 0.33image.layer.add(animation, forKey: nil) 这段代码非常熟悉：在transform属性上创建一个图层动画，并将其从当前值设置为之前设计的imageTransform。运行后， 点击“浏览”按钮，效果： 你现在已经完成了画廊; 当您在用户点击“浏览”按钮时添加关闭风扇的功能时，您将在“挑战”部分重新访问它。 更多一点交互为图像库添加一点交互性：点击图像，变成全屏，并且位置移到最前面，以便用户可以更好地查看它。 ImageViewCard已经具有名为didSelect的闭包表达式属性，当用户点击图像，就将点击的图像视图作为输入参数给这个闭包。 首先将以下代码添加viewDidAppear()的for循环体内： 1image.didSelect = selectImage 在ViewController中添加方法： 12345678910111213func selectImage(selectedImage: ImageViewCard) &#123; for subview in view.subviews &#123; guard let image = subview as? ImageViewCard else &#123; continue &#125; if image === selectedImage &#123; &#125; else &#123; &#125; &#125;&#125; 现在您还需要两个动画：一个用于为所选图像设置动画，另一个用于为图库中的所有其他图像设置动画。你将反过来解决这个问题并首先淡出未选择的图像。 上面的方法还缺少两个动画，当image === selectedImage，就是所选图像的动画；或者，未选择的所有其他图像的动画，前者代码为： 123456UIView.animate(withDuration: 0.33, delay: 0.0, options: .curveEaseIn, animations: &#123; image.alpha = 0.0&#125;, completion: &#123; (_) in image.alpha = 1.0 image.layer.transform = CATransform3DIdentity&#125;) 后者代码为： 12345UIView.animate(withDuration: 0.33, delay: 0.0, options: .curveEaseIn, animations: &#123; image.layer.transform = CATransform3DIdentity&#125;, completion: &#123;_ in self.view.bringSubview(toFront: image)&#125;) 在这里，没有对动画进行3D变换，然后确保图像位于视图堆栈的顶部，以便它可见。 最后，将以下代码添加到selectImage(selectedImage:)的末尾，更新标题： 1self.navigationItem.title = selectedImage.title 切换图库这小结工作是将使“浏览”按钮可以关闭图库视图。 向ViewController添加一个isGalleryOpen的新属性，并将其初始值设置为false。 需要在代码中的两个位置更新此属性的值： 在toggleGallery(_:)结束时将其设置为true 在selectImage(selectedImage:)结束时将其设置为false 在toggleGallery()的顶部，添加一个检查以查看图库是否已打开。 如果打开，则遍历所有图像并将其转换设置为原始值。 不要忘记重置isGalleryOpen并返回，因此其余的方法代码也不会执行。 12345678910111213141516171819if isGalleryOpen &#123; for subview in view.subviews &#123; guard let image = subview as? ImageViewCard else &#123; continue &#125; let animation = CABasicAnimation(keyPath: "transform") animation.fromValue = NSValue(caTransform3D: image.layer.transform) animation.toValue = NSValue(caTransform3D: CATransform3DIdentity) animation.duration = 0.33 image.layer.add(animation, forKey: nil) image.layer.transform = CATransform3DIdentity &#125; isGalleryOpen = false return&#125; 本章的最后效果：]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
        <tag>3D动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习iOS动画之四：视图控制器的转场动画]]></title>
    <url>%2F2018%2FiOS-Animation-4-View-Controller-Transition-Animations.html</url>
    <content type="text"><![CDATA[本文是我学习《iOS Animations by Tutorials》 笔记中的一篇。文中详细代码都放在我的Github上 andyRon/LearniOSAnimations。 之前学习了视图动画、图层动画、自动布局动画等。这个部分让视野更大一点，学习整个视图控制器的动画，视图控制器的转场动画(View Controller Transition Animations)。 iOS中最容易识别的动画之一是将新视图控制器推入导航堆栈的动画，当我们想让APP有自己的特色，自定义转场动画是非常好的方式。 在本文，将学习如何使用动画创建自己的自定义视图控制器转换。 预览： 17-视图控制器转场和屏幕旋转转场 了解如何通过自定义动画转场呈现视图控制器 - 作为奖励，您将创建动画转场以处理设备方向更改。 18-导航控制器转场 19-交互式导航控制器转场 17-视图控制器转场和屏幕旋转转场无论是呈现 照相机视图控制器、地址簿还是自定义的模态屏幕，每次都调用相同的UIKit方法：present(_:animated:completion:)。 此方法将当前屏幕“放弃”，然后跳到另一个视图控制器。 下图呈现一个“New Contact”视图控制器向上滑动以覆盖当前视图（联系人列表），这是默认的动画方式： 在本章中，学习创建自己的自定义演示控制器动画，以替换默认的动画，并使本章的项目更加生动。 开始项目本章开始项目是一个新项目，叫BeginnerCook。 这个开始项目可以简单概括 如下，ViewController中包括一个背景图UIImageView，一个标题UILabel，一个文本视图UITextView，下面是一个可以左右移动的UIScrollView。这个UIScrollView里会用代码加入一些香草(herb)图片，点击图片会跳转到另个展示详情的视图控制器HerbDetailsViewController，这个转场是标准的从下到上的垂直覆盖转场动画。 开始项目预览一下： 自定义转场的原理UIKit实现自定义转场动画是通过代理模式完成的。因此首先需要让ViewController遵守UIViewControllerTransitioningDelegate协议。 每次呈现新的视图控制器时，UIKit都会询问其代理是否要使用自定义转场。以下是自定义转场动画的第一步： 需要实现animationController(forPresented:presenting:source:)方法，这个方法如果返回nil，则进行默认的转场动画，如果返回时遵守UIViewControllerAnimatedTransitioning协议的对象，则将这个对象作为自定义转场的Animator（可以翻译为动画师）。 在UIKit使用自定义Animator之前，还需要一些步骤： transitionDuration(using:)返回动画持续时间。 animateTransition(using:)方法时实际动画代码所在的地方。在这个方法中可以访问屏幕上的当前视图控制器以及将要显示的新视图控制器，可以自己根据需要淡化，缩放，旋转等操作现有视图和新视图。 下面开始实现自定义转场！💪 实现转场代理新建一个NSObject子类PopAnimator(就是之前提到的Animator)，并遵守协议 UIViewControllerAnimatedTransitioning 。并在这个动画类中添加两个函数的存根： 123456func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return 0&#125; func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123;&#125; 让ViewController遵守UIViewControllerTransitioningDelegate协议： 123extension ViewController: UIViewControllerTransitioningDelegate &#123; &#125; 在didTapImageView(_:)中的present(herbDetails, animated: true, completion: nil)前添加： 1herbDetails.transitioningDelegate = self 现在，每次在屏幕上显示详情页的视图控制器时，UIKit都会向ViewController询问动画对象。 但是，目前仍然没有实现任何UIViewControllerTransitioningDelegate中的相关方法，因此UIKit仍将使用默认转换。 在 ViewController中创建动画属性： 1let transition = PopAnimator() 实现呈现时动画的协议方法： 123func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; return transition&#125; 实现解除（dismiss）时动画的协议方法： 123func animationController(forDismissed dismissed: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; return transition&#125; 现在点击香草🌿图片时，没有反应，这是因为，把默认的转场动画修改成了自定义，但自定义动画目前是空的。 创建转场动画师在PopAnimator添加： 123let duration = 1.0var presenting = truevar originFrame = CGRect.zero duration 是动画持续时间。 presenting 是用判断当前是呈现还是解除。 originFrame用来存储用户点击的图像的原始 frame —— 呈现动画就是需要它从原始frame到全屏图像frame，对应的解除动画正好相反。 用以下内容替换transitionDuration()中的代码： 1return duration 设置转场动画的上下文是时候为animateTransition(using:)添加代码了。 此方法有一个类型为UIViewControllerContextTransitioning的参数，通过该参数可以访问转场的相关参数和视图控制器。 在开始写动画代码之前，了解动画上下文实际上是什么很重要。 当两个视图控制器之间的转场开始时，现有视图将添加到转场容器视图(transition container view)中，并且新视图控制器的视图已创建但尚未可见，如下所示： 因此，现在的任务是将新视图添加到animateTransition()中的转场容器中，以特定动画将其显示，如有需要也是特定动画的方式解除旧视图。 默认情况下，转场动画完成后，旧视图将从转场容器中删除。 下面👇先实现简单的转场动画。 淡出转场获得动画将在其中进行的容器视图，然后您将获取新视图并将其存储在toView中，在animateTransition()中添加： 12let containerView = transitionContext.containerViewlet toView = transitionContext.view(forKey: .to)! view(forKey:)和viewController(forKey:)两个方法非常类似，分别获得转场动画对应的视图和视图控制器。 继续在animateTransition()中添加： 1234567containerView.addSubview(toView)toView.alpha = 0.0UIView.animate(withDuration: duration, animations: &#123; toView.alpha = 1.0&#125;, completion: &#123; _ in transitionContext.completeTransition(true)&#125;) 在动画完成闭包中调用用completeTransition()，告诉UIKit你的转场动画已经完成，UIKit可以自由地结束视图控制器转场。 目前的效果就是： pop转场上面的fade效果不是最终想要的，把animateTransition()中的代码替换为： 123let containerView = transitionContext.containerViewlet toView = transitionContext.view(forKey: .to)!let herbView = presenting ? toView : transitionContext.view(forKey: .from)! containerView是动画将存在的地方，而toView是要呈现的新视图。 如果是呈现（presenting为true），herbView是toView，否则将从上下文中获取。 对于呈现和解除，herbView将始终是表现动画的视图。 当呈详细页的控制器视图时，它将逐渐占用整个屏幕。 当被解除时，它将缩小到图像的原始帧。 在上面代码后添加： 12345let initialFrame = presenting ? originFrame : herbView.framelet finalFrame = presenting ? herbView.frame : originFramelet xScaleFactor = presenting ? initialFrame.width / finalFrame.width : finalFrame.width / initialFrame.widthlet yScaleFactor = presenting ? initialFrame.height / finalFrame.height : finalFrame.height / initialFrame.height initialFrame和finalFrame分别是初始和最终动画的frame，xScaleFactor 和yScaleFactor分别是x轴和y轴上视图变化的比例因子（scale factor） 。 继续在上面代码后添加： 1234567let scaleTransform = CGAffineTransform(scaleX: xScaleFactor, y: yScaleFactor) if presenting &#123; herbView.transform = scaleTransform herbView.center = CGPoint(x: initialFrame.midX, y: initialFrame.midY) herbView.clipsToBounds = true&#125; 当需要呈现新视图时，设置transform，并且定位（设置center） 继续在上面代码后添加： 12345678containerView.addSubview(toView)containerView.bringSubview(toFront: herbView)UIView.animate(withDuration: duration, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 0.0, options: [], animations: &#123; herbView.transform = self.presenting ? CGAffineTransform.identity : scaleTransform herbView.center = CGPoint(x: finalFrame.midX, y: finalFrame.midY)&#125;) &#123; (_) in transitionContext.completeTransition(true)&#125; 首先将toView添加到容器中，并确保herbView位于顶部，因为这是动画的唯一视图。 然后，实现动画，在这里使用弹簧动画。在动画表达式中，可以更改herbView的transform和位置。在呈现时，将从底部的小尺寸变为全屏；在解除时，将全屏缩小变为原始图像大小。 最后，您调用了completeTransition()告诉UIKit转场动画已经完成。 现在的效果： 动画从左上角开始; 这是因为originFrame的默认值的原点是(0,0) 。 在ViewController.swift的animationController(forPresented:presenting:source:) 返回代码前添加： 123transition.originFrame = selectedImage!.superview!.convert(selectedImage!.frame, to: nil)transition.presenting = trueselectedImage!.isHidden = true 这会将转场动画的originFrame设置为selectedImage的frame，并在动画期间隐藏初始图像。 目前的效果是初始小视图转场到全屏了，没有问题，但是解除详情页时就有问题，详情页突然就消失了： 解除转场剩下要做的就是解除详细页视图的动画。 在ViewController.swift的animationController(forDismissed:)中添加： 12transition.presenting = falsereturn transition 上面的代表 transition对象也作为解除转场动画使用。 转场动画看起来很棒，但解除详细页面后，原始的小尺寸的图片消失了。下面就解决这个问题。 在类PopAnimator中添加一个闭包属性，作为解除动画完成后处理： 1var dismissCompletion: (()-&gt;Void)? 在animateTransition(using:)的transitionContext.completeTransition(true)之前添加(也就是通知UIKit转场动画结束之前，如果是解除动画，就进行一些处理)： 123if !self.presenting &#123; self.dismissCompletion?()&#125; 在ViewController实现具体闭包内容，在viewDidLoad()中添加： 123transition.dismissCompletion = &#123; self.selectedImage!.isHidden = false&#125; 那么，目前效果： 屏幕旋转转场设备方向更改视为从视图控制器到其自身的转场过程。 iOS 8中引入的viewWillTransition(to:with:)方法，用来提供了一种简单直接的方法来处理设备方向的变化。 不需要构建单独的纵向或横向布局，而只需要对视图控制器视图的大小进行更改。 在ViewController中添加： 1234567override func viewWillTransition(to size: CGSize, with coordinator: UIViewControllerTransitionCoordinator) &#123; super.viewWillTransition(to: size, with: coordinator) coordinator.animate(alongsideTransition: &#123; context in self.bgImage.alpha = (size.width &gt; size.height) ? 0.25 : 0.55 &#125;, completion: nil)&#125; 第一个参数（size）指视图控制器变换后的大小。 第二个参数（coordinator）是转场协调对象，它可以访问许多转场的属性。 animate(alongsideTransition:completion:)允许指定自己的自定义动画，与UIKit在更改方向时默认执行的旋转动画一起执行。当设备横向时，减少背景图像的透明度，让文本看上去更清晰，更容易阅读。 运行，旋转设备（模拟器中按Cmd +向左箭头）： 将屏幕旋转为横向模式时，可以清楚地看到背景变深。 现在上面的动画看上去已经很不错，但如果仔细观看，会发现还有两个问题，解除动画时，全屏视图到小视图完成之前看到详细视图的文本；全屏视图是直角，直到动画要完成的最后一个才从直角突然变到圆角。 平滑转场动画纠正了细节视图的文本在被解除时消失的问题。 在animateTransition(using:)中的动画(UIView.animate(...))开始前添加： 12345let herbController = transitionContext.viewController(forKey: presenting ? .to : .from) as! HerbDetailsViewControllerif presenting &#123; herbController.containerView.alpha = 0.0&#125; 在animateTransition(using:)中的动画闭包中添加： 1herbController.containerView.alpha = self.presenting ? 1.0 : 0.0 圆角动画最后，为详情页视图的图层角半径设置动画，使其与主视图控制器中草本图像的圆角相匹配。 在animateTransition(using:)中的动画闭包中添加： 1herbView.layer.cornerRadius = self.presenting ? 0.0 : 20.0/xScaleFactor 为了更方便的查看动画，可以把持续时间增大或用模拟器中满动画（Command + T）。 上面两个修改后的效果： 18-导航控制器转场UINavigationController是iOS中为数不多的内置应用导航解决方案之一。 将一个新的视图控制器推入或弹出导航堆栈，这个过程自带一个时尚的动画。 上图显示了iOS如何将新视图控制器推送到设置应用中的导航堆栈：新视图从右侧滑入以覆盖旧视图，新标题淡入，而旧标题淡出。 本章的自定义导航控制器转场与前一章中构建自定义视图控制器转场的方式类似。 开始项目本章开始项目是一个新项目，叫LogoReveal 。 点击默认屏幕任意地方（MasterViewController），跳转展示vacation packing list页面(DetailViewController)，RW Logo是通过UIBezierPath绘制的CAShapeLayer图层。 自定义导航控制器转场的原理自定义导航控制器转场的原理类似上一章节的自定义转场的原理，同样也可以用两个图概括： 导航控制器代理首先需要新建一个Animator，新建一个NSObject子类RevealAnimator的类文件，并让它遵守UIViewControllerAnimatedTransitioning协议： 123class RevealAnimator: NSObject, UIViewControllerAnimatedTransitioning &#123;&#125; 在RevealAnimator中添加两个属性，并且实现UIViewControllerAnimatedTransitioning协议的两个方法： 1234567891011let animationDuration = 2.0var operation: UINavigationControllerOperation = .pushfunc transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -&gt; TimeInterval &#123; return animationDuration&#125;func animateTransition(using transitionContext: UIViewControllerContextTransitioning) &#123; &#125; operation是UINavigationControllerOperation类型的属性，用于表示是在推送还是弹出控制器。 用扩展的方式让MasterViewController遵守UINavigationControllerDelegate协议： 123extension MasterViewController: UINavigationControllerDelegate &#123; &#125; 在调用任何segues或将某些内容推送到堆栈之前，需要在视图控制器生命周期的早期设置导航控制器的代理。在MasterViewController的viewDidLoad()中添加： 1navigationController?.delegate = self 在MasterViewController中创建Animator属性： 1let transition = RevealAnimator() 实现协议UINavigationControllerDelegate的方法navigationController(): 1234func navigationController(_ navigationController: UINavigationController, animationControllerFor operation: UINavigationControllerOperation, from fromVC: UIViewController, to toVC: UIViewController) -&gt; UIViewControllerAnimatedTransitioning? &#123; transition.operation = operation return transition&#125; 这是一个方法名称非常长，参数有： navigationController：当对象是多个导航控制器的委托时，这用来区分导航控制器，这不是太常见。 operation：这是一个枚举UINavigationControllerOperation，可以是.push或.pop。 fromVC：这是当前在屏幕上可见的视图控制器，它通常是导航堆栈中的最后一个视图控制器。 toVC：这是将转场到的视图控制器。 如果需要不同视图控制器有不同转场动画，则可以选择返回不同的Animator。为了简化此项目，在推送或弹出转场时，都返回RevealAnimator对象。 运行，点击，导航栏有一个两秒转场，但其他就没有反应了，这是因为animateTransition()中还没有编写任何代码。 添加自定义显示动画自定义转场动画的计划相对简单。 您只需在DetailViewController上为蒙版设置动画，使其看起来像RW徽标的透明部分，显示底层视图控制器的内容。你将不得不处理图层和一些动画任务，但是到目前为止你还没有完成任务。 对于像你这样的动画专业人士来说，创建转场动画将是一件轻松的事！ 在RevealAnimator中创建一个存储动画上下文的属性： 1weak var storedContext: UIViewControllerContextTransitioning? 再在animateTransition()中添加： 1234567storedContext = transitionContextlet fromVC = transitionContext.viewController(forKey: .from) as! MasterViewControllerlet toVC = transitionContext.viewController(forKey: .to) as! DetailViewControllertransitionContext.containerView.addSubview(toVC.view)toVC.view.frame = transitionContext.finalFrame(for: toVC) 先获取fromVC并将其转换为MasterViewController；然后，获取toVC并转换为DetailViewController。最后，只需将toVC.view添加到转场容器视图中，并将其frame设置为transitionContext中的最终frame，这是详情页面在主屏幕上的最终位置。 将以下内容添加到animateTransition()中： 123let animation = CABasicAnimation(keyPath: "transform")animation.fromValue = NSValue(caTransform3D: CATransform3DIdentity)animation.toValue = NSValue(caTransform3D: CATransform3DConcat(CATransform3DMakeTranslation(0.0, -10.0, 0.0), CATransform3DMakeScale(150.0, 150.0, 1.0))) 这个动画将logo的大小增加了150倍，并同时向上移动了一点。 为什么？ logo的形状不均匀，我希望后面的视图控制器通过RW形状的“孔”显示。 将其向上移动意味着缩放图像的底部将更快地覆盖屏幕。 如果使用像圆形或椭圆形这种对称的logo，就不会有这种问题。 现在将以下面代码添加到animateTransition()以稍微优化动画： 12345animation.duration = animationDurationanimation.delegate = selfanimation.fillMode = kCAFillModeForwardsanimation.isRemovedOnCompletion = falseanimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn) 这些都是前面章节的知识。 RevealAnimator目前还不是动画代理，记得要让RevealAnimator遵守CAAnimationDelegate 协议。 在animateTransition()中添加图层： 1234let maskLayer: CAShapeLayer = RWLogoLayer.logoLayer()maskLayer.position = fromVC.logo.positiontoVC.view.layer.mask = maskLayermaskLayer.add(animation, forKey: nil) 效果： 优化细节细看上面的效果，会发现动画运行时，原来的logo还在那里，下面解决这个问题。 在animateTransition()中添加： 1fromVC.logo.add(animation, forKey: nil) 运行后，没有有原始的logo了： 还有一个稍微复杂一点的问题：在第一次推送转场后，导航不再工作了？ 在 RevealAnimator中实现CAAnimationDelegate的animationDidStop(_:finished:)方法： 1234567func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123; if let context = storedContext &#123; context.completeTransition(!context.transitionWasCancelled) // reset logo &#125; storedContext = nil&#125; 在方法结束时，只需将转场上下文设置为nil。 由于显示动画在完成后不会自动删除，因此需要自己处理。 使用以下内容替换位于animationDidStop()中的// reset logo： 123let fromVC = context.viewController(forKey: .from) as! MasterViewControllerfromVC.logo.removeAllAnimations() 只需要在推送转场期间屏蔽视图控制器的内容，一旦视图控制器完成转场，就可以安全地移除屏蔽。 接着上面的代码t添加： 12let toVC = context.viewController(forKey: .to) as! DetailViewControllertoVC.view.layer.mask = nil 运行报错： 这是因为，上面的代码只适用于推送，但不适用于弹出。 把animateTransition()中除了第一行storedContext = transitionContext的代码，都包含在if语句中： 123if operation == .push &#123; ...&#125; 淡入新视图控制器转场时，给详情页面添加淡入的动画。 在animateTransition(using:)的if operation == .push {语句中添加： 12345let fadeIn = CABasicAnimation(keyPath: "opacity")fadeIn.fromValue = 0.0fadeIn.toValue = 1.0fadeIn.duration = animationDurationtoVC.view.layer.add(fadeIn, forKey: nil) 弹出转场前面都是推送转场，现在添加是弹出转场。 给在animateTransition(using:)的if语句添加一个else ： 123456789101112else &#123; let fromView = transitionContext.view(forKey: .from)! let toView = transitionContext.view(forKey: .to)! transitionContext.containerView.insertSubview(toView, belowSubview: fromView) UIView.animate(withDuration: animationDuration, delay: 0.0, options: .curveEaseIn, animations: &#123; fromView.transform = CGAffineTransform(scaleX: 0.01, y: 0.01) &#125;) &#123; (_) in transitionContext.completeTransition(!transitionContext.transitionWasCancelled) &#125;&#125; 最终效果会是： 19-交互式导航控制器转场您不仅可以为转换创建自定义动画 - 还可以使其交互并响应用户的操作。通常，您通过平移手势驱动此操作，这是您将在本章中采用的方法。当您完成后，您的用户将能够通过在屏幕上滑动手指来来回穿过显示转场。那会有多酷？是的，我以为你会感兴趣！继续阅读，了解它是如何完成的！ 关于手势处理，可看我的一篇简单的小结 iOS tutorial 13：手势处理。 本章开始项目使用上一章节完成的项目。 创建交互式转场当导航控制器向其代理询问动画控制器（就是之前提到Animator）时，可能会发生两件事。返回nil，在这种情况下，导航控制器会运行标准转场动画； 如果返回一个动画控制器，那么导航控制器除了会向其代理询问转场动画控制器，也会询问交互控制器，如下所示： 交互控制器根据用户的操作移动转场，而不是简单地从开始到结束动画更改。 交互控制器不一定需要是与动画控制器分开的类；实际上，当两个控制器在同一个类中时，执行某些任务会更容易一些。 您只需要确保所述类遵守UIViewControllerAnimatedTransitioning和UIViewControllerInteractiveTransitioning两个协议。 UIViewControllerInteractiveTransitioning只有一个必需实现的方法 startInteractiveTransition(_:) ，它将转换上下文作为参数。 然后，交互控制器会定期调用updateInteractiveTransition（_ :)来移动转换。 首先，您需要更改处理用户输入的方式。 处理平移手势把点击手势修改成平移手势。平移手势可观察到转场的开始、过程和结束的状态。 先把底部的标签的文本修改成 Slide to start。 接下来，在MasterViewController.swift的viewDidAppear(_:)中删除以下代码： 12let tap = UITapGestureRecognizer(target: self, action: #selector(didTap))view.addGestureRecognizer(tap) 替代为平移手势识别代码： 12let pan = UIPanGestureRecognizer(target: self, action: #selector(didPan(_:)))view.addGestureRecognizer(pan) 当用户在屏幕上滑动是，会被识别然后调用didPan(_:)方法。 在MasterViewController中添加空didPan(_:)。 使用交互式动画师类为了处理上面的转场，需要使用内置的交互式动画师类：UIPercentDrivenInteractiveTransition。 此类遵守UIViewControllerInteractiveTransitioning协议，并可以将转场的进度表示为完成百分比。 打开RevealAnimator.swift，并更新文件顶部的类定义，如下所示： 1class RevealAnimator: UIPercentDrivenInteractiveTransition, UIViewControllerAnimatedTransitioning, CAAnimationDelegate &#123; 请注意，UIPercentDrivenInteractiveTransition是一个类，而不是其他协议，所以需要处于第一位置。 添加一个属性，来表示是否已交互方式驱动转场动画： 1var interactive = false 添加方法到RevealAnimator中： 123func handlePan(_ recognizer: UIPanGestureRecognizer) &#123;&#125; 当用户在屏幕上平移时，识别器将被传递给RevealAnimator中的handlePan(_:)处理，来更新当前的转场进度。 在MasterViewController.swift中添加委托方法： 123456func navigationController(_ navigationController: UINavigationController, interactionControllerFor animationController: UIViewControllerAnimatedTransitioning) -&gt; UIViewControllerInteractiveTransitioning? &#123; if !transition.interactive &#123; return nil &#125; return transition&#125; 当希望转场为交互式时，只需返回交互式控制器，否则返回nil。 现在，需要将平移手势识别器连接到交互控制器。 在didPan(_:)中添加： 1234567switch recognizer.state &#123; case .began: transition.interactive = true performSegue(withIdentifier: "details", sender: nil) default: transition.handlePan(recognizer)&#125; 当平移手势开始时，确保交互设置为true，然后通过 segue 连接到下一个视图控制器。 执行segue将启动转场，这时动画控制器和交互控制器的委托方法将返回转场动画。 如果手势已经开始，只需将操作交给交互控制器，如下图所示： 计算转场动画的进度平移手势处理程序中最重要的一点是要弄清楚转场的进度。 打开RevealAnimator.swift，并将以下代码添加到handlePan中： 123let translation = recognizer.translation(in: recognizer.view!.superview!)var progress: CGFloat = abs(translation.x / 200.0)progress = min(max(progress, 0.01), 0.99) 通过平移手势识别器计算转场的经度。从逻辑上讲，用户离开初始位置越远，转场的进度就越大。 200.0是一个合理的任意数字，来表示转场完成所需要的距离。 下面更新转场动画的进度，将以下代码添加到handlePan()中： 123456switch recognizer.state &#123; case .changed: update(progress) default: break&#125; update() 是来自UIPercentDrivenInteractiveTransition的方法，它设置转场动画的当前进度。 当用户在屏幕上平移时，手势识别器会重复调用MasterViewController中didPan()，从而不停的调用RevealAnimator中 的handlePan()来更新转场进度。 在RevealAnimator中添加属性： 1private var pausedTime: CFTimeInterval = 0 现在，通过将以下代码添加到animateTransition(using:)来控制图层： 123456if interactive &#123; let transitionLayer = transitionContext.containerView.layer pausedTime = transitionLayer.convertTime(CACurrentMediaTime(), from: nil) transitionLayer.speed = 0 transitionLayer.timeOffset = pausedTime&#125; 这里做的是阻止图层运行自己的动画。 这将冻结所有子图层动画。 重写update(_:)，以将图层与动画一起移动： 123456override func update(_ percentComplete: CGFloat) &#123; super.update(percentComplete) let animationProgress = TimeInterval(animationDuration) * TimeInterval(percentComplete) storedContext?.containerView.layer.timeOffset = pausedTime + animationProgress&#125; 运行效果： 这边出现问题，就是手指离开屏幕后，动画立即停止，再次滑动时也没有反应。 处理提前终止处理上面的问题。 在handlePan()的switch语句中添加case： 123456case .cancelled, .ended: if progress &lt; 0.5 &#123; cancel() &#125; else &#123; finish() &#125; 在用户手指离开屏幕之前，如果平移得足够远，就表示转场完成，呈现新的视图控制器；相反，就滚回原来的视图控制器。 重写cancel() 和 finish()方法： 123456789101112131415override func cancel() &#123; restart(forFinishing: false) super.cancel()&#125;override func finish() &#123; restart(forFinishing: true) super.finish()&#125;private func restart(forFinishing: Bool) &#123; let transitionLayer = storedContext?.containerView.layer transitionLayer?.beginTime = CACurrentMediaTime() transitionLayer?.speed = forFinishing ? 1 : -1&#125; 在.cancelled，.ended的case中添加： 1interactive = false 本章最后的效果：]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
        <tag>转场</tag>
        <tag>视图控制器的转场动画</tag>
        <tag>View Controller Transition Animations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习iOS动画之三：图层动画]]></title>
    <url>%2F2018%2FiOS-Animation-3-Layer-Animations.html</url>
    <content type="text"><![CDATA[本文是我学习《iOS Animations by Tutorials》 笔记中的一篇。文中详细代码都放在我的Github上 andyRon/LearniOSAnimations。 系统学习iOS动画之一：视图动画 学习了创建视图动画（View Animations），这一部分学习功能更强大、更偏底层的Core Animation(核心动画) APIs。核心动画的这个名字可能令人有点误解，暂时可以理解为本文的标题图层动画(Layer Animations)。 在本书的这一部分中，将学习动画层而不是视图以及如何使用特殊图层。 图层是一个简单的模型类，它公开了许多属性来表示一些基于图像的内容。 每个UIView都有一个图层支持(都有一个layer属性)。 视图 vs 图层 由于以下原因，图层(Layers)与视图(Views)（对于动画）不同： 图层是一个模型对象 —— 它公开数据属性并且不实现任何逻辑。 它没有复杂的自动布局依赖关系，也不用处理用户交互。 图层具有预定义的可见特征 —— 这些特征是许多影响内容在屏幕上呈现的数据属性，例如边框线，边框颜色，位置和阴影。 最后，Core Animation优化了图层内容的缓存并直接在GPU上快速绘图。 单个来说，两者的优点。 视图： 复杂视图层次结构布局，自动布局等。 用户交互。 通常具有在CPU上的主线程上执行的自定义逻辑或自定义绘图代码。 非常灵活，功能强大，子类很多类。 图层： 更简单的层次结构，更快地解决布局，绘制速度更快。 没有响应者链开销。 默认情况下没有自定义逻辑 并直接在GPU上绘制。 不那么灵活，子类的类更少。 视图和图层的选择技巧： 任何时候都可以选择视图动画; 当需要更高的性能时，就需要使用图层动画。 两者在架构中的位置： 预览： 本文比较长，图片比较多，预警⚠️😀。 8-图层动画入门 —— 从最简单的图层动画开始，了解调试动画错误的方法。9-动画的Keys和代理 —— 怎么更好地控制当前运行的动画，并使用代理方法对动画事件做出响应。10-动画组和时间控制 —— 组合许多简单的动画，并将它们作为一个组一起运行。11-图层弹簧动画 —— 学习如何使用CASpringAnimation创建强大而灵活的弹簧图层动画。12-图层关键帧动画和结构属性 —— 学习图层关键帧动画， 动画结构属性的一些特殊处理。 接下来，学习几个专门的图层： 13-形状和蒙版 —— 通过CAShapeLayer在屏幕上绘制形状，并为其特殊路径属性设置动画。14-渐变动画 —— 了解如何使用CAGradientLayer来绘制渐变和动画渐变。15-Stroke和路径动画 —— 以交互方式绘制形状，并使用关键帧动画的一些强大功能。16-复制动画 —— 学习如何创建图层内容的多个副本，然后利用副本制作动画。 8-图层动画入门图层动画的工作方式与视图动画非常相似; 只需在定义的时间段内为起始值和结束值之间的属性设置动画，然后让Core Animation处理两者之间的渲染。 但是，图层动画具有比视图动画更多的可动画属性; 在设计效果时，这会提供了很多选择和灵活性; 图层动画还有许多专门的CALayer子类（如CATextLayer、 CAShapeLayer 、 CATransformLayer 、CAGradientLayer、CAReplicatorLayer、CAScrollLayer、CAEmitterLayer、AVPlayerLayer等），这些子类有提供了许多其他属性。 本章介绍CALayer和Core Animation的基础知识。 可动画属性可与视图动画的可动画属性对照着看。 位置 和 大小bounds、position、transform 边borderColor、 borderWidth、cornerRadius 阴影 shadowOffset： 使阴影看起来更接近或更远离图层。shadowOpacity：使阴影淡入或淡出。shadowPath： 更改图层阴影的形状。 可以创建不同的3D效果，使图层看起来像浮动在不同的阴影形状和位置上。shadowRadius： 控制阴影的模糊; 当模拟视图朝向或远离投射阴影的表面移动时，这尤其有用。 内容contents ：修改此项以将原始TIFF或PNG数据指定为图层内容。 mask ：修改它将用于掩盖图层可见内容的形状或图像。 这个属性在13-形状和蒙版将详细介绍和使用。 opacity 第一个图层动画开始项目使用 3-过渡动画完成的项目。 把原本head的视图动画替换为图层动画。 分别删除ViewController的viewWillAppear()中： 1heading.center.x -= view.bounds.width 和viewDidAppear()中: 123UIView.animate(withDuration: 0.5) &#123; self.heading.center.x += self.view.bounds.width&#125; 在viewWillAppear()的开始（super调用后）添加： 1234let flyRight = CABasicAnimation(keyPath: "position.x")flyRight.fromValue = -view.bounds.size.width/2flyRight.toValue = view.bounds.size.width/2flyRight.duration = 0.5 核心动画中的动画对象只是简单的数据模型; 上面的代码创建了CABasicAnimation的实例，并设置了一些数据属性。这个实例描述了一个潜在的图层动画：可以选择立即运行，稍后运行，或者根本不运行。 由于动画未绑定到特定图层，因此可以在其他图层上重复使用动画，每个图层将独立运行动画的副本。 在动画模型中，您可以将要设置为动画的属性指定为keypath参数(比如上面设置是&quot;position.x&quot;); 这很方便，因为动画总是在图层中设置。 接下来，为在keypath上指定的属性设置fromValue和toValue。需要动画对象（此处我要处理的是heading）从屏幕左侧到屏幕中央。动画持续时间的概念没有改变; duration设置为0.5秒。 动图已经设置完成，现在需要把它添加需要运行此动画的图层上。 在刚添加的代码下方添加，将动画添加到heading的图层： 1heading.layer.add(flyRight, forKey: nil) add(_:forKey:)会把动画做个一个拷贝给将要添加的图层。 如果之后需要更改或停止动画，可以添加forKey参数用于识别动画。 此时的动画看上去和之前视图动画没有什么区别。 更多图层动画知识同一样的方法应用在Username Filed上，删除viewWillAppear()和viewDidAppear()中对应代码。再把之前的动画添加的Username Filed的layer上： 1username.layer.add(flyRight, forKey: nil) 此时运行项目，看上去会有点别扭，因为heading Label，Username Filed的动画是相同的，Username Filed没有之前的延迟效果。 在添加动画到Username Filed的layer上之前，添加： 1flyRight.beginTime = CACurrentMediaTime() + 0.3 动画的beginTime属性设置动画应该开始的绝对时间; 在这种情况下，可以使用CACurrentMediaTime()获取当前时间(系统的一个绝对时间，机器开启时间，取自机器时间 mach_absolute_time())，并以秒为单位添加所需的延迟。 此时，如果仔细观察会发现有个问题，Username Filed在开始动画之前已经出现了，这就涉及到另外一个图层动画属性 fillMode 了。 关于 fillMode以Username Field的移动动画来看看fillMode不同值的区别，为了方便观察，我把beginTime时间变大，代码类似于： 123456789let flyRight = CABasicAnimation(keyPath: "position.x")flyRight.fromValue = -view.bounds.size.width/2flyRight.toValue = view.bounds.size.width/2flyRight.duration = 0.5heading.layer.add(flyRight, forKey: nil)flyRight.beginTime = CACurrentMediaTime() + 2.3flyRight.fillMode = kCAFillModeRemovedusername.layer.add(flyRight, forKey: nil) kCAFillModeRemoved 是fillMode的默认值 在定义的beginTime处启动动画(如果未设置beginTime，也就是beginTime等于CACurrentMediaTime()，则立即启动动画)， 并在动画完成时删除动画期间所做的更改： 实际效果： now 到 begin 这段时间动画没有开始，但Username Field直接显示了，然后到 begin时动画才开始，这就是之前遇到的情况。 kCAFillModeBackwards 无论动画的实际开始时间如何，kCAFillModeBackwards都会立即在屏幕上显示动画的第一帧，并在以后启动动画: 实际效果： 第一帧在fromValue处，也就是&quot;position.x&quot;是负的在屏幕外，因此开始时没有看见Username Field，等待2.3s后动画开始。 kCAFillModeForwards kCAFillModeForwards像往常一样播放动画，但在屏幕上保留动画的最后一帧，直到您删除动画： 实际效果： 除了设置kCAFillModeForwards之外，还需要对图层进行一些其他更改以使最后一帧“粘贴”。 你将在本章后面稍后了解这一点。 和第一个有点类似，但还是有区别的。 kCAFillModeBoth kCAFillModeBoth是kCAFillModeForwards和kCAFillModeBackwards的组合; 这会使动画的第一帧立即出现在屏幕上，并在动画结束时在屏幕上保留最终帧： 实际效果： 要解决之前发现的问题，将使用kCAFillModeBoth。 同样对于Password Field，也删除其视图动画的代码，改换成类似Username Field的图层动画，不过beginTime要晚一点，具体代码： 123456flyRight.beginTime = CACurrentMediaTime() + 0.3flyRight.fillMode = kCAFillModeBothusername.layer.add(flyRight, forKey: nil)flyRight.beginTime = CACurrentMediaTime() + 0.4password.layer.add(flyRight, forKey: nil) 到目前为止，您的动画恰好在表单元素最初位于Interface Builder中的确切位置结束。 但是，很多时候情况并非如此。 调试动画在上面的动画后继续添加： 12username.layer.position.x -= view.bounds.widthpassword.layer.position.x -= view.bounds.width 这就是把两个文本框的图层移动到屏幕外，类似于flyRight.fromValue = -view.bounds.size.width/2（此时这段代码可以暂时注释掉），运行后发现问题，动画结束后两个文本框消失了，这是怎么回事呢？ 继续在上面的代码后添加一个延迟函数： 123delay(seconds: 5.0) print("where are the fields?")&#125; 并打断点后运行： 进入UI hierarchy 窗口： UI hierarchy 模式下可以查看当前运行时的UI层次结构，包括已经隐藏或透明视图以及在屏幕外的视图。还可以3D查看。 当然还可以在右侧检测器中查看实时属性： 动画完成后，代码更改会导致字段跳回其初始位置。 但为什么？ 动画 vs 真实内容当你为Text Field设置动画时，你实际上并没有看到Text Field本身是动画的; 相反，你会看到它的缓存版本，称为presentation layer（显示层）。动画完成后原始图层再次到原本位置，则从屏幕上移除presentation layer。首先，请记住在viewWillAppear(_:)中将Text Field设置在屏幕外： 动画开始时，Text Field暂时隐藏，预渲染的动画对象将替代它： 现在无法点击动画对象，输入任何文本或使用任何其他特定文本字段功能，因为它不是真正的文本字段，只是可见的“幻像”。动画一旦完成，它就会从屏幕上消失，原始Text Field将被取消隐藏。但它此时的位置还在屏幕左侧！ 要解决这个难题，您需要使用另一个CABasicAnimation属性：isRemovedOnCompletion。 将fillMode设置为kCAFillModeBoth可让动画在完成后保留在屏幕上，并在动画开始之前显示动画的第一帧。要完成效果，您需要相应地设置removedOnCompletion，两者的组合将使动画在屏幕上可见。在设置fillMode之后，将以下行添加到viewWillAppear()： 1flyRight.isRemovedOnCompletion = false isRemovedOnCompletion默认为true，因此动画一完成就会消失。将其设置为false并将其与正确的fillMode组合可将动画保留在屏幕上 。 现在运行项目，应该能看到所有元素都按预期保留在屏幕上。 更新图层模型从屏幕上删除图层动画后，图层将回退到其当前位置和其他属性值。 这意味着您通常需要更新图层的属性以反映动画的最终值。 虽然前面已经说明过把isRemovedOnCompletion设置成false是如何工作的，但尽可能避免使用它。 在屏幕上保留动画会影响性能，因此需要自动删除它们并更新原始图层的位置。 需要把原始图层设置到屏幕中间，在viewWillAppear中天假： 12username.layer.position.x = view.bounds.size.width/2password.layer.position.x = view.bounds.size.width/2 当然此时要注意把之前注释掉的flyRight.fromValue = -view.bounds.size.width/2，去掉注释，也要把调试动画时的代码去掉。 使用图层动画实现☁️的淡入删除viewWillAppear()中把四个☁️透明度设为0.0的代码，和viewDidAppear()的☁️的视图动画。 然后在viewDidAppear()加入： 1234567891011121314151617let cloudFade = CABasicAnimation(keyPath: "alpha")cloudFade.duration = 0.5cloudFade.fromValue = 0.0cloudFade.toValue = 1.0cloudFade.fillMode = kCAFillModeBackwardscloudFade.beginTime = CACurrentMediaTime() + 0.5cloud1.layer.add(cloudFade, forKey: nil)cloudFade.beginTime = CACurrentMediaTime() + 0.7cloud2.layer.add(cloudFade, forKey: nil)cloudFade.beginTime = CACurrentMediaTime() + 0.9cloud3.layer.add(cloudFade, forKey: nil)cloudFade.beginTime = CACurrentMediaTime() + 1.1cloud4.layer.add(cloudFade, forKey: nil) 登录按钮背景颜色变化的动画把原登录按钮背景颜色变化的动画修改成图层动画。 删除logIn()中的： 1self.loginButton.backgroundColor = UIColor(red: 0.85, green: 0.83, blue: 0.45, alpha: 1.0) 删除resetForm()中的： 1self.loginButton.backgroundColor = UIColor(red: 0.63, green: 0.84, blue: 0.35, alpha: 1.0) 在ViewController.swift文件中创建一个全局的背景颜色变化动画函数： 12345678func tintBackgroundColor(layer: CALayer, toColor: UIColor) &#123; let tint = CABasicAnimation(keyPath: "backgroundColor") tint.fromValue = layer.backgroundColor tint.toValue = toColor.cgColor tint.duration = 0.5 layer.add(tint, forKey: nil) layer.backgroundColor = toColor.cgColor&#125; 在logIn()中添加： 12let tintColor = UIColor(red: 0.85, green: 0.83, blue: 0.45, alpha: 1.0)tintBackgroundColor(layer: loginButton.layer, toColor: tintColor) 在resetForm()中登录按钮动画方法的completion闭包中添加： 1234completion: &#123; _ in let tintColor = UIColor(red: 0.63, green: 0.84, blue: 0.35, alpha: 1.0) tintBackgroundColor(layer: self.loginButton.layer, toColor: tintColor)&#125;) 登录按钮的圆角动画在ViewController.swift文件中创建一个全局的圆角变化动画函数： 12345678func roundCorners(layer: CALayer, toRadius: CGFloat) &#123; let round = CABasicAnimation(keyPath: "cornerRadius") round.fromValue = layer.cornerRadius round.toValue = toRadius round.duration = 0.33 layer.add(round, forKey: nil) layer.cornerRadius = toRadius&#125; 在logIn()中添加： 1roundCorners(layer: loginButton.layer, toRadius: 25.0) 在resetForm()中登录按钮动画方法的completion闭包中添加： 1roundCorners(layer: self.loginButton.layer, toRadius: 10.0) 两种状态的变化： 两个动画函数tintBackgroundColor和roundCorners最后都需要把动画最变化最终值赋值给动画的属性，这对应于前面的 动画 vs 真实内容 章节 本章节的最终效果： 9-动画的Keys和代理关于视图动画和相应的闭包语法的一个棘手问题是，一旦您创建并运行视图动画，您就无法暂停，停止或以任何方式访问它。 但是，使用核心动画，您可以轻松检查在图层上运行的动画，并在需要时停止它们。 此外，您甚至可以在动画上设置委托对象并对动画事件做出反应。 本章的开始项目使用上一章完成的项目 动画代理介绍 CAAnimationDelegate的两个代理方法： 12func animationDidStart(_ anim: CAAnimation)func animationDidStop(_ anim: CAAnimation, finished flag: Bool) 做个小测试，在flyRight初始化时，添加： 1flyRight.delegate = self 对ViewController添加扩展，并实现一个代理方法： 123456extension ViewController: CAAnimationDelegate &#123; func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123; print(anim.description, "动画完成") &#125;&#125; 运行，打印结果： 123&lt;CABasicAnimation: 0x6000032376e0&gt; 动画完成&lt;CABasicAnimation: 0x600003237460&gt; 动画完成&lt;CABasicAnimation: 0x600003237480&gt; 动画完成 会发现animationDidStop(_:finished:)方法被调用三次，并且每次调用的动画都不同，这因为当每一次调用layer.add(_:forKey:)把动画添加给图层时，都会拷贝一份，这在前面的图层动画基础知识中说明过。 KVOCAAnimation类及其子类是用Objective-C编写的，并且符合键值编码(KVO)，这意味着您可以将它们视为字典，并在运行时向它们添加新属性。(关于KVO，可查看我的小结文章 OC中的键/值编码(KVC)) 使用此机制为flyRight动画指定名称，以便之后可以从其他活动动画中识别它。 在viewWillAppear()中的flyRight.delegate = self后添加： 12flyRight.setValue("form", forKey: "name")flyRight.setValue(heading.layer, forKey: "layer") 在上面的代码中，在flyRight动画上创建键为&quot;name&quot;，值为&quot;form&quot;的键值对，可以从委托回调方法调用识别； 也创建了一个键为&quot;layer&quot;，值为heading.layer的键值对，以方便之后引用动画所属的图层。 同样的可以添加(之前已经说过每次动画都会拷贝一份，所以不会覆盖)： 12345flyRight.setValue(username.layer, forKey: "layer")// ...flyRight.setValue(password.layer, forKey: "layer") 在代理回调方法中验证上面的代码，上面的移动动画结束后再添加一个简单的脉动动画： 123456789101112131415161718func animationDidStop(_ anim: CAAnimation, finished flag: Bool) &#123; // print(anim.description, "动画完成") guard let name = anim.value(forKey: "name") as? String else &#123; return &#125; if name == "form" &#123; // `value(forKey:)`的结果总是`Any`，因此需要转换为所需类型 let layer = anim.value(forKey: "layer") as? CALayer anim.setValue(nil, forKey: "layer") // 简单的脉动动画 let pulse = CABasicAnimation(keyPath: "transform.scale") pulse.fromValue = 1.25 pulse.toValue = 1.0 pulse.duration = 0.25 layer?.add(pulse, forKey: nil) &#125;&#125; 注意: layer?.add()意味着如果动画中没有存储图层，则会跳过add(_:forKey:)的调用。 这是Swift中的可选链式调用，可参考以撸代码的形式学习Swift-17：可选链式调用(Optional Chaining) 移动动画结束后有一个简单变大的脉动动画效果： 动画Keysadd(_:forKey:)中的参数forKey(注意不要和setValue(_:forKey:)中的forKey混淆)，之前一直没使用。 在这部分中，将创建另一个图层动画，学习如何一次运行多个动画，并了解如何使用动画Keys控制正在运行的动画。 添加一个新标签，新标签将从右到左缓慢动画，用来提示用户输入。 一旦用户开始输入他们的用户名或密码（Text Field获得焦点），该标签将停止移动并直接跳到其最终位置（居中位置）。 一旦用户知道该怎么做就没有必要继续动画。 在ViewController中添加属性 let info = UILabel()，并在viewDidLoad()中配置： 1234567info.frame = CGRect(x: 0.0, y: loginButton.center.y + 60.0, width: view.frame.size.width, height: 30)info.backgroundColor = UIColor.clearinfo.font = UIFont(name: "HelveticaNeue", size: 12.0)info.textAlignment = .centerinfo.textColor = UIColor.whiteinfo.text = "Tap on a field and enter username and password"view.insertSubview(info, belowSubview: loginButton) 为info添加两个动画: 123456789101112// 提示信息Label的两个动画let flyLeft = CABasicAnimation(keyPath: "position.x")flyLeft.fromValue = info.layer.position.x + view.frame.size.widthflyLeft.toValue = info.layer.position.xflyLeft.duration = 5.0info.layer.add(flyLeft, forKey: "infoappear")let fadeLabelIn = CABasicAnimation(keyPath: "opacity")fadeLabelIn.fromValue = 0.2fadeLabelIn.toValue = 1.0fadeLabelIn.duration = 4.5info.layer.add(fadeLabelIn, forKey: "fadein") flyLeft是从左到右移动的动画，fadeLabelIn是透明度渐渐变大的动画。 此时的动画效果如下： 为Text Field添加代理。通过扩展，让ViewController遵循UITextFieldDelegate协议： 12345678extension ViewController: UITextFieldDelegate &#123; func textFieldDidBeginEditing(_ textField: UITextField) &#123; guard let runningAnimations = info.layer.animationKeys() else &#123; return &#125; print(runningAnimations) &#125;&#125; 在viewDidAppear()中添加： 12username.delegate = selfpassword.delegate = self 此时运行，info动画还在进行时点击文本框，会打印动画key值： 1[&quot;infoappear&quot;, &quot;fadein&quot;] 在 textFieldDidBeginEditing(:)里添加: 1info.layer.removeAnimation(forKey: "infoappear") 点击文本框后，删除从左向右移动的动画，info立即到达终点，也就是屏幕中央： 当然也可以通过removeAllAnimations()方法删除layer上的所有动画。 注意：动画进行完了，会默认被从layer上删除，也就是animationKeys()方法将获得不到动画keys了。 修改☁️的动画通过本章所学的动画代理和动画KVO修改☁️的动画 先在ViewController中添加动画方法： 12345678910111213/// 云的图层动画func animateCloud(layer: CALayer) &#123; let cloudSpeed = 60.0 / Double(view.layer.frame.size.width) let duration: TimeInterval = Double(view.layer.frame.size.width - layer.frame.origin.x) * cloudSpeed let cloudMove = CABasicAnimation(keyPath: "position.x") cloudMove.duration = duration cloudMove.toValue = self.view.bounds.width + layer.bounds.width/2 cloudMove.delegate = self cloudMove.setValue("cloud", forKey: "name") cloudMove.setValue(layer, forKey: "layer") layer.add(cloudMove, forKey: nil)&#125; 把viewDidAppear()中的四个animateCloud方法调用替代为： 1234animateCloud(layer: cloud1.layer)animateCloud(layer: cloud2.layer)animateCloud(layer: cloud3.layer)animateCloud(layer: cloud4.layer) 让☁️不停的移动，在动画代理方法animationDidStop中添加： 12345678910if name == "cloud" &#123; if let layer = anim.value(forKey: "layer") as? CALayer &#123; anim.setValue(nil, forKey: "layer") layer.position.x = -layer.bounds.width/2 delay(0.5) &#123; self.animateCloud(layer: layer) &#125; &#125;&#125; 本章的效果： 10-动画组和时间控制在上一章中，学习了如何向单个图层添加多个独立动画。 但是，如果您希望您的动画同步工作并保持彼此一致，该怎么办？ 这就用到动画组(animation groups)。 本章介绍如何使用CAAnimationGroup对动画进行分组，可以向组中添加多个动画并同时调整持续时间，委托和timingFunction等属性。对动画进行分组会产生简化的代码，并确保您的所有动画将作为一个实体单元同步。 本章的开始项目使用上一章完成的项目 CAAnimationGroup删除viewWillAppear()中的: 12loginButton.center.y += 30.0loginButton.alpha = 0.0 删除viewDidAppear()中登录按钮的显示动画： 1234UIView.animate(withDuration: 0.5, delay: 0.5, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.0, options: [], animations: &#123; self.loginButton.center.y -= 30.0 self.loginButton.alpha = 1.0&#125;, completion: nil) 在viewDidAppear()中组动画添加： 1234let groupAnimation = CAAnimationGroup()groupAnimation.beginTime = CACurrentMediaTime() + 0.5groupAnimation.duration = 0.5groupAnimation.fillMode = kCAFillModeBackwards CAAnimationGroup继承于CAAnimation，也有beginTime, duration, fillMode, delegate等属性。 继续三个动画，并把它们加入到上面的组动画中： 1234567891011121314let scaleDown = CABasicAnimation(keyPath: "transform.scale")scaleDown.fromValue = 3.5scaleDown.toValue = 1.0let rotate = CABasicAnimation(keyPath: "transform.rotation")rotate.fromValue = .pi / 4.0rotate.toValue = 0.0let fade = CABasicAnimation(keyPath: "opacity")fade.fromValue = 0.0fade.toValue = 1.0groupAnimation.animations = [scaleDown, rotate, fade]loginButton.layer.add(groupAnimation, forKey: nil) 登录按钮的效果为： 动画缓动图层动画中的动画缓动与1-视图动画入门中介绍的视图动画的动画选项的，在概念上是相同的， 只是语法有所不同。 图层动画中的动画缓动通过类CAMediaTimingFunction来表示 。用法如下： 1groupAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseIn) name参数有如下几种，和视图动画中的差不多： kCAMediaTimingFunctionLinear 速度不变化 kCAMediaTimingFunctionEaseIn 开始时慢，结束时快 kCAMediaTimingFunctionEaseOut 开始时快，结束时慢 kCAMediaTimingFunctionEaseInEaseOut 开始结束都慢，中间快 可以试一下不同的效果。 另外CAMediaTimingFunction有个初始化方法init(controlPoints c1x: Float, _ c1y: Float, _ c2x: Float, _ c2y: Float)，可以自定义缓动模式，具体可参考官方文档 更多动画时间控制的选项重复动画repeatCount 可设置重复动画指定的次数。为提示信息Label的动画添加重复次数，在viewDidAppear()中为flyLeft动画设置属性： 1flyLeft.repeatCount = 4 另外一个repeatDuration可用来设置总重复时间。 和视图动画一样，也要设置autoreverses，要不然不连贯： 1flyLeft.autoreverses = true 现在效果看着不错了，但是还有点问题，就是4次重复结束后，会直接跳到屏幕中心，如下（由于太长，gif已经省略了前几次滚动）： 这也很好理解，最后一个循环以标签离开屏幕结束。解决办法就是半个动画周期： 1flyLeft.repeatCount = 2.5 改变动画的速度可以通过设置速度属性来独立于持续时间来控制动画的速度。 1flyLeft.speed = 2.0 把三个form的动画修改为动画组下面代码： 1234567891011121314151617181920let flyRight = CABasicAnimation(keyPath: "position.x")flyRight.fromValue = -view.bounds.size.width/2flyRight.toValue = view.bounds.size.width/2flyRight.duration = 0.5flyRight.fillMode = kCAFillModeBothflyRight.delegate = selfflyRight.setValue("form", forKey: "name")flyRight.setValue(heading.layer, forKey: "layer")heading.layer.add(flyRight, forKey: nil)flyRight.setValue(username.layer, forKey: "layer")flyRight.beginTime = CACurrentMediaTime() + 0.3username.layer.add(flyRight, forKey: nil)flyRight.setValue(password.layer, forKey: "layer")flyRight.beginTime = CACurrentMediaTime() + 0.4password.layer.add(flyRight, forKey: nil) 修改为： 12345678910111213141516171819202122232425let formGroup = CAAnimationGroup()formGroup.duration = 0.5formGroup.fillMode = kCAFillModeBackwardslet flyRight = CABasicAnimation(keyPath: "position.x")flyRight.fromValue = -view.bounds.size.width/2flyRight.toValue = view.bounds.size.width/2let fadeFieldIn = CABasicAnimation(keyPath: "opacity")fadeFieldIn.fromValue = 0.25fadeFieldIn.toValue = 1.0formGroup.animations = [flyRight, fadeFieldIn]heading.layer.add(formGroup, forKey: nil)formGroup.delegate = selfformGroup.setValue("form", forKey: "name")formGroup.setValue(username.layer, forKey: "layer")formGroup.beginTime = CACurrentMediaTime() + 0.3username.layer.add(formGroup, forKey: nil)formGroup.setValue(password.layer, forKey: "layer")formGroup.beginTime = CACurrentMediaTime() + 0.4password.layer.add(formGroup, forKey: nil) 本章节的最终效果： 11-图层弹簧动画前面视图动画中的2-弹簧动画可以用于创建一些相对简单的弹簧式动画，而本章节学习的图层弹簧动画(Layer Springs)可以呈现一个看起来更自然的物理模拟。 本章的开始项目使用上一章完成的项目，添加一些新的图层弹簧动画，并说明两种弹簧动画之间的差异。 先说一些理论知识： 阻尼谐振子阻尼谐振子，Damped harmonic oscillators（直译就是，逐渐衰弱的振荡器），可以理解为逐渐衰减的振动。 UIKit API简化了弹簧动画的制作，不需要了解它们的原理就可以很方便的使用。 但是，由于您现在是核心动画专家，因此您需要深入研究细节。 钟摆，理想状况下钟摆是不停的摆动，像下面的一样： 对应的运动轨迹图就像： 但现实中由于能量的损耗，钟摆的摇摆的幅度会逐渐减小： 对应的运动轨迹： 这就是一个阻尼谐振子 。 钟摆停下来所需的时间长度，以及最终振荡器图形的方式取决于振荡系统的以下参数： 阻尼(damping)：由于空气摩擦、机械摩擦和其他作用在系统上的外部减速力。 质量(mass)：摆锤越重，摆动的时间越长。 刚度(stiffness)：振荡器的“弹簧”越硬（钟摆的“弹簧”是指地球的引力），钟摆摆动越困难，系统停下来也越快。想象一下，如果在月球或木星上使用这个钟摆；在低重力和高重力情况下的运动将是完全不同的。 初始速度(initial velocity)：推一下钟摆。 “这一切都非常有趣，但与弹簧动画有什么关系呢？” 阻尼谐振子系统是推动iOS中弹簧动画的动力。 下一节将更详细地讨论这个问题。 视图弹簧动画 vs 图层弹簧动画UIKit以动态方式调整所有其他变量，使系统在给定的持续时间内稳定下来。 这就是为什么UIKit弹簧动画有时有点被迫 停下来的感觉。 如果仔细观察会发现UIKit动画有点不太自然。 幸运的是，核心允许通过CASpringAnimation类为图层属性创建合适的弹簧动画。 CASpringAnimation在幕后为UIKit创建弹簧动画，但是当我们直接调用它时，可以设置系统的各种变量，让动画自己稳定下来。 这种方法的缺点是不能设置固定的持续时间（duration）；持续时间取决于提供的其它变量，然后系统计算所得。 CASpringAnimation的一些属性（对应之前振荡系统的参数）： damping 阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快 mass 质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大 stiffness 刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快 initialVelocity 初始速率，动画视图的初始速度大小。速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反 第一个图层弹簧动画BahamaAirLoginScreen项目中两个文本框移动动画结束后有个脉动动画，让用户知道该字段处于活动状态并可以使用。 然而，动画结束时有些突然。 通过用CASpringAnimation来让脉动动画更加自然一点。 把animationDidStop(_:finished:)动画代码： 123456// 简单的脉动动画let pulse = CABasicAnimation(keyPath: "transform.scale")pulse.fromValue = 1.25pulse.toValue = 1.0pulse.duration = 0.25layer?.add(pulse, forKey: nil) 转变为： 123456let pulse = CASpringAnimation(keyPath: "transform.scale")pulse.damping = 2.0pulse.fromValue = 1.25pulse.toValue = 1.0pulse.duration = pulse.settlingDurationlayer?.add(pulse, forKey: nil) 效果图前后对比： 这边要注意duration。要使用系统根据当前参数估算的弹簧动画从开始到结束的时间pulse.settlingDuration。 弹簧系统不能在0.25秒内稳定下来; 提供的变量意味着动画应该在它停止前再运行一段时间。关于如何切断弹簧动画的视觉演示： 如果抖动时间太长，可以加大阻尼系数damping，比如：pulse.damping = 7.5。 弹簧动画属性CASpringAnimation预定义的弹簧动画属性的默认值分别是： 1234damping: 10.0mass: 1.0stiffness: 100.0initialVelocity: 0.0 实现文本框的一个代理方法： 123456789101112func textFieldDidEndEditing(_ textField: UITextField) &#123; guard let text = textField.text else &#123; return &#125; if text.count &lt; 5 &#123; let jump = CASpringAnimation(keyPath: "position.y") jump.fromValue = textField.layer.position.y + 1.0 jump.toValue = textField.layer.position.y jump.duration = jump.settlingDuration textField.layer.add(jump, forKey: nil) &#125;&#125; 上面代码，表示当用户在文本中输入结束后，如果输入字符数小于5，出现一个小幅度的抖动动画，提醒用户太短了。 initialVelocity起始速度，默认值0。 在设置持续时间前添加，也就是在jump.duration = jump.settlingDuration前添加： 1jump.initialVelocity = 100.0 效果： 由于开始时的额外推动，文本框弹的更高了。 mass增加初始速度会使动画持续时间更长，如果增加质量会怎么样？ 在jump.initialVelocity = 100.0后添加： 1jump.mass = 10.0 效果： 额外质量使文本框的跳跃的要高了，并且稳定下来的持续时间更久了。 stiffness刚度，默认是100。越大弹簧更“硬”。 在jump.mass = 10.0后添加： 1jump.stiffness = 1500.0 效果: 现在跳跃的不是那么高了。 damping动画看起来很棒，但似乎确实有点太长了。 增加系统阻尼以使动画更快地稳定下来。 在jump.stiffness = 1500.0后添加： 1jump.damping = 50.0 效果： 特殊图层属性在文本框抖动时，添加有颜色的边框。 在textFieldDidEndEditing(_:)中的textField.layer.add(jump, forKey: nil)后添加： 12textField.layer.borderWidth = 3.0textField.layer.borderColor = UIColor.clear.cgColor 此代码给文本框周围添加了透明边框。在上面代码后添加： 1234567let flash = CASpringAnimation(keyPath: "borderColor")flash.damping = 7.0flash.stiffness = 200.0flash.fromValue = UIColor(red: 1.0, green: 0.27, blue: 0.0, alpha: 1.0).cgColorflash.toValue = UIColor.white.cgColorflash.duration = flash.settlingDurationtextField.layer.add(flash, forKey: nil) 运行，放慢效果： 注意：在某些iOS版本中，图层动画会删除文本字段的圆角。此情况可在最后一段代码之后添加此行：textField.layer.cornerRadius = 5. 把登录按钮的圆角和背景色变化动画转化为弹性动画这个改变很方便，只要修改ViewController.swift中两个函数： 12345678910111213141516171819202122232425262728293031323334353637// 背景颜色变化的图层动画func tintBackgroundColor(layer: CALayer, toColor: UIColor) &#123;// let tint = CABasicAnimation(keyPath: "backgroundColor")// tint.fromValue = layer.backgroundColor// tint.toValue = toColor.cgColor// tint.duration = 0.5// layer.add(tint, forKey: nil)// layer.backgroundColor = toColor.cgColor let tint = CASpringAnimation(keyPath: "backgroundColor") tint.damping = 5.0 tint.initialVelocity = -10.0 tint.fromValue = layer.backgroundColor tint.toValue = toColor.cgColor tint.duration = tint.settlingDuration layer.add(tint, forKey: nil) layer.backgroundColor = toColor.cgColor &#125;// 圆角动画func roundCorners(layer: CALayer, toRadius: CGFloat) &#123;// let round = CABasicAnimation(keyPath: "cornerRadius")// round.fromValue = layer.cornerRadius// round.toValue = toRadius// round.duration = 0.33// layer.add(round, forKey: nil)// layer.cornerRadius = toRadius let round = CASpringAnimation(keyPath: "cornerRadius") round.damping = 5.0 round.fromValue = layer.cornerRadius round.toValue = toRadius round.duration = round.settlingDuration layer.add(round, forKey: nil) layer.cornerRadius = toRadius&#125; 12-图层关键帧动画和结构属性图层上的关键帧动画(Layer Keyframe Animations，CAKeyframeAnimation)与UIView上的关键帧动画略有不同。 视图关键帧动画是将独立简单动画组合在一起,可以为不同的视图和属性设置动画，动画两者之间可以重叠或存在间隙。 相比之下，CAKeyframeAnimation允许我们为给定图层上的单个属性设置动画。可以定义动画的不同关键点，但动画中不能有任何间隙或重叠。 尽管听起来有些限制，但可以使用CAKeyframeAnimation创建一些非常引人注目的效果。 在本章中，将创建许多图层关键帧动画，从非常基本模拟真实世界碰撞到更高级的动画。 在15-Stroke和路径动画中，您将学习如何进一步获取图层动画，并沿给定路径为图层设置动画。 现在，您将在跑步之前走路，并为您的第一层关键帧动画创建一个时髦的摇摆效果。 介绍图层关键帧动画想一想基本动画是如何运作的？ 使用fromValue和toValue，核心动画会在指定的持续时间内逐步修改这些值之间的特定图层属性。例如，当在45°和-45°（或π/ 4和-π/ 4）之间旋转图层时，只需要指定这两个值，然后图层渲染所有中间值以完成动画： CAKeyframeAnimation使用一组值来完成动画，而不是fromValue和toValue。 另外，还需要提供动画应达到每个值的关键点的时间。 在上面的动画中，图层从45°旋转到-45°，但这次它有两个独立的阶段： 首先，它在动画持续时间的前三分之二内从45°旋转到22°，然后它在剩余的时间内一直旋转到-45°。实质上，使用关键帧设置动画，要求我们为设置动画的属性提供关键值，以及在0.0和1.0之间进行相应数量的相对关键时间。 本章的开始项目使用上一章完成的项目 创建图层关键帧动画在resetForm()中添加： 123456let wobble = CAKeyframeAnimation(keyPath: "transform.rotation")wobble.duration = 0.25wobble.repeatCount = 4wobble.values = [0.0, -.pi/4.0, 0.0, .pi/4.0, 0.0]wobble.keyTimes = [0.0, 0.25, 0.5, 0.75, 1.0]heading.layer.add(wobble, forKey: nil) keyTimes是从0.0到1.0的一系列值，并且与values一一对应。在登录按钮恢复原状后，heading有一个摇摆的效果： 眼睛敏锐的读者可能已经注意到我还没有介绍过结构属性的动画。 大多数情况下，你可以放弃动画结构的单个组件，例如CGPoint的x组件，或CATransformation3D的旋转组件，但是接下来你会发现动态结构值的动画比 你可能会先考虑一下。 Animating struct values结构体是Swift中的一等公民。 实际上，在使用类和结构之间语法上几乎没有区别。（关于类和结构体可查以撸代码的形式学习Swift-9：类和结构体(Classes and Structures)）但是，核心动画是一个基于C构建的Objective-C框架，这意味着结构体的处理方式与Swift的结构体截然不同。 Objective-C API喜欢处理对象，因此结构体需要一些特殊的处理。这就是为什么对图层属性（如颜色或数字）进行动画制作相对容易的原因，但是为CGPoint等结构体属性设置动画并不容易。CALayer有许多可动画属性，它们包含struct值，包括CGPoint类型的位置，CATransform3D类型的转换和CGRect类型的边界。 为了解决这个问题，Cocoa使用NSValue类，它可将一个struct值“包装”为一个核心动画好处理的对象。 NSValue附带了许多便利初始化程序： 1234init(cgPoint: CGPoint)init(cgSize: CGSize)init(cgRect rect: CGRect)init(caTransform3D: CATransform3D) 使用例子， 以下是使用CGPoint的示例位置动画： 1234let move = CABasicAnimation(keyPath: "position")move.duration = 1.0move.fromValue = NSValue(cgPoint: CGPoint(x: 100.0, y: 100.0))move.toValue = NSValue(cgPoint: CGPoint(x: 200.0, y: 200.0)) 在把CGPoint赋值给fromValue或toValue之前，需要把CGPoint转化为NSValue，否则动画无法工作。关键帧动画同样如此。 热气球的关键帧动画在logIn()中添加： 1234let balloon = CALayer()balloon.contents = UIImage(named: "balloon")!.cgImageballoon.frame = CGRect(x: -50.0, y: 0.0, width: 50.0, height: 65.0)view.layer.insertSublayer(balloon, below: username.layer) insertSublayer(_:below)方法创建了一个图片图层作为view.layer的子图层。 如果需要在屏幕上显示图像但不需要使用UIView的所有好处（例如自动布局约束，附加手势识别器等），可以简单地使用上面的代码示例中的CALayer。 在上面的代码后添加动画代码： 123456789let flight = CAKeyframeAnimation(keyPath: "position")flight.duration = 12.0flight.values = [ CGPoint(x: -50.0, y: 0.0), CGPoint(x: view.frame.width + 50.0, y: 160.0), CGPoint(x: -50.0, y: loginButton.center.y)].map &#123; NSValue(cgPoint: $0) &#125;flight.keyTimes = [0.0, 0.5, 1.0] values的三个对应点如下： 最后把动画添加到气球图层上，并且设置气球图层最终位置： 12balloon.add(flight, forKey: nil)balloon.position = CGPoint(x: -50.0, y: loginButton.center.y) 运行，效果： 13-形状和蒙版本章学习CALayer的一个子类CAShapeLayer，它可以在屏幕上绘制各种形状，从非常简单到非常复杂都可以。 本章的开始项目 MultiplayerSearch 模拟了正在搜索在线对手的战斗游戏的起始屏幕。其中一个视图控制器显示一个漂亮的背景图像，一些标签，一个”Search Again“按钮(默认是透明的)，和两个头像图像，其中一个将是空的，直到应用程序”找到“一个对手。 头像视图两个头像都是AvatarView类的一个实例。 下面开始完成一些头像视图的效果。打开AvatarView.swift，会发现有几个已定义的属性，它们分别表示： photoLayer：头像的图片图层。circleLayer：用于绘制圆的形状图层。maskLayer：另一个用于绘制蒙版的形状图层。label：显示玩家姓名的标签。 上面的组件已经存在于项目中，但尚未添加到视图中，第一个任务就是把它们添加动视图中。 将以下代码添加到didMoveToWindow()： 1photoLayer.mask = maskLayer 这简单地用maskLayer中的圆形掩盖方形图像。 还可以通过@IBDesignable(关于@IBDesignable，可查看iOS tutorial 8：使用IBInspectable 和 IBDesignable定制UI)在storyboard中看到设置属性。 运行效果： 现在将圆形边框图层添加到头像视图图层，在didMoveToWindow()中添加代码： 1layer.addSublayer(circleLayer) 这时的效果为： 添加名字标签： 1addSubview(label) 反弹动画下面创建类似两个物体相撞，然后弹开的反弹(bounce-off)动画。 在ViewController中创建searchForOpponent()函数，并在viewDidAppear中调用： 12345func searchForOpponent() &#123; let avatarSize = myAvatar.frame.size let bounceXOffset: CGFloat = avatarSize.width/1.9 let morphSize = CGSize(width: avatarSize.width * 0.85, height: avatarSize.height * 1.1) &#125; bounceXOffset是相互反弹时应移动的水平距离。 morphSize是头像碰撞后的形变大小（宽度变小，长度变大）。 在searchForOpponent()里继续添加： 12345let rightBouncePoint = CGPoint(x: view.frame.size.width/2.0 + bounceXOffset, y: myAvatar.center.y)let leftBouncePoint = CGPoint(x: view.frame.size.width/2.0 - bounceXOffset, y: myAvatar.center.y)myAvatar.bounceOff(point: rightBouncePoint, morphSize: morphSize)opponentAvatar.bounceOff(point: leftBouncePoint, morphSize: morphSize) 上面的bounceOff(point:morphSize:)方法，两个参数分别代表头像移动的位置和变形的大小。在AvatarView中添加： 1234567891011121314151617func bounceOff(point: CGPoint, morphSize: CGSize) &#123; let originalCenter = center UIView.animate(withDuration: animationDuration, delay: 0.0, usingSpringWithDamping: 0.8, initialSpringVelocity: 0.0, animations: &#123; self.center = point &#125;, completion: &#123;_ in &#125;) UIView.animate(withDuration: animationDuration, delay: animationDuration, usingSpringWithDamping: 0.7, initialSpringVelocity: 1.0, animations: &#123; self.center = originalCenter &#125;) &#123; (_) in delay(seconds: 0.1) &#123; self.bounceOff(point: point, morphSize: morphSize) &#125; &#125;&#125; 上面的两个动画分别是，使用弹簧动画将头像移动到指定位置 和 使用弹簧动画将头像移动到原来位置。此时效果如下： 图像变形实际生活中，两个物体相撞时，有一个短时间暂停，并且物体变形（”压扁“的效果）。下面就实现这种效果。 在bounceOff(point:morphSize:)添加： 123let morphedFrame = (originalCenter.x &gt; point.x) ? CGRect(x: 0.0, y: bounds.height - morphSize.height, width: morphSize.width, height: morphSize.height) : CGRect(x: bounds.width - bounds.width, y: bounds.height - morphSize.height, width: morphSize.width, height: morphSize.height) 通过originalCenter.x &gt; point.x来判断是左边头像还是右边头像。 在bounceOff(point:morphSize:)继续添加： 1234567let morphAnimation = CABasicAnimation(keyPath: "path")morphAnimation.duration = animationDurationmorphAnimation.toValue = UIBezierPath(ovalIn: morphedFrame).cgPathmorphAnimation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)circleLayer.add(morphAnimation, forKey: nil) 通过UIBezierPath创建椭圆。 运行后，效果有点问题： 只有边框图层发生了变形，图片图层没有变化。 把morphAnimation动画添加到蒙版图层： 1maskLayer.add(morphAnimation, forKey: nil) 这样的效果就好很多： 搜索对手在searchForOppoent()里最后添加delay(seconds: 4.0, completion: foundOppoent)，然后在ViewController中添加： 123456func foundOpponent() &#123; status.text = "Connecting..." opponentAvatar.image = UIImage(named: "avatar-2") opponentAvatar.name = "Andy"&#125; 利用延迟来模拟在寻找对手。 在foundOpponent()里添加delay(seconds: 4.0, completion: connectedToOpponent)，然后然后在ViewController中添加： 1234func connectedToOpponent() &#123; myAvatar.shouldTransitionToFinishedState = true opponentAvatar.shouldTransitionToFinishedState = true&#125; shouldTransitionToFinishedState是AvatarView中自定义的属性，用于判断连接是否完成，在下面使用。 在connectedToOpponent()里添加delay(seconds: 1.0, completion: completed)，然后然后在ViewController中添加： 1234567func completed() &#123; status.text = "Ready to play" UIView.animate(withDuration: 0.2) &#123; self.vs.alpha = 1.0 self.searchAgain.alpha = 1.0 &#125;&#125; 对手找到后，修改状态语，并显示重新搜索按钮。 效果： 连接成功后头像变成正方形在AvatarView中添加一个属性var isSquare = false，用于判断头像是否需要转换为正方形。 在bounceOff(point:morphSize:)的第一个动画（头像移动到指定位置）的 completion闭包中添加： 123if self.shouldTransitionToFinishedState &#123; self.animateToSquare()&#125; 其中animateToSquare()为： 1234567891011121314151617// 变换为正方形动画func animateToSquare() &#123; isSquare = true let squarePath = UIBezierPath(rect: bounds).cgPath let morph = CABasicAnimation(keyPath: "path") morph.duration = 0.25 morph.fromValue = circleLayer.path morph.toValue = squarePath circleLayer.add(morph, forKey: nil) maskLayer.add(morph, forKey: nil) circleLayer.path = squarePath maskLayer.path = squarePath&#125; 在bounceOff(point:morphSize:)的第二个动画（头像移动到原来位置）的 completion闭包添加判断： 123if !self.isSquare &#123; self.bounceOff(point: point, morphSize: morphSize)&#125; 这样的最终效果就是： 14-渐变动画本章通过以前iOS的屏幕“滑动解锁”效果来学习渐变动画(Gradient Animations)。 开始项目 SlideToReveal是一个简单的单页面项目，只有一个显示时间的UILabel，和一个之后用于渐变动画的自定义UIView子类AnimateMaskLabel。 第一个渐变图层CAGradientLayer是CALayer的另一个子类，专门用于渐变的图层。 配置CAGradientLayer，在属性gradientLayer定义的函数块中添加: 12gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5)gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5) 这定义了渐变的方向及其起点和终点。 1234567&gt; let gradientLayer: CAGradientLayer = &#123;&gt; let gradientLayer = CAGradientLayer() &gt; gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5)&gt; gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5)&gt; ... &gt; &#125;()&gt; 这种写法表示定义函数后直接调用，返回值直接给属性。这中写法在其它语言中也比较常见，比如JS。 继续添加： 12345678let colors = [ UIColor.black.cgColor, UIColor.white.cgColor, UIColor.black.cgColor]gradientLayer.colors = colorslet locations: [NSNumber] = [0.25, 0.5, 0.75]gradientLayer.locations = locations 上面的定义方式和前面学习的图层关键帧动画 中的values和keyTimes有点类似。 结果就是渐变以黑色开始，中间白色，最后为黑色。通过locations指定这些颜色应该出现在渐变过程中的确切位置。当然也是可以很多个颜色点，和对应位置点的。 上面的效果就类似： 在layoutSubviews()中定义渐变图层的frame： 12gradientLayer.frame = boundslayer.addSublayer(gradientLayer) 这就把渐变的图层定义在AnimateMaskLabel。 给渐变图层添加动画在didMoveToWindow()中添加： 123456let gradientAnimation = CABasicAnimation(keyPath: "locations")gradientAnimation.fromValue = [0.0, 0.0, 0.25]gradientAnimation.toValue = [0.75, 1.0, 1.0]gradientAnimation.duration = 3.0gradientAnimation.repeatCount = .infinitygradientLayer.add(gradientAnimation, forKey: nil) repeatCount设置为无穷大，动画持续3秒并将永远重复。效果如下： 上面的效果可能一时不好理解，如果把渐变图层的locations分别设置成[0.0, 0.0, 0.25]和[0.75, 1.0, 1.0]，也就是动画开始点和结束点，情况分别是： 动画的效果就是前者的状态到后者的状态，这样就方便理解了。 这看起来很漂亮，但渐变宽度有点小。 只需放大渐变边界，就会得到更温和的渐变。在layoutSubviews()中找到gradientLayer.frame = bounds行，替代为： 1gradientLayer.frame = CGRect(x: -bounds.size.width, y: bounds.origin.y, width: 3 * bounds.size.width, height: bounds.size.height) 这会将渐变框设置为可见区域宽度的三倍。 动画进入视图，直接穿过它，并从右侧退出： 效果： 创建文本蒙版在AnimateMaskLabel中创造一个文本属性： 12345678let textAttributes: [NSAttributedString.Key: Any] = &#123; let style = NSMutableParagraphStyle() style.alignment = .center return [ NSAttributedString.Key.font: UIFont(name: "HelveticaNeue-Thin", size: 28.0)!, NSAttributedString.Key.paragraphStyle: style ]&#125;() 接下来，需要将文本渲染为图像。 在text属性的属性观察者中的setNeedsDisplay()之后添加以下代码: 123let image = UIGraphicsImageRenderer(size: bounds.size).image &#123; (_) in text.draw(in: bounds, withAttributes: textAttributes)&#125; 在这里，使用图像渲染器来设置上下文。 使用该图像在渐变图层上创建蒙版，在上面代码后继续添加： 12345let maskLayer = CALayer()maskLayer.backgroundColor = UIColor.clear.cgColormaskLayer.frame = bounds.offsetBy(dx: bounds.size.width, dy: 0)maskLayer.contents = image.cgImagegradientLayer.mask = maskLayer 现在效果： 滑动手势在viewDidLoad()中添加： 123let swipe = UISwipeGestureRecognizer(target: self, action: #selector(ViewController.didSlide)) swipe.direction = .right slideView.addGestureRecognizer(swipe) 效果： 彩色渐变修改渐变的图层的colors和locations，然之前的黑白变成彩色： 12345678let colors = [ UIColor.yellow.cgColor, UIColor.green.cgColor, UIColor.orange.cgColor, UIColor.cyan.cgColor, UIColor.red.cgColor, UIColor.yellow.cgColor] 1let locations: [NSNumber] = [0.0, 0.0, 0.0, 0.0, 0.0, 0.25] 并修改动画的fromValue和toValue： 12gradientAnimation.fromValue = [0.0, 0.0, 0.0, 0.0, 0.0, 0.25]gradientAnimation.toValue = [0.65, 0.8, 0.85, 0.9, 0.95, 1.0] 效果： 本章的最终效果： 15-Stroke和路径动画 注： stroke 可翻译成 笔画，但好像又不当恰当，就干脆不翻译😏。 开始项目 PullToRefresh 有一个TableView，下拉新视图保持可见状态四秒钟，然后缩回。本章就是在这个下拉视图中做一个类似菊花转的动画。 创建交互stroke动画构建动画的第一步是创建一个圆形。 打开RefreshView.swift并将以下代码添加到init(frame:scrollView:)中： 12345678910// 飞机移动路线图层ovalShapeLayer.strokeColor = UIColor.white.cgColorovalShapeLayer.fillColor = UIColor.clear.cgColorovalShapeLayer.lineWidth = 4.0ovalShapeLayer.lineDashPattern = [2, 3]let refreshRadius = frame.size.height/2 * 0.8ovalShapeLayer.path = UIBezierPath(ovalIn: CGRect(x: frame.size.width/2 - refreshRadius, y: frame.size.height/2 - refreshRadius, width: 2 * refreshRadius, height: 2 * refreshRadius)).cgPathlayer.addSublayer(ovalShapeLayer) ovalShapeLayer是一个类型为CAShapeLayer的RefreshView的属性。CAShapeLayer之前已经学过了， 在这里，只需设置笔触和填充颜色，并将圆直径设置为视图高度的80％，这样可确保形成舒适的边距。 lineDashPattern属性是设置虚线模式，它是一个数组，其中包含短划线的长度和间隙的长度（以像素为单位），当然还可以设置很多种虚线，详细的可查看官方文档。 在redrawFromProgress()中添加： 1ovalShapeLayer.strokeEnd = progress 把飞机图片添加到飞机图层中，在init(frame:scrollView:)中添加： 1234567// 添加飞机let airplaneImage = UIImage(named: "airplane.png")!airplaneLayer.contents = airplaneImage.cgImageairplaneLayer.bounds = CGRect(x: 0.0, y: 0.0, width: airplaneImage.size.width, height: airplaneImage.size.height)airplaneLayer.position = CGPoint(x: frame.size.width/2 + frame.size.height/2 * 0.8, y: frame.size.height/2)layer.addSublayer(airplaneLayer)airplaneLayer.opacity = 0.0 下拉时逐步更改飞机图层的不透明度，在redrawFromProgress()添加： 1airplaneLayer.opacity = Float(progress) stroke的结尾在beginRefreshing()中添加： 1234567let strokeStartAnimation = CABasicAnimation(keyPath: "strokeStart")strokeStartAnimation.fromValue = -0.5strokeStartAnimation.toValue = 1.0let strokeEndAnimation = CABasicAnimation(keyPath: "strokeEnd")strokeEndAnimation.fromValue = 0.0strokeEndAnimation.toValue = 1.0 在beginRefreshing()的末尾添加以下代码以同时运行两个动画： 12345let strokeAnimationGroup = CAAnimationGroup()strokeAnimationGroup.duration = 1.5strokeAnimationGroup.repeatDuration = 5.0strokeAnimationGroup.animations = [strokeEndAnimation, strokeEndAnimation]ovalShapeLayer.add(strokeAnimationGroup, forKey: nil) 在上面的代码中，创建一个动画组并重复动画五次。 这应该足够长，以便在刷新视图可见时保持动画运行。 然后，将两个动画添加到组中，并将组添加到加载层。 运行效果： 创建path关键帧动画在12-图层关键帧动画和结构属性 学习了使用values属性来设置关键帧动画。下面学习另一种方式使用关键帧动画。 在beginRefreshing()的末尾添加飞机动画： 12345678910// 飞机动画let flightAnimation = CAKeyframeAnimation(keyPath: "position")flightAnimation.path = ovalShapeLayer.pathflightAnimation.calculationMode = CAAnimationCalculationMode.pacedlet flightAnimationGroup = CAAnimationGroup()flightAnimationGroup.duration = 1.5flightAnimationGroup.repeatDuration = 5.0flightAnimationGroup.animations = [flightAnimation]airplaneLayer.add(flightAnimationGroup, forKey: nil) CAAnimationCalculationMode.paced是另一种控制动画时间的方法，这时核心动画会以恒定的速度设置动画，忽略设置的任何keyTimes，这对于在任意路径上生成平滑动画非常有用。 CAAnimationCalculationMode还有其他几种模式，详细可查看官方文档。 运行效果： 这比较奇怪了，✈️移动时，角度也有相应的变化。 在创建flightAnimationGroup的行上方插入以下新动画代码，来调整飞机移动时角度 123let airplaneOrientationAnimation = CABasicAnimation(keyPath: "transform.rotation")airplaneOrientationAnimation.fromValue = 0airplaneOrientationAnimation.toValue = 2.0 * .pi 最终效果 16-复制动画本章节学习复制动画(Replicating Animations)。 CAReplicatorLayer是CALayer的另一个子类。它意思很简单，当创建了一些内容 —— 可以是一个形状，一个图像或任何可以用图层绘制的东西 —— 而CAReplicatorLayer可以在屏幕上复制它，如下所示： 为什么需要复制形状或图像？ CAReplicatorLayer的超级强大之处，在于可以让每个复制体与母体略有不同。例如，可以逐步更改每个副本的颜色。 原始图层可能是洋红色，而在创建每个副本时，将颜色向青色方向改变： 此外，还可以在副本之间应用转换(transform)。 例如，可以在每个副本之间应用简单的旋转转换，将它们绘制成圆形，如下所示： 但最好的功能是每个副本都能够设置动画延迟。 当原始内容的instanceDelay设置0.2秒时，第一个副本将延迟0.2秒执行动画，第二个副本将延迟0.4秒执行动画，第三个副本将延迟0.6秒执行动画，依此类推。 可以使用这种方式来创建引人入胜且复杂的动画。 在本章中，将创建一个模仿Siri，听到声音后，根据声音而产生波浪状的动画。这个开始项目 命名为Iris。 这个项目将创建两个不同的复制。 首先，是在Iris会话时播放的视觉反馈动画，它看起来很像一个迷幻的正弦波： 然后是一个交互式麦克风驱动的音频波，当用户说话时，它将提供视觉反馈： 这两个动画覆盖了CAReplicatorLayer的大部分功能。 Replicating like rabbits开始项目概述打开Main.storyboard： 只有一个视图控制器，它具有一个按钮和一个标签。 用户在按下按钮时询问问题; 当他们释放按钮时，Iris会做出回应。 标签用来显示麦克风输入和Iris的答案。 在ViewController.swift中，按钮事件已连接到操作。当用户触摸按钮时，actionStartMonitoring()会触发；当用户抬起手指时，actionEndMonitoring()会触发。 另外还有两个超出本章范围的类： Assistant：人工智能助理。它预定义的有趣答案列表，并根据用户的问题说出来。MicMonitor：监控iPhone麦克风上的输入，并反复调用您提供的闭包表达式。这是您有机会更新显示的地方。 下面开始！ 设置复制器层打开ViewController.swift并添加以下两个属性： 12let replicator = CAReplicatorLayer()let dot = CALayer() dot使用CALayer，用来绘制基本的简单形状。replicator作为复制器，用来之后复制dot。 下面添加一些常量 属性： 12let dotLength: CGFloat = 6.0let dotOffset: CGFloat = 8.0 doLength用作点图层的宽度和高度，dotOffset是每个点复制体之间的偏移量。 将复制器层添加到视图控制器的视图中，在viewDidLoad()中添加： 12replicator.frame = view.boundsview.layer.addSublayer(replicator) 下一步是设置点图层。 在viewDidLoad()中添加： 1234567dot.frame = CGRect(x: replicator.frame.size.width - dotLength, y: replicator.position.y, width: dotLength, height: dotLength)dot.backgroundColor = UIColor.lightGray.cgColordot.borderColor = UIColor(white: 1.0, alpha: 1.0).cgColordot.borderWidth = 0.5dot.cornerRadius = 1.5replicator.addSublayer(dot) 先将点图层定位到复制器的右边缘，然后设置图层的背景颜色并添加边框等，最后将点图层加入复制器图层。运行结果： 在继续下面之前，先介绍CAReplicatorLayer的三个属性：instanceCount： 副本数instanceTransform： 副本之间的转换instanceDelay： 副本之间的动画延迟 在viewDidLoad()中添加： 12replicator.instanceCount = Int(view.frame.size.width / dotOffset)replicator.instanceTransform = CATransform3DMakeTranslation(-dotOffset, 0.0, 0.0) 屏幕宽度除以偏移量，根据不同屏幕宽度设置副本数。比如5.5英寸（宽度为414）的instanceCount是51，4.7英寸是46 。。。 每个副本向左（-dotOffset）移动8 。结果为： 测试复制动画添加一个小测试动画，来了解instanceDelay的作用。 在viewDidLoad()的末尾添加： 123456let move = CABasicAnimation(keyPath: "position.y")move.fromValue = dot.position.ymove.toValue = dot.position.y - 50.0move.duration = 1.0move.repeatCount = 10dot.add(move, forKey: nil) 这个动画很简单，只是把点向上重复移动10次。 在上面代码的的末尾添加： 1replicator.instanceDelay = 0.02 效果： 在继续之前，需要删除上面的测试动画，除了instanceDelay。 复制多个动画在本节中，您将学习在Iris讲话时播放的动画。 为此，您将结合使用具有不同延迟的多个简单动画来产生最终效果。 缩放动画首先，在startSpeaking()中添加以下动画： 12345678let scale = CABasicAnimation(keyPath: "transform")scale.fromValue = NSValue(caTransform3D: CATransform3DIdentity)scale.toValue = NSValue(caTransform3D: CATransform3DMakeScale(1.4, 15, 1.0))scale.duration = 0.33scale.repeatCount = .infinityscale.autoreverses = truescale.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)dot.add(scale, forKey: "dotScale") 这是一个简单的层动画，重点在CATransform3DMakeScale的几个参数选择。此处将点图层在垂直方向缩放15倍。 运行，并点击灰色按钮，分别先后调用actionStartMonitoring，actionEndMonitoring()，最后调用startSpeaking()，效果： 可以尝试修改CATransform3DMakeScale的几个参数和duration来看看有什么不同效果。 透明动画在startSpeaking()添加淡出动画： 123456789let fade = CABasicAnimation(keyPath: "opacity")fade.fromValue = 1.0fade.toValue = 0.2fade.duration = 0.33fade.beginTime = CACurrentMediaTime() + 0.33fade.repeatCount = .infinityfade.autoreverses = truefade.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)dot.add(fade, forKey: "dotOpacity") 与缩放动画的持续时间相同，但延迟0.33秒，透明度从1.0到0.2，当“波浪”充分移动后，开始淡出效果。 当两个动画同时运行时，效果会更好一点： 色彩动画设置点背景颜色变化动画，在startSpeaking()添加： 12345678910let tint = CABasicAnimation(keyPath: "backgroundColor")tint.fromValue = UIColor.magenta.cgColortint.toValue = UIColor.cyan.cgColortint.duration = 0.66tint.beginTime = CACurrentMediaTime() + 0.28tint.fillMode = kCAFillModeBackwardstint.repeatCount = .infinitytint.autoreverses = truetint.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)dot.add(tint, forKey: "dotColor") 三种动画的效果： CAReplicatorLayer的属性前面已经通过复制器层制作了很多令人眼花缭乱的效果。 由于CAReplicatorLayer本身就是一个图层，因此也可以为其自身的一些属性设置动画。 可以为CAReplicatorLayer的基本属性（如position，backgroundColor或cornerRadius）设置动画，也可以通过其特殊的属性设置非常酷的动画。 CAReplicatorLayer特有的可动画属性包括(前面已经介绍过三个)： instanceDelay： 副本之间的动画延迟instanceTransform：副本之间的转换instanceColor： 颜色instanceRedOffset，instanceGreenOffset，instanceBlueOffset：应用增量以应用于每个实例颜色组件instanceAlphaOffset： 透明度增量 在startSpeaking()的末尾添加一个动画： 12345678let initialRotation = CABasicAnimation(keyPath: "instanceTransform.rotation")initialRotation.fromValue = 0.0initialRotation.toValue = 0.01initialRotation.duration = 0.33initialRotation.isRemovedOnCompletion = falseinitialRotation.fillMode = kCAFillModeForwardsinitialRotation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseOut)replicator.add(initialRotation, forKey: "initialRotation") 上面只是有一个微小的旋转，效果： 再需要一个上下扭动的效果，添加下面的动画以完成效果： 123456789let rotation = CABasicAnimation(keyPath: "instanceTransform.rotation")rotation.fromValue = 0.01rotation.toValue = -0.01rotation.duration = 0.99rotation.beginTime = CACurrentMediaTime() + 0.33rotation.repeatCount = .infinityrotation.autoreverses = truerotation.timingFunction = CAMediaTimingFunction(name: kCAMediaTimingFunctionEaseInEaseOut)replicator.add(rotation, forKey: "replicatorRotation") 这是在instanceTransform.rotation上运行第二个动画，它在之前第一个动画完成后启动。将旋转从0.01弧度（第一个动画的最终值）设置到-0.01弧度，这就有了扭到的效果（不同方向的旋转）。效果： 下面模拟语音助手，假装回单。startSpeaking()的开始处添加： 123meterLabel.text = assistant.randomAnswer()assistant.speak(meterLabel.text!, completion: endSpeaking)speakButton.isHidden = true 从Assistant类中随机获得一个答案，然后在meterLabel上显示，并且读处答案，读完后调用endSpeaking方法。这是过程中按钮需要隐藏。 之后，需要删除所有正在运行的动画，在endSpeaking()中添加： 1replicator.removeAllAnimations() 接下来，需要将点图层“优雅”地设置为原始比例的动画， 在endSpeaking()继续中添加： 123456let scale = CABasicAnimation(keyPath: "transform")scale.toValue = NSValue(caTransform3D: CATransform3DIdentity)scale.duration = 0.33scale.isRemovedOnCompletion = falsescale.fillMode = kCAFillModeForwardsdot.add(scale, forKey: nil) 上面的动画，没有指定fromValue ，会从当前值开始动画，变换为CATransform3DIdentiy。 最后，删除dot中当前正在运行的其余动画，并恢复说话按钮状态。 在endSpeaking()继续中添加： 1234dot.removeAnimation(forKey: "dotColor")dot.removeAnimation(forKey: "dotOpacity")dot.backgroundColor = UIColor.lightGray.cgColorspeakButton.isHidden = false 本节的效果： 交互式复制动画前面这有Iris回答时，才会有对应波动动画。这一节要做的是，当用户按住按钮说话（问问题）时也就对应波动动画。 在actionStartMonitoring()中添加： 1234dot.backgroundColor = UIColor.green.cgColormonitor.startMonitoringWithHandler &#123; (level) in self.meterLabel.text = String(format: "%.2f db", level)&#125; 当用户按下说话按钮时，触发actionStartMonitoring。为了表示“正在收听”，将点图层颜色更改为绿色。 然后在监视器实例上调用startMonitoringWithHandler()，它的参数是一个闭包块，会被重复执行，获取麦克风分贝数(db)。 这边的分贝数和我们平常见到分贝数范围有点不同， 它的值在-160.0 db到0.0 db的范围内，-160.0 db是最安静的，0.0 db意味着非常大的声音。 向上面的闭包中添加一段代码，添加完如下： 1234monitor.startMonitoringWithHandler &#123; (level) in self.meterLabel.text = String(format: "%.2f db", level) let scaleFactor = max(0.2, CGFloat(level) + 50) / 2&#125; scaleFactor将存储介于0.1和25.0之间的值。 在ViewController新加一个属性： 1var lastTransformScale: CGFloat = 0.0 对于缩放动画，比例不断变化的，lastTransformScale保存最后一个缩放值。 在上面的麦克风处理闭包中添加用户声音动画： 1234567let scale = CABasicAnimation(keyPath: "transform.scale.y")scale.fromValue = self.lastTransformScalescale.toValue = scaleFactorscale.duration = 0.1scale.isRemovedOnCompletion = falsescale.fillMode = kCAFillModeForwardsself.dot.add(scale, forKey: nil) 最后，保存lastTransformScale，接着上面的代码添加： 1self.lastTransformScale = scaleFactor 当用户手指离开按钮时，需要重置动画并停止监听麦克风。 在actionEndMonitoring()开始处添加： 12monitor.stopMonitoring()dot.removeAllAnimations() 这个时候，效果： 平滑麦克风输入和Iris动画之间的过渡仔细之前的效果，我发现用户麦克风输入动画和Iris动画之间是没有过渡，是直接跳过。这是actionEndMonitoring()中的dot.removeAllAnimations()造成的。 把dot.removeAllAnimations()替代为： 1234567891011121314151617// 麦克风输入和Iris动画之间的过渡let scale = CABasicAnimation(keyPath: "transform.scale.y")scale.fromValue = lastTransformScalescale.toValue = 1.0scale.duration = 0.2scale.isRemovedOnCompletion = falsescale.fillMode = kCAFillModeForwardsdot.add(scale, forKey: nil)dot.backgroundColor = UIColor.magenta.cgColorlet tint = CABasicAnimation(keyPath: "backgroundColor")tint.fromValue = UIColor.green.cgColortint.toValue = UIColor.magenta.cgColortint.duration = 1.2tint.fillMode = kCAFillModeBackwardsdot.add(tint, forKey: nil) 本章最后的效果：]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
        <tag>图层动画</tag>
        <tag>Layer Animations</tag>
        <tag>核心动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习iOS动画之二：自动布局]]></title>
    <url>%2F2018%2FiOS-Animation-2-Auto-Layout.html</url>
    <content type="text"><![CDATA[本文是我学习《iOS Animations by Tutorials》 笔记中的一篇。文中详细代码都放在我的Github上 andyRon/LearniOSAnimations。 自动布局(Auto Layout) 在iOS 6中首次推出，已经存在了一段时间，每次发布新版本的iOS和Xcode都经历了一系列成功的迭代。 自动布局背后的核心理念非常简单：它允许您根据布局中的每个元素之间创建的关系来定义应用程序的UI元素的布局。 我们平常开发时已将自动布局用于静态的布局，在本文中将学习使用约束来设置动画。 6-自动布局的介绍本章节是用自动布局完成下一章节需要使用的项目Packing List 。关于自动布局，可参考我之前的文章开始用Swift开发iOS 10 - 3 介绍Auto Layout，这里就不重复了。 7-约束动画约束动画(Animating Constraints)并不比属性动画困难; 它只是有点不同。 通常，只需使用新约束替换现有约束，然后让Auto Layout为两个状态之间的UI设置动画就可以了。 设置约束动画开始项目Packing List大概如下： 导航栏高度变化在ViewController中添加约束接口： 1@IBOutlet weak var menuHeightConstraint: NSLayoutConstraint! 并让它与导航栏视图的高度约束关联： 在右上角加号按钮的Action方法actionToggleMenu()中添加： 123isMenuOpen = !isMenuOpenmenuHeightConstraint.constant = isMenuOpen ? 200.0 : 60.0titleLabel.text = isMenuOpen ? "Select Item" : "Packing List” 点击加号按钮后导航栏高度变大，并且title变化。 布局变化的动画继续在actionToggleMenu()添加布局变化的弹簧动画： 1234UIView.animate(withDuration: 1.0, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 10.0, options: .curveEaseIn, animations: &#123; // 强制更新布局 self.view.layoutIfNeeded()&#125;, completion: nil) 在menuHeightConstraint.constant = isMenuOpen ? 200.0 : 60.0已经更新了约束值，但iOS还没有机会更新布局。通过从动画闭包中调用layoutIfNeeded()强制更新布局，可以设置布局中涉及的每个视图的中心和边界。比如table view也随着Menu的收缩或增大而收缩或增大，这就是约束的效果，现在相当于一次设置两个动画😊。 效果： 旋转让+旋转45°变成x在上面的动画闭包中添加： 12let angle: CGFloat = self.isMenuOpen ? .pi/4 : 0.0self.buttonMenu.transform = CGAffineTransform(rotationAngle: angle) 查看约束直接用可视化的方式为视图约束添加代码接口（outlet）是相对简单的方式。有的时候不方便在Interfa Builder使用Control-drag方式添加接口或者不方便添加有太多outlet，这时可以利用UIView提供的constraints属性，它是当前视图所有约束的数组。 比如下面代码： 123titleLabel.superview?.constraints.forEach &#123; constraint in print("-&gt; \(constraint.description)\n")&#125; 打印结果： 123456789-&gt; &lt;NSLayoutConstraint:0x600002d04320 UIView:0x7ff7df530c00.height == 200 (active)&gt;-&gt; &lt;NSLayoutConstraint:0x600002d02210 UILabel:0x7ff7df525350'Select Item'.centerX == UIView:0x7ff7df530c00.centerX (active)&gt;-&gt; &lt;NSLayoutConstraint:0x600002d02a30 UILabel:0x7ff7df525350'Select Item'.centerY == UIView:0x7ff7df530c00.centerY + 5 (active)&gt;-&gt; &lt;NSLayoutConstraint:0x600002d02d00 H:[UIButton:0x7ff7df715d20'+']-(8)-| (active, names: '|':UIView:0x7ff7df530c00 )&gt;-&gt; &lt;NSLayoutConstraint:0x600002d030c0 UIButton:0x7ff7df715d20'+'.centerY == UILabel:0x7ff7df525350'Select Item'.centerY (active)&gt; 看上去有点乱，不过仔细看还是能看出有五个约束分别对应于： 设置UILabel的约束动画在 actionToggleMenu()的isMenuOpen = !isMenuOpen下添加： 123456titleLabel.superview?.constraints.forEach &#123; constraint in if constraint.firstItem === titleLabel &amp;&amp; constraint.firstAttribute == .centerX &#123; constraint.constant = isMenuOpen ? -100.0 : 0.0 return &#125;&#125; 约束表达式的通用形式如下： 1firstItem.firstItemAttribute == secondItem.secondItemAttribute * multiplier + constant 对应于 NSLayoutConstraint的各种属性，名字看着很明显，其中==对应于属性relation，当然也可以是&lt;=、&gt;=等。 实际例子： 1Superview.CenterX = 1.0 * UILabel.CenterX + 0.0 这边的效果： 替代约束每个约束可以添加 Identifier属性，在代码中就可以通过 Identifier获取这个约束。 继续在上面的约束后添加： 1234567if constraint.identifier == "TitleCenterY" &#123; constraint.isActive = false let newConstraint = NSLayoutConstraint(item: titleLabel, attribute: .centerY, relatedBy: .equal, toItem: titleLabel.superview!, attribute: .centerY, multiplier: isMenuOpen ? 0.67 : 1.0, constant: 5.0) newConstraint.identifier = "TitleCenterY" newConstraint.isActive = true return&#125; 新加的约束可以表示为Title.CenterY = Menu.CenterY * 0.67 + 0.0，图示： 运行后效果： 添加导航栏内容在 actionToggleMenu()中添加： 123456789101112if isMenuOpen &#123; slider = HorizontalItemList(inView: view) slider.didSelectItem = &#123; index in print("add \(index)") self.items.append(index) self.tableView.reloadData() self.actionToggleMenu(self) &#125; self.titleLabel.superview!.addSubview(slider)&#125; else &#123; slider.removeFromSuperview()&#125; HorizontalItemList是自定义的一个UIScrollView子类，用于menu中左右滚动的视图， 动态创建视图当点击TableView的cell时，会调用showItem(_:)，在这个方法中添加： 1234567// 点击后创造图片let imageView = UIImageView(image: UIImage(named: "summericons_100px_0\(index).png"))imageView.backgroundColor = UIColor(red: 0.0, green: 0.0, blue: 0.0, alpha: 0.5)imageView.layer.cornerRadius = 5.0imageView.layer.masksToBounds = trueimageView.translatesAutoresizingMaskIntoConstraints = falseview.addSubview(imageView) 添加约束代码： 1let conx = imageView.centerXAnchor.constraint(equalTo: view.centerXAnchor) 此方法使用新的NSLayoutAnchor类，这使得创建常见约束非常容易。 在这里，您将在图像视图的中心x锚点和视图控制器的视图之间创建约束。 添加图片底部约束： 1let conBottom = imageView.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: imageView.frame.height) 此约束设置图像视图的底部以匹配视图控制器视图的底部，加上图像高度; 这会将图像定位在屏幕底部边缘之外，这将作为动画的起点。 添加图片宽度约束： 1let conWidth = imageView.widthAnchor.constraint(equalTo: view.widthAnchor, multiplier: 0.33, constant: -50.0) 这将图像宽度设置为屏幕宽度的1/3减去50磅。 目标尺寸是屏幕的1/3; 你将动画50磅的差异，使图像“成长”到位。 最后，添加高度和宽度相等约束，并激活上面所有约束： 12let conHeight = imageView.heightAnchor.constraint(equalTo: imageView.widthAnchor)NSLayoutConstraint.activate([conx, conBottom, conWidth, conHeight]) 此时点击TableView的Cell，只能看到下面： 为动态创建的视图创建动画在showItem(_:)添加： 12345UIView.animate(withDuration: 0.8, delay: 0.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 0.0, animations: &#123; conBottom.constant = -imageView.frame.size.height/2 conWidth.constant = 0.0 self.view.layoutIfNeeded()&#125;, completion: nil) 但是此时的效果是： 想一想：添加了一个视图，设置了一些约束，然后改变了这些约束并设置了布局变化的动画。 但是，视图从未有机会执行其初始布局，因此图像从其左上角的(0, 0)的默认位置开始🙄。 要解决此问题，只要在动画开始之前进行初始布局，在动画前添加： 1view.layoutIfNeeded() 效果变成从下面上来： 移出已经出现的图片上面的弹出图片会重叠在一起，下个图片出来之前，需要把上一个图片移出。 在之前的代码下添加： 1234567UIView.animate(withDuration: 0.8, delay: 1.0, usingSpringWithDamping: 0.4, initialSpringVelocity: 0.0, animations: &#123; conBottom.constant = imageView.frame.size.height conWidth.constant = -50.0 self.view.layoutIfNeeded() &#125;) &#123; (_) in imageView.removeFromSuperview() &#125; 效果为：😝]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
        <tag>自动布局</tag>
        <tag>Auto Layout</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习iOS动画之一：视图动画]]></title>
    <url>%2F2018%2FiOS-Animation-1-view-animation.html</url>
    <content type="text"><![CDATA[本文是我学习《iOS Animations by Tutorials》 笔记中的一篇。文中详细代码都放在我的Github上 andyRon/LearniOSAnimations。 这个部分介绍UIKit动画API，这些API专门用于轻松制作视图动画(View Animations)，同时避免核心动画(Core Animation)(见系统学习iOS动画之三：图层动画)的复杂性。 UIKit动画API不仅易于使用，而且提供了大量灵活性和强大功能，可以处理大多数（当然不是全部）动画要求。 UIKit动画API可以在屏幕上为最终继承自UIView的任何对象设置动画，例如：UILabel，UIImageView，UIButton等等，也可以是自己创建的任何自定义最终继承自UIView类。 本文包括五个章节，完成两个项目BahamaAirLoginScreen和Flight Info。 BahamaAirLoginScreen 是一个登录页面项目，1、2、3章节为这个项目的一些UI添加各种动画。 1-视图动画入门 —— 学习如何移动，缩放和淡化视图等基本的UIKit API。2-弹簧动画 —— 在线性动画的概念基础上，使用弹簧动画创造出更引人注目的效果。😊3-过渡动画 —— 视图的出现和消失。 Flight Info 是一个航班状态变化项目，4、5章节用一些高级一点动画来完成这个项目。 4-练习视图动画 —— 练习前面学到的动画技术。5-关键帧动画 —— 使用关键帧动画来创建由许多不同阶段组成的复杂动画。 1-视图动画入门第一个动画开始项目 BahamaAirLoginScreen是一个简单的登录页面，有两个TextField，一个Label，一个Button，4个云图片和一个背景图片，效果如下： 让Label和两个TextField在视图显示之前移动到屏幕外。在viewWillAppear()中添加： 123heading.center.x -= view.bounds.widthusername.center.x -= view.bounds.widthpassword.center.x -= view.bounds.width 添加Label和两个TextField进入屏幕的动画，在viewDidAppear()中添加： 1234567891011121314151617UIView.animate(withDuration: 0.5) &#123; self.heading.center.x += self.view.bounds.width&#125;UIView.animate(withDuration: 0.5, delay: 0.3, options: [], animations: &#123; self.username.center.x += self.view.bounds.width &#125;, completion: nil)UIView.animate(withDuration: 0.5, delay: 0.4, options: [], animations: &#123; self.password.center.x += self.view.bounds.width &#125;, completion: nil) 这样heading和TextField就有了前后分别进入屏幕的动画。 类似UIView.animate(...)的方法，根据参数的不同有好几个，不同参数的意义： withDuration ：动画持续时间。 delay ：动画开始之前的延迟时间。 options ：UIView.AnimationOptions的数组，用来定义动画的变化形式，之后会详细说明。 animations ：提供动画的闭包，也就是动画代码。 completion ：动画执行完成后的闭包 。 还有 usingSpringWithDamping和initialSpringVelocity之后章节会提到。 可动画属性前面，使用center创建简单的位置变化视图动画。 并非所有视图属性都可以设置动画，但所有视图动画（从最简单到最复杂）都可以通过动画视图上的属性来构建。下面来看看可用于动画的属性有哪些： 位置的大小bounds frame center 外形(Appearance)backgroundColoralpha : 可创建淡入和淡出效果。 转换(Transformation)transform ： 设置视图的旋转，缩放和/或位置的动画。 这些看起来像是非常基本的动画，可以制作令人惊讶的复杂动画效果！😉 动画选项动画选项(Animation options)就是之前提到的options参数，它是UIView.AnimationOptions的数组。UIView.AnimationOptions是结构体，有很多常量值，具体可查看官方文档 。 下面说明几个常用的 重复.repeat ：动画一直重复。 .autoreverse ：如果仅有.repeat参数动画的过程，就像是 b-&gt;e b-&gt;e ...，而有了.autoreverse，动画过程就像是b-&gt;e-&gt;b-&gt;e ...。看下图很容易看出区别。 动画缓动Animation easing，我暂且把它叫做 动画缓动。 curve:弯曲；使弯曲。ease：减轻，缓和。 在现实生活中，事物并不只是突然开始或停止移动。 像汽车或火车这样的物体会慢慢加速直到达到目标速度，除非它们碰到砖墙，否则它们会逐渐减速直到它们完全停在最终目的地。 为了使动画看起来更逼真，可以在开始时慢慢加速，在结束前放慢速度，一般称为缓入(ease-in)和缓出(ease-out)。 .curveLinear ：不对动画应用加速或减速。.curveEaseIn ：动画的开始时慢，结束时快。 123UIView.animate(withDuration: 1, delay: 0.6, options: [.repeat, .autoreverse, .curveEaseIn], animations: &#123; self.password.center.x += self.view.bounds.width&#125;, completion: nil) .curveEaseOut ：动画开始时快，结束时慢。 123UIView.animate(withDuration: 1, delay: 0.6, options: [.repeat, .autoreverse, .curveEaseOut], animations: &#123; self.password.center.x += self.view.bounds.width &#125;, completion: nil) .curveEaseInOut ：动画开始结束都慢，中间快 云的淡入动画这个很好理解，就是云的UIImageView的透明度变化动画。先在viewWillAppear()中把云设置成透明： 1234cloud1.alpha = 0.0cloud2.alpha = 0.0cloud3.alpha = 0.0cloud4.alpha = 0.0 然后在viewDidAppear()中添加动画。 123456789101112UIView.animate(withDuration: 0.5, delay: 0.5, options: [], animations: &#123; self.cloud1.alpha = 1.0&#125;, completion: nil)UIView.animate(withDuration: 0.5, delay: 0.7, options: [], animations: &#123; self.cloud2.alpha = 1.0&#125;, completion: nil)UIView.animate(withDuration: 0.5, delay: 0.9, options: [], animations: &#123; self.cloud3.alpha = 1.0&#125;, completion: nil)UIView.animate(withDuration: 0.5, delay: 1.1, options: [], animations: &#123; self.cloud4.alpha = 1.0&#125;, completion: nil) 2-弹簧动画1-视图动画入门中动画是单一方向上的动作，可以理解为一点移动到另一个。 这一章节是稍微复杂一点的弹簧动画(Springs)： 用点变化描述弹簧动画： 视图从A点到B点，在B点来回递减振荡，直到视图在B点停止。这是一个很好的效果， 让我们的动画添加了一种活泼，真实的感觉。 本章的开始项目 BahamaAirLoginScreen是上一章节的完成项目。 在viewWillAppear()中添加: 12loginButton.center.y += 30.0loginButton.alpha = 0.0 然后再在viewDidAppear()中添加： 12345UIView.animate(withDuration: 0.5, delay: 0.5, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.0, options: [], animations: &#123; self.loginButton.center.y -= 30.0 self.loginButton.alpha = 1.0&#125;, completion: nil) 这样Log In按钮就有个向上移动的动画变成了两个属性同时变化的动画。 usingSpringWithDamping ：阻尼参数， 介于0.0 ~ 1.0，接近0.0的值创建一个更有弹性的动画，而接近1.0的值创建一个看起来很僵硬的效果。 您可以将此值视为弹簧的“刚度”。 initialSpringVelocity ： 初始速度， 要平滑开始动画，请将此值与视图之前的视图速度相匹配。 效果： 与用户交互的动画让登录按钮产生一个与用户交互的动画，在Log In按钮的Action logIn()方法中添加： 123UIView.animate(withDuration: 1.5, delay: 0.0, usingSpringWithDamping: 0.2, initialSpringVelocity: 0.0, options: [], animations: &#123; self.loginButton.bounds.size.width += 80.0&#125;, completion: nil) 点击后有个宽度变大的简单动画。 继续在logIn()中添加： 123UIView.animate(withDuration: 0.33, delay: 0.0, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.0, options: [], animations: &#123; self.loginButton.center.y += 60.0&#125;, completion: nil) 点击后宽度变大的同时向下移动移动位置。 给用户反馈的另一个好方法是通过颜色变化。 在上面动画闭包中添加: 1self.loginButton.backgroundColor = UIColor(red: 0.85, green: 0.83, blue: 0.45, alpha: 1.0) 最后一个给用户反馈的方法：activity indicator(活动指示器，俗称菊花转😅)。 登录按钮应该通过网络启动用户身份验证活动，通过菊花转让用户知道登录操作正在进行。 继续在上面动画闭包中添加(spinner已经在viewDidLoad中初始化了，并且alpha设置为0.0)： 12self.spinner.center = CGPoint(x: 40.0, y: self.loginButton.frame.size.height/2)self.spinner.alpha = 1.0 让菊花转也随着登录按钮的向下移动而移动，最终登录按钮的效果： 把文本框的动画修改为弹簧动画把之前viewDidAppear()中的 123456UIView.animate(withDuration: 0.5, delay: 0.3, options: [], animations: &#123; self.username.center.x += self.view.bounds.width&#125;, completion: nil)UIView.animate(withDuration: 1, delay: 0.6, options: [], animations: &#123; self.password.center.x += self.view.bounds.width&#125;, completion: nil) 修改为： 1234567UIView.animate(withDuration: 0.5, delay: 0.3, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.0, options: [], animations: &#123; self.username.center.x += self.view.bounds.width&#125;, completion: nil)UIView.animate(withDuration: 0.5, delay: 0.4, usingSpringWithDamping: 0.6, initialSpringVelocity: 0.0, options: [], animations: &#123; self.password.center.x += self.view.bounds.width&#125;, completion: nil) 效果为： 3-过渡动画过渡动画(Transitions) 本章节的开始项目 是前一章节的完成项目。 过渡的例子使用过渡动画的各种动画场景。 添加视图要在屏幕上添加新视图的动画，可以调用类似于前面章节中使用的方法。 这次的不同之处在于，需要预先选择一个预定义的过渡效果，并为动画容器视图设置动画。过渡动画是设置在容器视图上，因此动画作用在添加到容器视图的所有子视图。 下面做一个测试（结束后，删除相应代码继续之后内容）： 123456789101112131415161718192021222324252627var animationContainerView: UIView!override func viewDidLoad() &#123; super.viewDidLoad() //设置动画容器视图 animationContainerView = UIView(frame: view.bounds) animationContainerView.frame = view.bounds view.addSubview(animationContainerView)&#125;override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) //创建新视图 let newView = UIImageView(image: UIImage(named: "banner")) newView.center = animationContainerView.center //通过过渡动画增加新视图 UIView.transition(with: animationContainerView, duration: 0.33, options: [.curveEaseOut, .transitionFlipFromBottom], animations: &#123; self.animationContainerView.addSubview(newView) &#125;, completion: nil )&#125; 效果： transitionFlipFromBottom被transitionFlipFromLeft替代后的效果： 完整的预定义过渡动画的选项如下，这些动画选项和上两节中出现options一样属于UIView.AnimationOptions。 1234567.transitionFlipFromLeft.transitionFlipFromRight.transitionCurlUp.transitionCurlDown.transitionCrossDissolve.transitionFlipFromTop.transitionFlipFromBottom 删除视图从屏幕中删除子视图的过渡动画操作和添加类似。 参考代码： 1234567UIView.transition(with: animationContainerView, duration: 0.33, options: [.curveEaseOut, .transitionFlipFromBottom], animations: &#123; self.newView.removeFromSuperview() &#125;, completion: nil) 隐藏或显示视图 添加和删除都会改变视图层次结构，这也是需要一个容器视图的原因。隐藏或显示的过渡动画使用视图本身作为动画容器。 参考代码： 1234567UIView.transition(with: self.newView, duration: 0.33, options: [.curveEaseOut, .transitionFlipFromBottom], animations: &#123; self.newView.isHidden = true &#125;, completion: nil) 一个视图替代另个视图 参考代码： 123UIView.transition(from: oldView, to: newView, duration: 0.33, options: .transitionFlipFromTop, completion: nil) 组合过渡动画这一部分将模拟一些用户身份验证过程，几个不同的进度消息变化的动画。 一旦用户点击登录按钮，将向他们显示消息，包括“Connecting…”，“Authorizing”和“Failed”。 在ViewController中添加方法showMessage()： 123456789func showMessage(index: Int) &#123; label.text = messages[index] UIView.transition(with: status, duration: 0.33, options: [.curveEaseOut, .transitionCurlDown], animations: &#123; self.status.isHidden = false &#125;, completion: &#123; _ in &#125;) &#125; 并在登录按钮的ActionlogIn方法的下移动画的completion闭包中添加调用self.showMessage(index: 0)： 12345UIView.animate(withDuration: 1.5, delay: 0.0, usingSpringWithDamping: 0.2, initialSpringVelocity: 0.0, options:[], animations: &#123; self.loginButton.bounds.size.width += 80.0&#125;, completion: &#123; _ in self.showMessage(index: 0)&#125;) 动画选项.transitionCurlDown的效果，就像一张纸翻下来，看起来如下： 这种效果很好的让静态文本标签的消息得到用户的关注。 注意：iPhone模拟器提供了慢动画查看，方便看清那些比较快动画的过程，Debug/Slow Animations(Command + T)。 添加一个状态信息消除动画方法: 12345678910func removeMessage(index: Int) &#123; UIView.animate(withDuration: 0.33, delay: 0.0, options: [], animations: &#123; self.status.center.x += self.view.frame.size.width &#125;) &#123; (_) in self.status.isHidden = true self.status.center = self.statusPosition self.showMessage(index: index+1) &#125;&#125; 这个信息消除方法在什么地方调用呢？当然是状态信息显示结束后调用，因此在showMessage方法的completion闭包中添加： 1234567delay(2.0) &#123; if index &lt; self.messages.count-1 &#123; self.removeMessage(index: index) &#125; else &#123; //reset form &#125;&#125; 恢复初始状态当“Connecting…”、“Authorizing”和“Failed”等几个信息显示完后，需要将信息标签删除和将登录按钮恢复原样。 添加resetForm()函数： 123456789101112131415func resetForm() &#123; // 状态信息标签消失动画 UIView.transition(with: status, duration: 0.2, options: .transitionFlipFromTop, animations: &#123; self.status.isHidden = true self.status.center = self.statusPosition &#125;, completion: nil) // 登录按钮和菊花转恢复原来状态的动画 UIView.animate(withDuration: 0.2, delay: 0.0, options: [], animations: &#123; self.spinner.center = CGPoint(x: -20.0, y: 16.0) self.spinner.alpha = 0.0 self.loginButton.backgroundColor = UIColor(red: 0.63, green: 0.84, blue: 0.35, alpha: 1.0) self.loginButton.bounds.size.width -= 80.0 self.loginButton.center.y -= 60.0 &#125;, completion: nil)&#125; 在之前的//reset form处调用，resetForm()。 结合之前的效果： 背景中☁️的动画如果背景中的那些云在屏幕上缓慢移动，并从左侧移动到右侧，然后到右侧消失后再左侧从新开始缓慢移动，那不是很酷吗？（之前的gif可以看到云在移动，到目前为止，云只有透明度变化动画，实际上是因为我做GIF时项目已经完成了，GIF是我补做的，所以就。。😬） 添加一个animateCloud(cloud: UIImageView)方法，代码为: 123456789101112func animateCloud(cloud: UIImageView) &#123; // 假设云从进入屏幕到离开屏幕需要大约60.0s，可以计算出云移动的速度 let cloudSpeed = view.frame.size.width / 60.0 // 云的初始位置不一定是在座边缘 let duration:CGFloat = (view.frame.size.width - cloud.frame.origin.x) / cloudSpeed UIView.animate(withDuration: TimeInterval(duration), delay: 0.0, options: .curveLinear, animations: &#123; cloud.frame.origin.x = self.view.frame.size.width &#125;) &#123; (_) in cloud.frame.origin.x = -cloud.frame.size.width self.animateCloud(cloud: cloud) &#125;&#125; 代码解释： 首先，计算☁️平均移动速度。假设云从进入屏幕到离开屏幕需要大约60.0s（当然这个时间自定义）。 接下来，计算☁️移动到屏幕右侧的持续时间。这边要注意，☁️不是从屏幕的左边缘开始，☁️移动的距离是view.frame.size.width - cloud.frame.origin.x。 然后创建动画方法animate(withDuration:delay:options:animations:completion:)。这边TimeInterval是Double别名，动画选项使用.curveLinear(不加速也不减速)，这种情况很少见，但作为☁️的缓慢移动非常适合。 动画闭包中cloud.frame.origin.x = self.view.frame.size.width，就把☁️移动到屏幕右边区域外。 到屏幕右区域外，立即在完成闭包中让☁️到左边缘外，cloud.frame.origin.x = -cloud.frame.size.width。 最后不要忘记，把开始四个☁️的动画，在viewDidAppear()中添加： 1234animateCloud(cloud: cloud1)animateCloud(cloud: cloud2)animateCloud(cloud: cloud3)animateCloud(cloud: cloud4) 整体效果： 4-练习视图动画本章是练习之前学习的动画。 本章节的开始项目 Flight Info 是定时改变几个视图（几个图片和一个Label），代码也非常简单： 1234567891011121314151617func changeFlight(to data: FlightData) &#123; // populate the UI with the next flight's data summary.text = data.summary flightNr.text = data.flightNr gateNr.text = data.gateNr departingFrom.text = data.departingFrom arrivingTo.text = data.arrivingTo flightStatus.text = data.flightStatus bgImageView.image = UIImage(named: data.weatherImageName) snowView.isHidden = !data.showWeatherEffects // schedule next flight delay(seconds: 3.0) &#123; self.changeFlight(to: data.isTakingOff ? parisToRome : londonToParis) &#125;&#125; 其中雪花❄️将在后面的章节26-粒子发射器学习，效果为： 淡出淡入动画(Crossfading animations)首先需要让两个背景图像之间平滑过渡。 第一直觉可能是简单地淡出当前的图像然后淡入新的图像（透明度的变化）。 但是当alpha接近零时，这种方法会显示图像背后的内容，效果看上去不好。如下所示： 在ViewController中添加背景图片淡入淡出的效果： 123456789func fade(imageView: UIImageView, toImage: UIImage, showEffects: Bool) &#123; UIView.transition(with: imageView, duration: 1.0, options: .transitionCrossDissolve, animations: &#123; imageView.image = toImage &#125;, completion: nil) UIView.animate(withDuration: 1.0, delay: 0.0, options: .curveEaseOut, animations: &#123; self.snowView.alpha = showEffects ? 1.0 : 0.0 &#125;, completion: nil)&#125; showEffects参数表示显示或隐藏降雪效果。 给changeFlight方法添加一个是否有动画的参数animated，并更新changeFlight方法: 1234567891011121314151617func changeFlight(to data: FlightData, animated: Bool = false) &#123; summary.text = data.summary flightNR.text = data.flightNr gateNr.text = data.gateNr departingFrom.text = data.departingFrom arrivingTo.text = data.arrivingTo flightStatus.text = data.flightStatus if animated &#123; fade(imageView: bgImageView, toImage: UIImage(named: data.weatherImageName)!, showEffects: data.showWeatherEffects) &#125; else &#123; bgImageView.image = UIImage(named: data.weatherImageName) snowView.isHidden = !data.showWeatherEffects &#125;&#125; 继续在changeFlight加一段让背景图不停循环变换的代码： 123delay(seconds: 3.0) &#123; self.changeFlight(to: data.isTakingOff ? parisToRome : londonToParis, animated: true)&#125; 现在的效果是： 对比开始时的效果，现在图像之间过渡非常流畅，因为在背景图淡入淡出的同时也对雪景效果进行了淡入淡出，动画看起来很无缝。 你甚至可以在罗马看到它一瞬间下雪！😝😝 不知不觉掌握了一种重要的技术：过渡动画可用于视图的不可动画属性。（1-视图动画入门中的可用于动画的属性中没有image） 动画选项.transitionCrossDissolve很适合当前项目的效果，其它如.transitionFlipFromLeft转换就不大适合，可以试试看。 立体过渡(Cube transitions)假装3d转换时文字背景颜色 这不是一个真正的3D效果，但它看起来非常接近。可以通过辅助视图来实现立体过渡动画。具体的方法是添加一个临时Label，同时对这个两个标签的高度进行动画，最后再删除。 在ViewController中添加一个枚举： 1234enum AnimationDirection: Int &#123; case positive = 1 case negative = -1&#125; 这个枚举的1和-1在之后表示在y轴变换时是向下还是向上。 添加一个cubeTransition方法： 12345678func cubeTransition(label: UILabel, text: String, direction: AnimationDirection) &#123; let auxLabel = UILabel(frame: label.frame) auxLabel.text = text auxLabel.font = label.font auxLabel.textAlignment = label.textAlignment auxLabel.textColor = label.textColor auxLabel.backgroundColor = label.backgroundColor&#125; 这是在构造一个临时辅助的Label，把原来Label属性复制给它，除了text使用新的值。 在Y轴方向变换辅助Label，向cubeTransition方法中添加： 123let auxLabelOffset = CGFloat(direction.rawValue) * label.frame.size.height/2.0auxLabel.transform = CGAffineTransform(translationX: 0.0, y: auxLabelOffset).scaledBy(x: 1.0, y: 0.1)label.superview?.addSubview(auxLabel) 当单独在Y轴缩放文本时，看起来就像一个竖着的平面被渐渐被推到，从而形成了假远景效果（faux-perspective effect）： 动画代码，继续在cubeTransition方法中添加： 1234567891011UIView.animate(withDuration: 0.5, delay: 0.0, options: .curveEaseOut, animations: &#123; auxLabel.transform = .identity // 原本的Label在Y轴上向反方向转换 label.transform = CGAffineTransform(translationX: 0.0, y: -auxLabelOffset).scaledBy(x: 1.0, y: 0.1)&#125;,completion: &#123; _ in // 把辅助Label的文本赋值给原来的Label，然后删除辅助Label label.text = auxLabel.text label.transform = .identity auxLabel.removeFromSuperview()&#125;) 最后要在changeFlight方法中添加这个假的3D转动效果动画： 12345678910111213141516171819202122if animated &#123; fade(imageView: bgImageView, toImage: UIImage(named: data.weatherImageName)!, showEffects: data.showWeatherEffects) let direction: AnimationDirection = data.isTakingOff ? .positive : .negative cubeTransition(label: flightNr, text: data.flightNr, direction: direction) cubeTransition(label: gateNr, text: data.gateNr, direction: direction)&#125; else &#123; // 不需要动画 bgImageView.image = UIImage(named: data.weatherImageName) snowView.isHidden = !data.showWeatherEffects flightNr.text = data.flightNr gateNr.text = data.gateNr departingFrom.text = data.departingFrom arrivingTo.text = data.arrivingTo flightStatus.text = data.flightStatus&#125; 最终，航班号和入口号的Label转换效果（我故意加长了动画duration，方便观看）： 淡入淡出和反弹的过渡为启程地和目的地Label添加淡入淡出和反弹的过渡(Fade and bounce transitions)动画。 先添加方法moveLabel，和上面的类似，创建一个辅助Label，并把原Label的一些属性复制给它。 123456789101112func moveLabel(label: UILabel, text: String, offset: CGPoint) &#123; let auxLabel = UILabel(frame: label.frame) auxLabel.text = text auxLabel.font = label.font auxLabel.textAlignment = label.textAlignment auxLabel.textColor = label.textColor auxLabel.backgroundColor = .clear auxLabel.transform = CGAffineTransform(translationX: offset.x, y: offset.y) auxLabel.alpha = 0 view.addSubview(auxLabel)&#125; 为原Label添加偏移转换和透明度渐渐降低动画，在moveLabel方法里添加： 1234UIView.animate(withDuration: 0.5, delay: 0.0, options: .curveEaseIn, animations: &#123; label.transform = CGAffineTransform(translationX: offset.x, y: offset.y) label.alpha = 0.0&#125;, completion: nil) 为辅助Label添加动画，并在动画结束后删除，在moveLabel方法里添加： 123456789UIView.animate(withDuration: 0.25, delay: 0.1, options: .curveEaseIn, animations: &#123; auxLabel.transform = .identity auxLabel.alpha = 1.0&#125;, completion: &#123; _ in auxLabel.removeFromSuperview() label.text = text label.alpha = 1.0 label.transform = .identity&#125;) 最后还是在changeFlight方法的if animated {中添加： 12345// 启程地和目的地Label动画let offsetDeparting = CGPoint(x: CGFloat(direction.rawValue * 80), y: 0.0)moveLabel(label: departingFrom, text: data.departingFrom, offset: offsetDeparting)let offsetArriving = CGPoint(x: 0.0, y: CGFloat(direction.rawValue * 50))moveLabel(label: arrivingTo, text: data.arrivingTo, offset: offsetArriving) 启程地和目的地Label动画的方向可以修改。 效果图： 航班状态条的动画可以使用前面的假的3D转动效果动画，changeFlight的if animated {中添加： 1cubeTransition(label: flightStatus, text: data.flightStatus, direction: direction) 本章节最终的效果： 5-关键帧动画很多时候，需要多个连续的动画。 前面的章节，已经使用动画闭包和完成闭包包含两个动画效果。 这种方法适用于连接两个简单的动画，但是当我们想要将三个，四个或更多动画组合在一起时，就会导致一些令人难以置信的混乱和复杂的代码。 让我们看看如果想将多个动画链接在一起并以矩形模式移动视图，它会是什么样子： 假设实现如下效果： 为了达到这个目的，可以将几个动画和完成闭包链接起来： 123456789101112131415161718192021222324252627UIView.animate(withDuration: 0.5, animations: &#123; view.center.x += 200.0 &#125;, completion: &#123; _ in UIView.animate(withDuration: 0.5, animations: &#123; view.center.y += 100.0 &#125;, completion: &#123; _ in UIView.animate(withDuration: 0.5, animations: &#123; view.center.x -= 200.0 &#125;, completion: &#123; _ in UIView.animate(withDuration: 0.5, animations: &#123; view.center.y -= 100.0 &#125; ) &#125; ) &#125; ) &#125;)``` 看上去复杂繁琐，这个时候就需要，使用本章节将要学习的关键帧动画(Keyframe Animations)，它可以代替上面繁琐的嵌套。 开始项目使用上一章节的完成项目Flight Info，通过让✈️“飞机来”，学习关键帧动画。 让飞机✈️起飞可以分成四个不同阶段的动画(当然具体怎么分可以视情况而定)： 在跑道上移动 给✈️一点高度，向上倾斜飞行 给飞机更大的倾斜和更快的速度，向上倾斜加速飞行 最后10%时飞机渐渐淡出视图 完整的动画可能会让人难以置信，但将动画分解为各个阶段会使其更易于管理。 一旦为每个阶段定义了关键帧，就会容易解决问题。 设置关键帧动画将让飞机从起始位置起飞，绕圈，然后降落并滑行回到起点。 每次屏幕在航班背景之间切换时，都会运行此动画。完整的动画将看起来像这样： 在ViewController中添加planeDepart()方法: 12345678910func planeDepart() &#123; let originalCenter = planeImage.center UIView.animateKeyframes(withDuration: 1.5, delay: 0.0, animations: &#123; //add keyframes &#125;, completion: nil )&#125; 并在changeFlight的 if animated {}调用planeDepart()： 1234if animated &#123; planeDepart() ... 添加第一个keyframe，在上面//add keyframes添加： 1234UIView.addKeyframe(withRelativeStartTime: 0.0, relativeDuration: 0.25, animations: &#123; self.planeImage.center.x += 80.0 self.planeImage.center.y -= 10.0&#125;) addKeyframe（withRelativeStartTime:relativeDuration:animations:) 与之前动画参数设置不同。withRelativeStartTime和relativeDuration都是相对时间百分比，相对于withDuration。 使用相对值可以指定keyframe应该持续总时间的一小部分; UIKit获取每个keyframe的相对持续时间，并自动计算每个keyframe的确切持续时间，为我们节省了大量工作。上面的代码的意思就是从1.5*0.0开始，持续时间1.5*0.25，✈️向右移动80.0，向上移动10.0。 接着上面，添加第二个keyframe： 123UIView.addKeyframe(withRelativeStartTime: 0.1, relativeDuration: 0.4, animations: &#123; self.planeImage.transform = CGAffineTransform(rotationAngle: -.pi/8)&#125;) 这一步是让✈️有个向上倾斜的角度。 接着，添加第三个keyframe： 12345UIView.addKeyframe(withRelativeStartTime: 0.25, relativeDuration: 0.25, animations: &#123; self.planeImage.center.x += 100.0 self.planeImage.center.y -= 50.0 self.planeImage.alpha = 0.0&#125;) 这一步在移动同时逐渐消失。 添加第四个keyframe： 1234UIView.addKeyframe(withRelativeStartTime: 0.51, relativeDuration: 0.01, animations: &#123; self.planeImage.transform = .identity self.planeImage.center = CGPoint(x: 0.0, y: originalCenter.y)&#125;) 这一步让✈️回到与原来高度相同的屏幕左边缘，不过现在换处于透明度为0状态。 添加第五个keyframe： 1234UIView.addKeyframe(withRelativeStartTime: 0.55, relativeDuration: 0.45, animations: &#123; self.planeImage.alpha = 1.0 self.planeImage.center = originalCenter&#125;) 让飞机回到原来位置。 现在来看这个五个keyframe的开始时间，它们不是一个接着一个的，而是有交集的，这是因为分步动画本身就有交叉，✈️在跑道上移动过程中也会有向上移动，机头也会渐渐向上倾斜，我把每一步的开始和持续时间列出来，得到这个时间可能需要之前不停调节，看什么时间分隔比较流畅🙂，下面是比较流畅的时间分隔方式。 12345(0.0, 0.25)(0.1, 0.4)(0.25, 0.25)(0.51, 0.01)(0.55, 0.45) 效果为： 关键帧动画中的计算模式关键帧动画不支持标准视图动画中可用的内置动画缓动。 这是设计好的; 关键帧应该在特定时间开始和结束并相互流动。 如果上面动画的每个阶段都有一个缓动曲线，那么飞机就会抖动，而不是从一个动画平稳地移动到下一个动画。 上面没有提到animateKeyframes(withDuration:delay:options:animations:completion:)方法，这方法有一个options参数（UIViewKeyframeAnimationOptions），可以提供几种计算模式的选择，每种模式提供了一种不同的方法来计算动画的中间帧以及不同的优化器，以实现帧之前的转化， 有关更多详细信息，可查看文档UIViewKeyframeAnimationOptions。 航班出发时间动画由于航班出发时间在屏幕顶部，变化时可以简单先向上移动到屏幕外，然后变化后再向下移动到屏幕内。 1234567891011121314func summarySwitch(to summaryText: String) &#123; UIView.animateKeyframes(withDuration: 1.0, delay: 0.0, animations: &#123; UIView.addKeyframe(withRelativeStartTime: 0.0, relativeDuration: 0.45, animations: &#123; self.summary.center.y -= 100.0 &#125;) UIView.addKeyframe(withRelativeStartTime: 0.5, relativeDuration: 0.45, animations: &#123; self.summary.center.y += 100.0 &#125;) &#125;, completion: nil) delay(seconds: 0.5) &#123; self.summary.text = summaryText &#125;&#125; 同样在changeFlight的 if animated {}中调用summarySwitch()。 本章最后效果：]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
        <tag>View Animation</tag>
        <tag>视图动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习iOS动画之零：说明和目录]]></title>
    <url>%2F2018%2FiOS-Animation-0.html</url>
    <content type="text"><![CDATA[动画制作很有趣，可以为用户界面注入活力。 如果使用得当，动画可以向用户传达信息，并将用户注意力吸引到界面的重要部分。 之前也做过一些iOS动画，但一直没有系统学习过，这次我用RW网站的书 《iOS Animations by Tutorials》 来系统地学习iOS动画。这本书的内容和项目不复杂但很全，基本上iOS动画的各个方面都介绍了。 《iOS Animations by Tutorials》 全书分为7个部分，27小章节，内容非常丰富，我对应7个部分分别总结为7篇文章，有几篇文章可能比较长，特别是动图比较多，用手机看的小伙伴请慎重，对自己温柔一点🥴。 开发环境：Xcode 10.1, Swift 4.2, macOS Mojave 10.14.1 目录目录可以很好看清整体脉络，每一篇文章的开始我也列出了小章节的题目，这样可以系统的学习iOS动画，那边有问题也好及时发先并对应到系统点上。要不可能越学越乱，这方面我自己深有体会的😕🤔。 系统学习iOS动画之一：视图动画系统学习iOS动画之二：自动布局动画系统学习iOS动画之三：图层动画系统学习iOS动画之四：视图控制器的转场动画系统学习iOS动画之五：使用UIViewPropertyAnimator系统学习iOS动画之六：3D动画系统学习iOS动画之七：其它类型的动画 关于代码我完成每一章节代码放在GitHub上 andyRon/LearniOSAnimations，代码中加一些中文注释便于理解。 原书提供的代码，每章都会有开始项目和最终完成项目代码（这应该是RW网站的惯例了😀），有的章节还有有挑战项目。建议按顺序阅读，因为前后章节知识点有一定关联。 开始项目都是相对简单项目或者是前一个章节的项目，可以直接使用原书提供的，也可以自己从头创建一下（我自己就是这么干的🤓🤓）。 悄悄地说，如果小伙伴暂时手头没有多余💰购买正版，可以私信我获取电子书+代码。 项目预览和对应章节 项目名 BahamaAirLoginScreen Flight Info Packing List 对应章节 1 2 3 8 9 10 11 12 4 5 6 7 预览图 项目名 MultiplayerSearch SlideToReveal PullToRefresh 对应章节 13 14 15 预览图 项目名 Lris BeginnerCook LogoReveal 对应章节 16 17 18 19 预览图 项目名 LockSearch OfficeBuddy ImageGallery 对应章节 20 21 22 23 24 25 预览图 项目名 Snow Scene SouthPoleFun 对应章节 26 27 预览图]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-AVL树]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-AVL%E6%A0%91.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/AVL Tree AVL树(AVL Tree) AVL树是二叉搜索树的自平衡形式，其中子树的高度最多只相差1。 当二叉树的左右子树包含大致相同数量的节点时，称树是 平衡的。 这就是使树搜索速度非常快的原因。 但是如果二元搜索树不平衡，搜索会变得非常慢。 这是一个不平衡树的例子： 所有的子节点都在左侧分支，没有一个在右侧分支。 这与链表基本相同。 因此，搜索需要 O(n) 时间，而不是您期望从二叉搜索树获得的更快的 O(log n) 。 该树的平衡版本如下所示： 使二进制搜索树平衡的一种方法是以完全随机的顺序插入节点。 但这并不能保证成功，也不总是切实可行。 另一种解决方案是使用自平衡二叉树。 插入或删除节点后，此类型的数据结构会调整树以使其保持平衡。 这种树的高度保证为 log(n)，其中 n 是节点的数量。 在平衡树上，所有插入，移除和搜索操作仅需 O(logn) 时间。 这意味着快速。;-) 介绍AVL树AVL树通过向左或向右“旋转”树来修复任何不平衡。 如果AVL树中的节点在“高度”上的差异最大为1，则认为它是平衡的。如果树的所有节点都是平衡的，则树本身是平衡的。 节点的height是获取该节点最低叶子所需的步数。 例如，在下面的树中，从A到E需要三个步，因此A的高度为3。B的高度为2，C的高度为1，其他的高度为0，因为它们是叶节点。 如上所述，在AVL树中，如果节点的左右子树具有相同的高度，则节点是平衡的。 当然不必是完全相同的高度，但差异不能大于1。这些都是平衡树的例子： 以下是不平衡的树，因为左子树的高度与右子树相比太大了： 左右子树的高度之间的差异称为平衡因子(balance factor)。 计算方法如下： balance factor = abs(height(left subtree) - height(right subtree)) 如果在插入或删除后平衡因子变得大于1，那么我们需要重新平衡AVL树的这一部分。 这是通过旋转完成的。 译注： abs是绝对值的意思。 旋转每个树节点在变量中跟踪其当前平衡因子。 插入新节点后，我们需要更新其父节点的平衡因子。 如果该平衡因子大于1，我们“旋转”该树的一部分以恢复平衡。 对于旋转，我们使用术语： Root - 将要旋转的子树的父节点; Pivot - 旋转后将成为父节点（基本上位于 Root 位置）的节点; RotationSubtree - 旋转侧的Pivot的子树 OppositeSubtree - 与旋转侧相对的Pivot的子树 让我们举一个使用右（顺时针方向）旋转来平衡不平衡树的示例： 旋转步骤可以通过以下方式描述： 将RotationSubtree指定为Root的新OppositeSubtree; 将Root指定为Pivot的新RotationSubtree; 检查最终结果 用伪代码，上面的算法可以写成如下： 123Root.OS = Pivot.RSPivot.RS = RootRoot = Pivot 这是一个恒定时间操作 - O(1) 插入永远不需要超过2次旋转。 删除可能需要最多 log(n) 轮换。 代码AVLTree.swift中的大多数代码只是常规二叉搜索树的东西。 您可以在二叉搜索树找到大部分实现。 例如，搜索树是完全相同的。 AVL树唯一不同的是插入和删除节点。 注意： 如果你对二叉搜索树的常规操作有点模糊，我建议你看这边。 这会使AVL树更容易理解。 有趣的位在balance()方法中，在插入或删除节点后调用。 扩展阅读AVL树的维基百科 AVL树是第一个自平衡二叉树。 最近，红黑树似乎更受欢迎。 作者：Mike Taghavi， Matthijs Hollemans翻译：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>AVL树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《以幽默的方式过一生》]]></title>
    <url>%2F2018%2F%E4%BB%A5%E5%B9%BD%E9%BB%98%E7%9A%84%E6%96%B9%E5%BC%8F%E8%BF%87%E4%B8%80%E7%94%9F.html</url>
    <content type="text"><![CDATA[自由选择是人的终极自由。 因为相对于亚当和夏娃犯错这件事来说，给他们犯错的权利和自由更重要，也就是人类的自由意志。 你可以选择善，也可以选择恶。 所有的伟大，都源于一个勇敢的开始。 职业不能有感觉了才开始行动。身为小姐，不能有感觉了再接客。 一个优秀的人，一定是在任何地方都表现出自己的优秀。 所谓职业，就是不管有没有欲望、灵感或状态，随时都可以让自己进入那个角色，在过程中找到感觉。当然，如有可能，尽量让自己体会到快乐。 处世每个人都可能会被骗，但不能因为被骗，就失去对所有人的信任。 一个坏朋友对你最大的打击，不是破坏了友谊，而是让你不再投入真诚。一个坏恋人对你最大的打击，不是让你伤痕累累，而是让你再也不敢投入感情。 可怕的，是你用这些过去，绑架了自己的未来。 在成人世界里，精确，是一件残忍的处世方式。糊涂，谁说不是一种高智商的生活态度。 成熟的定义是，在表达自己的同时，亦体谅对方的感受 生活中，解决问题，远比计较对错更有魅力！ 不要把精力用在讨好别人上。 在自己的世界里孤芳自赏，在别人的世界里随遇而安。 别人提意见，不必着急上火，他需要的或许不是建议，而是时间。 频繁使用感叹号的人，一般性子都比较急，以自我为中心，自己的情绪表达胜过一切，而往往不在意别人的感受。 表达正面情绪可以尽情用感叹号，比如你好帅！ 你那点事，有什么好说的。 爱爱是个动词，就是身为一个人，就应该有爱的能力，不要问为什么，这就是人存在于世界上的一个重要标志，所以你需要去释放爱，去爱人。 因为无知，所以迷恋。而一旦看清，就变成了赤裸裸的鄙视。 爱起来如疾风骤雨不爱死你不罢休，不爱了如雨过天晴当断则断绝不拖泥带水。爱恨分明不屑纠缠，侠肝义胆懒得伪装。说起话来干净利索绝不扭捏，做起事来风风火火当仁不让。 “长得丑化妆也就罢了，明明有些人天生丽质还要浪费这个时间，无法理解。” 始终找得到自己，才能真正爱上你。 要明白人是不完美的，才是长久相处的前提。 一种恋爱模式：爱是两个独立的人互相依靠。 在茫茫人海中我们都在寻找另一个自己，而不是在寻找一个完美的人。 读书读书是这个世界上最赚便宜的事情了，花几十元钱就能跟作者一辈子的思想做个交流。 读书最重要的作用，除了消遣，就是能发现生活的更多可能。 一是读书增加生命层次性 二是拥有更宽阔的胸怀。 三是增加智慧。 读着各种科幻的设想，其实核心还是人性的挣扎。《金瓶梅》无非用性来写人性，《红楼梦》是用贵族的没落来写人性，《西游记》用师徒取经的故事来写人性。 好作品，就是能剖析深刻的人性。而读人性，就是增长智慧，因为这世间最困扰人的，也就是人性了。 有人说读电子版的书没感觉，这纯粹是矫情，介质区别而已，何必如此纠结。就跟之前有人说用电脑写不出诗句一样，习惯就好了。 把精力用在更多的反思与分享上，比如读书后的心得，看完一部电影后的体会。你会逐渐发现，久而久之，自己的知识开始系统起来。 读书对一个人来说，永远都是进行时，而不是完成时。 生活生活，就是心怀最大的善意在荆棘中穿行。即使被刺伤，亦不改初衷。 人生的路归纳起来无非两条：一条用来实践，就是正在走的这条；一条用来遗憾，没事想想就好了。其实如果再给你一次选择，你依然会因为没有选择别的路而遗憾，因为人生不可能穷尽所有选择。 逛街重点在于“逛”，而不在于“买”。 我觉得短暂离开现实生活的方法大致有四种： 读书，是去别人的灵魂里偷窥； 看电影，是去银屏里感受别人的生活历程； 冥想，是去自己内心的秘境里探寻； 旅行，是去陌生的环境里感悟。 离开现实生活其实不是逃避，而是从另一个角度观察生活，启发心智。旅行归来自己还是自己，心境却已大不相同。读书、看电影、冥想三种方式只需要花费很小的成本就可以离开现实生活，旅行因为涉及种种安排和意外，所以稍微不慎就脱离不成，反而更加烦恼。 婚姻找个能说到一起的人结婚。 婚姻不是药，恋爱的问题不要用婚姻来解决。其实很多人在走入婚姻殿堂前，就明显知道双方是不合适的，但是他们天真地以为，结了婚就好了，婚姻真的是解决不合适的药方吗？当然不是，婚姻是两个人合适的结果。如果恋爱时存在问题，你千万不要以为通过婚姻就可以解决。如果谈恋爱都感觉不舒服，那婚后会更不舒服。为什么？因为婚姻后会放大这种痛苦，比如洗碗做饭拖地整理房间，这些鸡毛蒜皮的事都会放大两个人的矛盾。 如果我们的智商不在一个层次，怎么可能会结婚呢？ 成长母亲对我的信心，给了我极大的自信，所以我从小的志向渐渐地从村子，变成镇，变成市，变成省，变成国，而后变成了世界。 成熟就是在表达自己和体谅别人中间寻求一种平衡。 我很欣赏你，但不一定成为你，我转过身，安静地做我自己。 任何情况下，提升自己最重要。 生命，到底求长，还是求辉煌。 我们自己可以胆小怕事，我们可以明哲保身，这没什么丢人的，我们要活下去，就需要跟这个世界和解。但请不要辱骂那些铁骨铮铮敢于站出来的人，因为他们，世界上的不公或许会稍稍收敛一些。 其实你没必要活得那么紧张。 现在认为，人越成熟，就越放松，因为可以找得到生活的乐趣，所以不与世界为敌。我希望在我死后，我的墓志铭可以写：这个人轻轻松松活了一辈子，最后在微笑中走了。 没有一种痛会持久不消，没有一种恨会永承不变，没有一种爱会停滞不前，没有一种情会执迷不返。最终，时间会冲刷掉一切，在某个不经意间，与那个放下的自己见面，与这个世界和谈。 人生如四季，既得掌控春天的萌动，又得控制夏天的激情；既得享受秋天的收获，也得忍受冬天的孤独。 出发久了，就容易忘记目的地。 不要为了一条河，忘记了为什么而出战。 不是每个人的意见都值得倾听。 意见的逻辑规则。 个人真正的自信，来自基于理性的思考，而不是盲目自恋。一个人要摆脱自卑，也不是喊几句口号，或者相信几句心灵的安慰，而是来自理性思考之后，真正找到自己的价值所在。 自己的悲惨，不是让别人同情的资本。自己要强大，不能自甘堕落。 任何不能杀死你的，都会把你变得更加强大。 孤独多少人支持我，我不在意，但一个讨厌我的人，忽然喜欢我，我反而很在乎。 觉得别人晒，可能是自己缺。 我们觉得别人在晒什么，经常就是我们缺什么。 一个不能享受孤独的人，其实是很寂寞的。 孤独，其实是一种极高的人生姿态，因为你懂得如何照顾自己的内心需要。 说到底，人生就是自我对孤独的一场救赎，你越早学会越好。 教育教育孩子，我秉持四句话：旅行比上课重要，主见比顺从重要，兴趣比成绩重要，成长比输赢重要 你想别人抱着怎样的一个目的，开始做一件事情？兴趣，是最好的老师。 与其我们家长动用各种关系，去帮孩子得第一，不如去教育他如何面对失败与挫折，让他明白其实人生不可能每个地方都能成功，当然也没有绝对的失败，每次从成功或失败中得到成长才更重要。 原来，最有力量的语言，不是呵斥威胁，而是可爱地示弱。 其它所有看起来没有意义的累积，最终都会汇集起来，让今天的自己成为一个必然。 一是自己嘲笑失败的自己，自己都嘲笑过自己了，别人的嘲笑算什么呢？意思就是等你们嘲笑我的时候，我早就嘲笑过自己了，比如卖内衣那事，我自己都嘲笑过自己数百次了。 二是反向推理，把结果反过来，然后去寻找依据。比如，自己面试失败，我真是太悲催了，反向推理就是，真幸运今天面试失败了，然后去找个荒诞的理由让自己觉得开心，比如因为那家公司的前台实在不好看 出得了风头，顶得住骂名，受得了赞美，忍得住吐槽。 走在街上突然有一丝情感袭上心头，我就停下来，努力集中精力在这丝微弱的情感上，然后用文字把它描述出来。这丝情感稍纵即逝，经常是来不及用文字来描述就无影无踪。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-二叉搜索树]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Binary Search Tree 二叉搜索树(Binary Search Tree, BST) 这个话题已经有个辅助文章 二叉搜索树（或者叫做二分搜索树）是一种特殊的二叉树（每个节点最多有两个子节点），它执行插入和删除，以便始终对树进行排序。 译注： sort，平常都可以理解为从大到小或从小到大的排序，但本文有点不同，可以理解为是按一定规则的整理。因为“排序”在汉语中也不是简单理解为从大到小或从小到大，所以我还是把sort翻译成排序，但注意和平常理解的排序有点不同。 有关树的更多信息，请先阅读。 “始终排序”属性下面是一个有效二叉搜索树的示例： 注意每个左子节点小于其父节点，并且每个右子节点大于其父节点。 这是二叉搜索树的关键特性。 例如，2小于7，因此它在左边; 5大于2，因此它在右边。 插入新节点执行插入时，我们首先将新值与根节点进行比较。 如果新值较小，我们采取 左 分支; 如果更大，我们采取 右 分支。我们沿着这条路向下走，直到找到一个我们可以插入新值的空位。 假设我们要插入新值9： 我们从树的根（值为7的节点）开始，并将其与新值9进行比较。 9 &gt; 7，因此我们走右边的分支，并重复相同的过程，但这次节点是10。 因为9 &lt; 10，所以我们走左边的分支。 我们现在到了一个没有更多值可供比较的地方。 在该位置插入9的新节点。 插入新值9后树结构： 只有一个可能的位置可以在树中插入新元素。 找到这个地方通常很快。 它需要 O(h) 时间，其中 h 是树的高度。 注意： 节点的 高度 是从该节点到最低叶节点所需的步骤数。 整棵树的高度是从根到最低叶节点的距离。 二叉搜索树上的许多操作都以树的高度表示。 通过遵循这个简单的规则 —— 左侧较小的值，右侧较大的值 —— 我们保持树的排序，因此无论何时都可以查询某值是否在树种。 搜索树要在树中查找值，我们执行与插入相同的步骤： 如果该值小于当前节点，则选择左分支。 如果该值大于当前节点，则选择右分支。 如果该值等于当前节点，我们就找到了它！ 像大多数树操作一样，这是递归执行的，直到找到我们正在查找的内容或查完要查看的所有节点。 以下是搜索值5的示例： 使用树的结构搜索很快。 它在 O(h) 时间内运行。 如果你有一个具有一百万个节点的均衡树，那么在这棵树中只需要大约20步就可以找到任何东西。（这个想法与数组中的二分搜索非常相似） 注： 2^0 + 2^1 + 2^2 + ... + 2^19 大约是百万级别。 遍历树有时您需要查看所有节点而不是仅查看一个节点。 遍历二叉树有三种方法： 中序（或 深度优先，In-order/depth-first）：首先查看节点的左子节点，然后查看节点本身，最后查看其右子节点。 前序（Pre-order）：首先查看节点本身，然后查看其左右子节点。 后序（Post-order）：首先查看左右子节点并最后处理节点本身。 遍历树的过程也是递归的。 如果按中序遍历二叉搜索树，它会查看所有节点，就好像它们从低到高排序一样。 对于示例树，将打印1, 2, 5, 7, 9, 10： 删除节点删除节点很容易。不过删除节点后，需要将节点替换为左侧最大的子节点或右侧的最小子节点。这样，树在删除节点后仍然排序。在以下示例中，将删除10并替换为9（Figure 2）或11（Figure 3）。 请注意，当节点至少有一个子节点时，需要进行替换。 如果它没有子节点，您只需将其与其父节点断开连接： 代码（解决方案1）说了太多理论了。让我们看看如何在Swift中实现二叉搜索树。您可以采取不同的实现方法。首先，我将向您展示如何制作基于类的版本，但我们还将介绍如何使用枚举制作版本。 以下是BinarySearchTree类的示例： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class BinarySearchTree&lt;T: Comparable&gt; &#123; private(set) public var value: T private(set) public var parent: BinarySearchTree? private(set) public var left: BinarySearchTree? private(set) public var right: BinarySearchTree? public init(value: T) &#123; self.value = value &#125; /// 是否是根节点 public var isRoot: Bool &#123; return parent == nil &#125; /// 是否是叶节点 public var isLeaf: Bool &#123; return left == nil &amp;&amp; right == nil &#125; /// 是否是左子节点 public var isLeftChild: Bool &#123; return parent?.left === self &#125; /// 是否是右子节点 public var isRightChild: Bool &#123; return parent?.right === self &#125; /// 是否有左子节点 public var hasLeftChild: Bool &#123; return left != nil &#125; /// 是否有右子节点 public var hasRightChild: Bool &#123; return right != nil &#125; /// 是否有子节点 public var hasAnyChild: Bool &#123; return hasLeftChild || hasRightChild &#125; /// 是否左右两个子节点都有 public var hasBothChildren: Bool &#123; return hasLeftChild &amp;&amp; hasRightChild &#125; /// 当前节点包括子树中的所有节点总数 public var count: Int &#123; return (left?.count ?? 0) + 1 + (right?.count ?? 0) &#125;&#125; 此类仅描述单个节点而不是整个树。 它是泛型类型，因此节点可以存储任何类型的数据。 它还包含了left和right子节点以及一个parent节点的引用。 以下是如何使用它： 1let tree = BinarySearchTree&lt;Int&gt;(value: 7) count属性是此节点描述的子树中有多少个节点（译注：本身+此节点的所有子节点）。这不仅仅计算节点的直接子节点，还计算它们的子节点和子节点的子节点，等等。如果此节点是根节点，则count表示计算整个树中有多少个节点。 注意： 因为left，right和parent是可选的，我们可以很好地利用Swift的可选值链（?）和 空合运算符（??）。 你也可以用if let，但那不简洁。 译注：关于空合运算符，可查看我之前写的一篇文章Swift中的问号三种用法 插入节点只有树节点本身是没有什么用的，所以需要如何向树添加新节点的方法： 1234567891011121314151617public func insert(value: T) &#123; if value &lt; self.value &#123; if let left = left &#123; left.insert(value: value) &#125; else &#123; left = BinarySearchTree(value: value) left?.parent = self &#125; &#125; else &#123; if let right = right &#123; right.insert(value: value) &#125; else &#123; right = BinarySearchTree(value: value) right?.parent = self &#125; &#125;&#125; 像许多其他树操作一样，插入最容易用递归实现。 我们将新值与现有节点的值进行比较，并决定是将其添加到左侧分支还是右侧分支。 如果没有更多的左或右子节点，我们创建一个新节点BinarySearchTree对象，并通过设置其parent属性将其连接到树。 注意： 因为二叉搜索树的都是左边有较小的节点而右边有较大的节点，所以你应该总是在根节点开始（比较）插入元素，以确保它仍然是一个有效的二叉树！ 构建上面示例中完整的树： 123456let tree = BinarySearchTree&lt;Int&gt;(value: 7)tree.insert(2)tree.insert(5)tree.insert(10)tree.insert(9)tree.insert(1) Note: For reasons that will become clear later, you should insert the numbers in a random order. If you insert them in a sorted order, the tree will not have the right shape.注意： 由于后来会变得明确的原因，您应该以随机顺序插入数字。 如果按排序顺序插入它们，则树的形状将不正确。 （？？由于理解不够深，翻译的不准确，保留原文） 为方便起见，让我们添加一个以数组的方式初始化的方法，这个方法为数组中所有元素调用insert()： 1234567public convenience init(array: [T]) &#123; precondition(array.count &gt; 0) self.init(value: array.first!) for v in array.dropFirst() &#123; insert(value: v) &#125;&#125; 现在可以简单的使用： 1let tree = BinarySearchTree&lt;Int&gt;(array: [7, 2, 5, 10, 9, 1]) 数组中的第一个值成为树的根节点。 调试输出使用复杂的数据结构时，拥有人类可读的调试输出很有用。 12345678910111213extension BinarySearchTree: CustomStringConvertible &#123; public var description: String &#123; var s = "" if let left = left &#123; s += "(\(left.description)) &lt;- " &#125; s += "\(value)" if let right = right &#123; s += " -&gt; (\(right.description))" &#125; return s &#125;&#125; 当你执行print(tree)时，你应该得到： 1((1) &lt;- 2 -&gt; (5)) &lt;- 7 -&gt; ((9) &lt;- 10) 根节点位于中间。 发挥一些想象力，您应该看到这确实对应于下面的树： 您可能想知道插入重复项时会发生什么？我们总是将它们插入正确的分支中。 试试看！ 搜索我们现在做什么，让树有一些价值？ 当然，搜索它们吧！ 快速查找项是二叉搜索树的主要目的。:-) 这是search()的实现： 123456789public func search(value: T) -&gt; BinarySearchTree? &#123; if value &lt; self.value &#123; return left?.search(value) &#125; else if value &gt; self.value &#123; return right?.search(value) &#125; else &#123; return self // found it! &#125;&#125; 我希望逻辑清楚：这从当前节点（通常是根节点）开始并比较这些值。 如果搜索值小于节点的值，我们继续在左侧分支中搜索;如果搜索值更大，我们会跳到右侧分支中搜索。 如果没有更多的节点要看 —— 当left或right为nil时 —— 那么我们返回nil表示搜索值不在树中。 注意： 在Swift中，可以通过可选链方便地完成; 当你写left?.search(value)时，如果left为nil，它会自动返回nil。 没有必要使用if语句显式检查。 搜索是一个递归过程，但您也可以使用简单的迭代来实现它： 12345678910111213public func search(_ value: T) -&gt; BinarySearchTree? &#123; var node: BinarySearchTree? = self while let n = node &#123; if value &lt; n.value &#123; node = n.left &#125; else if value &gt; n.value &#123; node = n.right &#125; else &#123; return node &#125; &#125; return nil&#125; 验证您是否理解这两个实现是等效的。 就个人而言，我更喜欢使用迭代代码而不是递归代码，但您的意见可能会有所不同。;-) 测试搜索： 1234tree.search(value: 5)tree.search(value: 2)tree.search(value: 7)tree.search(value: 6) // nil 前三行返回相应的BinaryTreeNode对象。 最后一行返回nil，因为没有值为6的节点。 注意： 如果树中有重复项，search()返回“最高”节点。 这是有道理的，因为我们开始从根节点向下搜索。 遍历还记得有三种不同的方法可以查看树中的所有节点吗？ 如下： 1234567891011121314151617public func traverseInOrder(process: (T) -&gt; Void) &#123; left?.traverseInOrder(process: process) process(value) right?.traverseInOrder(process: process)&#125;public func traversePreOrder(process: (T) -&gt; Void) &#123; process(value) left?.traversePreOrder(process: process) right?.traversePreOrder(process: process)&#125;public func traversePostOrder(process: (T) -&gt; Void) &#123; left?.traversePostOrder(process: process) right?.traversePostOrder(process: process) process(value)&#125; 它们都以不同的顺序工作。 请注意，所有工作都是递归完成的。 Swift的可选链清楚地表明，当没有左或右子节点时，忽略对traverseInOrder()等的调用。 要打印出从低到高排序的树的所有值，您可以编写： 1tree.traverseInOrder &#123; value in print(value) &#125; 打印结果： 1234561257910 你还可以在树中添加map()和filter()方法。 例如，这是map的实现： 1234567public func map(formula: (T) -&gt; T) -&gt; [T] &#123; var a = [T]() if let left = left &#123; a += left.map(formula: formula) &#125; a.append(formula(value)) if let right = right &#123; a += right.map(formula: formula) &#125; return a&#125; 这将在树中的每个节点上调用formula闭包，并在结果以数组返回。 map()通过按中序遍历树来工作。 一个非常简单的如何使用map()的例子： 123public func toArray() -&gt; [T] &#123; return map &#123; $0 &#125;&#125; 这会将树的内容重新转换为已排序的数组。 在playground上试一试： 1tree.toArray() // [1, 2, 5, 7, 9, 10] 作为练习，看看是否可以实现filter和reduce。 译注：map, filter和reduce都是高阶函数，关于高阶函数可查看我总结的文章 Swift中的高阶函数：sorted, map, reduce, forEach, flatMap, filter 。 删除节点我们可以通过定义一些辅助函数来使代码更具可读性。 12345678910private func reconnectParentTo(node: BinarySearchTree?) &#123; if let parent = parent &#123; if isLeftChild &#123; parent.left = node &#125; else &#123; parent.right = node &#125; &#125; node?.parent = parent&#125; 对树进行更改涉及更改parent和left和right指针。 此功能有助于实现此功能。 它接受当前节点的父节点 - 即self - 并将其连接到另一个节点，该节点将是self的子节点之一。 我们还需要一个返回节点最小值和最大值的函数： 123456789101112131415public func minimum() -&gt; BinarySearchTree &#123; var node = self while let next = node.left &#123; node = next &#125; return node&#125;public func maximum() -&gt; BinarySearchTree &#123; var node = self while let next = node.right &#123; node = next &#125; return node&#125; 其余代码是不言自明的： 1234567891011121314151617181920212223242526272829@discardableResult public func remove() -&gt; BinarySearchTree? &#123; let replacement: BinarySearchTree? // Replacement for current node can be either biggest one on the left or // smallest one on the right, whichever is not nil if let right = right &#123; replacement = right.minimum() &#125; else if let left = left &#123; replacement = left.maximum() &#125; else &#123; replacement = nil &#125; replacement?.remove() // Place the replacement on current node's position replacement?.right = right replacement?.left = left right?.parent = replacement left?.parent = replacement reconnectParentTo(node:replacement) // The current node is no longer part of the tree, so clean it up. parent = nil left = nil right = nil return replacement&#125; 译注： swift正常的方法如果有返回值的话,调用的时候必须有一个接收方,否则的话编译器会报一个警告,如果在方法前加上@discardableResult 不处理的时候就不会有警告了。 深度和高度回想一下节点的高度是到最低叶节点的距离。 我们可以用以下函数来计算： 1234567public func height() -&gt; Int &#123; if isLeaf &#123; return 0 &#125; else &#123; return 1 + max(left?.height() ?? 0, right?.height() ?? 0) &#125;&#125; 我们看一下左右分支的高度并取最大值。 同样，这是一个递归过程。 由于这会查看此节点的所有子节点，因此性能为 O(n)。 注意： Swift的空合运算符方便处理left或right指针为nil的情况。 你也可以用if let，但这更简洁。 试试看： 1tree.height() // 2 您还可以计算节点的 深度，即到根节点的距离。 这是代码： 123456789public func depth() -&gt; Int &#123; var node = self var edges = 0 while let parent = node.parent &#123; node = parent edges += 1 &#125; return edges&#125; 它沿着 parent 指针向上逐步穿过树，直到我们到达根节点（即parent为nil）。 这需要 O(h) 时间。 这是一个例子： 123if let node9 = tree.search(9) &#123; node9.depth() // returns 2&#125; 前驱节点和后继节点二叉搜索树总是“排序”，但这并不意味着连续的数字实际上在树中是彼此相邻的。 请注意，通过查看其左子节点，您无法找到7之前的数字。 左子节点是2，而不是5。 同样地，也无法找到7之后的数字。 predecessor()函数以排序顺序返回其值在当前值之前的节点： 123456789101112public func predecessor() -&gt; BinarySearchTree&lt;T&gt;? &#123; if let left = left &#123; return left.maximum() &#125; else &#123; var node = self while let parent = node.parent &#123; if parent.value &lt; value &#123; return parent &#125; node = parent &#125; return nil &#125;&#125; 如果该节点有左子树很容易。 在这种情况下，该节点的前驱节点是左子树中的最大值。 您可以在上面的图片中验证5确实是7左分支中的最大值。 如果没有左子树，那么我们必须查看父节点，直到找到一个较小的值。如果我们想知道节点9的前驱节点是什么，我们一直向上，直到找到第一个具有较小值的父节点，即7。 successor()的代码以相同的方式工作： 123456789101112public func successor() -&gt; BinarySearchTree&lt;T&gt;? &#123; if let right = right &#123; return right.minimum() &#125; else &#123; var node = self while let parent = node.parent &#123; if parent.value &gt; value &#123; return parent &#125; node = parent &#125; return nil &#125;&#125; 这两种方法都在 O(h) 时间内运行。 注意： 有一种称为“线索”二叉树的二叉搜索树变体，其中“未使用的”左右指针被重新用于在前驱节点和后继节点之间建立直接链接。 非常聪明！ 搜索树有效吗？如果您打算进行破坏，可以通过在非根节点上调用insert()将二分搜索树变为无效树。 这是一个例子： 123if let node1 = tree.search(1) &#123; node1.insert(100)&#125; 根节点的值为7，因此值为100的节点必须位于树的右侧分支中。 但是，您不是插入根，而是插入树左侧分支中的叶节点。 所以新的100节点在树中的错误位置！ 结果，tree.search(100)给出nil。 您可以使用以下方法检查树是否是有效的二叉搜索树： 123456public func isBST(minValue minValue: T, maxValue: T) -&gt; Bool &#123; if value &lt; minValue || value &gt; maxValue &#123; return false &#125; let leftBST = left?.isBST(minValue: minValue, maxValue: value) ?? true let rightBST = right?.isBST(minValue: value, maxValue: maxValue) ?? true return leftBST &amp;&amp; rightBST&#125; 这将验证左侧分支包含的值是否小于当前节点的值，右侧分支仅包含更大的值。 使用如下： 123456if let node1 = tree.search(1) &#123; tree.isBST(minValue: Int.min, maxValue: Int.max) // true node1.insert(100) // EVIL!!! tree.search(100) // nil tree.isBST(minValue: Int.min, maxValue: Int.max) // false&#125; 代码（解决方案2）我们已经使用类实现二叉树节点，但您也可以使用枚举。 鉴于引用类型与值类型的不同。 对基于类的树进行更改将更新内存中的相同实例，但基于枚举的树是不可变的 - 任何插入或删除都将为您提供树的全新副本。哪一个好，完全取决于你想用它做什么。 以下是使用枚举创建二叉搜索树的方法： 12345public enum BinarySearchTree&lt;T: Comparable&gt; &#123; case Empty case Leaf(T) indirect case Node(BinarySearchTree, T, BinarySearchTree)&#125; 枚举有三种情况： Empty标记分支的结尾（基于类的版本使用nil引用）。 没有子节点的叶节点的Leaf。 具有一个或两个子节点的节点的Node。 这标记为indirect，因此它可以保存BinarySearchTree值。 如果没有indirect，你就无法生成递归枚举。 注意：此二叉树中的节点没有对其父节点的引用。 这不是一个主要障碍，但它会使某些操作实施起来更加麻烦。 这个实现是递归的，枚举的每个情况都将被区别对待。 例如，这是您可以计算树中节点数和树高的方法： 123456789101112131415public var count: Int &#123; switch self &#123; case .Empty: return 0 case .Leaf: return 1 case let .Node(left, _, right): return left.count + 1 + right.count &#125;&#125;public var height: Int &#123; switch self &#123; case .Empty: return 0 case .Leaf: return 1 case let .Node(left, _, right): return 1 + max(left.height, right.height) &#125;&#125; 插入新节点如下所示： 1234567891011121314151617181920public func insert(newValue: T) -&gt; BinarySearchTree &#123; switch self &#123; case .Empty: return .Leaf(newValue) case .Leaf(let value): if newValue &lt; value &#123; return .Node(.Leaf(newValue), value, .Empty) &#125; else &#123; return .Node(.Empty, value, .Leaf(newValue)) &#125; case .Node(let left, let value, let right): if newValue &lt; value &#123; return .Node(left.insert(newValue), value, right) &#125; else &#123; return .Node(left, value, right.insert(newValue)) &#125; &#125;&#125; 在playground尝试： 123456var tree = BinarySearchTree.Leaf(7)tree = tree.insert(2)tree = tree.insert(5)tree = tree.insert(10)tree = tree.insert(9)tree = tree.insert(1) 请注意，对于每次插入，都会返回一个新的树对象，因此需要将结果分配回tree变量。 这是最重要的搜索功能： 12345678910111213141516public func search(x: T) -&gt; BinarySearchTree? &#123; switch self &#123; case .Empty: return nil case .Leaf(let y): return (x == y) ? self : nil case let .Node(left, y, right): if x &lt; y &#123; return left.search(x) &#125; else if y &lt; x &#123; return right.search(x) &#125; else &#123; return self &#125; &#125;&#125; 大多数这些功能具有相同的结构。 在playground尝试： 123tree.search(10)tree.search(1)tree.search(11) // nil 要打印树以进行调试，可以使用以下方法： 12345678910extension BinarySearchTree: CustomDebugStringConvertible &#123; public var debugDescription: String &#123; switch self &#123; case .Empty: return "." case .Leaf(let value): return "\(value)" case .Node(let left, let value, let right): return "(\(left.debugDescription) &lt;- \(value) -&gt; \(right.debugDescription))" &#125; &#125;&#125; 当你执行print(tree)时，它看起来像这样： 1((1 &lt;- 2 -&gt; 5) &lt;- 7 -&gt; (9 &lt;- 10 -&gt; .)) 根节点位于中间，点表示该位置没有子节点。 当树变得不平衡时……当二叉制搜索树的左右子树包含相同数量的节点时，它是平衡的。 在这种情况下，树的高度为 log(n)，其中 n 是节点数。 这是理想的情况。 如果一个分支明显长于另一个分支，则搜索变得非常慢。 我们最终检查的花费超出了我们的需要。 在最坏的情况下，树的高度可以变为 n。 这样的树就像 链表 而不是二叉搜索树，性能降低到 O(n)。 不好！ 使二叉制搜索树平衡的一种方法是以完全随机的顺序插入节点。 平均而言，应该很好地平衡树，但不保证，也不总是实用。 另一种解决方案是使用 自平衡 二叉树。 插入或删除节点后，此类型的数据结构会调整树以使其保持平衡。 要查看示例，请查看AVL树和红黑树。 扩展阅读二叉树搜索的维基百科 作者：Nicolas Ameghino 和 Matthijs Hollemans译者：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>二叉搜索树</tag>
        <tag>Binary Search Tree</tag>
        <tag>BST</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-哈希表]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%93%88%E5%B8%8C%E8%A1%A8.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Hash Table 哈希表(Hash Table) 哈希表允许您通过“键”存储和检索对象。 哈希表用于实现一些结构，例如字典，映射和关联数组。 这些结构可以通过树或普通数组实现，但使用哈希表效率更高。 这也可以解释为什么Swift的内置Dictionary类型要求键符合Hashable协议：在内部Dictionary使用哈希表实现，就像你将在这里学到的那样。 怎么工作的哈希表只不过是一个数组。 最初，此数组为空。 将值放入某个键下的哈希表时，它使用该键计算数组中的索引。 这是一个例子： 1234567891011121314hashTable["firstName"] = "Steve" The hashTable array: +--------------+ | 0: | +--------------+ | 1: | +--------------+ | 2: | +--------------+ | 3: firstName |---&gt; Steve +--------------+ | 4: | +--------------+ In this example, the key &quot;firstName&quot; maps to array index 3.在这个例子中，键&quot;firstName&quot;映射到数组索引3。 Adding a value under a different key puts it at another array index:在不同的键下添加值会将其放在另一个数组索引处： 1234567891011121314hashTable["hobbies"] = "Programming Swift" The hashTable array: +--------------+ | 0: | +--------------+ | 1: hobbies |---&gt; Programming Swift +--------------+ | 2: | +--------------+ | 3: firstName |---&gt; Steve +--------------+ | 4: | +--------------+ The trick is how the hash table calculates those array indices. That is where the hashing comes in. When you write the following statement,这边的诀窍是哈希表如何计算这些数组索引。 这就是哈希的用武之地。当你写下面的陈述时， 1hashTable["firstName"] = "Steve" 哈希表使用键&quot;firstName&quot;并询问它的hashValue属性。 因此，键必须符合Hashable协议。 当你写&quot;firstName&quot;.hashValue时，它返回一个大整数：-4799450059917011053。 同样，&quot;hobbies&quot;.hashValue的哈希值为4799450060928805186.（您看到的值可能会有所不同。） 这些数字很大，可以用作我们数组的索引，其中一个甚至是负数！使这些大数字可用的常用方法是首先使哈希值为正，然后数组大小进行取模运算（取余数），这个值就是数组的索引。 我们的数组大小为5，所以&quot;firstName&quot;键的索引变为abs(-4799450059917011053) % 5 = 3。 你可以计算出&quot;hobbies&quot;的数组索引是1（译注： abs(4799450060928805186) % 5 = 1）。 以这种方式使用哈希是使字典有效的原因：要在哈希表中查找元素，必须用键的哈希值以获取数组索引，然后在底层数组中查找元素。 所有这些操作都需要不变的时间，因此插入，检索和删除都是 O(1)。 注意： 很难预测数组中对象的最终位置。 因此，字典不保证哈希表中元素的任何特定顺序。 避免冲突有一个问题：因为我们采用哈希值的模数和数组的大小，可能会发生两个或多个键被赋予相同的数组索引。 这称为冲突。 避免冲突的一种方法是使用大型数组，这样可以降低两个键映射到同一索引的可能性。另一个技巧是使用素数作为数组大小。但是，必然会发生冲突，因此您需要找到一种方法来处理冲突。 因为我们的表很小，很容易出现冲突。 例如，键&quot;lastName&quot; 的数组索引也是3，但我们不想覆盖已在此数组索引处的值。 处理冲突的常用方法是使用链接（chaining）。 该数组如下所示： 123456789101112buckets:+-----+| 0 |+-----+ +----------------------------+| 1 |---&gt; | hobbies: Programming Swift |+-----+ +----------------------------+| 2 |+-----+ +------------------+ +----------------+| 3 |---&gt; | firstName: Steve |---&gt; | lastName: Jobs |+-----+ +------------------+ +----------------+| 4 |+-----+ 使用链接，键和它们的值不会直接存储在数组中。 相反，每个数组元素都是零个或多个键/值对的列表。 数组元素通常称为 buckets(可以译为桶)，列表称为 chains(可以译为链)。 这里我们有5个桶，其中两个桶有链。 其他三个桶都是空的。 如果我们编写以下语句来从哈希表中检索项目， 1let x = hashTable["lastName"] 它首先用哈希键 &quot;lastName&quot; 来计算数组索引，即3。由于桶3有一个链，我们逐步遍历列表，找到带有 &quot;lastName&quot;键的值。这是通过使用字符串比较来比较键来完成的。 哈希表检查键是否属于链中的最后一项，并返回相应的值 &quot;Jobs&quot;。 实现此链机制的常用方法是使用链表或其他数组。由于链中项目的顺序无关紧要，您可以将其视为集合而不是列表。（现在你也可以想象术语“桶”的来源;我们只是将所有对象一起转储到桶中。） 链不应该变长，因为查找哈希表中的项将变得缓慢。理想情况下，我们根本没有链，但实际上不可能避免冲突。您可以通过使用高质量哈希函数为哈希表提供足够的桶来提高（避免冲突的）几率。 注意： 链的替代方法是“开放寻址”。 这个想法是这样的：如果已经采用了数组索引，我们将该元素放在下一个未使用的存储桶中。 这种方法有其自身的优点和缺点。 代码让我们看一下Swift中哈希表的基本实现。 我们将逐步建立起来。 12345678910111213public struct HashTable&lt;Key: Hashable, Value&gt; &#123; private typealias Element = (key: Key, value: Value) private typealias Bucket = [Element] private var buckets: [Bucket] private(set) public var count = 0 public var isEmpty: Bool &#123; return count == 0 &#125; public init(capacity: Int) &#123; assert(capacity &gt; 0) buckets = Array&lt;Bucket&gt;(repeatElement([], count: capacity)) &#125; HashTable是一个通用容器，两个泛型类型被命名为Key（必须是Hashable）和Value。 我们还定义了另外两种类型：Element是在链中使用的键/值对，而Bucket是这样的Elements的数组。 主数组名为buckets。 初始化方法init(capacity)利用固定容量来确定数组的大小。 我们还可以使用count变量跟踪已经向哈希表添加了多少项。 如何创建新哈希表对象的示例： 1var hashTable = HashTable&lt;String, String&gt;(capacity: 5) 哈希表还不能做任何事情，所以让我们添加下面的功能。 首先，添加一个帮助方法来计算给定键的数组索引： 123private func index(forKey key: Key) -&gt; Int &#123; return abs(key.hashValue) % buckets.count&#125; 这将执行您之前看到的计算：它将键的hashValue的绝对值对桶数组的大小取模。 我们已将其置于其自身的功能中，因为它在少数不同的地方使用。 使用哈希表或字典有四种常见的事情： insert a new element 插入一个新元素 查找元素 更新现有元素 删除元素 这些的语法是： 1234hashTable["firstName"] = "Steve" // insertlet x = hashTable["firstName"] // lookuphashTable["firstName"] = "Tim" // updatehashTable["firstName"] = nil // delete 我们也可以使用 subscript 函数完成所有这些操作： 123456789101112public subscript(key: Key) -&gt; Value? &#123; get &#123; return value(forKey: key) &#125; set &#123; if let value = newValue &#123; updateValue(value, forKey: key) &#125; else &#123; removeValue(forKey: key) &#125; &#125;&#125; 这需要三个辅助函数来完成实际工作。 让我们看一下value(forKey:)，它从哈希表中检索一个对象。 123456789public func value(forKey key: Key) -&gt; Value? &#123; let index = self.index(forKey: key) for element in buckets[index] &#123; if element.key == key &#123; return element.value &#125; &#125; return nil // key not in hash table&#125; 首先，它调用index(forKey:)将键转换为数组索引。 这给了我们桶号，但如果有碰撞，这个桶可能被多个键使用。 value(forKey:)从该存储桶循环链并逐个比较key。 如果找到，则返回相应的值，否则返回nil。 插入新元素或更新现有元素的代码位于updateValue(_:forKey:)中。 这复杂一点： 1234567891011121314151617public mutating func updateValue(_ value: Value, forKey key: Key) -&gt; Value? &#123; let index = self.index(forKey: key) // Do we already have this key in the bucket? for (i, element) in buckets[index].enumerated() &#123; if element.key == key &#123; let oldValue = element.value buckets[index][i].value = value return oldValue &#125; &#125; // This key isn't in the bucket yet; add it to the chain. buckets[index].append((key: key, value: value)) count += 1 return nil&#125; 同样，第一步是将key转换为数组索引以查找存储桶。然后我们循环通过该桶的链。如果我们在链中找到key，我们就使用新值更新它。如果key不在链中，我们将新的键/值对插入到链的末尾。 正如您所看到的，保持链短（通过使哈希表足够大）非常重要。 否则，你在这些for …in循环中花费的时间过长，哈希表的性能将不再是 O(1)，而更像O(n)。 删除也类似，再次遍历链： 12345678910111213public mutating func removeValue(forKey key: Key) -&gt; Value? &#123; let index = self.index(forKey: key) // Find the element in the bucket's chain and remove it. for (i, element) in buckets[index].enumerated() &#123; if element.key == key &#123; buckets[index].remove(at: i) count -= 1 return element.value &#125; &#125; return nil // key not in hash table&#125; 这些是哈希表的基本功能。 它们都以相同的方式工作：使用其哈希值将key转换为数组索引，找到存储桶，然后遍历该存储桶的链并执行所需的操作。 在 playground 试试这些东西。 它应该像标准的Swift Dictionary 一样工作。 调整哈希表的大小这个版本的HashTable总是使用固定大小或容量的数组。 如果要在哈希表中存储许多项目，则对于容量，请选择大于最大项数的素数。 哈希表的加载因子是当前使用的容量的百分比。 如果哈希表中有3个项有5个桶，那么加载因子是3/5 = 60％。 如果哈希表很小，并且链很长，那么加载因子可能会大于1，这不是一个好主意。 如果加载因子变大，大于75％，则可以调整哈希表的大小。添加此条件的代码留给读者练习。请记住，使桶数组更大将改变键映射到的数组索引！这要求您在调整数组大小后再次插入所有元素。 然后去哪儿？(Where to go from here?)HashTable非常基础。 作为Swift标准库高效集成为SequenceType。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>哈希表</tag>
        <tag>Hash Table</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《思考，快与慢》—— 直觉快速解决大部分事情，慢下来理性解决小部分麻烦]]></title>
    <url>%2F2018%2F%E6%80%9D%E8%80%83%EF%BC%8C%E5%BF%AB%E4%B8%8E%E6%85%A2.html</url>
    <content type="text"><![CDATA[作者和本书概要丹尼尔·卡尼曼，美国普林斯顿大学教授，历史上第一位获得诺贝尔经济学奖的心理学家（2002年），行为经济学的鼻祖。 《思考，快与慢》是行为经济学流派的经典力作，运用心理学理论和经济学分析结合的方法，第一次对于影响个人和群体经济决策的偏见问题进行深入分析。它认为人并不是理性的经济动物，相反在很多情况下并不理性，偏见与生俱来，与直觉紧密相关。 人类的思考模式可以拆分成快思考和慢思考两个系统。前者是依赖直觉的、无意识的思考系统，后者是需要主动控制的、有意识进行的思考系统。在人类的决策行为中，由于慢思考系统的懒惰，很多时候会由快思考系统占据主导。而快思考的直觉存在很多缺陷，容易导致种种偏见和失误。我们应该有意识的地动慢思考系统去弥补，提高决策质量。 内容第一部分 系统1和系统2概念 系统1 是直觉系统，运行起来速度快，不怎么消耗脑力，不用意识控制，非理性，可以称为快思考。 系统2 是非直觉系统，有意识进行，需要保持足够的专注，主动控制，理性，可以称为慢思考。 (系统1和系统2只是概念，为了理解方便，大脑中并不存在对应部位) 🌰： 当你看到一张女士的照片，她的头发是黑色的，正在瞪大眼睛，看起来是个年轻人。这些判断对你来说几乎是自动完成的，是无意识的，而且毫不费力，这就是系统1在发挥作用，这是你的快思考。而当你面对一道乘法计算题，比如17乘以24，你可能知道答案的大概范围，但是除了少数接受过专门训练的人士之外，如果你不花点时间去计算的话，就无法得到正确答案。这个计算过程对你来说，需要集中注意力，刻意并且努力进行，还要遵循一定的方法，这是系统2在发挥作用，也就是慢思考。 卡尼曼通过各种心理学实验的成果证明了一件事，那就是你在主观上，往往觉得自己是理性的，是理性在掌控着自己的决策。但实际上，系统1才是你行动的依据，你的大多数行为都是在系统1的指引下，在无意识之间完成的。 因为系统2需要集中注意力，但人类大脑又是天生有惰性的，不愿意多付出这些注意力。在这种惰性之下，系统2往往会对系统1的直观判断无条件接受。 每一个人的大脑里都存在系统1和系统2，对于日常问题，用系统1就可以做出直觉判断；对于复杂问题，需要系统2发挥理性，用慢思考来解决问题。系统1和系统2处于一种合作分工的状态，如果能实现合理分工合作，人的思考将会事半功倍。 第二部分 系统1主导决策导致偏见失误系统1的“七宗罪”：三种偏好和四种效应 1 典型性偏好 过度关注典型事件，而忽视了典型背后的概率。 🌰： 一个人在纽约地铁里阅读《纽约时报》，然后让你猜测她的学历，她是有博士学位，还是连大学文凭都没有。实验结果显示，大多数人想都没想，就选择了博士学位这个选项，这是基于典型性偏好做出的判断，但从概率来说，这个答案肯定是不明智的。因为在人群里，有博士学位的人和没有大学文凭的人，相差的是很多的。而系统1对于看报纸这个典型特征的过分关注，很容易让你忽视基础概率，这就是典型性偏好导致的偏见。 2 可得性偏好 如果一件事情更容易出现在大脑里，人们就认为这件事情更容易发生。 🌰： 你看新闻，发现上个月发生了一起飞机相撞事件，那你出远门就容易选择开车或者坐火车。如果依靠理性，你应该去认真计算各种交通工具的事故概率才对。有意思的是，把可得性偏好的效用发挥到极致的，不是科学家，也不是政治家，而是恐怖分子。 在以色列，恐怖主义活动猖獗，但是在恐怖活动中死亡的人数，也远远小于交通事故的死亡人数。但是，新闻媒体更关注恐怖事件，经常报道恐怖事件，这就导致公众更容易联想到恐怖事件，而不是去计算背后的概率。这样，即便是袭击规模不大的恐怖事件，也能引起社会的巨大恐慌。可得性偏好的成因，在于系统1会将“容易出现”和“概率较高”弄混，宁可做直觉判断，也懒得启动系统2进行科学的概率运算。 3 因果性偏好 系统1有个特点，喜欢对事物进行因果关系解释。这解释容易导致偏见。 对随机事件进行因果关系解释 🌰：二战期间，德国发射 V 型火箭袭击伦敦，伦敦人发现，在不同地区，爆炸点不一样。很多人相信，在没有爆炸的地点一定藏着德国的间谍。但是严谨的统计分析显示，爆炸点的分布只是典型的随机事件。 对回归平均值的结果进行因果关系解释 回归平均值是一个基本的统计学原理，意思是每一次的表现，总会趋向于回归平均水平。 🌰：高空滑雪技巧比赛，运动员要是这回做出一个完美动作，下一次就很有可能出现失误。但是，系统1对统计学原理缺乏直观理解，总是要用因果关系去解释。要是下一次动作表现不好，你会认为，运动员已经领先了，所以特别紧张，发挥失常。如果下一个动作表现得更好，你就会认为，运动员已经拿到了高分，心情放松，也就能更好发挥竞技状态了。 这样的判断往往没有什么事实根据，只不过是你大脑里的系统1，自动生成了因果关系解释。因果性偏好的成因，可能和人类与生俱来的合理化天性有关，所见所知的各种事物，都需要有一个说得过去的合理化解释。 4 光环效应 你先接受了事物的一些信息之后，这些信息就会影响你对事物的整体判断和理解。 🌰： 假设有两个人，一个叫艾伦，另一个叫本，用一组词语对他们进行描述，然后再要求志愿者对这两个人的个性进行评价。对艾伦的描述，把褒义词放在前边，比如聪明、勤奋，把贬义词放在后边，比如冲动、挑剔、固执、忌妒心强；对本的描述，还是这些词，但是顺序掉了个个儿，贬义词放在前边，褒义词放在后边。结果，志愿者都认为艾伦是个好人，本有问题。而且，你还会在大脑里做解释，你会认为艾伦首先是个聪明人，聪明人有理由固执，甚至这种固执还是值得尊重的；本首先是个忌妒心强和固执的人，这种人越聪明，你就会觉得他越危险。 其实，两个人唯一的区别，只是你对他们的了解顺序不同，系统1对先了解的信息先入为主了，这就是光环效应导致的偏见。 5 锚定效应 你评估某一个未知事物之前，先会估计一个参考答案，这叫锚定值，然后再来调整。 🌰1️⃣： 商家在调整商品价格时，是应该直接降价，还是应该打折呢？按照传统经济学理论，如果降价和打折之后的价格相同，对消费者的决策不会有任何影响。但是有经验的商人都知道，一般来说，打折的效果比直接降价要好得多。为什么呢？因为打折的时候会附带商品原价，根据锚定效应，原价会影响消费者脑子里对商品的估价，形成一个比较高的锚定值，消费者会觉得打折后的价格很合算，更容易成交。 🌰2️⃣： 实验人员向参观博物馆的游客提两个问题：第一，最高的那棵红杉树是高于1200英尺还是低于1200英尺？第二，你认为最高的那棵红杉树有多高？第一个问题里提到的1200英尺，会对游客的头脑产生影响，成为游客回答第二个问题时的锚定值。在这个锚定值下，游客对第二个问题的平均答案是842英尺。而如果把第一个问题中的数值改成180英尺，游客对第二个问题的平均答案变成了282英尺。正是锚定值的改变，让游客的判断发生了巨大变化。 6 框架效应 同一个问题的不同描述，会导致你做出完全不同的决策判断。 🌰： 在描述某个手术术后病人生存情况时，有两种方法，第一种说手术后3个月内的存活率是90%，第二种说手术3个月后会有10%的病人死亡。这两种描述只是说法不同，其实含义是一样的。但是，实验证明，无论是医生这样的专业人士，还是一般社会公众，都觉得第一种方法更好。 光环效应、锚定效应和框架效应，共同说明一个问题，人类的系统1是一个具有先入为主特性的系统，先输入的信息在判断中能够占据优势地位，不管这种信息是第一印象，是事先设定的参考值，还是描述时的词语和修辞，都会极大影响我们的判断 7 禀赋效应 指当你拥有某个物品之后，你就会觉得它价值更大。 🌰马克杯实验： 实验人员把马克杯作为商品在学生之中随机分配，然后让学生自由交易，结果发现成功完成交易的没有几个，因为马克杯买家和卖家对于马克杯的估价差得特别多。卖家估价中位数为5.25美元，但买家的估价中位数只有2.25美元。 最先设计这个马克杯实验的是另一位行为经济学家理查德·塞勒（2017诺贝尔经济学奖得主）。理查德·塞勒用前景理论解释禀赋效应，人对损失和获得的敏感程度是不同的，在损失时遭受的痛苦感，要大大超过获得时收获的快乐感。通俗的说就是你捡到100块钱获得的快乐，不能抵消丢失100块钱带来的痛苦。 第三部分 如何利用系统2来避免系统1带来的偏见和失误放慢思考，主动的激活系统2，来对系统1的直觉思考结果进行理性检验，弥补系统1的缺陷，减少那些由直觉产生的偏见和错觉。 激活系统2有自我提示和外部提示两种方式。外部提示更加有效，“旁观者清”。 事前验尸 事前验尸是一种有意识的激活系统2、启动慢思考的集体决策方法，也就是让我们在对一件事情做决策时，先假设这件事情将来会失败，然后每个人按照自己的理解，写下导致这件事失败的可能原因，同时按重要性和概率进行排序。这样可以未雨绸缪，预防这些因素，提高工作的成功率。 饮水机闲谈 饮水机闲谈是让决策者在决策之前，到比较轻松的环境，比如办公室的饮水机旁，听听大家的闲谈和批评。去面对这些批评虽然不容易，但是比起自己鼓起勇气自我批评，还是容易得多。而无论是听别人的闲言碎语，还是自我反思自我批评，目的都是一个，让思考慢下来，让系统2运转起来，尽量避免系统1的直觉思维和快思考，可能给你带来的偏见和失误。 参考： 得到-每天听本书]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>行为经济学</tag>
        <tag>偏见</tag>
        <tag>快思考</tag>
        <tag>慢思考</tag>
        <tag>锚定效应</tag>
        <tag>典型性偏好</tag>
        <tag>光环效应</tag>
        <tag>可得性偏好</tag>
        <tag>因果性偏好</tag>
        <tag>框架效应</tag>
        <tag>禀赋效应</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-链表]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Linked List 链表(Linked List) 这个主题已经有辅导文章 链表是一系列数据项，就像数组一样。 数组分配了一大块内存来存储对象，而链表中的元素在内存中是完全独立的对象，并通过链接连接： +--------+ +--------+ +--------+ +--------+ | | | | | | | | | node 0 |---&gt;| node 1 |---&gt;| node 2 |---&gt;| node 3 | | | | | | | | | +--------+ +--------+ +--------+ +--------+ 链表的元素称为 节点。 上图显示了 单链表，其中每个节点只有一个引用 - 或叫做“指针” - 到下一个节点。 在 双向链表中，如下所示，节点还有指向前一个节点的指针： +--------+ +--------+ +--------+ +--------+ | |---&gt;| |---&gt;| |---&gt;| | | node 0 | | node 1 | | node 2 | | node 3 | | |&lt;---| |&lt;---| |&lt;---| | +--------+ +--------+ +--------+ +--------+ 您需要跟踪链表的开始位置。 这通常用一个名为 head 的指针完成： +--------+ +--------+ +--------+ +--------+ head ---&gt;| |---&gt;| |---&gt;| |---&gt;| |---&gt; nil | node 0 | | node 1 | | node 2 | | node 3 | nil &lt;---| |&lt;---| |&lt;---| |&lt;---| |&lt;--- tail +--------+ +--------+ +--------+ +--------+ 引用链表末尾也很有用，称为 tail。 注意，最后一个节点的“下一个”指针是nil，第一个节点的“前一个”指针也是nil。 链表的性能链表上的大多数操作时间复杂度都是 O(n) ，因此链表通常比数组慢。但是，它们也更加灵活 —— 而不是像数组一样复制大块内存，链表上的许多操作只需要更改几个指针。 时间复杂度是O(n)的原因是你不能简单地写list[2]来从链表中访问节点2。 如果你已经没有对该节点的引用，你必须从head开始，然后按照next指针逐个访问（或者从tail开始，使用previous指针，逐个访问并找到指定节点）。 但是一旦你有一个节点的引用，插入和删除等操作真的很快。 只是寻找节点慢。 这意味着当您处理链表时，应尽可能在前面插入新项目。 这是O(1)操作。 如果你跟踪tail指针，同样可以在后面插入。 单链表 vs 双链表单链表使用比双链表使用更少的内存，因为它不需要存储所有那些previous指针。 但是如果你需要找到一个节点以前的节点，你就搞砸了。 您必须从头部开始并遍历整个链表，直到到达正确的节点。 对于许多任务，双向链表使事情变得更容易。 为什么使用链表？使用链表的典型示例是队列。 使用数组，从队列前面删除元素很慢，因为它需要向下移动内存中的所有其他元素。 但是通过链接链表，只需将head更改为指向第二个元素即可。 快多了。 但说实话，现在你几乎不需要编写自己的链表。 不过，了解它们的工作方式仍然很有用; 将对象链接在一起的原则也与树和图一起使用。 代码我们首先定义一个描述节点的类型： 123456789public class LinkedListNode&lt;T&gt; &#123; var value: T var next: LinkedListNode? weak var previous: LinkedListNode? public init(value: T) &#123; self.value = value &#125;&#125; 这是一种泛型类型，因此T可以是您想要存储在节点中的任何类型的数据。 我们将在后面的示例中使用字符串。 这边定义的是一个双向链表，每个节点都有一个next和previous指针。 如果没有下一个或前一个节点，则这些可以是nil，因此这些变量必须是可选项。 （在下文中，我将指出哪些函数需要更改，如果这只是单个而不是双向链表。） 注意： 为避免循环强引用，我们声明previous指针为弱。 如果链表中有一个节点A后面跟着节点B，那么A指向B，而B指向A。 在某些情况下，即使在删除节点后，此循环强引用也可能导致节点保持活动状态。 我们不希望这样，所以我们使其中一个指针weak来打破循环。 让我们开始构建LinkedList。 这是第一点： 12345678910111213public class LinkedList&lt;T&gt; &#123; public typealias Node = LinkedListNode&lt;T&gt; private var head: Node? public var isEmpty: Bool &#123; return head == nil &#125; public var first: Node? &#123; return head &#125;&#125; 理想情况下，我们希望类名尽可能具有描述性，但是，我们不希望每次要使用类时都打长名称，因此，我们在LinkedList中给LinkedListNode&lt;T&gt;定义了一个短的别名Node。 这个链表只有一个head指针，没有尾部。 添加尾指针留给读者练习。 （如果我们还有一个尾指针，我会指出哪些函数会有所不同。） 如果head为nil，则链表为空。 因为head是一个私有变量，所以我添加了属性first来返回对链表中第一个节点的引用。 在playground中测试： 123let list = LinkedList&lt;String&gt;()list.isEmpty // truelist.first // nil 我们还添加一个属性，为您提供链表中的最后一个节点。 这是将开始变得有趣了： 12345678910public var last: Node? &#123; guard var node = head else &#123; return nil &#125; while let next = node.next &#123; node = next &#125; return node&#125; 如果你是Swift的新手，你可能已经看过if let但也许不是if var。 它做了同样的事情 - 它解开head可选项并将结果放入一个名为node的新局部变量中。 区别在于node不是常量而是当前运行环境下的变量，因此我们可以在循环内更改它。 循环也做了一些Swift魔法。 while let next = node.next保持循环，直到node.next为nil。 您可以写如下： 1234var node: Node? = headwhile node != nil &amp;&amp; node!.next != nil &#123; node = node!.next&#125; 但这对我来说并不是很开心。 我们可以很好地利用Swift对解包选项的内置支持。 你会在随后的代码中看到一堆这样的循环。 注意： 如果我们保留一个尾指针，last只会做return tail。 但我们没有，所以它必须从头到尾逐步完成整个链表。这是一项昂贵的操作，特别是如果链表很长的话。 当然，last只返回nil，因为链表中没有任何节点。 让我们添加一个方法，将新节点添加到链表的末尾： 123456789public func append(value: T) &#123; let newNode = Node(value: value) if let lastNode = last &#123; newNode.previous = lastNode lastNode.next = newNode &#125; else &#123; head = newNode &#125;&#125; append()方法首先创建一个新的Node对象，然后请求我们刚刚添加的最后一个节点last属性。 如果没有这样的节点，链表仍然是空的，我们使head指向这个新的Node。但是如果我们确实找到了一个有效的最后节点对象，我们连接next和previous指针将这个新节点链接到链中。许多链表代码涉及这种next和previous指针操作。 在playground中测试： 1234list.append("Hello")list.isEmpty // falselist.first!.value // "Hello"list.last!.value // "Hello" The list looks like this:这个链表目前看上去是： +---------+ head ---&gt;| |---&gt; nil | &quot;Hello&quot; | nil &lt;---| | +---------+ 增加第二个节点： 123list.append("World")list.first!.value // "Hello"list.last!.value // "World" 现在链表看上去是： +---------+ +---------+ head ---&gt;| |---&gt;| |---&gt; nil | &quot;Hello&quot; | | &quot;World&quot; | nil &lt;---| |&lt;---| | +---------+ +---------+ 您可以通过查看next和previous指针来自行验证： 1234list.first!.previous // nillist.first!.next!.value // "World"list.last!.previous!.value // "Hello"list.last!.next // nil 让我们添加一个方法来计算链表中有多少个节点。 这与我们已经完成的工作非常相似： 123456789101112public var count: Int &#123; guard var node = head else &#123; return 0 &#125; var count = 1 while let next = node.next &#123; node = next count += 1 &#125; return count&#125; 它以相同的方式循环遍历链表，但这次增加了一个计数器。 注意： 加快获得count的速度（从O(n)到O(1)）的一种方法是跟踪一个计算链表中有多少节点的变量。 无论何时添加或删除节点，都会更新此变量。 如果我们想在链表中的特定索引处找到节点，该怎么办？使用数组我们可以编写一个O(1)操作array[index]。这更多地涉及链接链表，但代码遵循类似的模式： 1234567891011121314public func node(atIndex index: Int) -&gt; Node &#123; if index == 0 &#123; return head! &#125; else &#123; var node = head!.next for _ in 1..&lt;index &#123; node = node?.next if node == nil &#123; //(*1) break &#125; &#125; return node! &#125;&#125; 首先，我们检查给定的索引是否为0。 因为如果它是0，它会按原样返回head。但是，当给定索引大于0时，它从头开始，然后继续追踪node.next指针逐步执行链表。与此时计数方法的不同之处在于存在两种终止条件。一种是当for循环语句到达索引时，我们能够获取给定索引的节点。第二个是for-loop语句中的node.next返回nil并导致break。（*1）这意味着给定的索引超出范围并导致崩溃。 测试一下： 123list.nodeAt(0)!.value // "Hello"list.nodeAt(1)!.value // "World"// list.nodeAt(2) // crash 为了好玩，我们也可以实现subscript（下标）方法： 1234public subscript(index: Int) -&gt; T &#123; let node = node(atIndex: index) return node.value&#125; 现在可以编写如下内容： 123list[0] // "Hello"list[1] // "World"list[2] // crash! 它在list [2]上崩溃，因为该索引上没有节点。 到目前为止，我们已经编写了将新节点添加到链表末尾的代码，但这很慢，因为您需要先找到链表的末尾。（如果我们使用尾指针会很快。）因此，如果链表中项目的顺序无关紧要，则应在链表的前面执行插入操作。 这总是一个O(1)操作。 让我们编写一个方法，允许您在链表中的任何索引处插入新节点。 12345678910111213141516public func insert(_ node: Node, at index: Int) &#123; let newNode = node if index == 0 &#123; newNode.next = head head?.previous = newNode head = newNode &#125; else &#123; let prev = self.node(at: index-1) let next = prev.next newNode.previous = prev newNode.next = prev.next prev.next = newNode next?.previous = newNode &#125;&#125; 与node(at:)方法一样，insert(_:at:)方法也会根据索引参数是否为0进行判断。首先让我们来看看前一种情况（译注：也就是index == 0，插入最前面的情况）。 假设我们有以下链表和新节点（C）。 +---------+ +---------+ head ---&gt;| |----&gt;| |-----//-----&gt; | A | | B | nil &lt;---| |&lt;----| |&lt;----//------ +---------+ +---------+ [0] [1] +---------+ new ---&gt;| |----&gt; nil | C | | | +---------+ 现在将新节点放在第一个节点之前。 通过这种方式： new.next = head head.previous = new +---------+ +---------+ +---------+ new ---&gt;| |--&gt; head --&gt;| |----&gt;| |-----//-----&gt; | C | | A | | B | | |&lt;-----------| |&lt;----| |&lt;----//------ +---------+ +---------+ +---------+ 最后，用新节点作为头部。 head = new +---------+ +---------+ +---------+ head ---&gt;| |---&gt;| |----&gt;| |-----//-----&gt; | C | | A | | B | nil &lt;---| |&lt;---| |&lt;----| |&lt;----//------ +---------+ +---------+ +---------+ [0] [1] [2] 但是，当给定索引大于0时，必须获取节点的上一个和下一个索引并在它们之间插入。您还可以使用node(at:)获取上一个和下一个节点，如下所示： +---------+ +---------+ +---------+ head ---&gt;| |---//---&gt;| |----&gt;| |---- | | | A | | B | nil &lt;---| |---//&lt;---| |&lt;----| |&lt;--- +---------+ +---------+ +---------+ [0] [index-1] [index] ^ ^ | | prev next prev = node(at: index-1) next = prev.next 现在在prev和next之间插入新节点。 new.prev = prev; prev.next = new // connect prev and new. new.next = next; next.prev = new // connect new and next. +---------+ +---------+ +---------+ +---------+ head ---&gt;| |---//---&gt;| |----&gt;| |----&gt;| | | | | A | | C | | B | nil &lt;---| |---//&lt;---| |&lt;----| |&lt;----| | +---------+ +---------+ +---------+ +---------+ [0] [index-1] [index] [index+1] ^ ^ ^ | | | prev new next 测试： 1234list.insert(LinedListNode(value: "Swift"), at: 1)list[0] // "Hello"list[1] // "Swift"list[2] // "World 还可以尝试在链表的前面和后面添加新节点，以验证其是否正常工作。 注意： node(at:) 和 insert(_:at:)函数也可以与单链表一起使用，因为我们不依赖于节点的previous指针来查找前一个元素。 我们还需要什么？ 当然要删除节点！ 首先我们要做removeAll()，这很简单： 123public func removeAll() &#123; head = nil&#125; 如果你有一个尾指针，你也可以在这里设置为nil。 接下来，我们将添加一些可以删除单个节点的函数。 如果你已经有了对节点的引用，那么使用remove()是最优的，因为你不需要遍历链表来首先找到节点。 123456789101112131415public func remove(node: Node) -&gt; T &#123; let prev = node.previous let next = node.next if let prev = prev &#123; prev.next = next &#125; else &#123; head = next &#125; next?.previous = prev node.previous = nil node.next = nil return node.value&#125; 当我们将此节点从链表中取出时，我们将断开指向上一个节点和下一个节点的链接。 要使链表再次完整，我们必须将前一个节点链接到下一个节点。 不要忘记head指针！ 如果这是链表中的第一个节点，则需要更新head以指向下一个节点。 （同样，当你有一个尾指针，这是最后一个节点）。 当然，如果没有剩余的节点，head应该变为nil。 尝试一下： 1234list.remove(node: list.first!) // "Hello"list.count // 2list[0] // "Swift"list[1] // "World" 如果你没有对节点的引用，你可以使用removeLast()或 removeAt()： 123456789public func removeLast() -&gt; T &#123; assert(!isEmpty) return remove(node: last!)&#125;public func remove(at index: Int) -&gt; T &#123; let node = self.node(at: index) return remove(node: node)&#125; 所有这些删除函数都返回已删除元素的值。 123456list.removeLast() // "World"list.count // 1list[0] // "Swift"list.remove(at: 0) // "Swift"list.count // 0 注意： 对于单链表，删除最后一个节点稍微复杂一些。 您不能只使用last来查找链表的末尾，因为您还需要对倒数第二个节点的引用。 相反，使用nodesBeforeAndAfter()辅助方法。 如果链表有一个尾指针，那么removeLast()非常快，但你需要记住让tail指向前一个节点。 我们的LinkedList类还可以做一些有趣的事情。 一些很方便可读的调试输出： 123456789101112extension LinkedList: CustomStringConvertible &#123; public var description: String &#123; var s = "[" var node = head while node != nil &#123; s += "\(node!.value)" node = node!.next if node != nil &#123; s += ", " &#125; &#125; return s + "]" &#125;&#125; 这将如下形式打印链表： [Hello, Swift, World] 如何反转链表，使头部成为尾部，反之亦然？ 有一个非常快速的算法： 123456789public func reverse() &#123; var node = head tail = node // If you had a tail pointer while let currentNode = node &#123; node = currentNode.next swap(&amp;currentNode.next, &amp;currentNode.previous) head = currentNode &#125;&#125; 这循环遍历整个链表，并简单地交换每个节点的next和previous指针。 它还将head指针移动到最后一个元素。 （如果你有一个尾部指针，你还需要更新它。）你最终得到这样的东西： +--------+ +--------+ +--------+ +--------+ tail ---&gt;| |&lt;---| |&lt;---| |&lt;---| |---&gt; nil | node 0 | | node 1 | | node 2 | | node 3 | nil &lt;---| |---&gt;| |---&gt;| |---&gt;| |&lt;--- head +--------+ +--------+ +--------+ +--------+ 数组有map()和filter()函数，那么没有理由说链接链表没有。 123456789public func map&lt;U&gt;(transform: (T) -&gt; U) -&gt; LinkedList&lt;U&gt; &#123; let result = LinkedList&lt;U&gt;() var node = head while node != nil &#123; result.append(transform(node!.value)) node = node!.next &#125; return result&#125; 使用如下：（译注：创建一个新链表，用来存放之前链表中字符串的长度） 1234567let list = LinkedList&lt;String&gt;()list.append("Hello")list.append("Swifty")list.append("Universe")let m = list.map &#123; s in s.count &#125;m // [5, 6, 8] filter()函数： 1234567891011public func filter(predicate: (T) -&gt; Bool) -&gt; LinkedList&lt;T&gt; &#123; let result = LinkedList&lt;T&gt;() var node = head while node != nil &#123; if predicate(node!.value) &#123; result.append(node!.value) &#125; node = node!.next &#125; return result&#125; 一个简单的使用例子：（译注：筛选出链表中字符串长度大于5的元素并组成新的链表） 12let f = list.filter &#123; s in s.count &gt; 5 &#125;f // [Universe, Swifty] 为读者练习：map() 和filter() 的这些实现不是很快，因为它们将新节点追加到新链表的末尾。 回想一下，append是O(n)，因为它需要扫描整个链表以找到最后一个节点。 你能加快速度吗？ （提示：跟踪您添加的最后一个节点。） 另一种方法到目前为止，您看到的LinkedList版本使用的是类，具有引用语义。 这没有什么不对，但这确实使它们比Swift的其他集合（例如Array和Dictionary）更重要。(译注： 这里应该是想表达，Array和Dictionary都是结构体，链表也可以使用结构体和枚举实现) 可以使用枚举实现具有值语义的链表。 这看起来有点像这样： 1234enum ListNode&lt;T&gt; &#123; indirect case node(T, next: ListNode&lt;T&gt;) case end&#125; 与基于类的版本的最大区别在于，您对此链表所做的任何修改都将导致创建新副本。 这是否是您想要的取决于应用程序。 [如果有需求，我可能会更详细地填写此部分。] 符合Collection协议符合Sequence协议的类型，其元素可以多次遍历。非破坏性地通过索引的下标访问，应该符合Swift标准库中定义的Collection协议。 这样做可以访问处理数据集合时常见的大量属性和操作。 除此之外，它还允许自定义类型遵循Swift开发人员常用的模式。 为了符合这个协议，类需要提供： 1 startIndex和endIndex属性。 2 对元素的下标访问为O(1)。 需要记录这种时间复杂性的变化。 1234567891011121314151617181920/// The position of the first element in a nonempty collection.public var startIndex: Index &#123; get &#123; return LinkedListIndex&lt;T&gt;(node: head, tag: 0) &#125;&#125; /// The collection's "past the end" position---that is, the position one/// greater than the last valid subscript argument./// - Complexity: O(n), where n is the number of elements in the list./// This diverts from the protocol's expectation.public var endIndex: Index &#123; get &#123; if let h = self.head &#123; return LinkedListIndex&lt;T&gt;(node: h, tag: count) &#125; else &#123; return LinkedListIndex&lt;T&gt;(node: nil, tag: startIndex.tag) &#125; &#125;&#125; 12345public subscript(position: Index) -&gt; T &#123; get &#123; return position.node!.value &#125;&#125; 因为集合负责管理自己的索引，下面的实现保留对链表中节点的引用。 索引中的标记属性表示链表中节点的位置。 1234567891011121314/// Custom index type that contains a reference to the node at index 'tag'public struct LinkedListIndex&lt;T&gt; : Comparable&#123; fileprivate let node: LinkedList&lt;T&gt;.LinkedListNode&lt;T&gt;? fileprivate let tag: Int public static func==&lt;T&gt;(lhs: LinkedListIndex&lt;T&gt;, rhs: LinkedListIndex&lt;T&gt;) -&gt; Bool &#123; return (lhs.tag == rhs.tag) &#125; public static func&lt; &lt;T&gt;(lhs: LinkedListIndex&lt;T&gt;, rhs: LinkedListIndex&lt;T&gt;) -&gt; Bool &#123; return (lhs.tag &lt; rhs.tag) &#125;&#125; 最后，链接能够通过以下实现计算给定的索引之后的索引。 123public func index(after idx: Index) -&gt; Index &#123; return LinkedListIndex&lt;T&gt;(node: idx.node?.next, tag: idx.tag+1)&#125; 要注意的一些事情链接链表是灵活的，但许多操作是O(n)。 在链表上执行操作时，您总是需要小心更新相关的next和previous指针，还可能更新head和tail指针。 如果你搞砸了，你的链表将不再正确，你的程序可能会在某些时候崩溃。 小心！ 处理链表时，通常可以使用递归：处理第一个元素，然后在链表的其余部分再次递归调用该函数。 当没有下一个元素时你就完成了。 这就是链表是LISP等函数式编程语言的基础的原因。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS-tutorial-16：TravelVlogs——使用AVKit和AVFoundation创建视频应用]]></title>
    <url>%2F2018%2Fios-tutorial-16-TravelVlogs.html</url>
    <content type="text"><![CDATA[TravelVlogs项目是介绍如何使用AVKit和AVFoundation框架构建简单的视频流应用。 预览图 代码TravelVlogs 注意点AVKit 介绍一个有用的开发智慧：始终支持您可用的最高抽象级别。 然后，当您使用的不再适合您的需求时，您可以降低到较低的水平。 根据这一建议，您将在最高级别的视频框架中开始您的旅程。 AVKit位于AVFoundation之上，提供与视频交互所需的所有UI。 AVFoundation介绍AVFoundation是一个巨大的类，这个项目用到一些类： AVPlayerLayer： 这个特殊的CALayer子类可以显示给定AVPlayer对象的回放。 AVAsset：这些是媒体资产的静态表示。 资产对象包含持续时间和创建日期等信息。 AVPlayerItem：AVAsset的动态对应物。 此对象表示可播放视频的当前状态。 // 这是您需要为AVPlayer提供的东西。 本地视频播放AVPlayer（播放器对象）是iOS中播发视频的核心。它可以启动和停止视频，更改播放速率甚至可以上下调节音量。 您可以将播放器视为能够一次管理一个媒体资源播放的控制器对象。 远程视频播放123let videoURLString = &quot;https://wolverine.raywenderlich.com/content/ios/tutorials/video_streaming/foxVillage.mp4&quot;let videoURLString = &quot;https://wolverine.raywenderlich.com/content/ios/tutorials/video_streaming/foxVillage.m3u8&quot; 上面两个URL的唯一的区别是第二个URL代表HLS Livestream。 HLS Livestream通过将视频分成块来提升视频加载速度。 右下角的小视图右下角的小视图是一个浮动的自定义视频播放器。 它的目的是播放一组循环剪辑，让用户对所有这些视频感到兴奋。 循环时需要用到类似OC中的KVO(基本思想就是在特定属性的值发生变化时得到通知)。 右下角的小视图两个手势 点击一次打开关闭声音 双击两倍播放速度 当大视频播发时要把小视图自定义视频播放器的视频播放关闭让视频播放不要影响其他音乐应用的音乐播放在AppDelegate.swift的 application(_:didFinishLaunchingWithOptions:)方法添加一段如下代码： 1try? AVAudioSession.sharedInstance().setCategory(AVAudioSession.Category.ambient, mode: AVAudioSession.Mode.moviePlayback, options: [.mixWithOthers]) 参考Video Streaming Tutorial for iOS: Getting Started]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
      <tags>
        <tag>AVKit</tag>
        <tag>AVFoundation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-基数排序]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Radix Sort 基数排序(Radix Sort)基数排序是一种排序算法，它将整数数组作为输入，并使用排序子程序（通常是另一种有效的排序算法）来按整数基数或者它们的数字对整数进行排序。 Counting Sort和Bucket Sort通常用作Radix Sort的子程序。 例子 Input Array: [170, 45, 75, 90, 802, 24, 2, 66] Output Array (Sorted): [2, 24, 45, 66, 75, 90, 170, 802] 第一步：此算法的第一步是定义数字，或者更确切地说是我们将用于排序的“base”或基数。对于这个例子，我们将radix = 10，因为我们在示例中使用的整数是基数10。 第二步：下一步是简单地迭代n次（其中n是输入数组中最大整数中的位数），并且在每次迭代时对当前数字执行排序子程序。 算法中的行动我们来看看我们的示例输入数组。 我们数组中的最大整数是802，它有三位数（一，十，百）。 因此，我们的算法将迭代三次，同时对每个整数的数字执行一些排序算法。 Iteration 1: 170, 90, 802, 2, 24, 45, 75, 66 Iteration 2: 802, 2, 24, 45, 66, 170, 75, 90 Iteration 3: 2, 24, 45, 66, 75, 90, 170, 802 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import Foundation// 不能处理负数public func radixSort(_ array: inout [Int]) &#123; let radix = 10 var done = false var index: Int var digit = 1 while !done &#123; done = true var buckets: [[Int]] = [] // 我们的排序子程序是桶排序，所以让我们预定义我们的桶 for _ in 1...radix &#123; buckets.append([]) &#125; for number in array &#123; index = number / digit buckets[index % radix].append(number) if done &amp;&amp; index &gt; 0 &#123; done = false &#125; &#125; var i = 0 for j in 0..&lt;radix &#123; let bucket = buckets[j] for number in bucket &#123; array[i] = number i += 1 &#125; &#125; digit *= radix &#125;&#125;// 小数组的测试var array: [Int] = [19, 4242, 2, 9, 912, 101, 55, 67, 89, 32]radixSort(&amp;array)print(array)// 大数组的测试var bigArray = [Int](repeating: 0, count: 1000)var i = 0while i &lt; 100 &#123; bigArray[i] = Int(arc4random_uniform(1000) + 1) i += 1&#125;radixSort(&amp;bigArray)print(bigArray) 更多查看基数排序的维基百科基数排序的中文维基百科 作者：Christian Encarnacion翻译：Andy Ron校对：Andy Ron 翻译后补充基数排序对数组[53, 3, 542, 748, 14, 214, 154, 63, 616]的排序，示意图(来源：https://www.cnblogs.com/skywang12345/p/3603669.html) 说明：]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>基数排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-计数排序]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Counting Sort 计数排序(Counting Sort)Counting sort is an algorithm for sorting a collection of objects according to keys that are small integers. It operates by counting the number of objects that have each distinct key values, and using arithmetic on those counts to determine the positions of each key value in the output sequence.计数排序是一种根据小整数键对对象集合进行排序的算法。通过计算具有每个不同键值的对象的数量来操作，并对这些计数使用算术来确定输出序列中每个键值的位置。 例子为了理解算法，让我们来看一个小例子。 考虑数组: [ 10, 9, 8, 7, 1, 2, 7, 3 ] 第一步：第一步是计算数组中每个项的总出现次数。 第一步的输出将是一个新的数组，如下所示： 12Index 0 1 2 3 4 5 6 7 8 9 10Count 0 1 1 1 0 0 0 2 1 1 1 译注： 这边Index的最大值对应于，数组中最大值10。 这是完成第一步的代码： 123456let maxElement = array.max() ?? 0var countArray = [Int](repeating: 0, count: Int(maxElement + 1))for element in array &#123; countArray[element] += 1&#125; 第二步：在此步骤中，算法尝试确定在每个元素之前放置的元素的数量。通过第一步已经知道每个元素的总出现次数，可以得到。方法就是把前一个计数和当前计数相加存储到每个索引中（对应代码就是countArray[index] + countArray[index - 1]）。 计数数组如下： 12Index 0 1 2 3 4 5 6 7 8 9 10Count 0 1 2 3 3 3 3 5 6 7 8 第二步的代码： 1234for index in 1 ..&lt; countArray.count &#123; let sum = countArray[index] + countArray[index - 1] countArray[index] = sum&#125; 第三步这是算法的最后一步。 原始数组中的每个元素都放置在第二步的输出定义的位置。例如，数字10将放在输出数组中的索引7处。 此外，当您放置元素时，您需要将计数减少1，因为从数组中减少了许多元素。 最终的输出是： 12Index 0 1 2 3 4 5 6 7Output 1 2 3 7 7 8 9 10 以下是最后一步的代码： 123456var sortedArray = [Int](repeating: 0, count: array.count)for element in array &#123; countArray[element] -= 1 sortedArray[countArray[element]] = element&#125;return sortedArray 性能该算法使用简单循环对集合进行排序。 因此，运行整个算法的时间是O(n+k)其中O(n)表示初始化输出数组所需的循环，O(k)是创建计数数组所需的循环。 该算法使用长度为n + 1和n的数组，因此所需的总空间为O(2n)。 因此，对于密钥沿着数字线分散在密集区域中的集合，它可以节省空间。 作者：Ali Hafizji翻译：Andy Ron校对：Andy Ron 翻译后补充计数排序假设n个输入元素中的每一个都是在0到k区间内的一个整数，其中k为某个整数。当k=O(n)时，排序的运行时间为Θ(n)。 计数排序的思想是，对每一个输入元素，计算小于它的元素个数，如果有10个元素小于它，那么它就应该放在11的位置上，如果有17个元素小于它，它就应该放在18的位置上。当有几个元素相同时，这一方案要略做修改，因为不能把它们放在同一个输出位置上。下图（来源于《算法导论》）展示了实际的运行过程。 构造辅助数组C，C的长度为k。第一次遍历A后，得到[0,k)区间上每个数出现的次数，将这些次数写入C，得到图(a)的结果。然后把C中每个元素变成前面所有元素的累加和，得到图(b)的结果。接下来，再次从后向前遍历数组A，根据取出的元素查找C中对应下标的值，再把这个值作为下标找到B中的位置，即是该元素排序后的位置。例如，图中A的最后一个元素是3，找到C[3]是7，再令B[7]=3即可，然后顺便把C[3]减一，这是防止相同的数被放到同一个位置。 计数排序的时间代价可以这样计算，第一次遍历A并计算C所花时间是Θ(n)，C累加所花时间是Θ(k)，再次遍历A并给B赋值所花时间是Θ(n)，因此，总时间为Θ(k + n)。在实际中，当k=O(n)时，我们一般会采用计数排序，这时的运行时间为Θ(n)。 参考https://www.jianshu.com/p/ff1797625d66]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>计数排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-希尔排序]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Shell Sort 希尔排序(Shell Sort)希尔排序是插入排序的一种更高效的改进版本，方法是将原始列表分成较小的子列表，然后使用插入排序对其进行单独排序。 Sapientia大学创建了一个很好的视频，显示了匈牙利民间舞蹈的过程。（译注：类似希尔排序的过程，油管视频需要翻墙） 怎么运行的插入排序是比较相连的元素，如果它们顺序不对就交换它们，而希尔排序算法会比较相距很远的元素。 元素之间的距离称为 gap。 如果被比较的元素的顺序错误，则它们会在 gap 中交换。 这消除了插入排序中常见的许多中间副本。 译注： gap已经被翻译成步长/增量/间距等，为了避免歧义，本文就不做翻译，直接写成gap 这个想法是，通过在大 gap 上移动元素，数组变得非常快速地部分排序。 这使得之后的排序过程更快，因为他们不再需要交换那么多项。 一轮完成后，gap变小，新一轮开始。 这将重复，直到 gap 大小为1，此时算法的功能就像插入排序一样。 但是由于数据已经很好地排序，所以最后一轮可以非常快。 例子假设我们想使用希尔排序对数组 [64, 20, 50, 33, 72, 10, 23, -1, 4] 进行排序。 我们首先将数组的长度除以2： n = floor(9/2) = 4 这是 gap 大小。 我们创建n子列表。 在每个子列表中，每一项的间隔是大小为n的gap 。 在我们的示例中，我们需要制作其中四个子列表。 子列表按insertionSort()函数排序。 这可能没有多大意义，所以让我们仔细看看会发生什么。 第一轮如下。 我们有n = 4，所以我们制作了四个子列表： sublist 0: [ 64, xx, xx, xx, 72, xx, xx, xx, 4 ] sublist 1: [ xx, 20, xx, xx, xx, 10, xx, xx, xx ] sublist 2: [ xx, xx, 50, xx, xx, xx, 23, xx, xx ] sublist 3: [ xx, xx, xx, 33, xx, xx, xx, -1, xx ] 如您所见，每个子列表仅包含原始数组中的每间隔4的项。 不在子列表中的项用xx表示。 所以第一个子列表是[64,72,4]，第二个子列表是[20,10]，依此类推。 我们使用这个“gap”的原因是我们不必实际制作新的数组。 相反，我们将它们交织在原始数组中。 我们现在在每个子列表上调用一次insertionSort()。 插入排序的这个特定版本从后面到前面排序。子列表中的每个项目都与其他项目进行比较。如果它们的顺序错误，则交换值并一直向下移动，直到我们到达子列表的开头。 因此对于子列表0，我们将4与72交换，然后将4与64交换。 排序后，此子列表如下所示： sublist 0: [ 4, xx, xx, xx, 64, xx, xx, xx, 72 ] 排序后的其他三个子列表： sublist 1: [ xx, 10, xx, xx, xx, 20, xx, xx, xx ] sublist 2: [ xx, xx, 23, xx, xx, xx, 50, xx, xx ] sublist 3: [ xx, xx, xx, -1, xx, xx, xx, 33, xx ] 完整的数组看上去是： [ 4, 10, 23, -1, 64, 20, 50, 33, 72 ] 它还没有完全排序，但它比以前更加排序。 这完成了第一次轮操作。 在第二轮中，我们将 gap 大小除以2： n = floor(4/2) = 2 这意味着我们现在只创建两个子列表： sublist 0: [ 4, xx, 23, xx, 64, xx, 50, xx, 72 ] sublist 1: [ xx, 10, xx, -1, xx, 20, xx, 33, xx ] 每个子列表包含每个间隔为2的项。 我们再次调用insertionSort()来对这些子列表进行排序。 结果是： sublist 0: [ 4, xx, 23, xx, 50, xx, 64, xx, 72 ] sublist 1: [ xx, -1, xx, 10, xx, 20, xx, 33, xx ] 请注意，在每个列表中只有两个元素位置顺序不对（译注：sublist 0是64和50，sublist 1是10和-1）。 因此插入排序非常快。 那是因为我们已经在第一轮中对数组进行了一些排序。 总数组现在看起来像这样： [ 4, -1, 23, 10, 50, 20, 64, 33, 72 ] 这样就完成了第二轮。 最后一轮的gap是： n = floor(2/2) = 1 gap 大小为1表示我们只有一个子列表，即数组本身，我们再次调用insertionSort()对其进行排序。 最终排序的数组是： [ -1, 4, 10, 20, 23, 33, 50, 64, 72 ] 在大多数情况下，希尔排序的性能为O(n^2)，如果幸运，则为 O(nlogn)。 该算法是不稳定的排序; 它可能会改变具有相等值的元素的相对顺序。 gap 序列“ gap 序列”确定 gap 的初始大小以及每次迭代如何使 gap 变小。 良好的 gap 序列对于希尔排序表现良好非常重要。 上面实现例子中的 gap 序列是希尔原始版本中的 gap 序列：初始值是数组大小的一半，然后每次除以2。 还有其他方法可以计算 gap 序列。 只是为了好玩…这是 Matthijs 很久以前使用的一个旧的Commodore 64 BASIC版本的希尔排序，并且移植到他曾经使用的几乎所有编程语言中： 61200 REM S is the array to be sorted 61205 REM AS is the number of elements in S 61210 W1=AS 61220 IF W1&lt;=0 THEN 61310 61230 W1=INT(W1/2): W2=AS-W1 61240 V=0 61250 FOR N1=0 TO W2-1 61260 W3=N1+W1 61270 IF S(N1)&gt;S(W3) THEN SH=S(N1): S(N1)=S(W3): S(W3)=SH: V=1 61280 NEXT N1 61290 IF V&gt;0 THEN 61240 61300 GOTO 61220 61310 RETURN 代码希尔排序的Swift实现： 12345678910111213141516171819202122232425public func insertSort(_ list: inout[Int], start: Int, gap: Int) &#123; for i in stride(from: (start + gap), to: list.count, by: gap) &#123; let currentValue = list[i] var pos = i while pos &gt;= gap &amp;&amp; list[pos - gap] &gt; currentValue &#123; list[pos] = list[pos - gap] pos -= gap &#125; list[pos] = currentValue &#125;&#125;public func shellSort(_ list: inout [Int]) &#123; var sublistCount = list.count / 2 while sublistCount &gt; 0 &#123; for pos in 0..&lt;sublistCount &#123; insertionSort(&amp;list, start: pos, gap: sublistCount) &#125; sublistCount = sublistCount / 2 &#125;&#125;var arr = [64, 20, 50, 33, 72, 10, 23, -1, 4, 5]shellSort(&amp;arr) 扩展阅读希尔排序的维基百科 Rosetta code的希尔排序（译注：大概70种不同语言实现希尔排序😅😓） 作者：Mike Taghavi，Matthijs Hollemans翻译：Andy Ron校对：Andy Ron 翻译后补充希尔排序，也称递减增量排序算法，按其设计者希尔（Donald Shell）的名字命名，在1959年公布。 定义希尔排序是将待排序的数组元素按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。 希尔排序的原理图 图片一来源：图解排序算法(二)之希尔排序 图片二来源：排序：希尔排序（算法） 一个希尔排序的动画 Comparison Sorting Algorithms 参考图解排序算法(二)之希尔排序 排序：希尔排序（算法）]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>希尔排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《分享时代：如何缔造影响力》]]></title>
    <url>%2F2018%2F%E5%88%86%E4%BA%AB%E6%97%B6%E4%BB%A3%EF%BC%9A%E5%A6%82%E4%BD%95%E7%BC%94%E9%80%A0%E5%BD%B1%E5%93%8D%E5%8A%9B.html</url>
    <content type="text"><![CDATA[作者和本书概要作者布赖恩·克雷默(Bryan Kramer)， 知名演讲人、咨询师、教练、畅销书作者。 《分享时代：如何缔造影响力》原著名是《Shareology: how sharing is powering the human economy》，本书是一本教你通过分享提升影响力的书。它深刻剖析了人类分享的本质，同时为读者阐明了分享经济在未来将要发挥的力量。更重要的是，本书告诉你如何建立个人影响力，如何把有价值的内容传递到目标客户中从而提升企业的影响力。 内容一、分享的本质是获得身份认同感史前时代，人们分享是为了生存。现代社会，分享是为了沟通。沟通是一种融入群体的需求，一种对归属感的需求，只有跟大家在一起我们才安全。 二、分享的内容决定了个人品牌只有创造和分享个人品牌才能改变人们对你的认知，并以此相互联系，在此基础上才能找到跟你志趣相同的人。 公式：一个人的个人品牌 = 别人如何评价你分享的 信息内容 和 信息来源 。 三、把分享作为商业之道进行分享营销从品牌角度而言，数字化时代最大的缺点就是统一的品牌认知与个性化的客户之间的矛盾。 公式：你的用户愿意分享你的言论 = 他们信任你分享的内容和你信息的来源。 你要尽量人性化，人性化就代表着具有可分享性。未来的商业模式就是在人际关系之上建立顾客关系，并和顾客保持互动。从广而告之的传播方式转变为寻求怎样才能创造出有趣的分享内容，也就是进行分享营销。 四、如何做好分享营销 分享内容：只有触动了人性的内容才值得被分享 当一条推送的内容触动了一些人的人性，他们就会转发，接着转发的人也是由于同样被触碰了内心深处，以此类推。 🌰冰桶挑战 分享对象：让每位员工成为影响者 网络已经改变了影响力的源头，人人都能成为有影响力的影响者。影响力的背后，是信任，人们因为信任一个人或是机构而愿意接受他们的观点。 员工就像是后院中被人忽视的钻石，而他们是对你的企业和目标有着深刻理解的人。1.给员工提供时间和资源。2.要让合适的员工成为影响者 分享时机：把握分享时机的标准就是，受众是否会“产生共鸣” 分享的内容和频率都应该适度，并不是越多越好。找到自己最佳的分享频率。 分享方式：用帮助替代推销 每当买家或是他们身边的圈子有所需要时，你总能及时出现，并以高涵养、高价值的内容分享来换取生意和商机，你就早就赢得了客户的信任，这也是把最初的人际关系变为商业利润的最佳方式。这就是我们说的内容营销方式。 五、分享的未来发展未来将会是人们打开心扉的时代，因为人们愿意分享的信息越多，社会作为一个整体的进步就越快。 人们能够接触更多的信息，这意味着我们能够更快、更轻松地解决社会问题，我们清楚地知道一件事该由谁去做。 当所有人都可以无所顾忌地浏览信息并且随时分享自己的信息时，未来会进入分享型社会。不仅把自己的想法分享出来，而是把所有人内心深处的科学和哲学思想联系在一起，共同分享，一传十、十传百，最终改变这个世界。 参考： 得到-每天听本书]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>分享</tag>
        <tag>个人品牌</tag>
        <tag>影响力</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《知识的边界》—— 自下而上，链接一切]]></title>
    <url>%2F2018%2F%E7%9F%A5%E8%AF%86%E7%9A%84%E8%BE%B9%E7%95%8C.html</url>
    <content type="text"><![CDATA[作者和本书概要戴维·温伯格 是哈佛大学伯克曼网络与社会研究中心的资深研究员，还曾担任过美国总统候选人的网络政策顾问。在过去二十多年的时间里，他都在思考互联网对于人类的思想、沟通和社会的影响，写了很多重要的著作，可以称得上一位互联网思想家。 《知识的边界》，英文书名为“Too Big to Know”，直接翻译就是“大到不可知”。看这个书名的意思有点和另一本畅销书《浅薄 - 互联网如何毒化了我们的大脑》观点类似：互联网带来了信息过载的问题，知识碎片化的问题，网络世界实在是太大了，大到我们根本不可能去理解它。然而恰恰相反，本书的作者戴维·温伯格认为，如果有人认为互联网成为了获取知识的阻碍，那么很可能是因为他没有真正理解正在发生的知识变革，互联网创造出的无限连接的信息网络，让我们更接近知识的真相。 《知识的边界》 和 《浅薄 - 互联网如何毒化了我们的大脑》 两本书观点有点对立可以一起看看。 内容一、互联网时代的知识，人们抱有哪些偏见偏见1：纸质书比网络获取知识更好 纸质书看着有“质感”？ “质感”怎么去定义呢！ 实际上，大多数人看的书都是那种廉价的、看完就扔的一次性用品。 可能很多时候这种“质感”是虚荣心的一种表现。 纸质书上的知识真的“更成体系”吗？而且，书籍这种一页一页装订起来的物理性质，决定了它的内容大多是按顺序展开，作家的思路也就被它限制住了。作家在写书的时候，论证一件事情的思路就像一条小路，他会带着读者从 A 地到 Z 地，这么一路走下来，每一步都要仔细推敲。如果有什么和这条小路不同的观点，或者是从主观点分支出来的小观点，都会因为怕干扰了读者的注意力而被删掉。这样得到的知识是应该是一个链条，要说“成体系”，恐怕还要读者自己多多搜罗资料了。 偏见2：互联网让我们陷入了信息过载的焦虑信息过载很可能是一个伪问题。 其实在人类历史上，一直都有信息过载的问题。 今天的问题不是信息过载，而是新式的信息过滤器失效了，比如说，以前的过滤器有报纸、百科全书、教材，它们是有权威性的，会帮读者筛掉大部分信息，这样就缓解了人们对信息过载的焦虑。而互联网的一个特征，就是信息几乎不会被真正地过滤掉，它们永远都存在。想想看，你是不是经常会看到类似这样的标题，“2018年最不容错过的8条新闻”，这个筛选本身也是信息。而且，它并没有把其他没被选入的新闻删掉，那些新闻仍然在网上，只不过可能在搜索引擎排名的第100万条之后。 所以，我们要避免陷入焦虑，不是要远离信息，而是要 找到新的信息过滤器。比如通过社交网络，我们可以从自己熟悉、信任的人那里，获得有效的信息，忽略其他渠道的信息。 偏见3：“回声室效应”让极端主义加剧“回声室效应”，是指人们在网上经常会看一些和自己观点相近的消息，就好像在一个封闭的空间里，意见相似的声音不断地重复，人们都以为这些片面的消息就是事实了。现在我们用的一些手机软件，也会按你的喜好来推荐内容，这也是一种回声室。回声室效应会让人们更容易屏蔽掉那些和自己意见相左的声音，和真正的理性知识隔绝开，甚至有人认为，互联网就是孵化极端主义的温床。 不过，事情真的有这么糟糕吗？有两位美国的经济学家，跟踪调查了人们上网时浏览的网站，发现情况和我们想象的似乎相反。那些经常登录极端保守主义网站的人，也会登录自由主义的网站，而且还比一般上网者登录的可能性更大。反过来也一样，常常登陆极端自由主义网站的人，也更可能去访问偏保守主义的网站。温伯格说，回声室虽然有四面高墙，但是因为网络的存在，高墙已经变得可渗透了。原来的回声室是完全与世隔绝的，现在的回声室就像临街的房子，街上车水马龙的噪音都可以轻易地传到屋里来。 网络上虽然存在回声室效应，但并没有我们想象的那么可怕。 偏见4：事实还是知识的基础吗？最后一个偏见，我要说一个最颠覆的。我们常说，掌握知识要成体系，这说明我们认为知识是有一个框架的，它的地基非常扎实，能让我们在地基上建起一座知识宫殿。这个“地基”就是事实。那我就要问一个问题了，在互联网时代，你可能会说，这个问题太奇怪了，就说科学知识吧，要不是建立在事实的基础上，那不就成伪科学了吗？我们来听听温伯格是怎么说的。 温伯格把人类近代历史划分成了三个阶段，—— 在经典事实阶段，事实很稀缺，找到很不容易，比如达尔文曾经花了7年的时间研究藤壶这种生物，最后确定它是甲壳纲的动物。—— 后来到了基于数据的事实阶段，虽然这个时候数据比原来多很多，但因为技术限制，比如硬盘容量太小，还是需要有人对数据来进行筛选，我们对知识的认识没什么变化。—— 到了现在，人们进入到“网络化事实”的阶段，数据量剧增，原来写在期刊上的文章，因为版面有限，文章引用的数据只能摘录一小部分出现。而现在在网络上，一个超链接就可以了，于是每个人都可以随手获得大量的事实。 而这就带来了一个矛盾，事实太多，我们失去了得出结论的能力，反而比原来更容易犯错了。你可以说，我在世界资源研究所收集的数据里，找到关于全球气候变化的证据。他也可以说，我从欧洲动物群物种分布的数据库里拿到的数据，得出了跟你完全不一样的结论。 对于这个情况，温伯格拿牛顿第三定律做了个类比。牛顿第三定律是说，两个物体之间的相互作用力，总是大小相等，方向相反的。温伯格觉得，在网络上，事实也是这样，每个事实都有一个“反作用力”，它不一定对，但是当很多很多事实相互连接，各种相互作用力充满了网络的时候，你会发现，事实失去了它古老的作用，它没有那种板上钉钉的感觉了。你要是不喜欢我的结论，几秒钟就能找到反驳我的事实。人们都觉得自己的观点是绝对正确的，事实变得非常无力，变得很容易被推翻。 听到这里，你会不会很怀念原来的纸质媒体时代？在那时，人们在报刊上总能找到确定的结论，而不像现在，说什么好像都有人能反驳。不过温伯格提醒我们，因为纸张的成本问题，纸质媒体没有那么多版面来发表全部的事实，而且即使有错，在已经刊登的版面上也无法修改了。也就是说，我们那个时候相信的，可能也不是事实本身，而是报纸刊登的报道。 所以温伯格才说，传统的知识是纸张的意外产物。 事实失去了它古老的作用，不再是知识坚实的地基。 第二部分，互联网塑造出的全新的知识生态系统，到底是什么模样；互联网塑造出的全新的知识生态系统。我将从知识的本质，知识的生产方式，知识的传播方式和人们思维的形状，这四个方面的变化来跟你描述这个生态系统。 生物学上的生态系统是说，在自然界的一部分空间里，生物和环境构成了一个统一的整体，而现在网络也是这样的一个系统。也是因为互联网这样的特性，它重新定义了“知识”。 我们原来觉得，印刷在图书、报纸上的文字就是知识，它会被一直保存在图书馆里，永远没有变化。但温伯格提出，其实世界上根本不存在一种叫“知识”的东西能让我们这么保存，在网络世界里，知识不在书本里，也不在每个人的大脑里，而在网络本身。 怎么理解这句话呢？你可以把互联网想象成一间有好多人的房间，当知识网络化之后，最聪明的不是房间里的哪个人，也不是所有人的群体智慧，而是这个容纳了所有的人和思想，并且和外界相连接的房间。这就像生命一样，你不能说生命活在我们的神经里、活在血液里，它活在一切的联系当中。 既然知识的本质发生了变化，那它的生产方式和传播方式又是怎样的呢？先来说生产方式的变化。要说生产知识的人，你一定想到了，那就是专家。大到各国政府的智库，小到父母依赖的育儿专家，很多人对他们笃信不疑。 和专家相对的，就是“群众”。在大众传媒时代，“群众”这个词已经和“从众”联系在一起。把群众聚集在一起，就会出现社会心理学著作《乌合之众》那样的情况，人们一旦聚集起来，就变得盲目、冲动、更容易轻信别人。如果说要指望群众来生产知识，那简直是天方夜谭。 但是在互联网成熟之后，情况就变得不一样了。网络能成为知识的来源，有个很重要的原因恰好就是它连接了更多的人。很多原本可能花费高昂、费时费力的任务，依靠庞大的网络大军就能轻松完成。 而且，互联网也打通了传统专家们细分领域的圈子，它能让更多不一样领域的人来解决相同的问题，而这往往是解决问题的关键。 温伯格在书里给我们举了个例子，有一名电力工程师，他帮高露洁公司解决了一个难题。我们知道，氟化物能有效预防龋齿，但是它在被装进牙膏管的时候，很容易向空气里扩散。怎么解决这个问题呢？这名工程师发挥了他的专业特长，他提出，只要在往牙膏管里注入氟化物的时候，给氟化物加上一股电子流就行了。在电子流的作用下，氟化物的颗粒就会紧贴着牙膏管壁。哈佛商学院的教授拉卡尼评价说，谁的专业知识离问题越远，反而越可能解决这个问题。 在互联网的带动下，知识的生产方式，正在从“传统的专家”向“每个人都是专家”转变。 说完了生产，我们再来说传播，互联网将知识的传播方式从原来的金字塔模式，变成扁平的网状模式。 知识的金字塔模型你可能不陌生了，最底层是数据，往上是信息，然后是知识，最顶端是智慧。我们以前处理信息的方式，也是这种金字塔模式，数据本身没有价值，我们通过处理数据，得到信息，再通过处理信息得到知识，以此类推。有了这个模式，我们就能决定传播哪些东西了。最底层没有价值的数据不值得传播，人们会选择更上层的，比如信息、知识来传播。 温伯格说，在金字塔模型中，我们处理知识最基本的策略就是过滤、筛选。比如我们会设计一个复杂的过滤系统，过滤掉大多数人写的东西，只剩下精品才能发表出来，那这个过滤系统可能就是杂志编辑部。这种靠中央权威机构来过滤的模式，就是金字塔模型。我们的商业、文化、科学、政府都是围绕着中央权威来运行的。 当然，在网络里，我们也需要权威，只不过，权威机构、权威的人不再是知识的终点了。在网络化知识里，每个节点都不是终结点，它们构成了一个扁平的网。想了解进化论的知识，就算搜索到了达尔文的作品，你也可以继续从他作品当中找到可以延伸出去的链接，这些链接会让达尔文的观点更容易理解、更加贴近现代。而且，一部作品是不是权威，也不单单是由单个人或组织来决定的，而是在不断地讨论、编辑、修改当中，逐渐确立的。 温伯格的这个观点，倒是和牛津大学的动物学博士马特·里德利不谋而合。里德利在《自下而上》这本书里提出了一个观点，他把人们预先设计一套方案再去推广的过程，叫“自上而下的设计”，而那种从混乱中自发出现秩序的过程，叫做“自下而上的演变”。想想看，原来人们处理知识的金字塔模型，就是由权威机构自上而下设计的，而在互联网当中，人们能从网上海量的数据中，顺着一连串的链接得到自己想要的知识，这就是自下而上的涌现。里德利在《自下而上》这本书里还下了个断言说，好东西几乎都不是设计出来。 本书的作者温伯格倒没有说得这么绝对，因为 那些有错误和有害的观点也能通过扁平的网络迅速传播。 那么，既然知识有了这样的变化，我们思考方式会随着怎么变化呢？在美国作家卡尔《浅薄》这本书里，他提到说，网络上的那些闪烁的图标、各种链接让我们变得愚蠢。因为这些东西分散了注意力，减弱了我们对信息“深加工”的能力。 温伯格把这种能力叫做“长形式思考”的能力。什么意思呢？你看，书把思想固定到了纸上，想要让读者明白你最后的结论，那就要把论证过程细致地摆出来，必要的时候还要解决读者可能提出的不同意见，保证论证的完整。比如达尔文在写《物种起源》的时候，在全书15章的内容里，花了6章来解决他认为读者可能有的批评。这当然很高明，但这并不是因为我们思想本来就是这样的，而是受限于书籍的形式。因为书是一种单向的媒介，作者不得不自言自语，想象读者的反应，完善自己的论证。 书充当了“知识”太长时间的载体，我们就误以为，思考就应该是长形式的。 那么脱离了书，知识网络化之后，思考会回归本来的样子吗？那会是什么形状的？作者说，这种觉得思考一定有形状的想法会阻碍人们，不限长度、不限形式的思考才更好，而网络就是这样一个无边界的载体。比如，如果你在看《浅薄》这本书，你是可以从作者规定好的长形式思考中跳出来的，你可以在网上找到关于这本书的争论，可以看的更多关于互联网对人们影响的观点。这些观点组合起来，就是一张没有形状的思想之网。 那思想的这种形状的变化，真的让我们变浅薄了吗？作者也不同意这个观点，他引用了认知科学家史蒂芬·平克的话。平克拿科学研究举了个例子，他说如果互联网真的让我们变愚蠢了，那科学的质量应该直线下降才对，但是你想一下，从1994年万维网诞生到现在，科学技术的新发现是更多了还是更少了?答案显而易见。其他的精神生活领域也是一样的，比如文学、艺术，都在不断进步，没有倒退的迹象。 总结一下这部分的内容。互联网塑造出来的全新知识生态系统，和原来相比都有哪些变化呢？我们分别讲述了知识的本质、知识的生产方式、知识的传播方式和人们思维形状的变化。总的来看，网络化的知识告诉我们，世界更像是一个不定形状的、相互交织的、不可掌控的大网。 第三部分，我们来讨论一个跟每个人都有关系的问题，在这个海量信息、无限连接的网络世界，我们怎样才能变得更聪明。历史上每次出现不同的媒介，都会带来知识革命，从竹简到纸张，到广播、电视，再到现在的互联网，每次都带动了人类文明的进步。 温伯格说，我们希望这个过程能更加迅速地发生，因为我们现在的知识媒介比以往任何时候都更加便利。 那接下来我们要讨论一个和每个人都有关系的问题：我们该怎么利用网络，让自己变得更聪明呢？这就到了这本书的最后一部分。温伯格说，一套新的认识世界的策略正在形成，我们要在无法达成共识的世界里探索知识，我们要主动出击。他为我们提出了四个建议。 第一，是在开放的网络生态里，好好利用过滤器。我们在前面提到，在纸质书的时代，有各种过滤器会帮助我们过滤内容。在开放的生态里，我们还是会从图书出版社、期刊编辑那里受益，只不过我们要学习如何才能混合使用这些过滤器，怎么用一些过滤器作为其他过滤器的指标。利用好这个过滤体系，你就能更好地利用这个开放的网络。 第二个建议是，上传资料时，要上传“关联数据”。比如，如果你有很多很多关于化学元素的信息，那你在上传的时候，不要上传单个的数据，而可以用一种“三元组”的形式上传。三元组就是包含两个对象和一种关系，比如“汞”和“元素”分别是一个对象，它们的关系就是“汞是一种元素”。因为“汞”这个词在英语里还代表水星，还代表罗马神话的里的一个神，所以三元组的好处就是超越了单个数据，让数据之间发生联系，变成了知识。想想看，当科学、商业、文化等等所有领域的人都这么做的时候，我们就能拿到前所未有的、巨大的资源。温伯格说，这种资源就是一个数据公地，我们才刚刚知道它的变革作用。 第三个建议是展示你的工作，链接一切。在互联网时代，温伯格认为我们的知识系统应该是开放取用期刊那样的。比如，科学大刊《自然》杂志，可以说是在金字塔顶端的杂志了。它现在已经创办了自己的网络版，可以不受页面的限制刊登所有有价值的文章，研究者们可以在任何时候把自己的研究上传，让其他人能更快地接触到有价值的观点。而且，也要把你的作品链接到更多的文章。咱们前面已经说了很多关于链接的好处，它能让我们找到所有感兴趣的知识。这个想法凯文·凯利在《失控》这本书里也说过，他说，在未来，连接才是王道。他把整个世界的物质都叫做“进化体”，不管是石头、青蛙、人类、国家，还是互联网，它们都是打通的。而进化体内部个体连接的程度越高，这个进化体就越优秀。 最后一个建议是，学会拥抱不同。网上的知识越来越多，我们要学会用批判性思维去分辨哪些是废话，哪些是证据充分的结论。但是我们也要注意，想要避免回声室效应，我们就要学会包容不同的观点，不要只关心自己熟悉的、和自己意见一致的观点。温伯格说，我们一直是在技术的范畴里理解自己，想想看，知识的载体是书籍时，人们的思考形状就是长形式的思考，而互联网突破了这个思考模式。我们可以把自己想象成一帧网页，让超链接这个新型的基础设施，带给我们更多的、对自身的新发现。 总结人们对互联网和知识最大的四个偏见。 第一，纸质书真的比网络获取知识更好吗？温伯格认为，人们只是把图书过分浪漫化了。而且受限于书籍的形式，我们只能跟随者作者的思路，拿到一个“链条状”的知识，而不能像在互联网里一样，发散思维，开枝散叶。 第二，现代人们的焦虑，是因为信息过载吗？温伯格认为，这是因为我们过滤器失效了，它不再能帮我们删掉信息，反而会增加信息。 第三，回声室效应会让极端主义加剧吗？网络上虽然存在回声室效应，但并没有我们想象的那么可怕。我们进入一个回声室，也是在一片嘈杂当中听过了很多声音之后，才进入的。 第四，事实还是知识的基础吗？温伯格说，在互联网上，如果你不喜欢我的结论，那你很快就能找到反驳我的事实。事实失去了它古老的作用，不再是知识坚实的地基。 从知识的本质、知识的生产方式、知识的传播方式和人们思维的形状，这四个角度来给你描述了互联网塑造出的、全新的知识生态系统。 在互联网时代，知识的本质发生了变化，它不再是书本上固定的文字，也不是网络上的信息，而是网络本身。 知识的生产方式正在从“传统的专家”向“每个人都是专家”转变，而知识的传播方式，正在从原来的金字塔模式，变成扁平的网状模式。知识的这些变化也让我们的思考方式发生了变化，我们原来受限于书本的限制，都是从 A 到 Z 的长形式思考，而互联网的超链接帮助我们，能把这条链条扩展成一张网。 最后，温伯格给出了四条让我们能更好地利用互联网的建议。第一是在开放的网络生态里，学会混合利用过滤器，让一些过滤器成为筛选其他过滤器的指标。第二个建议是上传资料时，要上传“关联数据”，让数据和数据之间发生联系，变成知识。第三个建议是展示你的工作，让有价值的观点能及时让人们看到，并且链接一切，链接越多，网络就优秀。第四个建议是，学会拥抱不同，我们既要用批判性思维看待别人的观点，也要包容不同的意见。请把自己当成一帧网页，和世界做更多的连接，收获更多对自身的理解。 信息网络的这种超链接，的确会诱惑我们一路向前、不停地点击，不过我们换个角度来想，如果这个诱惑让我们偏离了本来的目的，那也许它真的消耗了我们的专注力。但是我们也可以把它当成一种新的学习形式。因为它不仅迅速地帮我们解答了困惑，也让我们能沿着自己的兴趣去探索。 温伯格后来在一次接受中国媒体采访的时候说，知识网络并不关心我们从哪里获得知识，无论是从网络上免费获取，还是从书本、课程里付费得到。它关心的是，在获取知识之后，你是不是能和别人构成网络，一起理解这个知识？互联网形成了比起聪明人还要聪明的专家网络，网络能够让我们更聪明，只要我们自己想要更聪明。 参考： 得到-每天听本书]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>知识</tag>
        <tag>互联网</tag>
        <tag>纸质书</tag>
        <tag>电子书</tag>
        <tag>链接</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《腾讯传》—— 腾讯的发展也是中国互联网企业的缩影]]></title>
    <url>%2F2018%2F%E8%AF%BB%E3%80%8A%E8%85%BE%E8%AE%AF%E4%BC%A0%E3%80%8B.html</url>
    <content type="text"><![CDATA[作者和本书概要吴晓波：著名财经作家，“吴晓波频道”、蓝狮子出版创始人，常年从事中国企业史和公司案例研究。著有《大败局》I和II、《激荡三十年》《跌荡一百年》《浩荡两千年》《历代经济变革得失》等广具影响力的财经书籍，著作两次入选《亚洲周刊》年度最佳图书。 《腾讯传1998-2016：中国互联网公司进化论》，腾讯官方唯一授权的权威传记，腾讯的发展路径，亦是中国互联网企业成长的缩影。读懂腾讯，读懂中国互联网。 内容0)前言 谁能定格一座正在喷发的火山 “在互联网行业里，所有人的眼睛都盯着未来，昨天一旦过去，就没有什么意义了。” 一个优秀画家应当描画两件主要的东西，即人和他的思想意图。第一件事做到很容易，第二件事情就很难。 “要知道我们说的东西很容易，但要知道我们为何这样说却非常难。” “世上尚未发生过任何总结性的事情，也无人说过针对世界，或关于世界的最终总结。这世界是开放自由的，所有一切仍有待于将来，而且永远如此。” 创业：1998-2004 “任何能打破对于人、产品和信息的时空限制的新发展，都会对商业运作的方式产生巨大的影响。” 小阿尔弗雷德·钱德勒 在研究美国早期工商企业的发家史中，提出过著名的“成长四阶段”论， 即积累资源、资源的合理化利用、持续增长和对扩展中的资源的合理利用 腾讯的案例中可见，中国互联网从业者在应用性创新上的能力和速度并不逊色于任何国际同行，这一特征与电子产品、汽车、医药、机械装备等领域发生的景象完全不同 网络环境、用户习惯、支付体系、国家政策等客观条件 中国在移动通信领域的增值服务起步比美国早得多 2000年底，“移动梦网” 出击：2005-2009 “机器应该工作，人类应该思考。”—— 托马斯·沃森（IBM） 虚拟道具的吸金能力，并以包月模式创造性地激发出中国网民的消费热情 传统的三大新闻门户——新浪、搜狐和网易，腾讯以迂回战术悄悄超越。刘胜义重新定义了网络广告的投放规则，并获得了广告主的认同，而QQ迷你首页对流量的巨幅拉动更是让所有对手无可奈何。 ”成长总是脆弱的” 腾讯在2010只有遇到空前的质疑和攻击 巨头：2010-2016中国互联网的三次“圈地运动”。 第一次是在1999年前后，以新闻门户为基本业态，出现了新浪、搜狐和网易“三巨头”。 2007年之后，出现了以应用平台为基本业态的大洗牌，门户们陷入“模式困境”，出现了成长乏力的态势，而百度、阿里巴巴和腾讯则分别从搜索、电子商务和即时通信工具三个方向出发，到2010年前后完成了反向超越，成为“新三巨头”，它们被合称为BAT。 从2012年开始，智能手机异军突起，互联网的用户重心从电脑端向移动端快速平移 马化腾的七种武器 一位创始型企业家的性格和才能，将最终决定这家企业的所有个性。 产品极简主义 少就是最合适的”， “Don’t make me think！（别让我思考！）”， “让功能存在于无形之中” 腾讯也是工程师文化与产品经理文化融合的标本。 用户驱动战略 技术驱动、应用驱动、用户和服务驱动 内部赛马机制 试错迭代策略 生态养成模式 资本整合能力 专注创业初心 两个互联网世界：美国的，中国的 中国互联网没有经过早期的非商业阶段，一开始它就是一个资本的舞台，所以互联网本身的民主性、非中心性，在中国从来都没有被广泛关注过。 腾讯历史上的战略性产品都找得到仿效的影子。而耐人寻味的是，被效仿者很快销声匿迹，而腾讯则据此获得成功。 如果说美国人总在想如何改变世界，那么，中国人想得更多的是，如何适应正在改变中的世界，他们更乐意改变自己的生活，这是商业价值观——广而言之，更是人生观的区别，也是很多美国与中国商业故事的不同起点。 互联网是罕见的阳光产业，因变革的快速和资源的不确定性，国有资本迄今没有找到对其进行有效控制和获取垄断利益的路径。 Part 1 创业：1998-20041)喜欢天文的Pony站长 “互联网是不是很像一个不确定的、正在爆炸的星系？” 马化腾和他的三个中学同学：许晨晔、张志东和陈一丹。 马化腾日后被称为“中国第一产品经理”，他的产品意识以及对用户体验的理解，最早都是在“马站”时期形成的。 1955左右和1970左右出生的两批人 马克·安德森，马化腾，马斯克，丁磊是71年，李彦宏68年 拉里·佩奇和谢尔盖·布林都是73年 Linus 69年的… 他们成年时差不多就是互联网开始爆发的时候 这有点像1955年左右那一批，到1975年差不多成年赶上个人计算机的时代 比尔盖茨、乔布斯1955 保罗·艾伦：1953年1月21日。 史蒂夫·鲍尔默：1956年3月24日。 埃里克·施密特：1955年4月27日 比尔·乔伊：1954年11月8日 等等一大批计算机牛人 这也该叫做天时 2)开局：并不清晰的出发 公司英文名Tencent的灵感，则来自Lucent（朗讯），“当时讲究左右对称，Tencent就很对称”。把这个词分开来，就是TenCent（十分钱），腾讯日后以微结算的盈利模式成就大业，也许是“天意”。 在中国乃至全球的互联网史上，从1998年到1999年的两年，是一个神秘的时期，错过了这一段，也就错过了一个世代。 Google，搜狐，新浪，网易，雅虎中国，联众游戏，盛大网络，京东，阿里巴巴，携程，当当，3721，百度…这些名声显赫的互联网企业全部诞生于1998-1999年 杨致远做了一生中最愚蠢的一个决定：1998年有两位出生于1973年的斯坦福校友上门找到杨致远，想要把自己的一个搜索技术以100万美元的价格卖给雅虎，杨致远优雅地拒绝了他们。9月7日，拉里·佩奇和谢尔盖·布林被迫在加州郊区的一个车库内孤独创业，他们把公司取名为Google。 采用UDP技术的开发难度较高，但能大大节约服务器的成本，使得单台服务器可以支持更多的客户端 3) 生死：泡沫破灭中的挣扎 救命的IDG与盈科 王树的对赌条款：“在协议签订后，先投一半的资金，我们在一年内须达到一定的用户数量，否则另外一半的钱就不给了，而他们仍然占20%的股份，我们答应了。” 从OICQ到QQ 任宇昕（腾讯首席运营官）是在腾讯最缺钱的时候进入公司的。 MIH的意外进入 偶然闯入的MIH以32.8%股份成为腾讯的第二大股东。 4)梦网：意外的拯救者 “影子国王”的梦网计划 文化差别太大了，中国的手机用户对手机短信的热情也许是全世界最高的，而美国人爽朗直率的个性使得大多数人更喜欢直接通电话。在2002年，全美国的手机用户发送短信息的总数为81亿条，但中国人仅在2004年春节7天长假期间就发送了70亿条。到2006年，美国全年的短信量都比不上中国春节一天。 不成功的收费试验 “当时的投放客户几乎都是正在烧钱的互联网公司，大家互相投放，我在你那里投广告，你也在我这里投一些，大家就都有了收入，其实是骗投资人的。” 在腾讯史上，2002年的“靓号收费”在日后很少被提及，事实上，这是一次非常危险的歧途经历。 Q币：虚拟货币的诞生 由于金融信用体系的缺失——这是中国与美国互联网产业最大的差异之一——长期以来，如何建立自己的支付体系困扰着所有的经营者。 5)QQ秀：真实世界的倒影 网络也是一个世界，一个我们可以实现现实中不可能实现的梦想世界，“阿凡达（Avatar）”提供了这种可能。—— 腾讯“阿凡达项目”计划书 群聊：“社区”的第一次出现（2002） QQ群的发明，彻底改变了网民维系关系链和在线互动交流的方式，标志着社交网络概念在中国的出现，而这比Facebook要早18个月。 市场部的“阿凡达计划” “腾讯在内容策划上力量薄弱，与内容相关的服务一直不是强项”在腾讯的历史，乃至中国互联网史上，QQ秀都堪称一款革命性的收费产品，它可以被视为全球互联网产业的一次“东方式应用创新” 西方的很多互联网研究者，对于中国网民愿意花钱购买虚拟道具来装扮自己这一点，感到非常的不可思议。在这里，可以透视出东西方社会人在角色认知上的巨大差异。“情感的寄托” QQ秀也是腾讯一个“蜕变之秀”，从此，这家即时通信服务商成为一个发掘人性、出售娱乐体验的供应商。 2003年：三个战略级的衍变 QQ、QQ会员、QQ秀以及Q币，构成一个独立的、闭环式运转的QQ世界，腾讯的组织体制内部也诱发出一系列战略级的衍变。 衍变之一：与工程师文化相交融的产品经理制。“谁提出，谁执行”“一旦做大，独立成军” 衍变之二：以Q币为流通主体的支付体系。 衍变之三：以特权和等级制为特色的会员服务体系。 互联网产品的收入增长取决于对用户情感需求的挖掘和对整个服务流程的掌控。 进入网游：没有“凯旋”的《凯旋》（2003） 腾讯第一次试水网游，以尴尬的结局告一段落 QQ.com:“青年的新闻门户”（2003） 6)上市：夹击中的“成人礼” 为什么选择高盛 “马化腾不太爱讲客套话，说话的逻辑性很强，同时，他也是一个不会轻易亮出底牌的人。”这是刘炽平对马化腾的第一印象。 纳斯达克还是香港￼理论上，一家立足于服务大众用户的公司，它的上市地点越贴近它的本土市场，公司价值就反应得越为真实。 员工期权的兑现 来自电信增值服务的收入占到了总收入的56%，而其他归入互联网增值业务的收入也有一半与此相关，所以，如果精确计算的话，刚上市时的腾讯几乎是一个被“移动梦网”“绑架”了的寄生型企业。 Part 2 出击：2005-20097)调整：一站式在线生活 “虚拟电信运营商”的幻灭 在过去的几年里，腾讯决策层一直对SP(Service Provider，服务提供商)业务保持着一种克制的态度，马化腾之所以“一意孤行”，相继投入游戏、门户等业务也与内心的恐惧有关。 新战略：“像水和电一样融入生活当中” 刘炽平说：“我管三件没有人管的事情，一是战略，二是并购，三是投资者关系。” 腾讯唯一的核心能力是掌握了人际关系网络 如何定义“在线生活”？ICEC。I代表Information（信息），C代表Communication（通信），E代表Entertainment（娱乐），C代表Commerce（商务）。 “腾讯希望能够全方位满足人们在线生活不同层次的需求，并希望自己的产品和服务像水和电一样融入生活当中。腾讯已经初步完成了面向在线生活产业模式的业务布局。”边界 第二次组织架构调整 2005年10月24日,公司的组织架构被划分为8个序列，分别由5个业务部门和3个服务支持部门组成。B0：企业发展系统，下属国际业务部、电子商务部、战略发展部、投资并购部，负责战略、投资并购及相关业务，由首席战略投资官刘炽平兼管。B1：无线业务系统，下属无线产品部、移动通信部、电信事业部和各地办事机构，负责与电信运营商相关的业务，负责人为刘成敏。B2：互联网业务系统，下属互联网研发部、社区产品部和新成立的数字音乐部，负责QQ及相关业务，负责人为吴宵光。B3：互动娱乐业务系统，下属互娱研发部、互娱运营部、渠道营销部，负责网络游戏业务，负责人为任宇昕。B4：网络媒体业务系统，下属网站部、广告销售部、搜索产品中心，负责门户网站业务，由首席信息官许晨晔兼管。O线：运营支持系统，下属运营支持部、系统架构部、安全中心、管理工程部、研发管理部和客服部，负责服务器、数据库及安全业务，负责人为李海翔。R线：平台研发系统，下属即时通信产品部、深圳研发中心、广州研发中心，负责技术研发，由首席技术官张志东兼管。S线：职能系统，下属行政、人事、财务、法律、投资者关系、内审、公关及董事会办公室，由首席行政官陈一丹兼管。 ”未来5年，腾讯最大的挑战就是执行力。市场怎么样，大家都看得见，但不一定都拿得住。通过完整的指标体系和组织结构保证压力的传导，通过严格考核和末位淘汰制留住好的人才，而所有这些，能把腾讯打造成一个不依赖个人精英，而是依靠体制化动力的成熟体系。” —— 马化腾 “我不盲目创新，微软、谷歌做的都是别人做过的东西。最聪明的方法肯定是学习最佳案例，然后再超越。我不争第一，没意义。新产品一出来就要保证稳定，不能想怎么改就怎么改，要慎重。” —— 马化腾 8)战MSN：荣誉与命运 MSN来了（2004.8） “收购”张小龙 比尔·盖茨通过捆绑战略击溃网景的故事更是殷鉴不远（指殷商子孙应以夏的灭亡为鉴戒。后泛指前人的教训就在眼前。）。 1亿多QQ用户中，使用QQ邮箱的不到1%，补板的最佳办法，就是收购Hotmail在中国的最强竞争对手，于是Foxmail进入了腾讯的视野中。 张小龙因此被业界视为继求伯君之后的第二代软件工程师的代表人物。张小龙个性内向，不喜欢混圈子，是一位业余网球高手。他对商业的兴趣不大，在Foxmail如日中天的时候，他都没有想到要组建一家公司来进行商业化运营。 腾讯与美国谷歌宣布业务合作。腾讯已经开始为其国内用户提供谷歌的网页搜索服务。同时，腾讯还将提供谷歌在网上针对搜索结果的广告服务AdSense。谷歌的网页搜索框嵌入腾讯的各主要互联网服务，包括QQ即时通信的客户端、网站、TT浏览器、腾讯TM和腾讯通RTX。 重新定义即时通信 我们不能拿用户价值冒险，这样不负责任 2007年10月，为了阻击正在快速崛起中的Facebook，微软的Hotmail将许多来自Facebook的邀请信归类为垃圾邮件，导致Facebook用户增长下跌了几乎70%，最终，两家坐下来谈判，扎克伯格答应了微软的投资要求，后者以2.4亿美元获得1.6%的股权。 马化腾宣布：“中国的即时通信应用目前已经领先世界，即时通信的下一个发展阶段也将进入由中国领导的即时通信全面社会化的阶段。” MSN做错了什么 首要的问题是，指挥体系的紊乱。如果说腾讯将它与MSN的竞争视为一场战争的话，那么，在微软看来，这连战役都算不上，顶多是一场无关痛痒的局部战斗而已。 其次，微软的全球开发模式很难适应区域性的市场竞争。 其三，罗川独创的分包合作模式在运营中出现了混乱。 其四，微软与雅虎的互联互通没有取得预料中的“里程碑式的效果”。在本质上，微软始终是一家软件技术公司，而不是互联网公司，它没有运营一个互联网产品的经验。 2005年：中国人统治中国互联网 安踏牌运动鞋的丁志忠描述了中美企业对中国消费市场的不同理解，“耐克、阿迪达斯的篮球鞋主要是在塑胶地板上穿，弹性是重要考核指标，而安踏的消费者只有1%能在塑胶地板上打球，其他都是在水泥地上。安踏更关心的是，在水泥地上打球的孩子如何才能不扭脚。” 9)空间：有别于Facebook的社交模式 “一个大号的QQ秀” 黄钻与进阶式会员体系 QQ空间在获利模式上的创新也可谓独步天下，无其他公司可以比拟。据摩根士丹利的互联网研究报告显示，多年以来，亚洲互联网公司在虚拟商品的探索上一直领先于欧美同行 绿钻：与iTunes不同 在社交网络中，通过会员制的方式获利，是腾讯成功的秘密之一。 腾讯提供音乐服务是从2005年2月开始 QQ空间是用户在虚拟世界里的、独享的私人场所，如同一个家庭的客厅，当客人到访的时候，用音乐款待客人是一种最常见的礼貌。人们购买音乐的动机，是为了对特定的人表达情感。 腾讯以自己的方式成为唯一通过正版音乐获得收入的互联网公司。 在中国数字音乐从无序到有序的过程中，QQ音乐所开创的正版化战略及构建付费生态的种种行动，逐渐为全行业所接受和普及。 美国大学与中国网吧 “得网吧者得天下”，在很长一段时间里是一个从不被公开讨论的中国秘密。 高学历的美国大学生与“三低”（低年龄、低学历、低收入）的中国网吧人，让这两个国家的互联网世界隔洋相望。 马化腾与扎克伯格 “Facebook从来都没能够设计出最好的应用软件，但是，扎克伯格通过（成为）一个平台，为自身卸下一些负担，而不用再面面俱到。” 扎克伯格在开放中“失去的是锁链，得到的是整个世界” “以我们在美国所获得的经验来看待印度或中国，有一半是看不懂的，还有一半是错误的。” 10)金矿：“游戏之王”的诞生 腾讯以一个游戏为独立单元组建专门的工作室，成则报酬丰厚，败则拆散重构，形成了内部的赛马机制。 死于没有应对，没有继续冒险创新 《泡泡堂》与《QQ堂》之战 紧盯市场新热点，快速跟进优化，利用自己的流量优势实现整体替代。环节构想和运营思路 QQ宠物：母爱情结的宣泄。 这种人格化的代入及对之的灵活掌握，是腾讯公司最擅长的秘密武器。 锁定一个“真实的诉求点”，在用户体验上力争做到极致—从庞大的用户基数中抓取消费群—在形成一定数量的基础用户之后推出进阶式有偿商业服务—持续优化、尽力延长产品的生命周期—寻找新的诉求点。 《穿越火线》与《地下城与勇士》 经过数年磨砺，腾讯在用户热情的激发上越来越娴熟，也越来越让人难以抵抗。 与即时通信工具不同，网游用的忠诚度和依户对平台赖度很低，游戏一旦不好玩，他们立即掉头而去 11)广告：社交平台的逆袭 2005年8月，腾讯网再次改版，宣布从“青年的新闻门户”向“立志做最好的综合门户”转型，这意味这家专注于娱乐新闻和年轻人的网站将更多地关注主流社会。 “我们利用QQ终端实现了新闻的即时性和互动性，其他门户只能看着我们干着急。” “在虚拟世界中，人们访问互联网的路径可以产生无数个广告接触点，属性不同的数字接触点也可以被需求不同的广告拦截。” ”互联网将会给整合营销传播带来巨大变化。围绕单纯向外的传播系统，这种情况在互联网上将不复存在。这里，传播体系不是单纯向外的，而是互动的。信息不再由营销人员或信息传播人员所控制，而是由顾客所控制。顾客不再是传播的目标，而是与营销人员或信息传播人员处于同等地位；消费者也不再是企业说服的对象，而是企业聆听和响应的对象。” 广点通（现在叫腾讯社交广告）的模式也是把腾讯庞大的流量资源释放出来，给广告主一个自由配置和投放的权利。 区别于“门户广告”和“搜索广告”，广点通提出了“效果广告”这个全新的概念。 广点通根据用户属性和好友群体推荐并展示广告内容，访问同一界面的不同用户，看到的是为其量身定制的不同的广告，在增强广告人性化和交互式体验的同时，通过用户的社交属性和好友关系链进行影响力放大和辐射。 Part 3 巨头：2010-201612)用户：小马哥的产品哲学 “那个只看见鸟的孩子是好学生” 印度史诗神话《摩诃婆罗多》中关于专注的故事： 大师特洛那教学生射箭，到了林子中，问一学生：看见鸟没有？答，看见。又问：看见树林和我没有？答：都看见了。又问另一学生：看见鸟、树林和众人没有？答：我只看见鸟。特洛那令其射，中。特洛那说，那个只看见鸟的孩子是好学生。 “他就是一个邮件狂人” 马化腾自陈是“一个不善言辞的人”，他用以推动迭代进化的办法，就是亲自参与几乎所有的产品研发，然后用发邮件的方式下“指导棋”，他可以算得上是中国首屈一指的“邮件狂人”。 “成功的秘诀，在于把自己的脚放入他人的鞋子里，进而用他人的角度来考虑事物，服务就是这样的精神，站在客人的立场去看整个世界。” 腾讯的工程师：每两个小时轮流监测、回复网上出现的用户意见。 马化腾的推动下，腾讯形成了一个“10/100/1000法则”：产品经理每个月必须做10个用户调查，关注100个用户博客，收集反馈1000个用户体验。 瞬间变成“白痴级用户”的速度 马化腾关于用户体验：“互联网化的产品不像传统软件开发，一下子刻光盘就推出。我们永远是Beta版本，要快速地去升级，可能每两三天一个版本，这就要不断地改动，而且不断地听论坛、用户的反馈，然后决定你后面的方向。因此，产品经理要把自己当成一个挑剔的用户。” 马化腾的第一次产品演讲 希望的产品经理是非常资深的，最好是由做过前端、后端开发的技术研发人员晋升而来。好的产品最好交到一个有技术能力、有经验的人员手上，这样会让大家更加放心。如果产品经理不合格，让很多兄弟陪着干，结果发现方向错误，这是非常浪费和挫伤团队士气的。 一个产品在没有口碑的时候，不要滥用平台。 在设计上我们应该坚持几点：——不强迫用户；——不为1%的需求骚扰99%的用户；——淡淡的美术，点到即止；——不能刻意地迎合低龄化。 在产品的总体构架及运营上，则可以采用下述的策略：——交互功能：“Don’t make me think！”（别让我思考！）——美术呈现：“尽可能简单。”——产品设计：“让功能存在于无形之中。”——运营要求：“不稳定会功亏一篑！”——总体要求：“快速，稳定，功能强，体验好！”——发现需求：勤看BBS和Blog。 大数据下的反馈体制 2005年开始，马化腾要求各条业务线的主管每天给他和张志东发送一封反映业务指标数字的邮件，内容包括：包月用户是多少？增加了多少？减少了多少？跟上周同日比，或者说是跟上个月同日比，分别升跌了多少？有什么异动？ 数字经营 为了解答用户体验的一个终极问题“用户到底需要什么”：Support产品交流平台 腾讯甚至把各个产品线上的用户体验人员，全部拎出来成立了一个公司级的部门——用户体验与研究部，从战略性的高度来建设，刚开始是十几个人，后来达到近百人的规模 “数据挖掘”才是腾讯最具门槛性质的技术 13)转折：3Q大战 企鹅帝国的“三宗罪” “一直在模仿从来不创新”“走自己的路让别人无路可走”“垄断平台拒绝开放” 毕竟商业模式你很难苛求去原创，因为本来就这么几种，关键看谁做得好。 舆论突袭：“狗日的”腾讯 “只要是一个领域前景看好，腾讯就肯定会伺机充当掠食者。它总是默默地布局、悄无声息地出现在你的背后；它总是在最恰当的时候出来搅局，让同业者心神不定。而一旦时机成熟，它就会毫不留情地划走自己的那块蛋糕，有时它甚至会成为终结者，霸占整个市场。” 宿敌的出现：从制毒者到杀毒者 正面冲突：电脑管家与隐私保护器 舆论攻防：技术的，还是道德的 “腾讯每一次重大升级都会选在节假日之前，这往往让对手措手不及。” 白热化：“扣扣保镖”与艰难的决定 尴尬的结局：“赢了官司，输了舆论” 人类的真实：事实真实、逻辑真实 互联网世界里的真实：事实真实、逻辑真实和情绪真实 相比较，周鸿祎的冒险取得了空前的商业成功，他赤身上扑，只要不被扼杀即是大胜，他对互联网舆论的超凡理解及掌控，更是前所未见。 14)开放：新的挑战与能力 一个行业发展得越快，它的商业模式就会越早达到极限，所以说，当下的成功抛物线经常是窄的尖峰状。——加里·哈默（美国商业战略大师），《管理的未来》 “打开未来之门” 英国历史学家汤因比在描述了人类众多文明的兴衰之后，提出过一个意味悠长的问题：对一次挑战做出了成功应战的创造性的少数人，需多长时间才能经过一种精神上的重生，使自己有资格应对下一次、再下一次的挑战？ 2010年11月11日晚间，马化腾通过内部邮件发布致全体员工的信中称：“过去，我们总在思考什么是对的。但是现在，我们要更多地想一想什么是能被认同的。” 战斗时全力以赴，战斗结束后，放下情绪和愤怒，继续前行！ “诊断腾讯”：十场神仙会 诊断会的主题由三个构成：关于公众责任与美誉度、行业的开放与垄断以及创新和山寨的难题 《21世纪商业评论》主编吴伯凡：“帝国的思维”，“如同蒙古帝国那样，疆域非常大，但管理半径不够大，可能膨胀得非常快，但由于管理半径的不对称，会在短时间遭遇严重危机，甚至在某一点上被彻底瓦解”。 开放能力：资本与流量 我们至少在三个方面有过纠结：第一，开放到底是以应用为主，还是以内容为主；第二，社交网络是否要开放广告资源，我们受到了来自品牌广告部门和搜索部门的压力；第三，开放是针对平台，还是针对上下游产业链。 “数字世界最根本的分歧是开放和封闭，而对一体化系统的本能热爱让乔布斯坚定地站在了封闭一边”—— 艾萨克森《史蒂夫·乔布斯传》 微博：移动时代的新对手 社交网络拥有“赢者通吃”和“环境通吃”的团体化特征 “挑战者必须找到不同于领先者的新竞争方式以取得成功” 15)微信：移动互联时代的“站台票” 张小龙与雷军赛跑 米聊：2010年12月10日，小米仅仅用了1个月的开发时间，发布了中国第一款模仿kik的产品，先是Android版，继而是iPhone版。 微信：2011年1月21日，与米聊不同的是，张小龙先发布了iPhone版，然后才是Android版和Symbian版。 微信开屏页：一个孤独的身影站立在地平线上，面对蓝色星球，仿佛在期待来自宇宙同类的呼唤。 微信1.2版迅速转向图片分享。在张小龙看来，移动互联网时代必然是一个图片为王的时代，人们在有限的载体上没有耐心进行深度阅读，而对图片的消费量会达到一个空前的程度。 5月，张小龙的微信新版本也及时地增加了语音聊天功能，用户猛然间出现井喷，用户日增数从一两万提高到了五六万。 “如果你说我是错的，你要证明你是对的。” 7月，微信推出“查看附近的人”功能，用张小龙的话说，“这个功能彻底扭转了战局”。 为什么是张小龙？ 张小龙：“产品经理永远都应该是文艺青年，而非理性青年” “在某一场景下的用户体验是一款互联网产品能否成功的关键，而不是其他。” 张小龙对产品经理的素养提出了极具个人色彩的解读： —— 敏锐感知潮流变化。移动互联网产品会从相对匮乏时代进入相对富足时代，用户可以选择的产品会随时日流逝而日渐增加。产品经理若是沉溺于各种新鲜玩意儿之中，追逐新奇，很可能错过真实的时代潮流，无法把握人群的真实需求。 —— 用户感知需求。移动互联网的最大特点是变化极快，传统的分析用户、调研市场、制定产品三年规划，在新的时代里已经落伍。人类群落本身也在迁移演变，产品经理更应该依靠直觉和感性，而非图表和分析，来把握用户需求。 —— 海量的实践。尽管移动互联网方兴未艾，目前没有任何人可以自称是领域内的专家，但是，这并不意味着可以寄希望于天降天才。《异类》中提出的一万小时定律，同样适用于产品经理。他们需要开展超过千次的产品实践，才能称得上是了解产品设计，拥有解决问题的能力。 —— 博而不专的积累。美术、音乐、阅读、摄影、旅游等等文艺行为貌似不能直接转化为生产力，但是合格的产品经理需要广博的知识储备，以此才能了解和认识大数量的人群，理解时代的审美，让自己的所思所感符合普通用户的思维范式。以此为基础，设计的产品才不会脱离人群。 —— 负责的态度。拥有合适的方法论和合适的素养，成功的产品经理还应该有对自己和产品负责的态度，唯有如此，产品经理才能足够偏执，清楚地知道自己究竟要做什么，抵挡住来自上级和绩效考核的压力，按照自己的意志不变形、不妥协地执行产品策划。 16)年轻：手机QQ的自我变革 “并非补充，而可能是颠覆” “QQ马上要进入第15个年头了，有8.5亿活跃用户，但互联网已进入下半场竞争，移动互联网并非PC端的补充，而可能是颠覆。QQ如果不自我变革，适应‘随时随地’的特征，就会被用户抛弃。” “近六成QQ用户是90后” QQ新打法一：娱乐化社交 EQ计划”（Entertainment Quotient Plan） 很多年前Linus的自传的书名就叫：Just for fun，中文版只是为了好玩. 一切公众话语都日渐以娱乐的方式出现，并成为一种文化精神。一切文化内容都心甘情愿地成为娱乐的附庸，而且毫无怨言，甚至无声无息，其结果是我们成了一个娱乐至死的物种。—— 尼尔·波兹曼《娱乐至死》 QQ新打法二：场景化通信 在教育、游戏、办公、娱乐等重要垂直领域，QQ都进行了部署。 17)互联网+：泛娱乐的环型生态 腾讯只做两件事，连接与内容，就这么简单。——马化腾 从《洛克王国》开始 从动漫撕开一个口子 50亿元收购盛大文学 盛大的战略如陈天桥的个性，数度迟疑而摇摆。 四环合璧，内容生态 目前腾讯互娱旗下总共具备了腾讯游戏、腾讯动漫、腾讯文学和腾讯影业四大平台，从而形成了一个完整的泛娱乐生态布局。 18)失控：互联网越来越像大自然 技术的力量正以指数级的速度迅速向外扩充。人类正处于加速变化的浪尖上，这超过了我们历史的任何时刻。—— 库茨维尔《奇点临近》 我最终发现，想要得到和生命真正类似的行为，不是设法创造出真正复杂的生物，而是给简单的生物提供一个极其丰饶的变异环境。—— 凯文·凯利《失控》 “谁将会成为腾讯未来的敌人？” “我非常喜欢中国，因为我坚信未来就在这儿，世界的未来就在中国”。 —— 凯文·凯利 “也许你们中国老祖宗的智慧可以帮到所有的互联网公司。” “在互联网世界，即将消灭你的那个人，从来不会出现在一份既定的名单中” 灰度法则的七个维度 要求设计者和开发者有很强的用户感。一定要一边做自己产品的忠实用户，一边把自己的触角伸到其他用户当中，去感受他们真实的声音。 沉静型领导团队 首席探索官（CXO） 腾讯需要把目光从游戏中转移出去，去看基因学、太空学、机器人和人工智能 领导形态上的沉静与行业扩张上的凶猛，以非常戏剧化的方式同时呈现在他的身上 “连接一切”与“互联网+” 在移动互联网年代，手机成为人的一个电子器官的延伸这个特征越来越明显 马化腾进而提出“互联网+”，“‘+’是什么？传统行业的各行各业……互联网已经在‘+’通信、媒体、娱乐、零售、金融等等，互联网是一个工具。 腾讯的公益与社会责任 “微微的晨光还照不亮太远的路” 这是一个善于控制自己的好奇心的人，而同时，他又能让自己的兴趣在无尽的可能性里得到延伸，在这个意义上，他还是那个喜欢趴在望远镜前眺望无垠星空的南方科技青年。 美国式优势与中国式优势的生动展现：美国人发明了推动进步的技术，而中国人找到了盈利的方法论。就更广泛的意义而言，中国互联网人对其他领域——制造业、零售服务业、传媒业以及金融业的渗透更加深刻，而这才刚刚开始。 最后这篇记录文章大约有一万字，花了好长时间，不过学习了很多东西。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>互联网</tag>
        <tag>腾讯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《混乱》—— 机械化中需要一点点混乱]]></title>
    <url>%2F2018%2F%E6%B7%B7%E4%B9%B1.html</url>
    <content type="text"><![CDATA[提到混乱，就想到两个影视剧中的台词第一个是权力的游戏：混乱是阶梯(Chaos is a ladder)S03E06，约48min处 小指头和瓦力斯的对话原文： 1234567891011121314151617181920212223242526272829303132The realm?王国？Do you know what the realm is?你懂王国是什么吗？It&apos;s the thousand blades of Aegon&apos;s enemies.只不过是依耿敌人的一千把剑融成的王座。A story we agree to tell each other over and over只不过是一个我们反反复复讲述给别人的故事till we forget that it&apos;s a lie.直到遗忘这是个谎言But what do we have left once we abandon the lie?戳穿了谎言 我们还剩什么呢？Chaos.混乱。A gaping pit waiting to swallow us all.血口大张的深渊 等待吞噬一切。Chaos isn&apos;t a pit. Chaos is a ladder.混乱不是深渊。混乱是阶梯。Many who try to climb it fail and never get to try again.The fall breaks them.很多人想往上爬 却失败了，且永无机会再试。失败毁了他们。And some are given a chance to climb,But they refuse.有人本有机会攀爬，但他们拒绝了。They cling to the realm or the gods or love.他们守着王国不放，守着诸神，守着爱情。Illusions.尽皆幻想。Only the ladder is real.唯有阶梯才是真实的。The climb is all there is.努力攀爬才是一切。 来自知乎秦小铥的回答 第二个是蝙蝠侠：黑暗骑士中的小丑🤡名言： 混乱即公平 chaos vs messy上面两个影视剧中都是使用chaos，而本书的混乱是messy，这两个词有一点区别。 messy 凌乱的，散乱的; 肮脏的，污秽的; 复杂的，麻烦的，难以应付的; chaos 强调的是更大的混乱和无序。来源于希腊神话，卡俄斯（英语：Chaos；希腊语：Χάος）是希腊神话中的混沌之神，一切世界及概念的开始。 作者和本书概要蒂姆·哈福德，经济学家出身，《金融时报》的专栏作家，之前写过一本经济学科普书《卧底经济学》。 英文书名 《Messy: The Power of Disorder to Transform Our Lives》，直译过来就是《混乱：改变我们生活的无序力量》，中文版翻译成了《混乱：如何成为失控时代的掌控者》 。 内容一、做事不仅需要专注力、意志力和刻意练习，更需要灵感和运气，而混乱可以带来灵感和运气二、团队凝聚力有时候会损害团队的工作能力把人组织在一起工作，其实有两种类型的队伍。第一种队伍讲团结，这种队伍比较适合那些目标明确，工作方法也明确的工作，所有人都知道应该做什么和怎么做，齐心合力当然是最好的。第二种队伍不讲团结，讲多样性，这种队伍适合没有固定套路、要求集思广益、讲究创造性的工作。 三、混乱代表了拥抱自由独立、拒绝循规蹈矩的人性整洁的背后是循规蹈矩，是把人机械化。混乱的背后是自由独立，是让人更像人。作为一个人，我们身处在这个充满机械化、标准化、规则化的现代世界之中，你对自己的生活方式，有一个什么样的选择，其实决定了你是个什么人。 总的来说，《混乱》想告诉我们生活中不那么循规蹈矩，学会拥抱混乱，甚至主动去制造混乱，更能激发出创造力，当你不去努力计划成功的时候，你可能离成功更近。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>混乱</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的高阶函数：sorted, map, reduce, forEach, flatMap, filter]]></title>
    <url>%2F2018%2Fswift-higher-order-function.html</url>
    <content type="text"><![CDATA[高阶函数（Higher-order function） 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数： 接受一个或多个函数作为输入 输出一个函数 函数式编程中，高阶函数比较常见了。 注：$0, $1, $2… 表示闭包第一个参数，第二个参数，第三个参数…。 详细可参考以撸代码的形式学习Swift-7：闭包(Closure) 1 sorted 根据给定的条件（一个用于比较的闭包）来对数组进行排序。 函数原型： 1public func sorted(by areInIncreasingOrder: (Element, Element) throws -&gt; Bool) rethrows -&gt; [Element] 12345let numbers = [1, 4, 2, 3]let res = numbers.sorted &#123; $0 &lt; $1&#125;print(res.description) 2 map 返回一个包含对原数组每个元素进行给定闭包处理后元素的数组。（也就是每个元素进行相同处理） 函数原型： 1public func map&lt;T&gt;(_ transform: (Element) throws -&gt; T) rethrows -&gt; [T] 12345let arr = [1, 2, 4]let brr = arr.map &#123; "No." + String($0)&#125;// brr = ["No.1", "No.2", "No.4"] 3 reduce Returns the result of combining the elements of the sequence using the given closure.（ 返回使用给定闭包组合序列元素的结果。） 函数原型： 1public func reduce&lt;Result&gt;(_ initialResult: Result, _ nextPartialResult: (Result, Element) throws -&gt; Result) rethrows -&gt; Result 1234567891011121314151617let crr = arr.reduce(0) &#123; (prevSum: Int, element: Int) in return prevSum + element&#125; // crr = 7let drr = arr.reduce("") &#123; if $0 == "" &#123; return String($1) &#125; else &#123; return $0 + " " + String($1) &#125;&#125;print(drr) // drr = "1 2 4"let res2 = [3,5,8,9].reduce(2) &#123; (prevSum: Int, element: Int) in return prevSum + element&#125;print(res2) // 27。 2+3+5+8+9 = 27 4 forEach Calls the given closure on each element in the sequence in the same order as a for-in loop.(与for-in类似) 函数原型： 1public func forEach(_ body: (Element) throws -&gt; Void) rethrows 123["Swift","OC","iOS","macOS"].forEach &#123; print($0)&#125; 5 flatMap Returns an array containing the concatenated results of calling the given transformation with each element of this sequence.（返回一个数组，其中包含使用此序列的每个元素调用给定转换的连接结果。） 函数原型： 1public func flatMap(_ transform: (Element) throws -&gt; String?) rethrows -&gt; [String] 123let collections = [[5, 2, 7], [4, 8], [9, 1, 3]]let flat = collections.flatMap &#123; $0 &#125;// [5, 2, 7, 4, 8, 9, 1, 3] flatMap和map的区别是，对二维数组时flatMap有个降维处理，对于一位数组，两者没有明显区别1234567891011let numbersCompound = [[1,2,3],[4,5,6]]let mapped = numbersCompound.map &#123; $0.map&#123; "\($0)-map" &#125; &#125;print(mapped) // [["1-map", "2-map", "3-map"], ["4-map", "5-map", "6-map"]]let flatMapped = numbersCompound.flatMap &#123; $0.map&#123; "\($0)-flatMap" &#125; &#125;print(flatMapped) // ["1-flatMap", "2-flatMap", "3-flatMap", "4-flatMap", "5-flatMap", "6-flatMap"]let numbers2 = [1, 2, 3, 4]let mapres = numbers2.map &#123; Array(repeating: $0, count: $0) &#125;// [[1], [2, 2], [3, 3, 3], [4, 4, 4, 4]]let flatMapres = numbers2.flatMap &#123; Array(repeating: $0, count: $0) &#125;// [1, 2, 2, 3, 3, 3, 4, 4, 4, 4] 注：新版Swift使用了Sequence.compactMap(_:)来替代Sequence.flatMap，详细 6 filter Returns an array containing, in order, the elements of the sequence that satisfy the given predicate.（返回一个数组，该数组按顺序包含满足给定闭包的序列元素。） 函数原型： 1public func filter(_ isIncluded: (Element) throws -&gt; Bool) rethrows -&gt; [Element] 1234let err = arr.filter &#123; $0 % 2 == 0&#125;// err = [2, 4] playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-二叉树]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E4%BA%8C%E5%8F%89%E6%A0%91.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Binary Tree 二叉树是一种树，其中每个节点具有0,1或2个子节点。 这是一个二叉树： 子节点通常称为 左 子节点 和 右 子节点。 如果节点没有任何子节点，则称为 叶子节点。 根 是树顶部的节点（程序员习惯树颠倒了😀）。 节点通常会有一个返回其父节点的连接，但这不是绝对必要的。 二叉树通常用作二叉搜索树。 在这种情况下，节点必须按特定顺序排列（左侧是较小的值，右侧是较大的值）。 但这不是所有二叉树的要求。 例如，这是一个二叉树，表示一系列算术运算，(5 * (a - 10)) + (-4 * (3 / b))： 代码以下是在Swift中实现通用二叉树的方法： 1234public indirect enum BinaryTree&lt;T&gt; &#123; case node(BinaryTree&lt;T&gt;, T, BinaryTree&lt;T&gt;) case empty&#125; 如何使用它的一个例子，让我们构建上面算术运算树： 12345678910111213141516171819// leaf nodeslet node5 = BinaryTree.node(.empty, "5", .empty)let nodeA = BinaryTree.node(.empty, "a", .empty)let node10 = BinaryTree.node(.empty, "10", .empty)let node4 = BinaryTree.node(.empty, "4", .empty)let node3 = BinaryTree.node(.empty, "3", .empty)let nodeB = BinaryTree.node(.empty, "b", .empty)// intermediate nodes on the leftlet Aminus10 = BinaryTree.node(nodeA, "-", node10)let timesLeft = BinaryTree.node(node5, "*", Aminus10)// intermediate nodes on the rightlet minus4 = BinaryTree.node(.empty, "-", node4)let divide3andB = BinaryTree.node(node3, "/", nodeB)let timesRight = BinaryTree.node(minus4, "*", divide3andB)// root nodelet tree = BinaryTree.node(timesLeft, "+", timesRight) 您需要反向构建树，从叶子节点开始，一直到顶部。 添加description属性以便打印树，这会很有用的： 12345678910extension BinaryTree: CustomStringConvertible &#123; public var description: String &#123; switch self &#123; case let .node(left, value, right): return "value: \(value), left = [\(left.description)], right = [\(right.description)]" case .empty: return "" &#125; &#125;&#125; 如果你 print(tree) 你应该看到这样的东西： value: +, left = [value: *, left = [value: 5, left = [], right = []], right = [value: -, left = [value: a, left = [], right = []], right = [value: 10, left = [], right = []]]], right = [value: *, left = [value: -, left = [], right = [value: 4, left = [], right = []]], right = [value: /, left = [value: 3, left = [], right = []], right = [value: b, left = [], right = []]]] 通过一点想象力，您可以看到树形结构。 ;-)如果你缩进它会清晰的看到： value: +, left = [value: *, left = [value: 5, left = [], right = []], right = [value: -, left = [value: a, left = [], right = []], right = [value: 10, left = [], right = []]]], right = [value: *, left = [value: -, left = [], right = [value: 4, left = [], right = []]], right = [value: /, left = [value: 3, left = [], right = []], right = [value: b, left = [], right = []]]] 另一个有用的属性是计算树中的节点数： 12345678public var count: Int &#123; switch self &#123; case let .node(left, _, right): return left.count + 1 + right.count case .empty: return 0 &#125;&#125; 对于示例的树，tree.count应该是12。 您经常需要对树进行的操作遍历它们，即以某种顺序查看所有节点。 遍历二叉树有三种方法： In-order（或深度优先）： 首先查看节点的左子节点，然后查看节点本身，最后查看其右子节点。 Pre-order： 首先查看节点，然后查看其左右子节点。 Post-order： 首先查看左右子节点最后处理节点本身。 以下是您实现的方法： 1234567891011121314151617181920212223public func traverseInOrder(process: (T) -&gt; Void) &#123; if case let .node(left, value, right) = self &#123; left.traverseInOrder(process: process) process(value) right.traverseInOrder(process: process) &#125;&#125;public func traversePreOrder(process: (T) -&gt; Void) &#123; if case let .node(left, value, right) = self &#123; process(value) left.traversePreOrder(process: process) right.traversePreOrder(process: process) &#125;&#125;public func traversePostOrder(process: (T) -&gt; Void) &#123; if case let .node(left, value, right) = self &#123; left.traversePostOrder(process: process) right.traversePostOrder(process: process) process(value) &#125;&#125; 这些函数会被递归调用，在使用树结构时很常见。 例如，如果您按 Post-order 遍历算术运算树，您将按以下顺序查看值： 1234567891011125a10-*4-3b/*+ 叶子节点首先出现。 根节点最后出现。 您可以使用堆栈计算机来评估这些表达式，类似于以下伪代码： 123456789101112tree.traversePostOrder &#123; s in switch s &#123; case this is a numeric literal, such as 5: push it onto the stack case this is a variable name, such as a: look up the value of a and push it onto the stack case this is an operator, such as *: pop the two top-most items off the stack, multiply them, and push the result back onto the stack &#125; the result is in the top-most item on the stack&#125; 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-查找最大／最小值]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%9F%A5%E6%89%BE%E6%9C%80%E5%A4%A7%EF%BC%8F%E6%9C%80%E5%B0%8F%E5%80%BC.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Select Minimum Maximum 目标：查找未排序数组中的最大/最小值。 最大值或最小值我们有一个通用对象数组，我们迭代所有对象，跟踪遇到的最小/最大元素。 例子假设我们想在未排序列表[8,3,9,4,6]中找到最大值。 选择第一个数字8，并将其存储作为目前为止的最大元素。 从列表中选择下一个数字3，并将其与当前最大值进行比较。 3小于8所以最大值8不会改变。 从列表中选择下一个数字9，并将其与当前最大值进行比较。 9大于8所以我们存储9作为最大值。 重复此过程，直到处理完列表中的所有元素。 代码在Swift中的一个简单实现： 123456789101112131415161718192021func minimum&lt;T: Comparable&gt;(_ array: [T]) -&gt; T? &#123; guard var minimum = array.first else &#123; return nil &#125; for element in array.dropFirst() &#123; minimum = element &lt; minimum ? element : minimum &#125; return minimum&#125;func maximum&lt;T: Comparable&gt;(_ array: [T]) -&gt; T? &#123; guard var maximum = array.first else &#123; return nil &#125; for element in array.dropFirst() &#123; maximum = element &gt; maximum ? element : maximum &#125; return maximum&#125; 将代码放在 playground 测试： 123let array = [ 8, 3, 9, 4, 6 ]minimum(array) // This will return 3maximum(array) // This will return 9 Swift的标准库Swift库已经包含一个叫做SequenceType的扩展，它可返回序列中的最小/最大元素。 123let array = [ 8, 3, 9, 4, 6 ]array.minElement() // This will return 3array.maxElement() // This will return 9 1234let array = [ 8, 3, 9, 4, 6 ]//swift3array.min() // This will return 3array.max() // This will return 9 最大值和最小值要同时查找数组中包含的最大值和最小值，为了最小化比较次数，我们可以成对比较。 例子假设我们想要在未排序列表[8,3,9,6,4]中找到最小值和最大值。 选择第一个数字8，并将其存储为目前为止的最小和最大值。 因为我们有一个奇数项目，我们从列表中删除8，留下两队[3,9]和[6,4]。 从列表中选择下一对数字，[3,9]。 在这两个数字中，3是较小的数字，因此我们将3与当前最小值8进行比较，并将9与当前最大值8进行比较。 3小于8，所以新的最小值是3。 9大于8，所以新的最大值是9。 从列表中选择下一对数字，[6,4]。 这里，4是较小的一个，所以我们将4与当前最小3进行比较，并将6与当前最大9进行比较。 4大于3，所以最小值不会改变。 6小于9，因此最大值不会改变。 结果是最小值为3，最大值为9。 代码在Swift中的一个简单实现： 123456789101112131415161718192021222324252627282930func minimumMaximum&lt;T: Comparable&gt;(_ array: [T]) -&gt; (minimum: T, maximum: T)? &#123; guard var minimum = array.first else &#123; return nil &#125; var maximum = minimum // if 'array' has an odd number of items, let 'minimum' or 'maximum' deal with the leftover let start = array.count % 2 // 1 if odd, skipping the first element for i in stride(from: start, to: array.count, by: 2) &#123; let pair = (array[i], array[i+1]) if pair.0 &gt; pair.1 &#123; if pair.0 &gt; maximum &#123; maximum = pair.0 &#125; if pair.1 &lt; minimum &#123; minimum = pair.1 &#125; &#125; else &#123; if pair.1 &gt; maximum &#123; maximum = pair.1 &#125; if pair.0 &lt; minimum &#123; minimum = pair.0 &#125; &#125; &#125; return (minimum, maximum)&#125; 在playground测试： 123let result = minimumMaximum(array)!result.minimum // This will return 3result.maximum // This will return 9 通过成对挑选元素并将其最大值和最小值与当前的最小值和最大值进行比较，我们将每2个元素的比较次数减少到3次。 性能这些算法以O(n)运行。 将数组中的每个对象与当前的最小值/最大值进行比较，所花费的时间与数组长度成比例。 作者：Chris Pilcher翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>查找最大／最小值</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《科学是怎样败给迷信的》——迷信有时简直太可怕了]]></title>
    <url>%2F2018%2F%E7%A7%91%E5%AD%A6%E6%98%AF%E6%80%8E%E6%A0%B7%E8%B4%A5%E7%BB%99%E8%BF%B7%E4%BF%A1%E7%9A%84.html</url>
    <content type="text"><![CDATA[作者和本书概要约翰·伯纳姆是美国俄亥俄州立大学历史系教授，还曾经是美国医学史学会的主席，也是科学传播史方面的专家。他的主要研究领域包括美国医学史、科学史和社会史，在历史学、医学和科学领域的许多重要期刊上都发表过文章，还出版了十余本科学史著作。 《科学是怎样败给迷信的：美国的科学与卫生普及》 研究美国从1830年起的科学普及史，揭示了这样一个令人迷惑的现象：曾经作为一种积极、进步的文化力量的科学，在美国消费文化中，慢慢地为新伪装下的迷信和神秘主义的复活让出了一条通道，最终导致科学在大众层面上被迷信击败。作者以19、20世纪美国的科学普及史为经，以公共卫生、心理学和自然科学三个领域内的普及活动为纬，向读者展现了一部美国的科学与迷信的“战斗史”。 面对迷信的泛滥，作者敏锐地指出，科学之所以败给迷信，就是因为科学知识的传播出现了问题。阅读这本书，不但能帮助我们分辨朋友圈中的各种谣言和迷信，还能启发我们建立起一种跨越自然科学和社会科学的大视角。🌰：各种养生保健的“小技巧”、各种占星相面风水手相的“小知识”、甚至转发求转运的锦鲤……数不胜数。 内容一、媒体的影响 媒体追求传播效果，削弱科学知识的严肃性 许多新闻记者对科学只是一知半解，为了要追求新闻的传播效应，科学发现的事实常常会被有意或者无意地夸大和歪曲。 真正有价值的科学发现被媒体冷落 新闻报道中的碎片化个例，违背科学精神 广告是科普“对手”，推波助澜迷信传播 广告似乎天然就是科学和科普的死对头，广告中不但经常会出现常识性错误，还可能出现各种夸大和虚假宣传，甚至出现反科学的言论。 在看到各种与科学有关的新闻时，必须保持一份应有的冷静和理性。 二、科学人退出了科普“科学人”，指的是那些从事科学前沿领域研究，同时也热心科学普及的科学家。 科普最早期（19世纪晚期），科学人不仅仅是“科学”的传播者，而且是一种理性文化的代言人 20世纪以来，各学科的发展越来越快，分支越来越细，一个科学家开始很难成为传统中那种“百科全书式”的学者，科学家用日常的语言“翻译”科学的语言越来越困难。 普通人与科学之间的鸿沟被新闻媒体所填补，报纸、广播、新闻和网络相继进入了千家万户，开始逐渐成为科普的重要媒介。 科学知识一旦变得严格起来，就会非常枯燥，大家喜欢听“薛定谔的猫”的故事，不代表大家真的就想要去学习怎么求解薛定谔方程，科普作家必须在“科学”和“普及”之间保持平衡。 三、大众丧失了怀疑精神在科学和迷信不断斗争的过程中，起初是科学精神的胜利，然而好景不长，由于科学本身能为我们提供了许多的确定性，大家对科学“太放心了”，导致理性的科学精神不断被稀释，再加上大家在不断接受着碎片化的知识，怀疑精神渐渐丧失，反而让迷信有了生存的空间。 传播 普及 稀释 碎片化 普通人接收到的是碎片化的科学进展和科学成果，导致人们开始把科学看成是一种新的“魔法”。 科学工作者们不能拒绝媒体，而是要去创作同时有科学性和传播性的科学作品。比如说美国的航空航天局，就非常善于利用社交网络传播真正的科学知识，每次有了重大的天文学发现，在新闻发布会之前，他们会在社交媒体上进行预热，勾起大家的兴趣，吸引更多的人来观看他们的发布会。也就是说，想要传播正确的科学知识，科学家们也要服从传播学的规律，才能让科学打败迷信。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读《睡眠革命》——睡眠质量直接影响生活和工作质量]]></title>
    <url>%2F2018%2F%E7%9D%A1%E7%9C%A0%E9%9D%A9%E5%91%BD.html</url>
    <content type="text"><![CDATA[作者和本书概要尼克·利特尔黑尔斯，英国睡眠协会的前任会长、英超曼联队御用的运动睡眠教练，曾经给 NBA、英国天空车队、英式橄榄球联合会、美国国家橄榄球联盟、英超足球联赛选手、奥运会英国代表队、皇家马德里足球俱乐部做睡眠指导。很多世界级顶级体育名将，比如足球名将大卫·贝克汉姆、瑞恩·吉格斯、保罗·斯科尔斯、尼基·巴特和内维尔兄弟等，都采纳了其睡眠方案，他们的工作和生活的质量都得到了提升。 《睡眠革命》的精髓是如何让睡眠变得高效，把睡眠当作一个工具，增强智力和体力。 睡眠占据了我们整个生命三分之一左右的时间，非常有必要认真对待。 内容一、如何打造一个合适的睡眠环境 褪黑素是人体的一种激素，能够帮助人体进入睡眠。正常来说，夜间人体会分泌比白天多5-10倍的褪黑素，但因为现代生活的各种光线的影响，会让褪黑素的分泌减少，久而久之就影响睡眠。 胎儿睡姿：侧向你的身体相对不太重要的一侧，就是你平常习惯使用相对比较少的一边。因为这一边相对来说没那么敏感。 合适的床垫： 从你的背面、把你整个人都拍进去，然后观察照片，如果你的头部、颈部和脊柱连成了一条直线，就说明这个床垫是适合你的 选择一个闹钟（秒针走动没有声音）或者模拟日出唤醒灯 二、R90睡眠方案 目前普通认为的“8小时睡眠最健康”，可能没那么科学。不同的人、不同成长阶段，睡眠时间都会有所不同。作者提出的R90睡眠方案，就是把睡眠时间分隔成90分钟一个周期、每晚需要4-5个周期，，从起床时间点倒推算出晚上入睡的时间点。通过尝试来找到合适自己的睡眠时间，掌控自己的睡眠就这么简单。 准备上床睡觉的那段时间和你刚醒来的一段时间，也是睡眠的一部分，是个修复的过程。 三、睡觉前后应该做什么样的准备来提升一整夜的睡眠质量 睡觉前做一些有助于入睡的事情，其实是很有必要的。 🌰 比如可以整理收拾一下东西。准备好明天上班或者出行的衣服，也可以做做家务，洗个碗，洗个衣服之类的。又比如，可以拿出纸和笔，列一份清单，把自己在想的事情都写下来，什么想法啊、担心和关心的事情啊，都写下来。在写的过程中，是非常放松和随意的。完成之后，就把这个清单放到钥匙边，或者其他第二天一定会带走的东西旁边，等明天再处理这些事情。这样做，也是给自己一个暗示，躺在床上的时候你很清楚地知道，自己已经把所有问题都处理好了，可以没有任何负担地休息了。 用鼻子呼吸，用口腔呼吸会大幅提高打鼾和睡眠呼吸暂停症的发生率。 怎么知道自己睡觉时是用鼻子还是嘴呼吸呢？留意一下，自己早上醒来，如果觉得口干舌燥，就说明你夜里是用嘴呼吸的；如果口腔还是湿润的，就说明是用鼻子呼吸的。 解决用鼻子呼吸的问题。在临睡前，贴上鼻贴来扩张鼻腔通道，然后用轻薄、低过敏性的医用胶带封上自己的嘴巴，让自己慢慢习惯在夜里用鼻子呼吸。 睡醒的第一件事不要看手机 睡眠占了一个人一生三分之一的时间，通过清醒的时间去掌控它，那一天24小时都是有价值的。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-选择排序]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Selection Sort 目标：将数组从低到高（或从高到低）排序。 您将获得一系列需要按正确顺序排列的数字。 选择排序算法将数组分为两部分：数组的开头是排序的，数组的其余部分是仍然需要排序的数字。 [ ...sorted numbers... | ...unsorted numbers... ] 这类似于插入排序，但区别在于如何将新数字添加到已排序部分。 它的工作原理如下： 找到数组中的最小数字。 从索引0开始，遍历数组中的所有数字，并追踪最小数字的位置。 使用索引0处的数字交换最小数字。现在，已排序部分仅包含索引0处的数字。 转到索引1处。 找到数组其余部分中的最小数字。 从索引1开始查看。再次循环直到数组结束并追踪最小数字。 使用索引1处的数字交换最小数字。现在，已排序部分包含两个数字，索引0和索引1。 转到索引2处。 从索引2开始，找到数组其余部分中的最小数字，并将其与索引2处的数字交换。现在，数组从索引0到2已排序; 此范围包含数组中的三个最小数字。 并继续，直到没有数字需要排序。 这种排序方式之所以被称为“选择”排序，是因为在每个步骤中，都是在数组的其余部分里搜索选择下一个最小数字。 例子假设要排序的数字是[5,8,3,4,6]。 用|符号表示数组的已排序部分的结束位置(讲述插入排序时也是如此表示的)。 最初，排序部分为空： [| 5, 8, 3, 4, 6 ] 现在我们找到数组中的最小数字。 从|栏开始向右扫描数组，找到数字3。 要将此数字放入已排序的位置，将它与|旁边的数字5交换（然后把|向右移动一位）： [ 3 | 8, 5, 4, 6 ] * * 排序部分现在是[3]，其余部分是[8,5,4,6]。 再一次，我们从|栏开始寻找最低的数字。 我们找到4并用8与之交换得到（同样把|向右移动一位）： [ 3, 4 | 5, 8, 6 ] * * 每一步，|栏都会向右移动一个位置。 我们再次查看数组的其余部分，找到5是最小数字。 没有必要与自己交换，只需|栏前进： [ 3, 4, 5 | 8, 6 ] * 重复此过程，直到数组都排序了。 请注意，|栏左侧的所有内容始终按排序顺序排列，并且始终包含数组中的最小数字。 最后，我们最终得到： [ 3, 4, 5, 6, 8 |] 选择排序是原地排序，因为所有内容都发生在同一个数组中而不使用额外的内存。您也可以将其实现为 稳定排序，以便相同的元素不会相互交换（请注意，下面给出的版本不稳定）。 代码这是Swift中选择排序的一个实现： 1234567891011121314151617181920func selectionSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; // 1 var a = array // 2 for x in 0 ..&lt; a.count - 1 &#123; // 3 var lowest = x for y in x + 1 ..&lt; a.count &#123; // 4 if a[y] &lt; a[lowest] &#123; lowest = y &#125; &#125; if x != lowest &#123; // 5 a.swapAt(x, lowest) &#125; &#125; return a&#125; 将此代码放在 playground 测试： 12let list = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]selectionSort(list) 代码逐步说明： 如果数组为空或仅包含单个元素，则无需排序。 生成数组的副本。 这是必要的，因为我们不能直接在Swift中修改array参数的内容。 与Swift的sort()函数一样，selectionSort()函数将返回排完序的原始数组拷贝。 函数内有两个循环。 外循环依次查看数组中的每个元素; 这就是向前移动|栏的原因。 内循环实现找到数组其余部分中的最小数字。 使用当前数组索引数字交换最小数字。 if判断是必要的，因为你不能在Swift中swap()同一个元素。 译注：Swift中的数组没有swap()方法，只有swapAt()方法，而且swapAt()交换同一个元素是没有问题的。这可能是Swift版本更新的问题。 总结：对于数组的每个元素，选择排序使用数组其余部分中的最小值交换位置。结果，数组从左到右排序。（你也可以从右到左进行，在这种情况下你总是寻找数组中最大的数字。试一试！） 注意： 外循环以索引a.count - 2结束。 最后一个元素将自动处于正确的位置，因为此时没有剩下其他较小的元素了。 源文件SelectionSort.swift是一个使用泛型的函数版本，因此您也可以使用它来对字符串和其他数据类型进行排序。 性能选择排序很容易理解，但执行速度慢 O(n^2)。它比插入排序更糟，但优于冒泡排序。查找数组其余部分中的最低元素很慢，特别是因为内部循环将重复执行。 堆排序使用与选择排序相同的原则，但使用了一种快速方法在数组的其余部分中查找最小值。 堆排序性能是 O(nlogn)。 扩展阅读选择排序的维基百科 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>选择排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-二维数组]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Array2D 在C和Objective-C中，您可以编写下面代码， int cookies[9][7]; 制作9x7网格的cookies。 这将创建一个包含63个元素的二维数组。 要在第3列和第6行找到cookie，您可以写： myCookie = cookies[3][6]; 这段代码在Swift中不能成立的。 要在Swift中创建一个多维数组，您可以编写： 12345678var cookies = [[Int]]()for _ in 1...9 &#123; var row = [Int]() for _ in 1...7 &#123; row.append(0) &#125; cookies.append(row)&#125; 然后，要查找cookie，您可以写： 1let myCookie = cookies[3][6] 您还可以使用一行代码中创建上面的数组： 1var cookies = [[Int]](repeating: [Int](repeating: 0, count: 7), count: 9) 这看起来很复杂，但您可以使用辅助函数简化它： 123func dim&lt;T&gt;(_ count: Int, _ value: T) -&gt; [T] &#123; return [T](repeating: value, count: count)&#125; 译注：这边的dim，应该是dimension（维度）的缩写。 然后，你可以这样创建数组： 1var cookies = dim(9, dim(7, 0)) Swift推断数组的数据类型必须是Int，因为您指定了0作为数组元素的默认值。 要使用字符串数组，您可以编写： 1var cookies = dim(9, dim(7, "yum")) dim()函数可以更容易地创建更多维度的数组： 1var threeDimensions = dim(2, dim(3, dim(4, 0))) 以这种方式使用多维数组或多个嵌套数组的缺点是无法跟踪什么维度代表什么。 然而，您可以创建自己的类型，其作用类似于二维数组，使用起来更方便： 123456789101112131415161718192021222324public struct Array2D&lt;T&gt; &#123; public let columns: Int public let rows: Int fileprivate var array: [T] public init(columns: Int, rows: Int, initialValue: T) &#123; self.columns = columns self.rows = rows array = .init(repeating: initialValue, count: rows*columns) &#125; public subscript(column: Int, row: Int) -&gt; T &#123; get &#123; precondition(column &lt; columns, "Column \(column) Index is out of range. Array&lt;T&gt;(columns: \(columns), rows:\(rows))") precondition(row &lt; rows, "Row \(row) Index is out of range. Array&lt;T&gt;(columns: \(columns), rows:\(rows))") return array[row*columns + column] &#125; set &#123; precondition(column &lt; columns, "Column \(column) Index is out of range. Array&lt;T&gt;(columns: \(columns), rows:\(rows))") precondition(row &lt; rows, "Row \(row) Index is out of range. Array&lt;T&gt;(columns: \(columns), rows:\(rows))") array[row*columns + column] = newValue &#125; &#125;&#125; 译注：precondition(_:_:file:line:)函数类似assert，满足条件会造成程序的提前终止并抛出错误信息，详细查看官方文档。此处有来表示当下标超过范围的提示，效果如下： Array2D是一个泛型，因此能够支持所有类型对象，而不是只能是数字 创建Array2D示例代码： 1var cookies = Array2D(columns: 9, rows: 7, initialValue: 0) 通过使用下标函数，您可以从数组中检索一个对象： 1let myCookie = cookies[column, row] 或者设置对象： 1cookies[column, row] = newCookie 在内部，Array2D使用单个一维数组来存储数据。 该数组中对象的索引由(row x numberOfColumns) + column给出，但作为Array2D的用户，您只需要考虑column和row，具体事件将 由Array2D完成。 这是将基本类型包装成包装类或结构中的优点。 作者： Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>二维数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-树]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%A0%91.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Tree 这个话题已经有个辅导文章 树表示对象之间的层次关系。 这是一个树的结构： 树由节点组成，这些节点彼此连接。 节点可以连接到他们的子节点，也可以连接到他们的父节点。 子节点是给定节点下的节点; 父节点是上面的节点。 节点始终只有一个父节点，但可以有多个子节点。 没有父节点的节点是 root 节点。 没有子节点的节点是 leaf 节点。 树中的指针不能形成循环。 这不是树： 这种结构称为图。 树实际上是一种非常简单的图形形式。 （类似地，链表是树的简单版本。想一想！） 本文讨论通用树。 通用树对每个节点可能有多少个子节点或树中节点的顺序没有任何限制。 这是在Swift中的基本实现： 123456789101112131415public class TreeNode&lt;T&gt; &#123; public var value: T public weak var parent: TreeNode? public var children = [TreeNode&lt;T&gt;]() public init(value: T) &#123; self.value = value &#125; public func addChild(_ node: TreeNode&lt;T&gt;) &#123; children.append(node) node.parent = self &#125;&#125; 这描述了树中的单个节点。 它包含泛型类型T，对parent节点的引用，以及子节点数组。 添加description以便打印树： 123456789extension TreeNode: CustomStringConvertible &#123; public var description: String &#123; var s = "\(value)" if !children.isEmpty &#123; s += " &#123;" + children.map &#123; $0.description &#125;.joined(separator: ", ") + "&#125;" &#125; return s &#125;&#125; 在 playground 创建树： 1234567891011121314151617181920212223242526272829303132333435let tree = TreeNode&lt;String&gt;(value: "beverages")let hotNode = TreeNode&lt;String&gt;(value: "hot")let coldNode = TreeNode&lt;String&gt;(value: "cold")let teaNode = TreeNode&lt;String&gt;(value: "tea")let coffeeNode = TreeNode&lt;String&gt;(value: "coffee")let chocolateNode = TreeNode&lt;String&gt;(value: "cocoa")let blackTeaNode = TreeNode&lt;String&gt;(value: "black")let greenTeaNode = TreeNode&lt;String&gt;(value: "green")let chaiTeaNode = TreeNode&lt;String&gt;(value: "chai")let sodaNode = TreeNode&lt;String&gt;(value: "soda")let milkNode = TreeNode&lt;String&gt;(value: "milk")let gingerAleNode = TreeNode&lt;String&gt;(value: "ginger ale")let bitterLemonNode = TreeNode&lt;String&gt;(value: "bitter lemon")tree.addChild(hotNode)tree.addChild(coldNode)hotNode.addChild(teaNode)hotNode.addChild(coffeeNode)hotNode.addChild(chocolateNode)coldNode.addChild(sodaNode)coldNode.addChild(milkNode)teaNode.addChild(blackTeaNode)teaNode.addChild(greenTeaNode)teaNode.addChild(chaiTeaNode)sodaNode.addChild(gingerAleNode)sodaNode.addChild(bitterLemonNode) 如果你打印出tree的值，你会得到： beverages {hot {tea {black, green, chai}, coffee, cocoa}, cold {soda {ginger ale, bitter lemon}, milk}} 这对应于以下结构： beverages节点是根节点，因为它没有父节点。 叶子是黑色，绿色，柴，咖啡，可可，姜汁，苦柠檬，牛奶，因为它们没有任何子节点。 对于任何节点，您可以查看parent属性， 并按照自己的方式返回到根： 12teaNode.parent // this is the "hot" nodeteaNode.parent!.parent // this is the root 在谈论树时，我们经常使用以下定义： 树的高度。 这是根节点和最低叶子之间的连接数。 在我们的示例中，树的高度为3，因为从根到底部需要三次跳转。 节点的深度。 此节点与根节点之间的连接数。 例如，tea 的深度为2，因为需要两次跳跃才能到达根部。 （根本身的深度为0.） 构建树的方法有很多种。 例如，有时您根本不需要 parent 属性。 或者，您可能只需要为每个节点提供最多两个子节点 - 这样的树称为二叉树。 一种非常常见的树类型是二叉搜索树（或BST），它是二叉树的更严格版本，其中节点以特定方式排序以加速搜索。 我在这里展示的通用树非常适合描述分层数据，但它实际上取决于您的应用程序需要具备哪种额外功能。 下面是一个如何使用TreeNode类来确定树是否包含特定值的示例。 首先看一下节点自己的value属性，如果没有匹配，那么依次看看这个节点所有的子节点。 当然，这些子节点也是TreeNode，所以它们将递归地重复相同的过程：首先看看它们自己的value属性，然后看看它们的子节点。 它们的子节点也会再次做同样的事情，等等…递归和树齐头并进。 这是代码： 12345678910111213extension TreeNode where T: Equatable &#123; func search(_ value: T) -&gt; TreeNode? &#123; if value == self.value &#123; return self &#125; for child in children &#123; if let found = child.search(value) &#123; return found &#125; &#125; return nil &#125;&#125; 如何使用它的示例： 123tree.search("cocoa") // returns the "cocoa" nodetree.search("chai") // returns the "chai" nodetree.search("bubbly") // nil 也可以使用数组来描述树。 数组中的索引表示不同的节点，然后，创建不同节点之间的连接。 例如，如果我们有： 123450 = beverage 5 = cocoa 9 = green1 = hot 6 = soda 10 = chai2 = cold 7 = milk 11 = ginger ale3 = tea 8 = black 12 = bitter lemon4 = coffee 那么我们可以使用以下数组描述树： [ -1, 0, 0, 1, 1, 1, 2, 2, 3, 3, 3, 6, 6 ] 数组中的每个项的值都是指向其父节点的指针。索引3处的项tea，其值为1，因为其父项为hot。根节点指向-1，因为它没有父节点。您只能将这些树从一个节点遍历到根节点，而不是相反。 顺便说一句，有时您会看到使用术语 forest 的算法。 显而易见，这是给予单独树对象集合的名称。 有关此示例，请参阅 union-find。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>tree</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-统计出现次数]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E7%BB%9F%E8%AE%A1%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Count Occurrences 目标：计算某个值在数组中出现的次数。 显而易见的方法是从数组的开头直到结束的线性搜索，计算您遇到该值的次数。 这是一个 O(n) 算法。 但是，如果数组已经排过序的，则可以通过使用修改二分搜索来更快的完成这个任务，时间复杂度为O(logn)。 假设我们有以下数组： [ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ] 如果我们想知道值3出现的次数，我们可以进行常规二分搜索。 这可以获得四个3索引中的一个： [ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ] * * * * 但是，这仍然没有告诉你有多少其它的3。 要找到那些其它的3，你仍然需要在左边进行线性搜索，在右边进行线性搜索。 在大多数情况下，这将是足够快的，但在最坏的情况下 —— 当这个数组中除了之前的一个3之外就没有其它3了 —— 这样时间复杂度依然是O(n)。 一个诀窍是使用两个二分搜索，一个用于查找3开始（左边界）的位置，另一个用于查找3结束的位置（右边界）。 代码如下： 12345678910111213141516171819202122232425262728293031func countOccurrencesOfKey(_ key: Int, inArray a: [Int]) -&gt; Int &#123; func leftBoundary() -&gt; Int &#123; var low = 0 var high = a.count while low &lt; high &#123; let midIndex = low + (high - low)/2 if a[midIndex] &lt; key &#123; low = midIndex + 1 &#125; else &#123; high = midIndex &#125; &#125; return low &#125; func rightBoundary() -&gt; Int &#123; var low = 0 var high = a.count while low &lt; high &#123; let midIndex = low + (high - low)/2 if a[midIndex] &gt; key &#123; high = midIndex &#125; else &#123; low = midIndex + 1 &#125; &#125; return low &#125; return rightBoundary() - leftBoundary()&#125; 请注意，辅助函数leftBoundary()和rightBoundary()与二分搜索算法非常相似。最大的区别在于，当它们找到搜索键时，它们不会停止，而是继续前进。 要测试此算法，将代码复制到 playground，然后执行以下操作： 123let a = [ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ]countOccurrencesOfKey(3, inArray: a) // returns 4 请记住： 使用的数组，确保已经排序过！ 来看看这个例子的过程。 该数组是： [ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ] 为了找到左边界，我们从low = 0和high = 12开始。 第一个中间索引是6： [ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ] * 通过常规二分搜索，你现在就可以完成了，但是我们不只是查看是否出现了值3 —— 而是想要找到它第一次出现的位置。 由于该算法遵循与二分搜索相同的原理，我们现在忽略数组的右半部分并计算新的中间索引： [ 0, 1, 1, 3, 3, 3 | x, x, x, x, x, x ] * 我们再次找到了一个3，这是第一个。 但算法不知道，所以我们再次拆分数组： [ 0, 1, 1 | x, x, x | x, x, x, x, x, x ] * 还没完， 再次拆分，但这次使用右半部分： [ x, x | 1 | x, x, x | x, x, x, x, x, x ] * 数组不能再被拆分，这意味着左边界在索引3处。 现在让我们重新开始，尝试找到右边界。 这非常相似，所以我将向您展示不同的步骤： [ 0, 1, 1, 3, 3, 3, 3, 6, 8, 10, 11, 11 ] * [ x, x, x, x, x, x, x | 6, 8, 10, 11, 11 ] * [ x, x, x, x, x, x, x | 6, 8, | x, x, x ] * [ x, x, x, x, x, x, x | 6 | x | x, x, x ] * 右边界位于索引7处。两个边界之间的差异是7 - 3 = 4，因此数字3在此数组中出现四次。 每个二分搜索需要4个步骤，所以总共这个算法需要8个步骤。 在仅有12个项的数组上获得的收益不是很大，但是数组越大，该算法的效率就越高。 对于具有1,000,000个项目的排序数组，只需要2 x 20 = 40个步骤来计算任何特定值的出现次数。 顺便说一句，如果你要查找的值不在数组中，那么rightBoundary()和leftBoundary()返回相同的值，因此它们之间的差值为0。 这是一个如何修改基本二分搜索以解决其它算法问题的示例。 当然，它需要先对数组进行排序。 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>统计出现次数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-归并排序]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Merge Sort 这个主题已经有辅导文章 目标：将数组从低到高（或从高到低）排序 归并排序是1945年由John von Neumann发明的，是一种有效的算法，最佳、最差和平均时间复杂度都是O(n log n)。 归并排序算法使用分而治之方法，即将一个大问题分解为较小的问题并解决它们。 归并排序算法可分为 先拆分 和 后合并。 假设您需要按正确的顺序对长度为 n 的数组进行排序。 归并排序算法的工作原理如下： 将数字放在未排序的堆中。 将堆分成两部分。 那么现在就有两个未排序的数字堆。 继续分裂两个未排序的数字堆，直到你不能分裂为止。 最后，你将拥有 n 个堆，每堆中有一个数字。 通过顺序配对，开始 合并 堆。 在每次合并期间，将内容按排序顺序排列。 这很容易，因为每个单独的堆已经排序（译注：单个数字没有所谓的顺序，就是排好序的）。 例子拆分假设给你一个长度为n的未排序数组：[2,1,5,4,9]。 目标是不断拆分堆，直到你不能拆分为止。 首先，将数组分成两半：[2,1]和[5,4,9]。 你能继续拆分吗？ 是的你可以！ 专注于左边堆。 将[2,1]拆分为[2]和[1]。 你能继续拆分吗？ 不能了。检查右边的堆。 将[5,4,9]拆分为[5]和[4,9]。 不出所料，[5]不能再拆分了，但是[4,9]可以分成[4]和[9]。 拆分最终结果为：[2]`[1][5][4][9]`。 请注意，每个堆只包含一个元素。 合并您已经拆分了数组，您现在应该 合并并排序 拆分后的堆。 请记住，这个想法是解决许多小问题而不是一个大问题。 对于每次合并迭代，您必须关注将一堆与另一堆合并。 对于堆 [2] [1] [5] [4] [9]，第一次合并的结果是[1,2]和[4,5] 和[9]。 由于[9]的位置落单，所以在合并过程中没有堆与之合并了。 下一次将合并[1,2]和[4,5]。 结果[1,2,4,5]，再次由于[9]的位置落单不需要合并。 只剩下两堆[1,2,4,5]和[9]，合并后完成排序的数组为[1,2,4,5,9]。 自上而下的实施(递归法)归并排序的Swift实现： 1234567891011func mergeSort(_ array: [Int]) -&gt; [Int] &#123; guard array.count &gt; 1 else &#123; return array &#125; // 1 let middleIndex = array.count / 2 // 2 let leftArray = mergeSort(Array(array[0..&lt;middleIndex])) // 3 let rightArray = mergeSort(Array(array[middleIndex..&lt;array.count])) // 4 return merge(leftPile: leftArray, rightPile: rightArray) // 5&#125; 代码的逐步说明： 如果数组为空或包含单个元素，则无法将其拆分为更小的部分，返回数组就行。 找到中间索引。 使用上一步中的中间索引，递归地分割数组的左侧。 此外，递归地分割数组的右侧。 最后，将所有值合并在一起，确保它始终排序。 这儿是合并的算法： 12345678910111213141516171819202122232425262728293031323334353637func merge(leftPile: [Int], rightPile: [Int]) -&gt; [Int] &#123; // 1 var leftIndex = 0 var rightIndex = 0 // 2 var orderedPile = [Int]() // 3 while leftIndex &lt; leftPile.count &amp;&amp; rightIndex &lt; rightPile.count &#123; if leftPile[leftIndex] &lt; rightPile[rightIndex] &#123; orderedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; else if leftPile[leftIndex] &gt; rightPile[rightIndex] &#123; orderedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; else &#123; orderedPile.append(leftPile[leftIndex]) leftIndex += 1 orderedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; &#125; // 4 while leftIndex &lt; leftPile.count &#123; orderedPile.append(leftPile[leftIndex]) leftIndex += 1 &#125; while rightIndex &lt; rightPile.count &#123; orderedPile.append(rightPile[rightIndex]) rightIndex += 1 &#125; return orderedPile&#125; 这种方法可能看起来很可怕，但它非常简单： 在合并时，您需要两个索引来跟踪两个数组的进度。 这是合并后的数组。 它现在是空的，但是你将在下面的步骤中通过添加其他数组中的元素构建它。 这个while循环将比较左侧和右侧的元素，并将它们添加到orderedPile，同时确保结果保持有序。 如果前一个while循环完成，则意味着leftPile或rightPile中的一个的内容已经完全合并到orderedPile中。此时，您不再需要进行比较。只需依次添加剩下一个数组的其余内容到orderedPile。 merge()函数如何工作的例子。假设我们有以两个个堆：leftPile = [1,7,8]和rightPile = [3,6,9]。 请注意，这两个堆都已单独排序 – 合并排序总是如此的。 下面的步骤就将它们合并为一个更大的排好序的堆： 123leftPile rightPile orderedPile[ 1, 7, 8 ] [ 3, 6, 9 ] [ ] l r 左侧索引（此处表示为l）指向左侧堆的第一个项目1。 右则索引r指向3。 因此，我们添加到orderedPile的第一项是1。 我们还将左侧索引l移动到下一个项。 123leftPile rightPile orderedPile[ 1, 7, 8 ] [ 3, 6, 9 ] [ 1 ] --&gt;l r 现在l指向7但是r仍然处于3。 我们将最小的项3添加到有序堆中。 现在的情况是： 123leftPile rightPile orderedPile[ 1, 7, 8 ] [ 3, 6, 9 ] [ 1, 3 ] l --&gt;r 重复上面的过程。 在每一步中，我们从leftPile或rightPile中选择最小的项，并将该项添加到orderedPile中： 1234567891011leftPile rightPile orderedPile[ 1, 7, 8 ] [ 3, 6, 9 ] [ 1, 3, 6 ] l --&gt;rleftPile rightPile orderedPile[ 1, 7, 8 ] [ 3, 6, 9 ] [ 1, 3, 6, 7 ] --&gt;l rleftPile rightPile orderedPile[ 1, 7, 8 ] [ 3, 6, 9 ] [ 1, 3, 6, 7, 8 ] --&gt;l r 现在，左堆中没有更多物品了。 我们只需从右边的堆中添加剩余的项目，我们就完成了。 合并的堆是[1,3,6,7,8,9]。 请注意，此算法非常简单：它从左向右移动通过两个堆，并在每个步骤选择最小的项目。 这是有效的，因为我们保证每个堆都已经排序。 译注： 关于自上而下的执行(递归法)的归并排序，我找了一个比较形象的动图，来源 自下而上的实施(迭代)到目前为止你看到的合并排序算法的实现被称为“自上而下”的方法，因为它首先将数组拆分成更小的堆然后合并它们。排序数组（而不是链表）时，实际上可以跳过拆分步骤并立即开始合并各个数组元素。 这被称为“自下而上”的方法。 下面是Swift中一个完整的自下而上的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func mergeSortBottomUp&lt;T&gt;(_ a: [T], _ isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T] &#123; let n = a.count var z = [a, a] // 1 var d = 0 var width = 1 while width &lt; n &#123; // 2 var i = 0 while i &lt; n &#123; // 3 var j = i var l = i var r = i + width let lmax = min(l + width, n) let rmax = min(r + width, n) while l &lt; lmax &amp;&amp; r &lt; rmax &#123; // 4 if isOrderedBefore(z[d][l], z[d][r]) &#123; z[1 - d][j] = z[d][l] l += 1 &#125; else &#123; z[1 - d][j] = z[d][r] r += 1 &#125; j += 1 &#125; while l &lt; lmax &#123; z[1 - d][j] = z[d][l] j += 1 l += 1 &#125; while r &lt; rmax &#123; z[1 - d][j] = z[d][r] j += 1 r += 1 &#125; i += width*2 &#125; width *= 2 d = 1 - d // 5 &#125; return z[d]&#125; 它看起来比自上而下的版本更令人生畏，但请注意主体包含与merge()相同的三个while循环。 值得注意的要点： 归并排序算法需要一个临时工作数组，因为你不能合并左右堆并同时覆盖它们的内容。 因为为每个合并分配一个新数组是浪费，我们使用两个工作数组，我们将使用d的值在它们之间切换，它是0或1。数组z[d]用于读，z[1 - d]用于写。 这称为 双缓冲。 从概念上讲，自下而上版本的工作方式与自上而下版本相同。首先，它合并每个元素的小堆，然后它合并每个堆两个元素，然后每个堆成四个元素，依此类推。堆的大小由width给出。 最初，width是1但是在每次循环迭代结束时，我们将它乘以2，所以这个外循环确定要合并的堆的大小，并且要合并的子数组在每一步中变得更大。 内循环穿过堆并将每对堆合并成一个较大的堆。 结果写在z[1 - d]给出的数组中。 这与自上而下版本的逻辑相同。 主要区别在于我们使用双缓冲，因此从z[d]读取值并写入z [1 - d]。它还使用isOrderedBefore函数来比较元素而不仅仅是&lt;，因此这种合并排序算法是通用的，您可以使用它来对任何类型的对象进行排序。 此时，数组z[d]的大小width的堆已经合并为数组z[1-d]中更大的大小width * 2。在这里，我们交换活动数组，以便在下一步中我们将从我们刚刚创建的新堆中读取。 这个函数是通用的，所以你可以使用它来对你想要的任何类型对象进行排序，只要你提供一个正确的isOrderedBefore闭包来比较元素。 怎么使用它的示例： 12let array = [2, 1, 5, 4, 9]mergeSortBottomUp(array, &lt;) // [1, 2, 4, 5, 9] 译注：关于迭代的归并排序，我找到一个图来表示，来源 性能归并排序算法的速度取决于它需要排序的数组的大小。 数组越大，它需要做的工作就越多。 初始数组是否已经排序不会影响归并排序算法的速度，因为无论元素的初始顺序如何，您都将进行相同数量的拆分和比较。 因此，最佳，最差和平均情况的时间复杂度将始终为 O(n log n)。 归并排序算法的一个缺点是它需要一个临时的“工作”数组，其大小与被排序的数组相同。 它不是原地排序，不像例如quicksort。 大多数实现归并排序算法是稳定的排序。这意味着具有相同排序键的数组元素在排序后将保持相对于彼此的相同顺序。这对于数字或字符串等简单值并不重要，但在排序更复杂的对象时，如果不是稳定的排序可能会出现问题。 译注：当元素相同时，排序后依然保持排序之前的相对顺序，那么这个排序算法就是稳定的。稳定的排序有：插入排序、计数排序、归并排序、基数排序等等，详见穩定的排序。 扩展阅读归并排序的维基百科 归并排序的中文维基百科 作者：Kelvin Lau. Additions ， Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>归并排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-线性搜索]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Linear Search 目标：在数组中查找特定值。 我们有一组通用对象。 通过线性搜索，我们迭代数组中的所有对象，并将每个对象与我们正在寻找的对象进行比较。 如果两个对象相等，我们停止并返回当前对象在数组中的索引。 如果不相等，只要数组中还有对象，我们就会继续寻找下一个。 一个例子假设我们有一个数组[5,2,4,7]，我们想检查数组是否包含数字2。 我们首先将数组中的第一个数字5与我们正在寻找的数字2进行比较。 它们显然不一样，所以我们继续比较下一个数组元素。 我们将数组中的数字2与数字2进行比较，注意到它们是相等的。 现在我们可以停止迭代并返回1，这是数组中数字2的索引。 代码这是Swift线性搜索的简单实现： 123456func linearSearch&lt;T: Equatable&gt;(_ array: [T], _ object: T) -&gt; Int? &#123; for (index, obj) in array.enumerated() where obj == object &#123; return index &#125; return nil&#125; 将此代码放在playground里测试： 12let array = [5, 2, 4, 7]linearSearch(array, 2) // This will return 1 性能线性搜索性能是O(n) 。它将我们要查找的对象与数组中的每个对象进行比较，因此它所花费的时间与数组长度成正比。在最坏的情况下，我们需要查看数组中的所有元素。 最好的情况是 O(1)，但这种情况很少见，因为我们要查找的对象必须位于数组的开头才能立即找到。你可能会很幸运，但大部分时间你都不会。平均而言，线性搜索需要查看数组中对象的一半。 扩展阅读线性搜索的维基百科 作者：Patrick Balestra翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>线性搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-二分搜索]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Binary Search 目标：在数组中快速寻找一个元素。 假设你有一个数字数组，你想确定一个特定的数字是否在该数组中，如果在，那么获得这个数字的索引。 对于上面的情况，Swift的indexOf()函数足够完成： 123let numbers = [11, 59, 3, 2, 53, 17, 31, 7, 19, 67, 47, 13, 37, 61, 29, 43, 5, 41, 23]numbers.indexOf(43) // returns 15 内置的indexOf()函数执行的是线性搜索。代码大概是： 12345678func linearSearch&lt;T: Equatable&gt;(_ a: [T], _ key: T) -&gt; Int? &#123; for i in 0 ..&lt; a.count &#123; if a[i] == key &#123; return i &#125; &#125; return nil&#125; 使用如下： 1linearSearch(numbers, 43) // returns 15 有什么问题呢？ linearSearch（）从头开始遍历整个数组，直到找到你正在寻找的元素。 在最坏的情况是数值不在数组中，那么之前的遍历就白费。 平均而言，线性搜索算法需要查看数组中一半的值。 如果您的数组足够大，这将会变得非常慢！ 分而治之提升速度的经典方法是使用 二分搜索。 诀窍是将数组分成两半，直到找到值。 对于大小为n的数组，性能不是线性搜索的O(n)，而是只有 O(log n)。换句话说，对具有1,000,000个元素的数组进行二分搜索只需要大约20个步骤来查找要查找的内容，因为log_2（1,000,000）= 19.9。对于具有十亿个元素的数组，它只需要30步。 （然而，你上一次使用数十亿项的数组是什么时候？） 听起来很棒，但使用二分搜索有一个缺点：数组必须被排好序的。 在实践中，这通常不是问题。 下面二分搜索的工作原理： 将数组分成两半，并确定您要查找的内容（称为搜索键）是在左半部分还是在右半部分。 您如何确定搜索键的键在哪一半呢？ 这就是首先要对数组进行排序的原因，排好序你就可以做一个简单的&lt;或&gt;比较。 如果搜索键位于左半部分，则在那里重复该过程：将左半部分分成两个更小的部分，并查看搜索键位于哪一块。 （同样，对于右半部分同样处理。） 重复此操作直到找到搜索键。 如果无法进一步拆分数组，则必须遗憾地得出结论，搜索键不在数组中。 现在你知道为什么它被称为“二分”搜索：在每一步中它将数组分成两半。 分而治之 可以快速缩小搜索键所在的位置。 代码这是Swift中二分搜索的递归实现： 1234567891011121314151617181920212223func binarySearch&lt;T: Comparable&gt;(_ a: [T], key: T, range: Range&lt;Int&gt;) -&gt; Int? &#123; if range.lowerBound &gt;= range.upperBound &#123; // If we get here, then the search key is not present in the array. return nil &#125; else &#123; // Calculate where to split the array. let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2 // Is the search key in the left half? if a[midIndex] &gt; key &#123; return binarySearch(a, key: key, range: range.lowerBound ..&lt; midIndex) // Is the search key in the right half? &#125; else if a[midIndex] &lt; key &#123; return binarySearch(a, key: key, range: midIndex + 1 ..&lt; range.upperBound) // If we get here, then we've found the search key! &#125; else &#123; return midIndex &#125; &#125;&#125; 尝试一下，将代码复制到 playground 并执行以下操作： 123let numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]binarySearch(numbers, key: 43, range: 0 ..&lt; numbers.count) // gives 13 请注意，numbers数组已排序。 否则二分搜索算法不能工作！ 二分搜索通过将数组分成两半来搜索，但我们实际上并没有创建两个新数组。 我们使用SwiftRange对象跟踪这些拆分。起初，此范围涵盖整个数组，0 .. &lt;numbers.count。 当我们拆分数组时，范围变得越来越小。 注意： 需要注意的一点是range.upperBound总是指向最后一个元素之后的元素。 在这个例子中，范围是0 .. &lt;19，因为数组中有19个数字，所以range.lowerBound = 0和range.upperBound = 19。但是在我们的数组中，最后一个元素是在索引18而不是19，因为我们从0开始计数。在处理范围时要记住这一点：upperBound总是比最后一个元素的索引多一。 分步执行示例查看算法的详细工作方式或许是很有用的。 上例中的数组由19个数字组成，排序后如下所示： [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67 ] 我们试图确定数字43是否在这个数组中。 将数组拆分为一半，我们需要知道中间对象的索引。 这是由这行代码确定： 1let midIndex = range.lowerBound + (range.upperBound - range.lowerBound) / 2 最初，范围有lowerBound = 0和upperBound = 19。 细看，我们发现midIndex是0 +（19 - 0）/ 2 = 19/2 = 9。 它实际上是9.5，但因为我们使用的是整数，所以答案是向下舍入了。 在下图中，*处表示中间项。 如您所见，每侧的项目数相同，因此我们将在中间分开。 [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67 ] * 二分搜索将确定使用哪一半的相关代码是： 1234567if a[midIndex] &gt; key &#123; // use left half&#125; else if a[midIndex] &lt; key &#123; // use right half&#125; else &#123; return midIndex&#125; 在这种情况下，a[midIndex] = 29。 这比搜索键的值小，所以我们可以得出结论，搜索键永远不会出现在数组的左半部分。毕竟，左半部分只包含小于29的数字。 因此，搜索键肯定位于右半部分（或根本不在数组中）。 现在我们可以简单地重复二分搜索，数组间距从midIndex + 1到range.upperBound： [ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43, 47, 53, 59, 61, 67 ] 由于我们不再需要关注数组的左半部分，我用x标记了它。 从现在开始，我们只看右半部分，从数组索引10开始。 我们计算新的中间元素的索引：midIndex = 10 +（19 - 10）/ 2 = 14，然后再将数组从中间拆分。 [ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43, 47, 53, 59, 61, 67 ] * 正如你所看到的，a [14]是数组右半部分的中间元素。 搜索键是大于还是小于a [14]？ 小，因为43 &lt;47。 这次我们取左半边并忽略右边较大的数字： [ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43 | x, x, x, x, x ] 新的midIndex如下： [ x, x, x, x, x, x, x, x, x, x | 31, 37, 41, 43 | x, x, x, x, x ] * 搜索键大于37，因此继续右侧： [ x, x, x, x, x, x, x, x, x, x | x, x | 41, 43 | x, x, x, x, x ] * 同样，搜索键更大，因此再次拆分并采取右侧： [ x, x, x, x, x, x, x, x, x, x | x, x | x | 43 | x, x, x, x, x ] * 现在我们已经完成了。搜索键等于我们正在查看的数组元素，所以我们终于找到了我们要搜索的内容：数字43位于数组索引13。 这可能看起来像很多工作，但实际上只需要四个步骤就能找到数组中的搜索键，因为log_2（19）= 4.23。通过线性搜索，它将花费14个步骤。 如果我们要搜索42而不是43会发生什么？在这种情况下，最后我们不能再进一步拆分数组。 range.upperBound变得小于range.lowerBound。这告诉算法搜索键不在数组中，它返回nil。 注意： 二分搜索许多执行会计算 midIndex = (lowerBound + upperBound) / 2。这包含了一个在非常大的数组中会出现的细微bug，因为lowerBound + upperBound可能溢出一个整数可以容纳的最大数。这种情况不太可能发生在64位CPU上，但绝对可能在32位机器上发生。 迭代与递归二分搜索本质上是递归的，因为您将相同的逻辑一遍又一遍地应用于越来越小的子数组。 但是，这并不意味着您必须将binarySearch()实现为递归函数。 将递归算法转换为迭代版本通常更有效，使用简单的循环而不是大量的递归函数调用。 这是Swift中二分搜索的迭代实现： 123456789101112131415func binarySearch&lt;T: Comparable&gt;(_ a: [T], key: T) -&gt; Int? &#123; var lowerBound = 0 var upperBound = a.count while lowerBound &lt; upperBound &#123; let midIndex = lowerBound + (upperBound - lowerBound) / 2 if a[midIndex] == key &#123; return midIndex &#125; else if a[midIndex] &lt; key &#123; lowerBound = midIndex + 1 &#125; else &#123; upperBound = midIndex &#125; &#125; return nil&#125; 如您所见，代码与递归版本非常相似。 主要区别在于使用while循环。 使用迭代实现： 123let numbers = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]binarySearch(numbers, key: 43) // gives 13 结束数组必须先排序是一个问题？ 排序是需要时间的 —— 二分搜索和排序的组合可能比进行简单的线性搜索要慢。但是在您只排序一次然后进行多次搜索的情况下，二分搜索会起到大作用。 二分搜索的维基百科 作者：Matthijs Hollemans翻译：Andy Ron校对：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>二分搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-插入排序]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Insertion Sort 目标：把数组从低到高（或从高到低）排序 您将获得按正确的顺序排列一系列数字。插入排序算法的工作原理如下: 把一系列数字放在一个未排序的堆里。 从堆中挑选一个数字。 你选择哪一个并不重要，但从堆顶挑选是最容易。 把这个数插入一个新的数组。 从未排序堆中再选择一个数字，并将其插入之前的数组中。 这个数字在第一个数字之前或之后，所以现在这两个数字被排序。 再从堆中选择一个数字，并将其插入到数组中的正确排序位置。 继续这样做，直到堆里没有数字。 最终得到一个空堆和一个排序的数组。 这就是为什么这被称为“插入”排序，因为你从堆中取一个数字并将其插入数组中的正确排序位置。 例子假设这边有需要排序的一些数字 [ 8, 3, 5, 4, 6 ]。 选择第一个数字8，然后将其插入新数组中。 新数组是空的，所以插入很容易。 排序的数组现在是[8]，堆是[3,5,4,6]。 从堆中选择下一个数字3，然后将其插入到已排序的数组中。 3应该在8之前，所以排序的数组现在是[3,8]，而堆被缩减为[5,4,6]。 从堆中选择下一个数字5，然后将其插入到已排序的数组中。 5介于3和8之间。 排序的数组是[3,5,8]，堆是[4,6]。 重复上面的过程直到堆为空。 原地排序 译注：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。包括：希尔排序、冒泡排序、插入排序、选择排序、堆排序、快速排序。 上面的解释使你看起来需要两个数组：一个用于存放未排序的堆，另一个用于存放按次序排好的数字。 但您可以执行原地插入排序，而无需创建单独的数组。 您只需追踪数组的哪个部分已经排序，哪个部分是未排序。 最初，数组是[8,3,5,4,6]。 |条显示已排序部分的结束位置和堆的开始位置： [| 8, 3, 5, 4, 6 ] 这表明排序的部分是空的，堆开始于8。 处理完第一个数字后，结果为： [ 8 | 3, 5, 4, 6 ] 排好序的部分是[8]，未排序的堆是[ 3, 5, 4, 6 ]。|条向右移动了一个位置。 下面是排序期间数组内容的变化过程： 123456[| 8, 3, 5, 4, 6 ][ 8 | 3, 5, 4, 6 ][ 3, 8 | 5, 4, 6 ][ 3, 5, 8 | 4, 6 ][ 3, 4, 5, 8 | 6 ][ 3, 4, 5, 6, 8 |] 每一步，|条向右移动一个位置。 如您所见，数组的开始到|部分总是排好序的。堆缩小一位置，排序部分增加一位置，直到堆变为空的，没有更多未排序的数字为止。 怎么插入每一步，您从未排序堆中选择最顶部的数字，并将其插入到数组的已排序部分。 但必须将该数字插入适当的位置，以便数组的从头开始保持排序。 这是如何运作的？ 假设我们已经完成了前几个元素，数组看起来像这样： [ 3, 5, 8 | 4, 6 ] 要排序的下一个数字是4。 我们需要将它插入到已经排好序的[3,5,8]中。 一种方法是：查看前一个元素8。 [ 3, 5, 8, 4 | 6 ] ^ 前一个元素比4大吗？ 是的，所以4应该在8之前。 我们交换这两个数字得到： [ 3, 5, 4, 8 | 6 ] &lt;--&gt; 交换 还没有完成。 新的前一个元素5也大于4。 我们还需交换这两个数字： [ 3, 4, 5, 8 | 6 ] &lt;--&gt; 交换 再看一下前面的元素。 3大于4吗？ 不大于， 这意味着我们完成了数字4保持排序的插入。 下一节将对插入排序算法的内部循环的进行描述，通过交换数字将数字从堆的顶部插入到已排序的部分。 代码下面插入排序的Swift实现： 1234567891011func insertionSort(_ array: [Int]) -&gt; [Int] &#123; var a = array // 1 for x in 1..&lt;a.count &#123; // 2 var y = x while y &gt; 0 &amp;&amp; a[y] &lt; a[y - 1] &#123; // 3 a.swapAt(y - 1, y) y -= 1 &#125; &#125; return a&#125; 代码在 playground 里测试： 12let list = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]insertionSort(list) 代码工作原理： 先创建一个数组的拷贝。因为我们不能直接修改参数array中的内容，所以这是非常必要的。insertionSort() 会返回一个原始数组的拷贝，就像Swift已拥有的sort() 方法一样。 在函数里有两个循环，外循环依次查找数组中的每一个元素；这就是从数字堆中取最上面的数字的过程。变量x是有序部分结束和堆开始的索引（也就是 | 符号的位置）。要记住的是，在任何时候，从0到x的位置数组都是有序的，剩下的则是无序的。 内循环则从 x 位置的元素开始查找。x是堆顶的元素，它有可能比前面的所有元素都小。内循环从有序数组的后面开始往前查找。每次找到一个大的元素，就交换它们的位置，直到内层循环结束，数组的前面部分依然是有序的，有序的元素也增加了一个。 注意： 外层循环是从1开始，而不是0。从堆顶将第一个元素移动到有序数组没有任何意义，可以跳过。 不交换上面的插入排序算法可以很好的完成任务，但是也可以通过移除对 swap() 的调用来提升速度。 通过交换两个数字来让下一个元素移动到合适的位置的： [ 3, 5, 8, 4 | 6 ] &lt;--&gt; swap [ 3, 5, 4, 8 | 6 ] &lt;--&gt; swap 可以通过将前面的元素往右挪一个位置来代替元素的交换，然后将新的数字放到正确的位置。 [ 3, 5, 8, 4 | 6 ] remember 4 * [ 3, 5, 8, 8 | 6 ] shift 8 to the right ---&gt; [ 3, 5, 5, 8 | 6 ] shift 5 to the right ---&gt; [ 3, 4, 5, 8 | 6 ] copy 4 into place * 代码： 12345678910111213func insertionSort(_ array: [Int]) -&gt; [Int] &#123; var a = array for x in 1..&lt;a.count &#123; var y = x let temp = a[y] while y &gt; 0 &amp;&amp; temp &lt; a[y - 1] &#123; a[y] = a[y - 1] // 1 y -= 1 &#125; a[y] = temp // 2 &#125; return a&#125; //1 这行代码就是将前一个元素往右移动一个位置，在内层循环结束的时候， y 就是 插入的数字 在有序数组中的位置， //2 这行代码就是将数字拷贝到正确的位置。 泛型化如果能排序的类型不止数字就更好了。我们可以使数组的数据类型泛型化，然后使用一个用户提供的函数（或闭包）来执行比较操作。这只要改变两个地方。 函数签名变成： 译注：函数签名的英文原文是 function signature，而我们常接触到是 函数声明（function declaration），这两个概念都是有的，暂且不去追究它们的区别了，此处就译为函数签名，应该不影响对下面文章的理解。 1func insertionSort&lt;T&gt;(_ array: [T], _ isOrderedBefore: (T, T) -&gt; Bool) -&gt; [T] &#123; 数组有一个类型 [T]，[T] 是泛型化的一个占位类型。现在 insertionSort() 可以接收任何类型的数组，不管它是包含数字、字符串或者其它类型。 新的参数 isOrderedBefore: (T, T) -&gt; Bool 是一个接收两个 T 对象然后返回一个 Bool 值的方法，如果第一个对象大于第二个，那么返回 true，反之则返回 false。这与 Swift 内置的 sort() 方法是一样的。 另外一个变化就是内循环，现在是这样的： 1while y &gt; 0 &amp;&amp; isOrderedBefore(temp, a[y - 1]) &#123; temp &lt; a[y - 1]被 isOrderedBefore() 替代，不仅可以比较数字，还可以比较各种对象了。 在 playground 中测试: 123let numbers = [ 10, -1, 3, 9, 2, 27, 8, 5, 1, 3, 0, 26 ]insertionSort(numbers, &lt;)insertionSort(numbers, &gt;) &lt; 和 &gt; 决定排序的顺序，分别代表低到高和高到低。 译注：参数isOrderedBefore可以使用&lt;或&gt;，是因为在Swift中运算符定义就类似(T, T) -&gt; Bool。在Foundation中可以看到不同类型定义了运算符，比如Decimal就定义了&lt;： public static func &lt; (lhs: Decimal, rhs: Decimal) -&gt; Bool。Swift文档介绍了Custom Operators可以参考。 当然，我们也可以对其它数据类型排序如字符串： 12let strings = [ "b", "a", "d", "c", "e" ]insertionSort(strings, &lt;) 也可以是更复杂的对象： 12let objects = [ obj1, obj2, obj3, ... ]insertionSort(objects) &#123; $0.priority &lt; $1.priority &#125; 闭包告诉 insertionSort() 方法用 priority 属性来进行排序。 插入排序是一个 稳定 的排序算法。当元素相同时，排序后依然保持排序之前的相对顺序，那么这个排序算法就是 稳定 的。对于像数字或者字符串这样的简单类型来说，这不是很重要。但是对于复杂的对象来说，这就很重要了，如果两个对象有相同的 priority， 不管它们其他的属性如何，这两个对象都不会交换位置。 性能如果数组是已经排好序的话，插入排序是非常快速的。这听起来好像很明显，但是不是所有的搜索算法都是这样的。在实际中，有很多数据（大部分，可能不是全部）是已经排序好的，插入排序在这种情况下就是一个非常好的选择。 插入排序的最差和平均性能是 O(n^2)。这是因为在函数里有两个嵌套的循环。其他如快速排序和归并排序的性能则是 O(n log n)，在有大量输入的时候会更快。 插入排序在对小数组进行排序的时候实际是非常快的。一些标准库在数据量小于或者等于10的时候会从快速排序切换到插入排序。 我们做了一个速度测试来对比我们的 insertionSort() 和 Swift 内置的 sort()。在大概有 100 个元素的数组中，速度上的差异非常小。然后，如果输入一个非常大的数据量， O(n^2) 马上就比 O(n log n) 的性能糟糕多了，插入排序差很多。 扩展阅读插入排序的维基百科 作者：Matthijs Hollemans翻译：Andy Ron校队：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>插入排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-队列]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E9%98%9F%E5%88%97.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Queue 队列(Queue) 这个话题已经有个辅导文章 队列的本质是一个列表，但只能从队尾添加元素，从队首移除元素。这保证了第一个入队的元素总是第一个出队。先到先得！ 为什么要这样做呢？在很多算法的实现中，你可能需要将某些对象放到一个临时的列表中，之后再将其取出。通常加入和取出元素的顺序非常重要。 队列可以保证元素存入和取出的顺序是先进先出(first-in first-out, FIFO)的，第一个入队的元素总是第一个出队，公平合理！另外一个非常类似的数据结构是栈，它是一个后进先出(last-in, first-out, LIFO)的结构。 举例来说，我们将一个数字入队： 1queue.enqueue(10) 队列现在为 [ 10 ]。再将下一个数字入队： 1queue.enqueue(3) 队列现在为 [ 10, 3 ]。再加入一个数字： 1queue.enqueue(57) 队列现在为 [ 10, 3, 57 ]。现在我们将第一个元素出队： 1queue.dequeue() 这条语句返回数字 10，因为这是我们入队的第一个元素。队列现在是 [ 3, 57 ]。剩下的元素都往前移动一位。 1queue.dequeue() 这条语句返回 3，下次调用 dequeue 将返回 57，以此类推。如果队列为空，出队操作将返回 nil，在有些实现中，会触发一个错误信息。 注意： 队列并不总是最好的选择，如果加入和删除元素的顺序无所谓的话，你可以选择使用栈来达到目的。栈更加简单快速。 代码下面给出了一个简单粗暴的队列实现。它只是简单地包装了一下自带的数组，并提供了入队(enqueue)、出队(dequeue)和取得队首元素(peek)三个操作： 123456789101112131415161718192021222324252627public struct Queue&lt;T&gt; &#123; fileprivate var array = [T]() public var isEmpty: Bool &#123; return array.isEmpty &#125; public var count: Int &#123; return array.count &#125; public mutating func enqueue(_ element: T) &#123; array.append(element) &#125; public mutating func dequeue() -&gt; T? &#123; if isEmpty &#123; return nil &#125; else &#123; return array.removeFirst() &#125; &#125; public var front: T? &#123; return array.first &#125;&#125; 上面实现的队列只是可以正常工作，但并没有任何的优化。 入队操作的时间复杂度为 O(1)，因为在数组的尾部添加元素只需要固定的时间，跟数组的大小无关。 你可能会好奇为什么在数组尾部添加元素的时间复杂度为 O(1)，或者说只需要固定的时间。这是因为在 Swift 的内部实现中，数组的尾部总是有一些预设的空间可供使用。如果我们进行如下操作： 1234var queue = Queue&lt;String&gt;()queue.enqueue("Ada")queue.enqueue("Steve")queue.enqueue("Tim") 则数组可能看起来想下面这样 1[ &quot;Ada&quot;, &quot;Steve&quot;, &quot;Tim&quot;, xxx, xxx, xxx ] xxx 代表已经申请，但还没有使用的内存。在尾部添加一个新的元素就会用到下一块未被使用的内存： 1[ &quot;Ada&quot;, &quot;Steve&quot;, &quot;Tim&quot;, &quot;Grace&quot;, xxx, xxx ] 这只是简单的拷贝内存的工作，只需要固定的常量时间。 当然，数组尾部的未使用内存的大小是有限的，如果最后一块未使用内存也被占用的时候，再添加元素会使得数组重新调整大小来获取更多的空间。 重新调整的过程包括申请新的内存，将已有数据迁移到新内存中。这个操作的时间复杂度是 O(n)，所以是一个较慢的操作。但考虑到这种情况并不常见，所以，这个操作的时间复杂度依然是 O(1) 的，或者说是近似 O(1) 的。 但出队操作就有点不一样了。出队操作是将数组头部的元素移除，而不是尾部。这个操作的时间复杂度永远都是 O(n)，因为这会导致内存的移位操作。 在我们的例子中，将 &quot;Ada&quot; 出队会使得 &quot;Steve&quot; 接替 &quot;Ada&quot; 的位置；&quot;Tim&quot; 接替 &quot;Steve&quot; 的位置；&quot;Grace&quot; 接替 &quot;Tim&quot; 的位置： 出队前 [ &quot;Ada&quot;, &quot;Steve&quot;, &quot;Tim&quot;, &quot;Grace&quot;, xxx, xxx ] / / / / / / / / / / / / 出队后 [ &quot;Steve&quot;, &quot;Tim&quot;, &quot;Grace&quot;, xxx, xxx, xxx ] 在内存中移动这些元素的时间复杂度永远都是 O(n)，所以我们实现的简单队列对于入队操作的效率是很高的，但对于出队操作的效率却较为低下。 更加高效的队列为了让队列的出队操作更加高效，我们可以使用和入队所用的相同小技巧，保留一些额外的空间，只不过这次是在队首而不是队尾。这次我们需要手动编码实现这个想法，因为 Swift 内建数组并没有提供这种机制。 我们的想法如下：每当我们将一个元素出队，我们不再将剩下的元素向前移位（慢），而是将其标记为空（快）。在将 &quot;Ada&quot; 出队后，数组如下： 1[ xxx, &quot;Steve&quot;, &quot;Tim&quot;, &quot;Grace&quot;, xxx, xxx ] &quot;Steve&quot; 出队后，数组如下： 1[ xxx, xxx, &quot;Tim&quot;, &quot;Grace&quot;, xxx, xxx ] 这些在前端空出来的位子永远都不会再次使用，所以这是些被浪费的空间。解决方法是将剩下的元素往前移动来填补这些空位： 1[ &quot;Tim&quot;, &quot;Grace&quot;, xxx, xxx, xxx, xxx ] 这就需要移动内存，所以这是一个 O(n) 操作，但因为这个操作只是偶尔发生，所以出队操作平均时间复杂度为 O(1) 下面给出了改进版的队列的时间方式： 123456789101112131415161718192021222324252627282930313233343536373839public struct Queue&lt;T&gt; &#123; fileprivate var array = [T?]() fileprivate var head = 0 public var isEmpty: Bool &#123; return count == 0 &#125; public var count: Int &#123; return array.count - head &#125; public mutating func enqueue(_ element: T) &#123; array.append(element) &#125; public mutating func dequeue() -&gt; T? &#123; guard head &lt; array.count, let element = array[head] else &#123; return nil &#125; array[head] = nil head += 1 let percentage = Double(head)/Double(array.count) if array.count &gt; 50 &amp;&amp; percentage &gt; 0.25 &#123; array.removeFirst(head) head = 0 &#125; return element &#125; public var front: T? &#123; if isEmpty &#123; return nil &#125; else &#123; return array[head] &#125; &#125;&#125; 现在数组存储的元素类型是 T?，而不是先前的 T，因为我们需要某种方式来将数组的元素标记为空。head 变量用于存储队列首元素的下标值。 绝大多数的改进都是针对 dequeue() 函数，在将队首元素出队时，我们首先将 array[head] 设置为 nil 来将这个元素从数组中移除。然后将 head 的值加一，使得下一个元素变成新的队首。 数组从这样： 12[ &quot;Ada&quot;, &quot;Steve&quot;, &quot;Tim&quot;, &quot;Grace&quot;, xxx, xxx ] head 变成这样： 12[ xxx, &quot;Steve&quot;, &quot;Tim&quot;, &quot;Grace&quot;, xxx, xxx ] head 这就像在某个超市，在那里排队结账的人保持不动，而收银员从头往队尾移动来挨个结账。 当然，如果我们从不移除队首的空位，随着不断地入队和出队，队列所占空间将不断增长。为了周期性地清理无用空间，我们编写了如下代码： 12345let percentage = Double(head)/Double(array.count)if array.count &gt; 50 &amp;&amp; percentage &gt; 0.25 &#123; array.removeFirst(head) head = 0&#125; 这段代码计算了队首空余的元素占数组总元素的百分比，如果空余元素超过 25%，我们就进行一波清理。但是，如果队列的长度过小，我们也不想频繁地清理空间，所以在清理空间之前，队列中至少要有 50 个元素。 注意： 50这个数字只是我凭空捏造的一个数字，在实际的项目中，你应该根据项目本身来选定一个合情合理的值。 在 Playground 中测试： 1234567891011121314151617181920var q = Queue&lt;String&gt;()q.array // [] empty arrayq.enqueue("Ada")q.enqueue("Steve")q.enqueue("Tim")q.array // [&#123;Some "Ada"&#125;, &#123;Some "Steve"&#125;, &#123;Some "Tim"&#125;]q.count // 3q.dequeue() // "Ada"q.array // [nil, &#123;Some "Steve"&#125;, &#123;Some "Tim"&#125;]q.count // 2q.dequeue() // "Steve"q.array // [nil, nil, &#123;Some "Tim"&#125;]q.count // 1q.enqueue("Grace")q.array // [nil, nil, &#123;Some "Tim"&#125;, &#123;Some "Grace"&#125;]q.count // 2 为了测试队列的自动调整特性，将下面这段代码： 1if array.count &gt; 50 &amp;&amp; percentage &gt; 0.25 &#123; 替换为： 1if head &gt; 2 &#123; 现在，如果你再次执行出队操作，数组将看起来像下面这样： 123q.dequeue() // "Tim"q.array // [&#123;Some "Grace"&#125;]q.count // 1 在数组前面的 nil 已经被移除了，数组本身也没有空间浪费了。新版本的队列实现并没有比初版复杂很多，但现在出队操作的复杂度已经从当初的 O(n) 变为了现在的 O(1)，只是因为我们在数组的使用策略上耍了一点小心机。 扩展阅读事实上，队列还有很多种其他的实现方式，例如可以使用链表、环形缓冲区或是堆来实现。 队列有很多变体，包括双端队列，一个两端都可以出队和入队的队列；优先队列，一个有序的队列，最重要的元素排在队首。 作者：Matthijs Hollemans译者：KSCO校队：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-栈]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E6%A0%88.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。🐙andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。本文的翻译原文和代码可以查看🐙swift-algorithm-club-cn/Stack 这个话题已经有个辅导文章 栈类似于数组，但是限制了存取操作的灵活性。栈只允许使用者从栈顶 压入(push) 元素；从栈顶 弹出(pop) 元素；取得(peek) 栈顶元素，但不弹出。 这样的限制有什么意义呢？在很多算法的实现中，你可能需要将某些对象放到一个临时的列表中，之后再将其取出。通常加入和取出元素的顺序非常重要。 栈可以保证元素存入和取出的顺序是后进先出(last-in first-out, LIFO)的。栈中弹出的元素总是你最后放进去的那个。另外一个非常类似的数据结构是队列，它是一个先进先出(first-in, first-out, FIFO)的结构。 举例来说，我们先将一个数字压入栈中： 1stack.push(10) 栈现在是 [10]。压入下一个数字： 1stack.push(3) 栈现在是 [10, 3]。再压入一个数字： 1stack.push(57) 栈现在是 [10, 3, 57]。现在把栈顶的数字弹出来： 1stack.pop() 这行代码返回 57，因为它是我们最后压入的元素。现在栈又变成了 [10, 3]。 1stack.pop() 这行代码返回 3，以此类推。如果栈空了，弹栈操作将返回 nil，在有些实现中，会触发一个 stack underflow 错误消息。 栈在 Swift 中的实现非常容易。只需要包装一下自带的数组，将存取功能限制为 pop、push 和 查看栈的顶部元素。 1234567891011121314151617181920212223public struct Stack&lt;T&gt; &#123; fileprivate var array = [T]() public var isEmpty: Bool &#123; return array.isEmpty &#125; public var count: Int &#123; return array.count &#125; public mutating func push(_ element: T) &#123; array.append(element) &#125; public mutating func pop() -&gt; T? &#123; return array.popLast() &#125; public var top: T? &#123; return array.last &#125;&#125; 注意到，压栈操作是将新元素压入数组的尾部，而不是头部。在数组的头部插入元素是一个很耗时的操作，它的时间复杂度为 O(n)，因为需要将现有元素往后移位为新元素腾出空间。而在尾部插入元素的时间复杂度为 O(1)；无论数组有多少元素，这个操作所消耗的时间都是一个常量。 关于栈的有趣知识：每次你调用函数或方法，CPU都会将函数返回地址压入到运行栈中。当这个函数执行结束的时候，CPU将返回地址从栈中取出，并据此返回到函数被调用的位置。所以，如果不断地调用太多的函数(例如死递归函数)，就会得到一个所谓的“栈溢出(stack overflow)” 错误，因为CPU运行栈没有空间了。 作者：Matthijs Hollemans译者：KSCO校队：Andy Ron]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《拖延心理学》——认识拖延，找到应对策略]]></title>
    <url>%2F2018%2F%E6%8B%96%E5%BB%B6%E5%BF%83%E7%90%86%E5%AD%A6.html</url>
    <content type="text"><![CDATA[初次阅读时间：2016.7 作者和本书概要简·博克和莱诺拉·袁她们两人是心理学博士、美国加利福尼亚大学的资深心理咨询师。 从1979年开始就为学生中的拖延者创设了第一个团体治疗课程，曾经出现在《奥普拉》和《20/20》等电视节目中，同时也是《纽约时报》、《今日美国》、《洛杉矶时报》、《人物》和《当代心理学》等出版物的专访对象。 一直致力于为全美国的学生、公司组织和公众团体提供治疗的心理工作坊和专题演讲方面的服务，终年活跃在伯克利、斯坦福大学的讲坛。 《拖延心理学》 ，副标题: 向与生俱来的行为顽症宣战，原作名: Procrastination: Why You Do It, What To Do About It Now。 拖延是普遍存在的，从我阅读本书的过程中也能体会到。我们需要认识拖延，知道它背后原因，找到应对策略，然后完善自我。本书非常详细的分析了拖延的方方面面。 内容序言 拖延从根本上来说并不是一个时间管理方面的问题，也不是一个道德问题，而是一个复杂的心理问题 拖延的问题是一个人跟自身如何相处的问题 很多时候对一些事情弃之不理反而对你最为有利 当我们按照自己真实的样子而不是按照自己希望的样子来接受自己的时候，我们才能以最有利于我们的方式来采取行动，而不是生活在拖延的无边阴影之下。 了解你自己 “拖延就像蒲公英。你把它拔掉，以为它不会再长出来了，但是实际上它的根埋藏得很深，很快又长出来了。” 拖延的根源 涉及内心感受、恐惧、希望、记忆、梦想、怀疑以及压力 拖延者与时间的纠葛 “期望式思维” 在杂乱无章和拖拖拉拉背后，大多数拖延者其实是在害怕他们自己无法在根本上被人接受。 面对自己对失败的恐惧，对成功的恐惧，对受控制的恐惧，以及对亲近和疏远的恐惧，因为我们相信当你了解了自己的感受究竟是什么以及为什么自己会有这样的感受时，你就会有望变得更自信，更踏实，也更自在，这样你才能摆脱拖延，大步向前。 拖延vs行为一、 质疑拖延：是可恶的坏习惯还是应得的报应 如果身处现代社会是拖延唯一的原因的话，那么每个人就都成了拖延者了。也有很多人在面对社会压力的时候呈现出其他一些苦恼的症状，比如工作狂、抑郁症、酗酒、吸毒上瘾和恐惧症；同时也有人在全天候的压力下却能茁壮成长。 为了理解你为什么会选择拖延作为你应对压力的基本策略，我们必须到你个人生活中寻找原因。 你还记得自己的第一次拖延吗？那是在一个什么样的环境下发生的？你是在学业上还是在父母叫你做的事情上拖拖拉拉？那时你多大？是在读小学还是中学……？甚至更早？后来结果怎样？你当时的感受又是什么？我们这里有一些拖延者向我们描述他们早期记忆的例子： ”我们一直推迟我们知道最终无法逃避的事情，这样的蠢行是一个普遍的人性弱点，它或多或少都盘踞在每个人的心灵之中。“ 按时完成每件事情是不可能的。面对无法把每件事都做好的情况，那些接受自己能力有限这个事实的人不太会为此过于烦恼 拖延给拖延者造成的内在后果就是他们必须承受某些内在情绪的折磨，从恼怒、后悔到强烈的自我谴责和绝望。 处于不停的哀叹之中 你创造一种事情不断取得进展的假象 当那个任务最终无论是被放弃了还是被完成了，拖延者通常会因为如释重负和精疲力竭而近乎崩溃，这几乎变成了一次严峻的考验，虽然历经磨难，但是毕竟已经过去。 即便在离开学校很多年之后，很多成年人还是会以他们孩提时获得的头衔来认识自己。 拖延很可能成了他们掩盖自己弱项的一个心理策略 按照别人的规定做事意味着屈服和失去掌控。 虽然要忍受自责、自轻和对自己的反感是相当痛苦的，但是比起去看清真实的自我所带来的脆弱和无地自容，这样的感受或许更能够被承受得起，拖延是保护他们的盾牌。 二、 审问拖延：被架在审判席上的失败恐惧症 如果戴维关心的是成为一个出色的律师，那么他为什么要通过拖延来回避有助于他成就梦想而必须做的工作呢 是啊，为什么呢？想成就某些事，却不能专注去做，然后再去懊悔！ 这些因害怕失败而压抑自己的人往往以一种宽泛的方式来定义“失败”。当他们对自己在一件事情上的表现感到失望的时候，他们不仅认为自己在那件事情上失败了，他们还认为自己是一个失败者。 如果这样就判定失败，那么失败就不是成功他妈了，是孙子 不管能力是如何被定义的，当它成了一个人自我价值感的单一决定因素时，问题就产生了 全力以赴后失败比没有尽力的失败更加让人挫败。所以潜意识选择逃避，保有如果尽力后虚无缥缈的希望。 人们通过拖延来安慰自己，让自己相信他们的能力要大于其表现，他们甚至还维护着这样一种信念：他们的潜在能力是出色的、不可限量的 有些人宁愿承受拖延所带来的痛苦后果，也不愿意承受努力之后却没有如愿以偿所带来的羞辱。 警惕：喜欢拖延的完美主义者 如果一个人认为不管他面对的材料多复杂，他都应该能够马上理解它，一旦不能做到这一点时，他们的努力就会戛然而止。他们对必须努力做事感到失望，这让他们不想付出为了熟悉和精通材料所必要的努力。相反，他们通过拖延来回避努力。 我不知道有多少人是这样的，但我知道我有点这方面的倾向。 他们对聪明的渴望却使他们变得无知。 他们相信每个问题都有一个正确的解决办法，而找到这个办法就是他们的职责所在。在发现正确的解决办法之前，他们不愿意采取任何行动，也不承担任何任务。 大部分人都有一个愿望，希望将来某一天我们也可以知道和控制所有事情 “自残”是一种间接保护你的自我和自尊的方式 它不是黄金就是垃圾 蜗壳：第二就是最大的失败。蜗壳害人不浅😂 固定心态（fixed mindset) 成长心态（growth mindset） 你不擅长的事情反而更为有趣，因为通过做这样的事情，你可以拓展你自己，并从中学习。 “午夜时分，往事历历，纷至沓来。其中不尽是美事：痛苦、错误、未尽之事，以及令人羞愧和悲伤的种种往事一齐涌上心头。但是一切，无论好与坏，痛苦与欢乐，都描绘进了丰富的人生画卷中，都成了我思想的粮食和进步的动力。”—— 作家梅·撒尔顿（May Sarton）描写了成长的心态 三、 对话拖延：拖延你好，成功再见 及时追随目标 虽然没有其他人知道他们的成功只不过是赶出来的，但是他们自己知道——对他们来说，这意味着他们仍然没有真正成功。 实际上很可能是在恐惧成功，并利用拖延来避免成功的到来。 对成功的渴望要比对成功的恐惧更容易鉴别出来 内心的冲突有时候会以一种无法解释的情绪转变表现出来，以一阵自我怀疑或者负疚感，或者以希望与失望的交替起伏表现出来，就好像依稀的耳语，我们不清楚那些耳语到底是什么，以及究竟谁在那里跟我们说话。 以至于让我们丧失了自发性、好奇心以及面对挑战的勇气。 拖延者往往给人留下“随便你，无所谓”的印象，因为他们做事从不全力以赴 一旦你产生了一个非常有创意的可以付诸实施的设计思路，人们会期待每一件你所做的事情都是富有创新精神的。 就像一个电动扶梯，一旦你一脚踏上去，不到顶端你就找不到地方可以下去 成功毫无例外地会导致一个人失去对自己生活的控制权和选择权。 人们常常团结在一起相互抱怨那些破事，从中得到相互心理上的支持。 相信自己有权利走自己的人生之路，这样的决断或许会让你跟自己的家庭和文化观念发生冲突。在一些文化传统中，拥有一个自己的人生要比照顾家庭成员和考虑集体需要次要得多。 中国是典型案例 用拖延代替了选择 变故会让你感到有风险。当你的人生发生了某个变故，你可能遭遇到一个未知的自己，一段未知的关系，或者一个未知的世界。但是我们认为，跟你认为的风险相比，它会让你进入到一个更好的人生阶段。你可以改变自己以适应环境，也可以改变自己以适应成功。 拖延vs心理四、 挣扎中的拖延者：成为战败者怎么办 争夺控制权的较量,因为你想证明没有人可以强迫你违反自己的意愿。成了争夺控制权以及赢得尊敬和独立自主的一场争夺战。 规则是以某种外在力量加诸于我们身上的限制或者期待的形式出现的 很多时候，我有意无意的通过打破规则来表现自己的与众不同。 拖延增强了她的自由感，并让她确信自己不是这些规矩的囚犯。 虽然规则最初是你自己定的，但是它就像是外部强加给你的一个要求，你必须从中夺回你的自由 个人感到被人侵犯时的反应要比规则或者权力对他的影响大多了 拖延成了抵制侵犯的一种方式。 拖延也可以带来复仇的快感。 跟现实相对抗的战斗是最不可思议的 如果你的自我价值感是建立在不让别人左右你的能力上，那么每一次跟人打交道都会让你如临大敌。 如果我对自己的独立性确定无疑，那么我就没有必要通过这样的拖延来证明它。 对害怕在争战中败下阵来的拖延者而言，把自己所想所感暴露给别人看会让他们感到自己极为脆弱 在抉择和承诺中拖延是保护你自己的一种间接方式 拖延的间接特性可以保护你不受愤怒情绪的破坏性影响，间接地表达愤怒是你控制自己情绪的一种方式。很可能你慢慢开始相信任何情绪都应该被包裹起来。任何恼怒或者气愤的表露都会让别人看穿你，他们就可以通过你的敏感处来操控你。下一次你的对手就会知道怎么摆布你。 那些通过拖延发动争战的人常常会在一个强势的人面前感到自己的软弱。 阻碍对方比得到自己想要的更为重要。 叛逆期这表现的非常明显！ 在日常生活的种种细节中被过分管束的孩子，他们的独立人格往往得不到鼓励和支持，反而受到讥笑和打压。虽然每一个生活细节中的摩擦和碰撞都是微不足道的，但是当这样的事情几年以来一直重复地发生，就会对一个人的心理产生很大的影响。一个对自己的独立自主性没有自信的孩子无法发展出一个健全的自我。 一个请求不一定意味着控制；一个规则并不必然是一个无法逃脱的牢房，而与人合作也可能是一件令人开心的事情。 五、 心理舒适区：对亲近与疏远的恐惧 害怕疏远的人都是通过与人保持亲近的关系来获得巨大安全感的。而害怕亲近的人则刚好相反，与人保持距离会让他们更加自在。 如果你害怕你的利益在被这个掠夺性的世界所知晓之后就会被侵占，你可能就会过上一种连自己的真实愿望都不了解的生活 不去爱要胜于失去爱 无论你的焦虑是来自于对疏远的恐惧还是对亲密的恐惧，拖延始终是你维护心理舒适边界的一种方式。 一个良好的关系需要在依赖和独立之间取得平衡。 六、 拖延时钟：你知道现在几点吗 如果没有人来测定时间，时间还存在吗？ 钟表时间和沉浸时间 时间会帮助你摆脱那种依循季节周期变化而形成的线性时间观 时间对于每个人都是不同的，事实上，你对时间的主观感受可能让另一个人迷惑不解，甚至生气发火，因为他也有他自己独特的时间感，而且很可能跟你的大为不同。 人们是参照基于过去、现在和未来的不同坐标来感知时间的 在三种不同的时间坐标参照中保持平衡的人最有可能适应社会发展的步伐，也更能够充分地享受生活 未来折扣 认识到时间的有限性是中年人心理上面临的一个主要挑战： 对于一个跟生命的有限性做着抗争的拖延者而言，接受生命无可避免的终结是一项具有重要心理意义的挑战 你或许已经注意到，不受时间限制的感觉往往发生在当你处于深深的愉悦或者玩得最开心的时候，富有创造性的时刻仿佛也是发生在时间之外。当你深深地沉浸在自己所做的事情中的时候，你不知道时间究竟过去了几分钟还是几个小时。在时间迷失的状态中待上一个小时、一天或者一个星期都可以让你焕然一新、创意无穷。 正是这个不被察觉的过去剥夺了她走向未来的权利 你的过去就是你的过去，不管你喜不喜欢它，不管你是不是清楚地记得它，也不管你是否为它承担起你的责任。过去发生的许多事情不是你的错——或许也不是任何人的错，或许有一些事情是你的错，但是这些在你生活中发生的事件属于你，并将永远属于你。即便你感到事情还没有完，或者不公平，你也无法回到过去改变它们。 拖延vs大脑七、 世界上存在“拖延基因”吗 大脑具有一种重组能力，它可以打破旧的神经联系，建立新的神经联系，我们把这种能力称做“神经可塑性” 可能在很多时间下你没有意识到迫使你逃避某个事情的那个感受是什么。即便是这样，你的身体还是会有反应。 在遭遇过一次危险的刺激之后，只要下一次再次碰到这样的刺激，恐惧就会被重新激发，哪怕你已经不记得它了 原始刺激与你的恐惧之间的那个联系现在还处于无意识之中 恐惧这么难以处理的另外一个原因是 大脑负责传导恐惧的通道非常强劲 为了对付恐惧和冲动，人类逐渐发展出了一系列的防卫机制，将不堪忍受的痛苦的思想、情感及记忆阻挡在意识范围之外， 对负面情绪加以认知重塑的人降低了他们的紧张度，这使他们更容易从适应不良的陈旧思想和负面情绪中摆脱出来。 显性记忆，有时候被称作“后期”记忆，更为我们所熟悉，因为它们是在我们发展了语言和意识能力之后才产生的 敬畏和接受你大脑产生的反应依然是极为重要的一步 你身处当下这个时刻，而那些记忆，不管你是否记得，都来自过去。 一个人大脑的状态会影响到另外一个人的状态。 这样的不和谐在所有的人际关系中都是不可避免的，但是它们不一定都是有问题的。每个父母都有不开心的日子。只有当这些不和谐成为一种常态的时候，它们才会在孩子心里留下不健全的影响 后叶催产素有助于调整社会关系和对其他人的情感依赖。 你可以用鼓励而不批评、同情而不攻击的态度来对待自己。 八、 如何打造大脑的全局领导力 一个执行能力低下的人不管拥有多好的个人素质，他都可能在重要的生存技能上有所缺失 分解成几个小的步骤，跨出小小的第一步，学习怎样记录时间，以及如何优化周围环境使之向有利于成功的方向推进 一个不能有效抑制自己的人会成为冲动的牺牲品。 如果你发现自己对“临时抱佛脚”上瘾了，那么你可能是通过这样的方式在给自己开出一剂自行生效的药方：肾上腺素，它会增强你专注的能力。 当你抑郁时，你会感到能量不足，不愿意参与，失去兴趣，没有目标，不再乐观。如果你处于悲惨的心境中，对生活感到无望，也不再关心自己究竟活得怎样，那么，你很可能就不会再去关心自己的工作或学业，也不再关心是否能跟朋友待在一起，对处理税收事务或者照顾好自己的身体都变得毫无兴致。如果你抑郁了，你很可能会在很多重要的事情上拖沓不前。要把自己拉出去散步简直成了一件不可能的事情；当你连刷牙的力气都没有的时候，要你整理抽屉简直会让你昏倒。 请放心，你并不孤独 不要这样做！你或许需要它……你可能再也找不到这样的东西了……有一天它会值很多钱……它是我外祖母的！ 该扔就扔吧！ 拖延产生压力，而压力又会导致拖延 睡眠被剥夺的年轻人在从事一项任务时显得力不从心、无法坚持，在从事一些被认为是‘无聊乏味’的任务时尤其如此。他们在面对一些需要计划或目标导向的复杂任务时会碰到同样的问题，在目标抽象、报酬滞后的情况下，问题就更大了。 更加仔细和敬畏的心态爱护自己的大脑 九、 你是怎样变成一个拖延者的 如果你先天的特性跟你后天被对待的方式之间没有被很好地协调的话，你很难为自己建立起坚实的自信，而缺乏自信是导致拖延的一个主要因素。 一个被理想化的成功榜样是无法付诸实践的！ 人脑对未来的期待是以过去所习得的东西作为参照的。你是通过过去的经验来感知未来的 施压、怀疑、控制、依附和疏远 当这个世界对孩子来说事实上已经成了一个危险的所在，而直接的反抗又太冒险。在被父母监控的环境下，拖延就成了他们的一种反抗方式。 帮助孩子容忍失败和接受现实。 一些富有人性的品质往往会被忽视或者低估 十、 拖延行为模式的法庭大调查 心理根源、生物因素和人生经 勇敢并非没有恐惧，而是克服恐惧，战胜恐惧 改善拖延状况同时也意味着要面对他们一直回避的恐惧 帮助他人而不照看好自己会让你失去自我的方向 如果照看别人这件事成了你回避自己的一种方式的话，这时你就成了一个受难者，而不是一个圣人 缺乏对真正重要事情的洞察的人可能会对每一个新出现的机会都兴趣盎然。他们不断从一项行动跳到另一项行动中，而没有完成的工作都被堆在一边。如果你在那些做了一半和即将要做的事情之间奔忙，如果你为那些即将到来或将被错过的最后期限而忧心忡忡，你可能会让自己的内心充满了焦虑，因为内心的白板总是需要某些东西来填补。 最可怕的事情是去全然地接受自己 对自己的弱项心怀敬畏地给予关注，友善地对待自己，并通过锻炼提高相应的技能，或者做一些相应的安排，那样，你才可以真正地帮助到自己。 很多时候我们接受的是别人眼中的自己！ 要完全地接受自己就必须了解自己的情感并与之共处，不论这个情感是好是坏，是美好还是丑陋。 要完全地接受自己就必须了解自己的情感并与之共处，不论这个情感是好是坏，是美好还是丑陋。 一种辨识自身和他人情感的能力，一种自我激发的能力，也是一种管理自身情感和人际情感的能力 认为你只有在舒舒服服的时候才能采取行动也是一种非常局限的看法 “会花费很多精力想要去维护他们的焦虑，维护焦虑似乎成了他们的职业 如果你在某方面的拖延是出于你在另一方面的价值观，那么这其中一定传递了某些你应该去理解的重要信息 当你的自我系统太过刻板，你就站在了一个完美主义者的立场上，而完美主义又是拖延的温床；你一遍又一遍地重复同样的行为，也不管它是否有效；你对别人的期望缺乏弹性；当你设想的生活不能如你所愿的时候，你的内心就容易陷入混乱与骚动之中 对于像“我自己想要的是什么”这样的问题，没有一个现成的答案可以决定你是对还是错 你不仅必须把作为一个个体的自我与他人对你的影响区分开来，而且还必须跟那个充当内心检察官的你区分开来，你必须从自我阻碍中走出来 ◆ 找出导致拖延的因素 目标和回报太遥远了，感受不到对我有什么意义。 一个长远的目标对界定你是谁以及你想要什么都是非常重要的 ◆ 如何运用这些技巧 观察内心的抵抗 自由书写 不做判断的情况下去了解你的思维和情绪 挖掘你的恐惧，了解内心的抵抗，找出你的价值观，检查你对我们建议的反应，或者监测你对改变的态度。 在我看到自己所写的文字之前，我对自己的所思所想并不是十分了解 拖延vs征服之战十一、 作战前传：拖延大盘点 如果你以一个旁观者的身份来观察自己，你就会对自己的拖延问题有更多的了解 一个拖延者是毫无希望的，即便你的拖延已经蔓延到很多领域，但是总有一些方面你是不拖延的。 十二、 作战武器：明确的目标与可行性的计划 为了设立一个更为现实的目标，我们请拖延者设想一个最小的目标。你可以设立一个什么样的目标，它既非常小，又可以给你带来进步感和成就感？一 可能是应该结束一天工作的一个信号。 奖赏自己的想法对一个拖延者而言或许很陌生，因为他们倾向于惩罚自己而不是表扬自己。 斯科特从来没有对自己所做的事情感到满意，因为他的关注焦点始终停留在那些他没有完成的事情。 很多时候只是急着走，感觉慢下来就好像少了点什么 这对拖延者而言或许有点难度，他们不喜欢回想所做的和没有做的事情。 十三、 作战方法A：学会怎样判断时间 拖延者喜欢待在一个具有潜在可能性的模糊王国，而不喜欢一个具体的、可测量的或者有限的时间框架内。 这是我听过关于计划的，最好的一句。 “计划是将未来带入到当下，这样你马上就可以做一些事情来创造未来。” “计划是将未来带入到当下，这样你马上就可以做一些事情来创造未来。” 如果他们将娱乐用于逃避工作，他们可能并没有在这样的疯狂消遣中感受到多少真正的快乐 在做完事之后，你记录得越及时，奖赏的效力就越显著，减轻拖延的一个重要因素就是更快地给予奖 自我监测有助于增进工作时间和提升工作成就 将你对完成时间的预测与实际使用时间做对比。 惩罚起不到激励作用，胡萝卜政策要比大棒政策要管用得多 “非此即彼”的观念对拖延者而言始终是一个不断出现的障碍 真正的失败是生活中每件事你都要固执地亲力亲为，这样做只会有一个结果，那就是你只能完成其中的一半。 能够以另一个方式将事情做完总比拖着不做要好多了 这种禁欲主义和自我惩罚型的心态和做法并不会增加你的做事效率，它只会增加你的压力和苦恼，增加压力就是给自己添麻烦 过于忙碌本身是否就是拖延呢？ 这种理由让自己感觉振振有词！ “我并没有在拖延，我只是太忙了，无法及时干完每一件事。” 学会在过去、现在和未来之间取得认知上的平衡 不要黏滞在时间中，这一点很重要。如果你黏滞在过去，你就无法享受现在，也不能为未来做打算；如果你黏滞在现在，你就处于当下时刻的控制之中，而失去了跟过去和未来的联系，你也无法从自己的经验中受益；如果你黏滞在未来，你就被锁定在一个幻想的世界，无论这个幻想是正面的还是负面的，你所能做的就只有计划或者担忧。 通过拖延的方式来窃取休闲的时间 十四、 作战方法B：学会“接受”和“拒绝” 消费驱动并以索取为导向的社会中 拖延者对别人的目标总是能够保持非常清醒和务实的头脑，但是对他们自己的目标却一片糊涂，过于理想化 应对挑战有利于你的成长。 对杂乱无序说不 对电子杂物说不！太多信息涌进来，远远超过了大脑所能处理的范围 十五、 作战方法C：利用你的身体减轻拖延 正念（mindfulness）指的是“在当下时刻对周遭环境不带判断地保持有意识的觉察” 当他们将注意力放在他们的呼吸上，而没有想要改变任何事情的时候，他们的吸气就开始变得更缓慢、更充分，他们的呼气也会变得更深长。 光是感受到自己活生生的身体和心灵，就已经让你内心充满感激之情。 拖延vs建议十六、 对患有注意力缺失紊乱和执行功能障碍拖延者的一些建议 难以管控冲动和干扰 很重要的一点就是要有策略地去减少干扰的数量，并提醒自己回到正在从事的事情。 自我监督的能力是一项重要的执行功能。 如果你在做这些事情的时候形成了惯例，那么你就不太可能会将它们推迟。 十七、 巧妙应对造成拖延的文化压力 哪里有尴尬和不舒服，哪里就潜伏着拖延的可能性：学生们可能会推迟与家人和老朋友的接触，可能还会拖延功课，阻挡自己在学业上取得进步，这是他们跟原有社交圈减少隔阂的一种方式。 自我怀疑会腐蚀你的自信，打击你尝试新事物和冒险的意愿。 神经科学家认为成人保持大脑活跃的最好办法就是去学习一门新的语言。 十八、 聪明摆脱被动拖延的怪圈 想要拖延者做某件事情，但是他不做。 当你说“只管做”的时候，你强调的是：拖延者没有能力去做每个人都能够做的事情。这让拖延者的感觉更差。 强化了拖延者的期待，他们会更加指望在最后时分有人来拯救他们。 长期来看，将重心放在过程上反而有利于获得一个更好的结果，学习的乐趣会强化学习的动力。 保持你的个人立场 勇气不是不恐惧，而是征服恐惧。 制自己说这样的话，“你为什么不直接去做呢？”或其他一些说法，尤其不要带着恼怒、不信任、蛮横或者其他类似的语调跟孩子说话。 拖延者能够欣赏别人身上的优良品质，但是却无法珍视自己身上的这些品质，他们认为他们就是他们所做的事情。 后记 因此，拖延真的就像一棵蒲公英，不是吗？它具有错综复杂的根须，很难完全根除。请你拔出这些蒲公英，一次一棵，这样你的花园才不会被蒲公英全部占据，你才有空间去种植其他你所喜欢的植物 快乐来自于按照你的价值观健康地生活，来自于跟他人和跟自己内心深处的连通，它还来自于能够接受自己本来的样子，来自于不管拖延是否是你生活的一部分，而仍能够如实地接受它，就像虽然花园里长着一些蒲公英，而你依然能够乐在其中。 你必须要有一段让自我控制稍事放松的时间 关于自我约束能力差，存在着很多不同的解释，但是没有一种解释将它联系到品行问题。 那种适应不良的完美主义者。 就在他们这样的声明中已经反映出他们完美主义的态度。 开放性（理智上的好奇心、创造性和想象力、对艺术与美的欣赏）、宜人性（合作、为他人考虑、关心人际和谐、乐观、诚实）、寻求刺激（这跟冒险稍微有一点联系）和智能等 单单依靠对喜欢和不喜欢的表面汇报就对人们拖延的原因做出解释是一个错误 可能只不过是出于人们对很多生活责任的厌恶这一观点 人们并不总是会做出理性的经济选择 心理学与经济学 人们过份强调了当前事情的重要性，而低估了未来事情的重要性，他将这种倾向称为“未来折扣” 拖延者在对任务重要性的评估上是前后不一致的，而这种不一致导致他很难向着未来目标持续稳定地迈进。 非理性乐观主义跟一个人的自我在时间跨度中的延续感有关 每个人都有给未来打折扣的倾向。 增加一个人对成功的期望是减少拖延的另一个好办法]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>拖延</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-算法设计技巧]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%8A%80%E5%B7%A7.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。欢迎有兴趣学习算法和数据结构，有时间的小伙伴一起参与翻译，欢迎issue，或者直接提交pull request。 当你遇到新问题的时候，需要寻找新的算法。 是否有类似的其它问题？如果您可以根据另一个更普遍的问题来构建解决你目前需要解决问题，那么您可以使用现有算法。 为什么重新发明轮子？ 我喜欢Steven Skiena的算法设计手册，它包含了一系列可以尝试的问题和解决方案。(另见Steven Skiena的算法库) 译注：豆瓣 算法设计手册 可以从暴力方案开始原始而暴力的解决方案通常对实际使用而言太慢，但它们是一个很好的起点。 通过编写暴力解决方案，您将学习如何理解问题的真正含义。 一旦你有一个暴力实施方案，就可以使用它来验证你提出的任何改进是否正确的。 如果您只使用小型数据集，那么暴力方法实际上可能足够好。 不要陷入过早优化的陷阱！ 分而治之 “当你改变你看待事物的方式时，你看到的东西会发生变化。” —— 马克斯·普朗克，量子物理学家和诺贝尔奖获得者 分而治之是一种处理大问题的方法，将其分解成碎片并逐步向解决方案迈进。 不是将整个问题看作一个单一，庞大而复杂的任务，而是将问题分成相对较小的问题，这样问题更容易理解和处理。 您可以解决较小的问题并聚合解决方案，直到您只使用解决方案。 在每个步骤中，手头的问题都会缩小，解决方案会变得成熟，直到您拥有最终正确的解决方案。将问题分解为规模更小的子问题，将这些规模更小的子问题逐个击破，然后将已解决的子问题合并，最终得出“母”问题的解。 将相同的解决方案重复地（或经常递归地）应用于解决较小的任务，从而在更短的时间内获得结果。]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-大O表示法]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%A4%A7O%E8%A1%A8%E7%A4%BA%E6%B3%95.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。欢迎有兴趣学习算法和数据结构，有时间的小伙伴一起参与翻译，欢迎issue，或者直接提交pull request。 知道某个算法的运行速度和占用的内存空间，对于选择正确的算法来解决问题非常有帮助。 大O表示法 能让你对一个算法的运行时间和占用内存有个大概概念。当有人说，“这个算法在最糟情况下的运行时间是 O(n^2)，而且占用了 O(n) 大小的空间”时，他的意思是这个算法有点慢，不过没占多大内存。 要知道一个算法的大O 表示法通常要通过数学分析。在这里我们不会涉及具体的数学，不过知道不同的值意味着什么会很有用。所以这里有一张方便的表。n 在这里代表的意思是数据的个数。举个例子，当对一个有 100 个元素的数组进行排序时，n = 100。 Big-O表示符号 名字 描述 O(1) 常数级 最好的。不论输入数据量有多大，这个算法的运行时间总是一样的。例子: 基于索引取出数组中对应的元素。 O(log n) 对数级 相当好。这种算法每次循环时会把需要处理的数据量减半。如果你有 100 个元素，则只需要七步就可以找到答案。1000 个元素只要十步。100,0000 元素只要二十步。即便数据量很大这种算法也非常快。例子：二分查找。 O(n) 线性级 还不错。如果你有 100 个元素，这种算法就要做 100 次工作。数据量翻倍那么运行时间也翻倍。例子：线性查找。 O(n log n) 线性对数级 还可以。比线性级差了一些，不过也没那么差劲。例子：最快的通用排序算法。 O(n^2) 二次方级 有点慢。如果你有 100 个元素，这种算法需要做 100^2 = 10000 次工作。数据量 x 2 会导致运行时间 x 4 (因为 2 的 2 次方等于 4)。例子：循环套循环的算法，比如插入排序。 O(n^3) 三次方级 特别慢。如果你有 100 个元素，那么这种算法就要做 100^3 = 100,0000 次工作。数据量 x 2 会导致运行时间 x 8。例子：矩阵乘法。 O(2^n) 指数级 超级慢。这种算法你要想方设法避免，但有时候你就是没得选。加一点点数据就会把运行时间成倍的加长。例子：旅行商问题。 O(n!) 阶乘级 比蜗牛还慢！不管干什么都要跑个 N 年才能得到结果。 以下是每种大O表示法的示例： O(1) O(1)复杂性的最常见示例是访问数组索引。 1let value = array[5] Another example of O(1) is pushing and popping from Stack. 另外一个O(1)的例子是栈的推进和弹出。 O(log n) 12345678910111213141516 var j = 1 while j &lt; n &#123; // do constant time stuff j *= 2 &#125; ``` 不是简单地递增，'j'在每次运行中增加2倍。二分搜索算法是O(log n)复杂度的示例。**O(n)** ```swift for i in stride(from: 0, to: n, by: 1) &#123; print(array[i]) &#125; 数组遍历和线性搜索是O(n)复杂性的示例。 O(n log n) 1234567for i in stride(from: 0, to: n, by: 1) &#123;var j = 1 while j &lt; n &#123; j *= 2 // do constant time stuff &#125;&#125; 或 12345678for i in stride(from: 0, to: n, by: 1) &#123; func index(after i: Int) -&gt; Int? &#123; // multiplies `i` by 2 until `i` &gt;= `n` return i &lt; n ? i * 2 : nil &#125; for j in sequence(first: 1, next: index(after:)) &#123; // do constant time stuff &#125;&#125; 合并排序和堆排序是O(n log n)复杂度的示例。 O(n^2) 12345for i in stride(from: 0, to: n, by: 1) &#123; for j in stride(from: 1, to: n, by: 1) &#123; // do constant time stuff &#125;&#125; 遍历简单的二维数组和冒泡排序是O(n^2)复杂度的示例。 O(n^3) 1234567891011121314151617181920212223 for i in stride(from: 0, to: n, by: 1) &#123; for j in stride(from: 1, to: n, by: 1) &#123; for k in stride(from: 1, to: n, by: 1) &#123; // do constant time stuff &#125; &#125; &#125; ``` **O(2^n)** 具有运行时间O(2^N)的算法通常是递归算法，其通过递归地解决大小为N-1的两个较小问题来解决大小为N的问题。 以下示例打印了解决著名的N盘“汉诺塔”问题所需的所有动作。 ```swift func solveHanoi(n: Int, from: String, to: String, spare: String) &#123; guard n &gt;= 1 else &#123; return &#125; if n &gt; 1 &#123; solveHanoi(n: n - 1, from: from, to: spare, spare: to) &#125; else &#123; solveHanoi(n: n - 1, from: spare, to: to, spare: from) &#125; &#125; O(n!) 下面给出了O(n!)的最简单的例子。 12345func nFactFunc(n: Int) &#123; for i in stride(from: 0, to: n, by: 1) &#123; nFactFunc(n: n - 1) &#125;&#125; 大部分情况下你用直觉就可以知道一个算法的大O 表示法，不需要使用数学。比如说，如果你的代码用一个循环遍历你输入的每个元素，那么这个算法就是 O(n)。如果是循环嵌套循环，那就是 O(n^2)。如果3个循环嵌套在一起就是 O(n^3)，以此类推。 注意，大O 表示法只是一种估算，当数据量大的时候才有用。举个例子，插入排序的最糟情况运行时间是 O(n^2)。 理论上来说它的运行时间比归并排序要慢一些，归并排序是 O(n log n)。但对于小数据量，插入排序实际上更快一些，特别是那些已经有一部分数据是排序好的数组。 如果你看完没懂，也不要太纠结了。这种东西仅仅在比较两种算法哪种更好的时候才有点用。但归根结底，你还是要实际测试之后才能得出结论。而且如果数据量相对较小，哪怕算法比较慢，在实际使用也不会造成太大的问题。]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>swift</tag>
        <tag>Big-O</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-为什么要学习算法与数据结构？]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。欢迎有兴趣学习算法和数据结构，有时间的小伙伴一起参与翻译，欢迎issue，或者直接提交pull request。 如果你已经写过一些代码，你也许就会好奇学习算法和数据结构的意义何在，特别是如果你没有接受过计算机科学专业的高等教育。 毕竟，在平时的编码工作中，到底会有多少机会需要自己亲自编写一个链表或排序算法呢？答案是：可能永远都不会。 然而…了解一点现有算法解决问题时所用的奇技淫巧可能会给予你启发，让你能更好地优化自己的代码。 除了自带的标准数组和字典之外，了解一些其它的数据结构让你在构建自己的 App 时拥有更多的选择。 学习算法和数据结构会助你成为更好的开发者！（当然也就意味了可以赚到更多的$$$） 运用算法能让你编写出其它方式编写不出的软件过去曾经在编写 App 时遇到过瓶颈，无法继续编写下去，因为我陷入到了一些基础的问题中，无法自拔。 通常的瓶颈都是运行速度的问题，我的 App 不够快。现在回想起来，原因多是我在解决问题是选用了错误的算法。如果我当时知道 O(n) 和 O(n^2) 之间的区别，或许就能克服这些瓶颈了。 对于小规模的数据量简单粗暴的方法往往能很好的完成工作，但事情并不总是如人所愿。对于大数据量，你需要使用更加聪明的算法。 有些时候，我对自己所面对的问题根本就手足无措，甚至写不出来一个运行较慢的正确算法，不知道从何处下手。这时候，如果了解一些算法理论，就会有更多的方法可供尝试。 不要死记硬背算法实现本文的目的不在死记硬背算法实现。你应该试着去理解不同的算法是如何解决不同的问题的，而不是死记硬背。 学习一些算法技术，例如：分而治之、动态规划、贪婪算法等，可以助你更好地理解算法之间的快慢差异，并学会在算法对时间和空间的使用上做出平衡。 所以本项目的主要目的是教会你如何更好的跟计算机打交道。 放轻松，算法并没有听起来那么可怕很多算法书开篇就摆上来很多数学理论，数学公式固然有用，但初学并不需要。所以不要被那些公式吓到了。只要写过代码，你就能很好地理解那些神奇的算法和数据结构背后的原理。 相信我，算法是很有趣的。:-)]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【译】Swift算法俱乐部-什么是算法和数据结构？]]></title>
    <url>%2F2018%2FSwift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%97%E6%B3%95%E5%92%8C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9F.html</url>
    <content type="text"><![CDATA[本文是对 Swift Algorithm Club 翻译的一篇文章。Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。andyRon/swift-algorithm-club-cn是我对Swift Algorithm Club，边学习边翻译的项目。欢迎有兴趣学习算法和数据结构，有时间的小伙伴一起参与翻译，欢迎issue，或者直接提交pull request。 什么是算法和数据结构？一个算法就像一张教计算机“烹饪”的“食谱”。如果你了解做菜的过程，你就能理解算法的定义。 下面有一张关于制作薄饼的食谱： 在一个大碗里，将面粉，发酵粉，盐和糖过筛。 加入牛奶、鸡蛋和融化了的奶油。 搅拌混合直至丝柔顺滑。 中火加热平底锅。 将搅拌好的面糊缓慢倒入锅中，每个薄饼大概用1/4杯的面糊即可。 薄饼两面都呈黄褐色即可出锅享用了。 这张食谱由一系列的步骤组成，你只需一步接一步按照指令来就可以了。算法也是如此，只不过它的指令是交给计算机去执行的，而不是厨师。 这些原料(面粉、牛奶、鸡蛋、黄油等)相当于算法中的待处理数据。这些原始数据(各种不同的原料)作为算法的输入，输出的数据(好吃的薄饼)即是结果。 那么数据结构是什么？它们是在算法运行时保存数据的容器。例如，在煎饼配方中，数据结构是用于盛放面粉的袋子，是用于将所有东西组合在一起的搅拌碗，是用于煎饼的煎锅，是最后用于盛放成品煎饼的盘子。]]></content>
      <categories>
        <category>swift-algorithm-club-cn</category>
      </categories>
      <tags>
        <tag>算法与数据结构</tag>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于字符编码]]></title>
    <url>%2F2018%2Fascii-unicode-utf8.html</url>
    <content type="text"><![CDATA[作为一名程序员，对编码问题有必要了解一下。计算机是以二进制形式存储数据的，至于为什么选择二进制，这可能就需要从计算机的诞生历史说起了，这不是现在关注的点。 计算机文件一般可以分为（暂且这样分吧）：文本文件和二进制文件。通俗的说，文本文件就是平常通过某个软件（记事本，EditPlus，UltraEdit，sublime等各种编辑器，各种IDE等等）打开看到是‘字符’，二进制文件就是打开是图片或视频等，当然是通过某些能够解释二进制的程序来完成。这里需要强调的是，文件的后缀名不能用来区分文件的类型，后缀名只是系统（特别是Windows）用来对文件进行预先分类，并给予对应的图标和相应双击后打开的程序，至于预先给定的程序能不能打开就不得而知。如，在Windows下，把一个txt文件的后缀名改成jpg后：变成 双击打不开，用记事本依然能打开，就是内部编码没变，其实文件的类型在编码成二进制形式已经确定（一般是在头部）。 php读取图片文件：12$a = file_get_contents(&apos;bg.png&apos;);echo $a; 浏览器以UTF8形式打开图片的二进制形式，虽然大部分是乱码，但头部还是可以看到解码为PNG的： 字符编码字符编码就是每个在电脑里出现的字符都会对应一个二进制数，这个二进制可以成为码点(code point)。不同的编码形式，包含的字符数不同，字符和二进制数对应关系也不同。 ASCII码ASCII(American Standard Code for Information Interchange)码是 比较早的编码形式，总共定义128个字符，用了一个字节的7位，也就是从 0000 0000 到 0111 1111 。 0-32, 127：（共34个）不能直接显示字符的（控制或者通信使用的），32是空格也算在其中，127是删除符； 33-64,91-96,123-126：（共21*2=42个）键盘上除了英文字母和不直接显示字符的键有21个，每一个键上有两个字符； 65-90,97-122：（26*2=56个）英文字母； 对于英语系的人来说这128个字符已经够了，他们在电脑上接触的的字符也就这么多够了，说来也是奇特，英文字符26个就能通过组合用来表示英语所有意思，这种组合形式很适合计算机。而我们汉语就不同了，我想是不能通过笔画的组合组成所有汉字了。据说汉语是最难学的语言之一😅，辛亏我已经会汉语了😀😝。 Unicode128个字符对于其他语言是远远不够的，单汉字就有将近10万个（常用应该几千个），每个汉字都需要一个码点，其他语言中的字符也需要对其字符编码成码点，原本有很多编码方式，这些编码没有进行统一规定，就会有冲突，一个二进制数在不同编码方式中就有可能解释为不同的字符，这样使不同地区的人交流不便。 Unicode就是在这样条件下诞生，简单的说，Unicode就是大的映射表，把全世界所有语言符号都包含其中，每个符号的映射的码点的都不相同。 汉字大部分可以用4个16进制数表示，参看汉字Unicode。如：U+620E表示戎(这是我的姓，读róng，不是 戒，在这里普及一下，我已经被叫成 戒某 无数次了🤦‍♀️🤦‍♀️🤦‍♀️)。 Unicode是一个庞大的字符集，一个很多字符与二进制数的唯一的一一对应集合。Unicode没有规定怎么存储，620E（0110 0010 0000 1110）至少需要2个字节，而其他字符可能需要更多字节。像U+0041表示英文字母A，如果也需要用2个字节或者更多，则前面的有一些字节都是0，那么太浪费资源了，为了减少空间的浪费就出现了UTF8。 UTF8UTF8是Unicode存储一种实现方式。它采用变字节数（1-4个）来节约资源。 UTF-8的编码规则很简单，只有二条： 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的Unicode码。因此对于英语字母，此时UTF-8编码和ASCII码是相同的。 对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的Unicode码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围(十六进制) UTF-8编码方式 (二进制） 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 这样解读UTF8编码就容易区分几个字节表示一个字符了。如果一个字节的第一位是0，那么这个字节单独表示一个字符；如果一个字节的第一位是1，那么这个字节下面连续几个1，就表示当前字符占用几个字节。 以汉字戎为例，看看UTF8编码实现过程： 已知戎的Unicode是620E（0110 0010 0000 1110）。 620E 在第三行范围内（0000 0800 - 0000 FFFF），因此需要三个字节编码戎，即 1110xxxx 10xxxxxx 10xxxxxx 从戎的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。得戎的UTF8编码的十六进制是E6888E。 参考：字符编码笔记：ASCII，Unicode和UTF-8]]></content>
      <categories>
        <category>暂时没想到怎么分类</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
        <tag>Unicode</tag>
        <tag>UTF8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《畅销的原理》——作为消费者，我不想被商家牵着鼻子走]]></title>
    <url>%2F2018%2F%E7%95%85%E9%94%80%E7%9A%84%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[作者和本书概要马修·威尔科克斯（Matthew Willcox），博达大桥广告公司（FCB）决策制定研究所的创立者和执行常委。博达大桥广告公司（FCB）是世界最早的广告公司之一，也是全球最早上市的广告公司之一。马修在品牌战略领域已经有25年的从业经历，足迹遍布欧洲、亚洲和北美洲。他服务过李维斯、美国艺电、希尔顿酒店集团、联合利华、雀巢、壳牌和葛兰素史克等大企业。 《畅销的原理》，作者在书里总结了自己25年的广告和营销从业经验，以及半个世纪以来人类行为和神经科学的研究成果，揭秘营销的本质以及如何刺激大脑做出决策。 内容一、营销的本质 营销的本质是：影响选择，使事情变得直观，让别人轻易就能选择你的商品和服务 品牌方针：想尽办法找到用户喜欢啥，再看看自己的商品有啥好的地方能够迎合他们的喜好。 大脑方针：从大脑做决策的过程出发，去研究怎么影响消费者的每一次选择，每一次营销行为都是一次影响选择的过程。 品牌的重要性也在逐渐降低，品牌对消费者的吸引力在下降。传统营销中的品牌方针逐渐变得不适用，应转为以大脑决策为出发点的大脑方针。 二、刺激大脑做出选择的方法1)成为用户心里的“老熟人”先让商品成为消费者生活中反复出现的“老熟人”，产生熟悉度，在此基础上，再通过制造 小惊喜和小新奇 让消费者持续关注。 🌰：在一个各种声音混杂的鸡尾酒会上，无论多么吵闹，只要有人喊我们的名字，我们总能听得到，这就是认知神经科学中一个著名的现象，叫做“鸡尾酒会效应”，说的就是熟悉和相关的事物会受到人们的重点关注。 🌰：登机或者入住酒店时，升舱或者换更好的房间会让我们获得意外惊喜。这份高兴不仅仅是因为感觉受到了优待，还因为我们的大脑感受到因为自己的好决策带来了好回报，所以，在第二次面临选择时，大脑会做出同样的决策。 2)制造稀缺展望理论(prospect theory，也作前景理论)：通过考虑损失和保存所得的决策行为。前景理论的一个表现就是人们特别讨厌损失，不愿放弃已经得到的东西。 利用大脑害怕失去的本能，可以制造稀缺感，从而驱动消费者的各种行为。 🌰：打客服电话的时候，我们经常会听到“坐席正忙”，同样都是让用户等待，为什么不把语音录制成“马上就有人接听电话”呢？马上就有人接听难道不是对用户更友善吗？其实，这是营销人员的一种营销手段。研究表明，当人们听到“坐席正忙”时，会产生这种服务很稀有的感觉，这种稀缺感让人们害怕失去的感觉更强烈，人们就更愿意继续等待。 禀赋效应(Endowment effect)：人们会高估已经拥有的东西。 🌰：人们不愿意交换自己购买到的彩票，因为人们都认为自己买的彩票中奖概率高。 3)用轻松打动客户人类永远偏好最容易的那条路，大脑喜欢简单。 行动上的便利 和 精神上的放松。 🌰：要想人们吃得健康，可以把健康食品放在餐厅最显眼的地方，用灯光突出陈列，让人们一眼就能看到，伸手就能拿到。总之，就是让健康食品的选项成为最省力的选项。 4)利用时间的力量系列位置效应(serial-position effect)：人们倾向于对首先见到的事物和最后见到的事物有更好的印象。 🌰：背单词的时候，如果能把一本单词书从头背到尾，往往是 A、Z 开头的单词容易记住，中间部分的单词记得就没那么好了。 强势结尾理论， 最后一步一定要做好，给消费者留下一个好的结尾。销售人员如何与消费者道别，要比如何欢迎他们更重要。🌰：一位司机在高速公路上开车时，看到了同样多的红色汽车和蓝色汽车，但如果在下高速的时候他看到的是一辆红色汽车，那么他会认为自己一路上看到的红色汽车更多。 参考：得到-每天听本书]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心理学</tag>
        <tag>营销</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-5-iP协议相关技术]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-5.html</url>
    <content type="text"><![CDATA[这是学习《图解TCP/IP（第5版）》的一篇笔记。 仅凭IP无法完成通信 1 DNS 2 ARPARP(Address Resolution Protocol)，以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。 ARP的工作机制ARP借助ARP请求与ARP响应两种类型的包确定MAC地址。 RARPRARP(Reverse Address Resolution Protocol)，从MAC地址定位IP地址的协议 代理ARP3 ICMPICMP的主要功能：确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网路设置等。 4 DHCPDHCP(Dynamic Host Configuration Protocol)，实现自动设置IP地址、统一管理IP地址分配。 DHCP工作机制 5 NATNAT(Network Address Translator)，用于本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。 6 IP隧道]]></content>
      <categories>
        <category>计算机网络</category>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读《设计心理学1》——好的设计是有章可循的]]></title>
    <url>%2F2018%2F%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A61.html</url>
    <content type="text"><![CDATA[作者和本书概要唐纳德·诺曼(Donald Arthur Norman)，曾被美国《商业周刊》评为全球影响力设计师之一。美国认知心理学家、计算机工程师、工业设计家，认知科学学会的发起人之一。现为美国西北大学计算机科学系和心理学教授，是尼而森-诺曼集团(Nielsen Norman Group)咨询公司的创办人之一，苹果计算机公司先进技术部副总裁。1999年，Upside杂志提名诺曼博士为世界100精英之一。2002年，诺曼获得了由人机交互专家协会(SIGCHI)授予的终身成就奖。作为一个以人为中心的设计的倡导者，诺曼最著名的书就是《设计心理学》。 《设计心理学》最早出版于1988年，是设计学的经典入门书籍。2013左右，作者对这套书大幅度增加和完善，现在《设计心理学》 有四本书： 《设计心理学1：日常的设计》 《设计心理学2：与复杂共处》 《设计心理学3：情感化设计》 《设计心理学4：未来设计》 本文是对《设计心理学1：日常的设计》的读书笔记。 内容一、什么是好设计 可视性，就是让用户知道这个产品怎么用，怎么操作才是合理的。 🌰，门的把手让用户知道门是拉的或推的，或是左右移动的。 易通性，就是要让用户明白你的设计意图，明确的告诉用户，你设计的这个东西是干什么用的。 🌰，电视遥控器太多的键，让用户不知所谓 为什么有那么多的糟糕设计？ 因为很多产品都是工程师做的，工程师都是受过严格逻辑训练的人，他们天然地以为，所有人都应该按照逻辑思考，所以他们设计出来的产品往往都“不近人情”。 🔥作为工程师的我，要时刻注意这一点，不要任何时候都太注重逻辑。 二、交互设计的五个基本原则 示能（显示能力）： 指某些物体本身就有的、特定的交互方式，不需要解释，它直接就可以被感知到。 🌰：一把椅子，不管它怎么设计，一定会有一个平面，咱们还是能认出它是一把椅子，可以坐人。这里面的“平面”，就是一种示能。一出现平面，人们就会天然地认为，这个地方是可以坐的。 意符： 是一种提示，告诉用户可以采取什么行为。 🌰：有些商场的大门上，会写上“推”或者是“拉”的提示，这个推和拉就是一种意符。 意符不仅可以用视觉的方式来展现，声音也可以起到意符的作用。🌰：门锁锁好的时候，会发出“咔嚓”一声。面包片烤好之后从面包机里跳出来的声音。这些声音都是一种意符，能传达给人某种信息。 🌰：汽车发动机的声音会给人一种安全警告⚠️，现在电动车没有那种声音，有时就电动机就需要模仿汽车发动机的声音来给人警告。 约束 很多东西咱们以前都没用过，但为什么总是能很快上手呢？这就是约束在设计里起到的作用。 🌰：比如一辆乐高的玩具摩托车，即便你以前没玩儿过，也能很快就把它组装起来。因为它的轮子只能装在前叉上，手臂只能装在小人的躯干上，每个部件的接口都不一样，可以执行的操作就那么几种，多尝试几次，我们就能把这个玩具摩托车组装好。 映射 最好的映射，就是控制开关直接安装在被控制的对象上。 🌰：触屏手机比按键手机好 如果做不到这么直接的映射，那就尽量把开关装到被控制对象的附近。 🌰：有两个灶眼的煤气灶，开关就会分别装到两个灶眼的旁边。 如果这也做不到，那就要让开关和被控制对象的空间分布保持一致。 🌰：墙面上的开关和屋顶的吊灯，要有明确的映射关系。 反馈一个好的设计，一定要有及时的反馈。当然，反馈也不能太频繁，这会打扰到用户。 🌰：很多遥控器按一下就会发出“滴”的一声，完成一个操作要按好几下遥控器，这时候连续的滴滴声就会搞得人心烦意乱。 三、人为差错往往来源于糟糕的设计人不是机器，不能要求人做出违反自然规律的事情,比如要求人好几个小时保持高度警惕的状态，或者同一时间处理好几个任务，这几乎是不可能的，肯定会有人会出错。 面对问题的时候，多问几个为什么，能促进人们更多思考，也能到最根本的原因，发现设计问题。 五个为什么：12345678战斗机失事，查找原因：为什么飞机失事？ 因为它当时失控了不断向下俯冲。飞机员为什么没有把俯冲状态下的飞机恢复到正常状态？ 因为飞行员没有及时启动恢复装置。为什么他没有启动恢复装置呢？ 可能是因为他当时缺氧了或者是恢复装置按钮太小了。... 四、怎么设计，才能避免人们操作失误 约束 🌰：比如在银行办理业务，填写完信息之后，人们很可能顺手就把营业窗口的笔装到自己兜里了，为了避免这种失误，银行就把笔拴在窗口上，这个小约束就能减少人们的失误。 🌰：ATM机，如果约束先拔卡后取钱 就可以避免忘记取卡 强制 🌰：在没有断电的情况下打开微波炉是非常危险的，为了防止这个错误，微波炉就可以被设计成在开门的一瞬间，也同时断开电源。 🌰：割草机，弹簧开关，按着才能使用 故意制造困难 🌰：很难打开的药瓶，就可以防止小孩吃错药，但还不影响大人平时正常使用。 二次确认、撤销 🌰：很多电脑软件，在你点击关闭之后，都会弹窗提醒你，是否确认关闭。还可以加上撤销功能，比如电脑的“回收站”功能。 五、“以人为本”的设计思维“以人为本”，不仅是价值观，还是方法论。它可以指导我们的行动。学会定义问题，工程师解决问题强 观察 设计师不会一开始就聚焦于解决方案，而是会先分析隐藏在问题之下的本质原因，找到问题的本质，才开始下一步的行动。设计师还会去找潜在用户，观察他们的行为，理解他们的兴趣爱好、动机以及真实需求。通过这些信息，来定义设计要解决的真正问题。 当然要在用户自然状态下观察。 创意 在创意的初期，要发散思维，让人们尽量多提出新点子，这个阶段千万不要急着批判，不管人们说出什么点子，都要记下来。等有了一堆点子的时候，再进行筛选整合，挑出最好的点子进行下一步。 打样 要想知道一个创意是不是合理，唯一的方法就是测试。所谓的打样，就是用草图，或者是模型，快速做出一个可以展示的样品出来。 测试 先找一小部分目标用户，让他们使用样品，这个过程一定要自然，尽量还原到真实的使用场景里。得到反馈之后。 再次重复上面四个步骤：观察、创意、打样、测试。直到设计出能真正解决用户需求，并且有良好用户体验的产品为止。 参考：得到-每天听本书]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心理学</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《赤裸裸的统计学》——面对爆炸的数据，了解统计学是很有必要的]]></title>
    <url>%2F2018%2F%E8%B5%A4%E8%A3%B8%E8%A3%B8%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6.html</url>
    <content type="text"><![CDATA[作者和本书概要查尔斯•惠伦（Charles Wheelan），于1997～2002年间担任《经济学人》杂志驻美国中西部地区的记者，还为《芝加哥部报》、《纽约时报》和《华尔街日报》撰稿，所著《赤裸裸的经济学》是畅销多年的经济学普及读物。 《赤裸裸的统计学》是一本关于统计学常识的科普书。 内容作为大数据时代炙手可热的学问，统计学可以解决很多实际问题。可如果运用不当，统计学也会制造假象、造成误导。 了解统计学，了解在大数据时代生存的游戏法则。 运用好统计学知识，能让我们在面对陌生问题的时候，得出有说服力的结论，做出合理的决策。统计学家的工作：通过分析数据来推断事物的本质，预测它未来的发展。 一、大数定律大数定律 的数学表达：当试验次数足够多时，实验结果的平均值会无限地接近一个数值，这个数值一般叫做“期望值”。 彩票：发行机构只要保证彩票的销售额大于奖金期望值，就肯定赚钱。 赌场：只要能吸引到足够数量的赌客，不管幸运儿赢走多少钱，赌场永远是最后的赢家。 投资风险承受能力越强，意味着允许试验的次数越多，也就越有可能赚到期望的投资回报。 保险行业 二、中心极限定理中心极限定理： 任意一个群体样本的平均值，都会围绕在这个群体的整体平均值周围。 任意群体样本的平均值≈整体平均值 例子🌰： 假如你烧了一锅汤，想知道味道怎么样，没必要把汤都喝光，只要尝一小勺就可以了，任意一勺汤的味道绝不会相差很远。 三、随机抽样选取代表性样本的过程就是随机抽样。 注意偏见。 选择性偏见 幸存者偏见 健康用户偏见 四、回归分析回归分析 ：通过一个已知的现象，来找到未知的原因。多元线性回归方程模型。研究复杂统计学问题的必备工具。保持理性的态度。 五、常犯的错误 “黑天鹅事件”：一般用来指那些影响很大，但难以预测的小概率事件。 美国次贷危机，致命问题是它的概率学模型参照的是过去20年的市场行为，不能对未知的意外情况做出预测。 统计误差： 只要数据分析建立在抽样调查之上，样本的统计结果和真实情况之间就会存在误差。 六、总结精确有时候并不意味着准确。 概率学本身不会犯错，犯错的是使用它的人。 随着大数据时代的到来，转变自己对周围世界的认知方式非常重要。 参考：得到-每天听本书]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>统计学</tag>
        <tag>大数据</tag>
        <tag>大数定律</tag>
        <tag>期望值</tag>
        <tag>随机抽样</tag>
        <tag>中心极限定理</tag>
        <tag>回归分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-4-IP协议]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-4.html</url>
    <content type="text"><![CDATA[这是学习《图解TCP/IP（第5版）》的一篇笔记。 TCP/IP的心脏是互联网层，包括IP(Internet Protocol)和ICMP(Internet Control Message Protocol)两个协议。 1IP即网际协议 主机：配置IP地址，但不进行路由控制的设备。路由器：配置IP地址又有路由控制的设备。节点：主机和路由器的统称。 2IP基础知识IP地址属于网络层地址路由控制IP路由也叫多路路由 为了将数据包发给目标主机，所有主机都维护这一张路由控制表（Routing Table） 数据链路的抽象化不同数据链路最大区别是最大传输单位（MTU，Maximum Transmission Unit）。 IP属于面向无连接型面向无连接是指在发包之前，不需要建立与对端目标地址之间的连接。 这样做的原因： 简化 提速 为了提高可靠性，上一层的TCP采用面向有连接型 3IP地址的基础知识IP地址组成IP地址组成： 网路标识（网络地址）， 主机标识（主机地址） IP地址的分类 广播地址IP多播 子网掩码 CIDR与VLSM0、10、27等开头的A类地址都是具有特殊意义的保留地址。 全局地址与私有地址4路由控制IP地址与路由控制 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。 在Windows和Unix上表示路由器的方法分别为netstat-r， netstat-rn。 环回地址：同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。 127.0.0.1 路由控制器的聚合 5IP分割处理与再构成处理 IP报文的分片与重组经过分片之后的IP数据报在背重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。 路径MTU发现 6 IPv67 IPv4首部8 IPv6 首部格式]]></content>
      <categories>
        <category>计算机网络</category>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-3-数据链路]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-3.html</url>
    <content type="text"><![CDATA[这是学习《图解TCP/IP（第5版）》的一篇笔记。 1数据链路的作用二进制0、1表示信息，在通信媒介中对应的是电压的高低、光的闪灭以及电波的强弱等信号。 数据链路被视为网络传输中的最小单位。 不同的数据链路网路：以太网FDDI（Fiber Distributed Data Interface，光纤分布式数据接口）ATM（Asynchronous Transfer Mode，异步传输方式）无线LAN蓝牙 网络拓扑（Topology） 2数据链路相关技术2.1MAC地址MAC地址长48比特，一般被烧入到ROM中。任意一个网卡的MAC地址是全世界唯一的（虚拟网卡除外）。 厂商识别码（OUI, Organizationally Unique Ideifier），可通过网络分析器分析得到。 2.2共享介质网路：多个设备共享一个通信介质 争用方式（Contention），也叫 CSMA（载波监听多路访问） CSMA/CD (Carrier Sense Multiple Acess with Collision Detection) 令牌传递方式只有获得令牌的站才能发送数据 2.3非共享介质网络 半双工与全双工通信 2.4 根据MAC地址转发交换集线器 也叫 以太网交换机 2.5 环路检测技术2.6 VLAN3以太网以太网（Ethernet）源于Ether（以太），意为介质。 以太网的分类BASE前的10、100、10G等代表传输速度，BASE后的2、5、T、F等字符代表传输介质。 以太网传输速度与计算机内部的表现值不同，以太网中是1000（1K=1000，1M=1000K等），而计算机内部是1024。 4无线通信 5PPPPPP(Point-to-Point Protocol) 点对点]]></content>
      <categories>
        <category>计算机网络</category>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-2-TCP/IP基础知识]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-2.html</url>
    <content type="text"><![CDATA[这是学习《图解TCP/IP（第5版）》的一篇笔记。 1TCP/IP出现的背景及其历史军用技术ARPANET UNIX系统的普及与互联网的扩张 商用互联网服务的启蒙 ISP 2TCP/IP的标准化 TCP/IP协议群 TCP/IP规范 —- RFCRFC(Request For Comment，征求意见表) TCP/IP的标准化流程 互联网草案阶段 -&gt; 记入RFC进入提议标准阶段 -&gt; 草案标准阶段 -&gt; 真正的标准阶段 3互联网基础知识 互联网结构 4TCP/IP协议分层模型 硬件（物理层） 网络接口层（数据链路层） 互联网层（网络层）连接互联网的所有主机跟路由器必须实现IP的功能，其它连接互联网的网络设备（如网桥、中继器或集线器）就没有必要一定实现IP或TCP的功能（有时为了监控和管理这些设备就要了）。 ARP：从分组数据包的IP地址中解析出物理地址（MAC地址）的协议 传输层 ： 让应用程序之间实现通信 应用层 5TCP/IP分层模型与通信示例 每个分层的包首部中还包含一个识别位。]]></content>
      <categories>
        <category>计算机网络</category>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-1-网络基础知识]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-1.html</url>
    <content type="text"><![CDATA[这是学习《图解TCP/IP（第5版）》的一篇笔记。 现在TCP/IP不局限于链接计算机，还可以链接汽车、数码相机、家电等，另外还应用在计算机系统虚拟化和云计算。 1计算机网络出现的背景 从独立模式到网络互连模式WAN（Wide Area Network， 广域网），LAN（Local Area Network，局域网） 从计算机通信到信息通信 2计算机与网络发展的7个阶段 批处理（batch processing）： 事先先将用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取 分时系统（time sharing system ，TSS）(1960s)：多个终端与同一个计算机连接，允许多个用户同时使用一台计算机的系统。 独占性、多路性、交互性、及时性 BASIC 计算机之间的通信 (1970s) 多台计算机分布式处理 通信线路 计算机网络的产生 (1980s)分组交换技术 窗口系统 互联网的普及 (1990s) 以互联网技术为中心 (2000s)电话网 -&gt; IP网 从“单纯建立连接”到“安全建立连接” TCP/IP 3协议 协议就信是计算机之间通过网络实现通时事先达成都的一种“约定”。协议如同人与人的对话：将汉语和英语当作“协议”将聊天当作“通信”将说话的内容当作“数据” cpu通常同一时间只能运行一个程序。乱转机制 多任务调度 人与人之间交流的容错率很高，而计算机不一样，计算机之间交流要注意“应对异常”。 分组交换协议 是将大数据分割成包（Packet）的较小单位进行传输的方法。 4协议由谁规定 ISO（International Organization for Standards, 国际标准化组织）制定了国际标准OSI（Open System Interconnection, 开放式通信系统互联参考模型） 5协议分层分层 类似模块化开发。“接口” 上下层之间交互所遵循的约定“协议” 同一层之间交互所遵循的约定 分层的优势：独立使用（扩展灵活），细分通信功能。 分层的劣势：过分模块化，使处理变得更加沉重以及每个模块都不得不实现相似的处理逻辑 OSI参考模型各个分层的作用 6OSI参考模型通信处理举例假设用户A使用主机A要给使用主机B的用户B 在应用层 在表示层表示层将数据从主机特有的格式转换为网络标准传输格式。不同计算机对数据在内存中相异的分配方式（如：大实体和小实体） 在会话层会话层决定采用哪个链接发送（何时连接，何时发送，但没有实际传输数据的功能） 在传输层：实际传输数据 网络层 网络层与传输层相互协作以确保数据包能够传送的世界各地，实现可靠传输。 数据链路层、物理层 数据链路层通过传输介质互连的设备之间进行数据处理 物理层将数据的0、1转换为电压和脉冲传输给物理的传输介质，而相互直连的设备之间使用地址（MAC地址）实现传输 7传输方式的分类 面向有连接型与面向无连接型 电路交换（历史久，主要用于电话网）和 分组交换（蓄积交换） 根据接收端数量分类 单播（unicast） 广播（broadcast) 电视播放 多播（multicast） 电视会议 任播（anycast） DNS根域名解析服务器 8地址1.地址的唯一性 在同一个通信网络中不允许有两个相同地址的通信主体存在。2.地址的层次性 为了高效地从越来越多的地址中找出通信的目标地址。 ip地址具有层次性 MAC寻址 参考 地址转发表(记录实际的MAC地址)IP地址 参考 路由控制表(记录之后的网络号和子网掩码) 9网络的构成要素 9.1通信媒介与数据链路 传输速率，单位bps(Bits Per Second, 每秒比特数)， 又称为 带宽(Bandwidth) 吞吐量：主机之间实际的传输速率。吞吐量不仅衡量带宽，也衡量主机的CPU处理能力、网络的拥堵程度、报文中数据字段的占有份额等信息。 9.2网卡网卡，全程网络接口卡（NIC, Network Information Center），也称网络适配器、LAN卡。 9.3中继器(Repeater)波形调整和放大中继器无法改变传输速率有多个端口服务的中继器被称为 集线器 9.4网桥/2层交换机 自学式网桥会记住曾经通过自己转发的所有数据帧的MAC地址，并保存到自己里的内存表中。 交换集线器 是网桥的一种 9.5路由器/3层交换机 网络是根据物理地址（MAC地址）进行处理，而路由器/3层交换机则是根据IP地址进行处理的。 9.6 4~7层交换机 9.7网关 典型例子是互联网邮件与手机邮件之间的转换服务。 代理服务器也是网关的一种，成为应用网关 防火墙]]></content>
      <categories>
        <category>计算机网络</category>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《我所理解的生活》记录]]></title>
    <url>%2F2018%2F%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E7%94%9F%E6%B4%BB.html</url>
    <content type="text"><![CDATA[注： 本文是我几年前的记录，整理时发现还可以再看看。 序我所理解的生活就是除了造谣以外，去造其他一切东西。 这世道让那些不说粗话但最缺德的人能做道德评判家，这世道让那些话不脏但心眼脏、手段脏的人当道。 我所理解的生活就是做着自己喜欢的事件，养活自己，养活家人。 你在台面上看见我成功一次，我在台面下就干砸十次，那又如何，我又没死，不停地干就行了，人们只会记住你成功的那一次。 我只负责制造作品，不负责用户体验，也没有售后服务，更不会根据大家的口味来改进。 充满挫败甚至后悔，但遗憾并不多。 得之我幸，不得我也没什么不幸。 国事我走得“肤浅”， 几乎所有人都和气。 除了利益和人与人之间的斗争，我们几乎对一切都冷漠。 我们所炫耀的，他们的纳税人不会答应；我们所失去的，他们都留下了；我们所缺少的，才是最能让人感到自豪的。 在这个一点就着、一煽就旺的社会里，每个人的私有财产都是不安全的。 看见好的捧个场，遇见坏的冷个场，碰见傻的笑个场，等他们自己给自己砸个场。 很多人恨特权没有在自己手中。 没有人能控制自己不会凌驾在他人和法律之上，哪怕他再好再温厚。体制赋予特殊个体的特权是无法靠自我修行来美化和消解的。 地表上的光鲜，地底下的不堪。城市让生活更美好，也能让生活更槽糕。 现在的人心其实相信的是情绪。大家的注意力转移得太快了。 中国人有时候不认可自己人。 总是习惯于认可当下，追溯过往。不是每件事都能给人生带来什么，人生的时光，总需要去度过。我选择这样度过。在做事件的时候，我希望看得远一些；但在过日子的时候，我希望看得近一些。 只是我的欲望可能未必那么直接。我始终不能接受和很多不解风情的人在一起。有些人的努力是为了摆脱自己原来的出身和环境，有些人的努力是为了证明无论出身和环境自己都可以，这都无可厚非。 天下势革命不保证就能带来民主。不能用完美的民主、完美的自由、完美的人权字面上的解释来逃避中国的现实。一切能用钱解决的社会矛盾都不算什么矛盾。自由在中国最没有感染力。我不会用他人的前途来美化我自己的履历。 消费政治 消费情绪 消费公共事件现实社会中的可行性操作 成功之道有很多未必能展开的东西，而且你也不能将自己的狗屎运赠送给受众。 家世荒诞的欺骗你说你一生没做坏事，为何这样。我想我可以试着告诉你为何。因为，你一生没做过坏事，所以，就是这样。 命里有时终须有，命里无时须强求。因为命里本来什么都没有，只有诞生和死亡，而中间的都是你要强求的部分。两个想在一起的人，便是最大，便是最正，他人皆是第三者。 牢骚也是推动社会进步的一种方式。愿怀着善意，相信他是无心的吹水。没有人永远和过去的自己一致，除非你不再成长。 我选择走得道路太不一样，充满未知，所以我很希望日常生活里没有变故，不再有陌生的事物。 为在乎我的人创造各种东西，绝不向厌恶我的人解释是个什么东西。 人生的许多问题需要阅历来回答，而不能像数学问题一样，通过不停论证而得到。 过去式如果文明不够文明，那就让野蛮足够野蛮。 《这个男人来自地球》 为热爱的人或事物洒下热血和热泪，最坏的结果无非就是对方一句“你想怎样”。 有的时候死死的坚持可能会在一个合适的时候重拾，无论对理想还是对感情都是这样。 我是一个虚荣的人，有时候甚至还虚伪，由于我得到的越来越多，所以也可以假装越来越不虚荣，因为有了一些真容。但我的内心还是虚荣的。不出席所有颁奖典礼，不去各种上流场合其实是另一种虚荣，并不是淡泊。 成名算屁，多少屡秀下限的傻逼也能粉丝绕膝。 我是你当时都没有做好、没有做到，你有什么资格豁免被他人嘲笑？自己没有展露光芒，就不应该怪别人没有眼光。 历史只会记得你的作品和荣誉，而不会留下一事无成者的闲言碎语。 青春就是一场离自己的童年、自己的少年越来越远的远行。 因为我们不能回去了，不能简单了，所以才会对过往那些纯粹发出偶然的叹息。 往往没怎么经历过的人会有一堆感悟，经历越多反而要说的越少。 神不保佑你，因为神就是你所理解的你自己。 开始了并会有结果，过程各不同。走过的路我会记得，但不会重新走过。正在走的和未来的路我会走过，方式不得而知，让别人有路可走吧！但我知道有很多人会给我指路的。我会非常感谢他们，我爱他们，他们怕我迷路或者误入歧途。不管最终我怎么选择，都能到达终点。路开始了就一定会结束，方式和路线属于每个人自己。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《黑客与画家》记录]]></title>
    <url>%2F2018%2F%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6.html</url>
    <content type="text"><![CDATA[注： 本文是我几年前的记录，整理时发现还可以再看看。 保罗-格雷厄姆其人其事“运营创业公司，每天都像在战斗；而为大公司工作，就像在窒息中挣扎。” “我生活的中得一切，都正在成为计算机。所以，如果你想理解我们目前的世界以及它的未知动向，那么多了解一些黑客的想法会对你有帮助。” Y Combinator创始人本身比他的创意更重要内耗 译者序表面上这是一个机器的时代，但是实际上机器的设计者决定了我们的时代。stallman：“出于兴趣而解决某个难题，不管它有没用，这就是黑客。” 好玩，高智商，探索精神真正的黑客致力于改变世界，让世界运转得更好。 前言计算机世界就像是智力世界的大西部，在那里没有你不敢想得事件，只要你愿意承担冒险后果。 为什么书呆子不受欢迎他们真的不想让自己受欢迎 “任何一种艺术，不管是否重要，如果你想要再该领域出类拔萃，就必须全身投入” —- 阿尔伯蒂 对于那些高度困难的领域，只有身处其中的人，才能意识到成功需要不间断（虽然未必是自觉的）付出。在一个人产生良知之前，折磨就是一种娱乐。 那些对自己没自信的人就会通过虐待他们眼中的下等人来突显自己的身份。 没有什么比一个共同的敌人更能使得人们团结起来了 难怪聪明的小孩读中学时往往是不快乐的。 那些在学校的想法在社会中得到了实现也成为了他们个人魅力所在。 当所做的事件能产生真实的效果，那么发现正确的答案就开始变得重要了。 书呆子已经在思考的东西，正是真实世界看重的东西。 学校的真正目的是把儿童都关在同一个地方，以便大人们白天可以腾出手来把事件做完。 你告诉一个人，他的脚天生就是坏的，并不能阻止他去怀疑他可能穿错了鞋子。 逃离这种空虚生活的唯一方法，就是向它屈服。 2 黑客与画家创作者 computer science1 计算机科学家/数学家2 计算机博物学家/计算机的实验室科学3 黑客 没有什么比一个错误的前提更容易产生大量待解决的问题了。 创造优美事物的方式往往不是从头做起，而是在现有成果的基础上做一些小小的调整，或者将已有的观点用比较新的方式组合起来。 创造性从不同方面限制了优美软件的诞生 更大的危险是你自己也会误解自己的工作。 黑客搞懂“计算理论”的必要性，与画家搞懂颜料化学成分的必要性差不多大。 （黑客的想法）来自于其他创作领域。 太过专业化所带来的弊端。 允许动态扩展(malleable)。编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。 作家和画家没有“对数学家的妒忌”，他们认为自己在从事与数学完全不相关的事件。大学和实验室强迫黑客成为科学家，企业强迫黑客成为工程师。当你排斥差异的时候，你不仅将失败的可能性排除在外，也将获得高利润的可能性排除在外。好玩的软件的需求量，比不上解决客户麻烦问题的软件的需求量。day job应该定期地从头开始，而不要长年累月地在一个项目上不断工作，并且试图把所有的最新想法以修订版的形式包括进去。 初始的原创和站在巨人的肩上 从他人的角度思考问题正是成功的奥秘所在。 了解别人对于事件的看法，并不代表你为他的利益服务。 怎样向没有技术背景的人解释技术问题。 程序写出来是给人看的，附带能在机器上运行。 —- 《计算机程序的结构与解释》 一种新的媒介刚刚诞生的时候，人们热情高涨、兴奋不已，短短几代人就探索清楚了这种媒介的大部分可能性，把它的能量发挥到极致。 编程目前好像就处在这个阶段。 不能说的话习俗的力量不足以束缚他们 “要根据社会要求，改造自己的思想” 历史的倒退 未来的人们可能会发现，他们觉得很平常的话，在我们今天这个时代都是不能说的。 回顾过去。我们可以去找那些过去被认为理所当然，如今却被认为不可思议的事情 hard sicence soft science 我们喜欢孩子们看上去天真无邪。 流行的时尚 流行的道德观念 如果一个团队强大到无比自信，它更本不会在乎别人的抨击。 道德禁忌的最大制造者是权力斗争中占上风的，但同时有软弱到需要禁忌保护自己的利益。 抱负心 恐惧心 第二批的接受者只有跟随者了我要亲眼看一下，然后自己做决定。 优秀作品往往来自于其他人忽视的想法，而最被忽视的想法就是那些被禁止的思想观点。 只要你能看到别人看不到或不敢看的东西，你就有很大的优势。 训练自己去想那些不能想的事情，你获得的好处会超过所得到的想法本身。自由思考比畅所欲言更重要。在心里无所不想，但是不一定要说出来。“守口如瓶，笑脸相迎”“不能说的话”太多了，如果口无遮拦，你就没时间做正事了。只要不是错误的观点，就不应该被压制讨论。 良好的坏习惯hacker, hack prose, hack the problem只有深入了解当前的技术，黑客才能构想下一代技术。黑客永远是自负的。黑客的所作所为完全出于兴趣，想到哪里就做到哪里，没有明确的计划，只求开心。很自负的人必须培养出敏锐的感觉，及时发现周围情势的变化，知道怎样才能脱身。一个人们拥有言论自由和行动自由的社会，往往最有可能采纳最优方案，而不是采纳最有权势的人提出的方案。Laffer curve 另一条路桌面软件 互联网软件 用户密集互动的软件 坐下来写东西的时候，一半的构思是写作时产生的。 实现某个构思，会带来更多的构思。 提高软件可靠性的关键在于开发时全神贯注，而不是降低开发速度。如果你亲眼见到某人第一次使用你的软件，你就会知道软件的哪个地方最打动他。 一定数量的盗版对软件公司是有好处的。 价格歧视 公司内部所有不直接感受到竞争压力的部门都应该外包出去，让它们暴露在竞争压力之下。 如果新事物真的有重大改进，那么它总是可以找到生存空间的。 管理企业：做出用户喜欢的产品，保证开支小于收入。 只有懂得设计的黑客，才能设计软件，不能交给对软件一知半解的设计师。如果你不算自己动手设计和开发，那就不要创业。 他们害怕你胜过你害怕他们 开发互联网软件不需要得到任何人的许可，没有人能够阻止你。你不需要去申请许可证，不需要在零售店的货架上谋得一席之地，也不需要卑躬屈膝地求人家，将你的软件与操作系统捆绑在一起。你能狗购过浏览器发布软件，没有人能在你和浏览网站的用户之间插上一脚。 如何创造财富平均主义泛滥 使用“挣钱”这个词会不利于理解如何才能挣钱。(make money-财富，money-金钱) 金钱是专业化的副产品。 公司的存在目的就是满足人们的某种需要。 苦恼：无法准确测量每个员工的贡献。 团队越大，每个人的贡献就越接近于整体的平均值。 技术就是某种手段，就是我们做事的方式。经济价值取决于有多少人使用这种新方式。我们很乐于迫使那些又大又慢的竞争对手跟着我们一起走进沼泽地。不是让买家看到有获利的可能，而是让他们感到失去机会的恐惧。 无论你的技术水平有多高，用户数量都比你自己的判断更能准确反映哪些问题应该优先解决。 创造人们需要的东西，也就是创造财富。创造财富的人能够心安理得地享用自己的财富。 没有财富的激励，就不会有人愿意去做技术革新。 关注贫富分化不管是战争还是政治斗争，本质上都属于偷窃。技术的发展使得通过创造而积累的速度第一次有可能超过通过偷窃而积累财富的速度。 每一笔巨大财富的背后，都隐藏着罪行。 —- 巴尔扎克技术无法使其变得更便宜的唯一东西，就是品牌。无所事事使人感到孤独和消沉技术在加大收入差距的同时，缩小了大部分的其他差距。生活在一个整体上非常富裕但是我个人相对贫穷的社会，还是生活在一个我个人相对非常富裕但是整体上非常贫穷的社会呢？ 防止垃圾邮件的一种方法设计者的品味喜欢一件东西，却不知道为什么自己喜欢它。 人类的思想就是没有经过整理的无数杂念的混合。 如果你是一个设计师，并且你不承认有一种人们共同认可的东西叫做“美”，那么你就没有办法做好工作。 优秀设计的原则是许多学科的共同原则 装饰品本身并不是坏事，只有当它被用来掩盖结构的苍白时，才变成了一件坏事。 好设计师永远不过时的设计 对称的危险在于它可以用来取代思考，在大量使用重复的时候这种危险性更大。 大自然在长期的演化中已经解决了很多设计问题。 遗传算法可能会创造出正常条件下难以设计的复杂事物。 你应该培养对自己的不满。 编程语言解析一个操作所需的代码越多，就越难避免bug，也越难发现它们。 只要你懂得驾驭开源软件社区，就会有很多人在短期内为你提供大量的代码。 一百年后的编程语言一种编程语言的两大组成部分：1.基本运算符的集合（扮演公理的角色）。2.除运算符以外的其他部分（原则上，这个部分可以用基本运算符表达出来） 数学家总是觉得公理越少越好。 一种语言的内核设计得越小、越干净，它的生命力就越顽强。 对速度的追求是人类内心深处根深蒂固的欲望。效率低下的软件并不等于很烂的软件。浪费程序员的时间而不是浪费机器的时间才是真正的无效率。 拒绝平庸选择使用哪一种技术的时候，你不能考虑别人的做法，只能考虑什么样的技术能最好地完成工作。在竞争中，你的对手无法理解你的技术优势，这可是再宝贵不过了。他们都满足于自己碰巧用熟了的那种语言。Lisp人类天性变化的速度大大慢于计算机硬件变化的速度。 书呆子的复仇条件越苛刻的项目，强大的编程语言就越能发挥作用。把软件运行在服务器端就可以没有顾忌地使用最先进的技术。 他们眼中不正常的事件恰恰就是使得这一切发生的原因所在。在基础语言之上先构建一种你自己的语言，然后再用后者开发应用程序。程序员使用某种语言能做到的事件是有极限的。经理真正关心的是不承担决策失败的责任。 梦寐以求的编程语言只有流行才会让它保持优秀。 无法以一种语言本身的优缺点评判这种语言。 只有当一种语言本身的优缺点评判这种语言。只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。敞开胸怀：对于制造工具的人来说，总是会有用户以违背你本意的方式使用你的工具。 让字节码成为语言的正式组成部分，允许程序员在瓶颈处内嵌字节码。 硬件和软件现在捆绑在一起供应。 人们有时候会想要自己并不真正需要的东西。 大多数热门新商品事后被证明都是浪费时间的噱头，没多久就消失得无影无踪。 人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里。 “最好的文字来自不停的修改。” 对解决难题的可能性保持乐观，同时对当前解法的合理性保持怀疑。 做出优秀成果的人，在做的过程中常常觉得自己做得不够好。 如果你能平衡好希望和担忧，它们就会推动项目前进，就像自行车在保持平衡中前进一样。 如果用户数量庞大，修改语言带来的痛苦就将持续很长时间。 设计与研究设计与研究，好与新。 只有应用“新”的创意和理论，才会诞生超越前人的最佳设计；只有解决那些值得解决的难题（也就是“好”的难题），只是前进的路线不同罢了。除非设定目标用户，否则一种设计的好坏根本无从谈起。如果目标用户群体涵盖了设计师本人，那么最有可能诞生优秀设计。 “弱即是强”(Worse is Better) 尽快拿出原型，听取用户的意见。先做出原型，再逐步加工做出成品。 任何时候，代码必须能够运行。 “画作永远没有完工的一天，你只是不再画下去而已。”]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>计算机</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为博客添加Disqus评论系统]]></title>
    <url>%2F2018%2Fcomment-disqus.html</url>
    <content type="text"><![CDATA[给博客添加一个评论系统，考虑了好几个，但最终还是选择了Disqus，考虑一下几点： 之前非常受欢迎的多说，某原因关闭了，现在国内也有非常多好的评论系统，但就是担心又出现某原因关闭，那就麻烦了 Disqus唯一的问题就是在墙外，我考虑一下，访问我博客十有八九都是做技术的，梯子肯定是多的是，😀 Disqus添加也非常方便。 注册Disqus到Disqus，注册一个账号 I want to install Disqus on my site就是现在Disqus做个站点的标记。 这边的Shortname比较重要，之后再hexo-next中配置就是用这个Shortname，需要不重复。 下面的信息就按照规则填就是了。 填写配置文件在next/_config.yml中添加或修改，如下：12345# Disqusdisqus: enable: true shortname: http-andyron-com count: true 更新一下系统123hexo cleanhexo ghexo d 现在在文章底部就出现评论系统了。 Disqus刚刚推出了 Reactions，可以在后台配置。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Disqus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用LeanClound给hexo+next博客添加文章阅读数]]></title>
    <url>%2F2018%2Fleanclound-hexo-next.html</url>
    <content type="text"><![CDATA[个人博客之前用的NexT 框架介绍 不蒜子统计 来统计文章阅读数、网站访问人数和网站访问总数。但是总是发现文章阅读数老是出现问题，因此把文章阅读数换成用LeanCloud来统计，看起来也方便。LeanCloud的免费的开发版完全满足了我博客这种小网站的需求了。配置起来也很方便，下面做个记录： 注册LeanClound账号这个很方便，微博，GitHub都可以直接关联注册，或者直接用邮箱注册。 创建应用比如我创建一个名为andyron.com.counter的应用。 获取APP ID，APP Key，之后再配置文件中配置。 创建Class 在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表，为了便于区分我们新建一张表来保存我们的数据。新建Class用来专门保存我们博客的文章访问量等数据，理论上来说名字可以随意取名，只要你交互代码做相应的更改即可，但是为了保证对NexT主题的修改兼容，此处的新建Class名字必须为Counter: 添加安全域名添加安全域名后，只有这些安全域名才有权访问后台的数据了，可以进一步提升安全性。 修改一下主题配置文件修改配置文件next/_config.yml12345678910111213141516171819202122leancloud_visitors: enable: true app_id: #你的app_id app_key: #你的的app_key# Show PV/UV of the website/page with busuanzi. 不蒜子统计# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问人数 site_uv_footer: 人次 # # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: false page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读 page_pv_footer: 次 更新一下系统123hexo cleanhexo ghexo d 最新的NexT框架已经不需要再配置样式，可以看到 在LeanCloud中也可以查看数据了： 注：objetcId这个主键是由日期和博文标题组合成的，因此标题变化，阅读会重新计数 参考： 为NexT主题添加文章阅读量统计功能使用leancloud给博客添加阅读次数]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>LeanClound</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于iOS多线程，这边勉强可以看看(OC&Swift)]]></title>
    <url>%2F2018%2Fios-multithreading.html</url>
    <content type="text"><![CDATA[iOS开发多线程总是绕不过的坎，看了很多前辈们优秀的文章，如：关于iOS多线程，我说，你听，没准你就懂了！、谈iOS多线程(NSThread、NSOperation、GCD)编程、iOS多线程：『GCD』详尽总结、iOS多线程：『pthread、NSThread』详尽总结、iOS多线程：『NSOperation、NSOperationQueue』详尽总结、关于iOS多线程，你看我就够了等，但不自己整理一下，敲一下代码总是感觉不深刻 ，于是就有这篇文章，断断续续整理了好久。 示例我尽量把不同知识点代码独立开，看着简单一些，容易理解。示例代码我都用OC和Swift分别写了，不过文中都是以OC说明的，因为如果用两种语言一起，看起来可能比较乱，文章也会更加长（已经非常长了😂😂）。Swift写法可能有比较大区别，也有些功能取消，但看一下代码应该能明白了。文中的所有示例代码：andyRon/iOS-Multithreading 先看个大概： 1 简介一些帮助理解的概念，可以先简单看一下，然后读完全文再回来看一下这一部分，可能就比较清晰了。🙂 1.1 一些概念 系统中正在运行的每一个应用程序都是一个 进程(Process) ，每个进程系统都会分配给它独立的内存运行。也就是说，在iOS系统中中，每一个应用都是一个进程。 一个进程的所有任务都在 线程(Thread) 中进行，因此每个进程至少要有一个线程，也就是主线程。那多线程其实就是一个进程开启多条线程，让所有任务并发执行。 iOS App一旦运行，默认就会开启一条线程。这条线程，通常称作为“主线程”。在iOS应用中主线程的作用一般是：刷新UI；处理UI事件，例如点击、滚动、拖拽。 如果主线程的操作太多、太耗时，就会造成App卡顿现象严重。所以，通常我们都会把耗时的操作放在子线程中进行，获取到结果之后，回到主线程去刷新UI。 多线程在一定意义上实现了进程内的资源共享，以及效率的提升。同时，在一定程度上相对独立，它是程序执行流的最小单元，是进程中的一个实体，是执行程序最基本的单元，有自己栈和寄存器。 同步： 只能在当前线程按先后顺序依次执行，不开启新线程。 异步： 可以在当前线程开启多个新线程执行，可不按顺序执行。 队列： 装载线程任务的队形结构。 并发： 线程执行可以同时一起进行执行。 串行： 线程执行只能依次逐一先后有序的执行。 通过确保主线程自由响应用户事件，并发可以很好地提高应用的响应性。通过将工作分配到多核，还能提高应用处理的性能。但是并发也带来一定的额外开销(调度)，并且使代码更加复杂，更难编写和调试。 1.2 多线程概念补充 多线程的原理： 同一时间，CPU只能处理一条线程，也就是只有一条线程在工作。所谓多线程并发(同时)执行，其实是CPU快速的在多线程之间调度(切换)。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。 在实际项目开发中并不是线程越多越好，如果开了大量的线程，会消耗大量的CPU资源，CPU会被累死，所以一般手机只开1~3个线程为宜，不超过5个。 多线程的优点： 能适当提高程序的执行效率能适当提高资源的利用率，这个利用率表现在(CPU，内存的利用率) 多线程的缺点： 开启线程需要占用一定的内存空间(默认情况下，主线程占用1M，子线程占用512KB，如果开启大量的线程，会占用大量的内存空间，降低程序的性能) 线程越多，CPU在调度线程上的开销就越大 线程越多，程序设计就越复杂，比如线程之间的通信，多线程的数据共享，这些都需要程序的处理，增加了程序的复杂度。 在iOS开发中使用线程的注意事项： 别将比较耗时的操作放在主线程中 耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验 2 四种解决方案对比 目前iOS多线程有四种方法：pthread，NSThread，GCD， NSOperation，四种方案的简单对比一下。 由于pthread平常几乎用不到，我暂时就不学了。 每个NSThread对象对应一个线程，真正最原始的线程，相对简单，但是需要手动管理所有的线程活动，如生命周期、线程同步、睡眠等。 怎么选择？简单而安全的选择NSOperation实现多线程即可。处理大量并发数据，又追求性能效率的选择GCD。 3 NSTread生命周期还是需要程序员手动管理，所以这套方案也是偶尔用用，不过获取当前线程([NSThread currentThread])和获取主线程([NSThread mainThread])的这两个方法会经常使用。 3.1 NSThread三种线程开启方式 动态开启 12NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething1:) object:(@"NSThread1")];[thread1 start]; 静态开启 12// 创建好之后直接启动[NSThread detachNewThreadSelector:@selector(doSomething2:) toTarget:self withObject:(@"NSTread2")]; 隐式开启 12// 创建好之后也是直接启动[self performSelectorInBackground:@selector(doSomething3:) withObject:(@"NobjcSTread3")]; 3.2 NSThread拓展 获取当前线程 1NSThread *current = [NSThread currentThread]; 获取主线程 1NSThread *main = [NSThread mainThread]; 暂停当前线程一段时间 1[NSThread sleepForTimeInterval:2]; 暂停当前线程到某个时间 1[NSThread sleepUntilDate: date]; 线程之间通信 123456//在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; //在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; //在当前线程执行操作[self performSelector:@selector(run) withObject:nil]; 4. GCD GCD为Grand Central Dispatch的缩写。Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。 4.1 GCD的优点 GCD 可用于多核的并行运算 GCD 会自动利用更多的 CPU 内核（比如双核、四核） GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程） 程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码 4.2 任务和队列 任务： 表现上就是一段代码，OC就对应一个Block。任务 有两种执行方式，是否会创建新的线程，会不会阻塞当前线程 同步执行（sync）：在当前线程执行任务，不会开辟新的线程。必须等到Block函数执行完毕后，dispatch函数才会返回。 异步执行（async）：可以在新的线程中执行任务，但不一定会开辟新的线程。dispatch函数会立即返回, 然后Block在后台异步执行。 队列：任务管理方式。分为 串行 和 并行两种方式，都是按照 FIFO（先进先出）原则依次触发任务。 串行队列 ： 所有任务会在一条线程中执行（有可能是当前线程也有可能是新开辟的线程），并且一个任务执行完毕后，才开始执行下一个任务。（等待完成） 并行队列： 可以开启多条线程并行执行任务（但不一定会开启新的线程），并且当一个任务放到指定线程开始执行时，下一个任务就可以开始执行了。（等待发生） 两者的区别：执行顺序不同，以及开启线程数不同。 两个特殊队列： 主队列： 系统创建好的一个 串行队列，它管理必须在主线程中执行的任务。 全局队列：系统为我们创建好的一个并行队列，使用起来与我们自己创建的并行队列无本质差别。 不同队列创建获取方式： 123456789101112- (void)create &#123; // dispatch_queue_create 第一个参数是队列名字，一般用app的Bundle Identifier命名方式命名；第二个参数为NULL时表是串行队列 //串行队列 dispatch_queue_t serialQueue = dispatch_queue_create("q1.andyron.com", NULL); dispatch_queue_t serialQueue2 = dispatch_queue_create("q2.andyron.com", DISPATCH_QUEUE_SERIAL); //并行队列 dispatch_queue_t concurrentQueue = dispatch_queue_create("q3.andyron.com", DISPATCH_QUEUE_CONCURRENT); //全局并行队列 DISPATCH_QUEUE_PRIORITY_DEFAULT表示优先级 dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //主队列获取 dispatch_queue_t mainQueue = dispatch_get_main_queue();&#125; 同步执行 异步执行 串行队列 当前线程，一个一个执行 其他线程，一个一个执行 并行队列 当前线程，一个一个执行 开很多线程，一起执行 4.3 下面👇以一个一个🌰来学习GCD，帮助搞清上面的概念 例子一:线程死锁（主队列 + 同步执行）1234567- (void)case1 &#123; NSLog(@"A=====%@", [NSThread currentThread]); dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@"B=====%@", [NSThread currentThread]); &#125;); NSLog(@"C=====%@", [NSThread currentThread]);&#125; 运行结果崩溃： 打印结果： 1GCD(OC)[51511:6351422] A=====&lt;NSThread: 0x600000064340&gt;&#123;number = 1, name = main&#125; 解释：默认就一个主队列和一个主线程，因此case1函数这段任务就在主队列中同步执行，dispatch_sync...这段代码表示把B处任务加入主队列中，并且同步执行，这就出问题，B处任务要等主队列中同步执行之前的case1这段任务结束后执行，但B处任务在case1这段任务中，case1又要等B处任务执行完才能继续执行。case1任务要等B处完成才能继续，但case1又排在B处前面，这就尴尬了，￣□￣｜｜，因此崩溃了😖 例子二：主队列 + 异步执行1234567- (void)case2 &#123; NSLog(@"A=====%@", [NSThread currentThread]); dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@"B=====%@", [NSThread currentThread]); &#125;); NSLog(@"C=====%@", [NSThread currentThread]);&#125; 结果：123GCD(OC)[52567:6465354] A=====&lt;NSThread: 0x600000068d40&gt;&#123;number = 1, name = main&#125;GCD(OC)[52567:6465354] C=====&lt;NSThread: 0x600000068d40&gt;&#123;number = 1, name = main&#125;GCD(OC)[52567:6465354] B=====&lt;NSThread: 0x600000068d40&gt;&#123;number = 1, name = main&#125; 解释：任务都在主队列（串行），而且只要一个主线程（name都是main），B处任务由于是异步执行，等case2任务完成后执行。 例子三：串行队列 + 同步执行1234567891011121314// 串行队列 + 同步执行- (void)case3 &#123; dispatch_queue_t serialQueue = dispatch_queue_create("q2.andyron.com", DISPATCH_QUEUE_SERIAL); dispatch_sync(serialQueue, ^&#123; NSLog(@"1======%@", [NSThread currentThread]); &#125;); dispatch_sync(serialQueue, ^&#123; NSLog(@"2======%@", [NSThread currentThread]); &#125;); dispatch_sync(serialQueue, ^&#123; NSLog(@"3======%@", [NSThread currentThread]); &#125;); NSLog(@"4======%@", [NSThread currentThread]);&#125; 结果：1234GCD(OC)[53734:6582112] 1======&lt;NSThread: 0x604000261700&gt;&#123;number = 1, name = main&#125;GCD(OC)[53734:6582112] 2======&lt;NSThread: 0x604000261700&gt;&#123;number = 1, name = main&#125;GCD(OC)[53734:6582112] 3======&lt;NSThread: 0x604000261700&gt;&#123;number = 1, name = main&#125;GCD(OC)[53734:6582112] 4======&lt;NSThread: 0x604000261700&gt;&#123;number = 1, name = main&#125; 解释：🌰1中的主队列也是串行队列，但和这边不同，这边是新建了另一个串行队列，不会出现冲突，并且都在主线程中运行，这也说明了同步执行不具备创建新线程的能力。 列子四：串行队列 + 异步执行1234567891011121314// 串行队列 + 异步执行- (void)case4 &#123; dispatch_queue_t serialQueue = dispatch_queue_create("q2.andyron.com", DISPATCH_QUEUE_SERIAL); dispatch_async(serialQueue, ^&#123; NSLog(@"1========%@",[NSThread currentThread]); &#125;); dispatch_async(serialQueue, ^&#123; NSLog(@"2========%@",[NSThread currentThread]); &#125;); dispatch_async(serialQueue, ^&#123; NSLog(@"3========%@",[NSThread currentThread]); &#125;); NSLog(@"4========%@",[NSThread currentThread]);&#125; 打印结果：1234GCD(OC)[53970:6604711] 4========&lt;NSThread: 0x60000007c880&gt;&#123;number = 1, name = main&#125;GCD(OC)[53970:6604933] 1========&lt;NSThread: 0x600000460280&gt;&#123;number = 3, name = (null)&#125;GCD(OC)[53970:6604933] 2========&lt;NSThread: 0x600000460280&gt;&#123;number = 3, name = (null)&#125;GCD(OC)[53970:6604933] 3========&lt;NSThread: 0x600000460280&gt;&#123;number = 3, name = (null)&#125; 解释：现在打印了4，后打印了1，2，3，这是一部执行的结果，并且4在主线程，其它在子线程打印，这也说明了异步执行可以创建新线程。 列子五：并行队列 + 同步执行1234567891011121314151617/// 并行队列 + 同步执行- (void)case5 &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create("q3.andyron.com", DISPATCH_QUEUE_CONCURRENT); dispatch_sync(concurrentQueue, ^&#123; NSLog(@"1========%@",[NSThread currentThread]); //[self nslogCount:10000 number:1]; &#125;); dispatch_sync(concurrentQueue, ^&#123; NSLog(@"2========%@",[NSThread currentThread]); //[self nslogCount:10000 number:2]; &#125;); dispatch_sync(concurrentQueue, ^&#123; NSLog(@"3========%@",[NSThread currentThread]); //[self nslogCount:10000 number:3]; &#125;); NSLog(@"4========%@",[NSThread currentThread]);&#125; 打印结果：1234GCD(OC)[54401:6646454] 1========&lt;NSThread: 0x600000260e80&gt;&#123;number = 1, name = main&#125;GCD(OC)[54401:6646454] 2========&lt;NSThread: 0x600000260e80&gt;&#123;number = 1, name = main&#125;GCD(OC)[54401:6646454] 3========&lt;NSThread: 0x600000260e80&gt;&#123;number = 1, name = main&#125;GCD(OC)[54401:6646454] 4========&lt;NSThread: 0x600000260e80&gt;&#123;number = 1, name = main&#125; 解释：都在主线程执行，由于只有一个线程，结果看上去是顺序执行。 列子六： 并行队列 + 异步执行1234567891011121314// 并行队列 + 异步执行- (void)case6 &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create("q3.andyron.com", DISPATCH_QUEUE_CONCURRENT); dispatch_async(concurrentQueue, ^&#123; NSLog(@"1========%@",[NSThread currentThread]); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@"2========%@",[NSThread currentThread]); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@"3========%@",[NSThread currentThread]); &#125;); NSLog(@"4========%@",[NSThread currentThread]);&#125; 打印结果：1234GCD(OC)[54687:6675227] 2========&lt;NSThread: 0x600000466600&gt;&#123;number = 5, name = (null)&#125;GCD(OC)[54687:6675036] 4========&lt;NSThread: 0x604000078d00&gt;&#123;number = 1, name = main&#125;GCD(OC)[54687:6675226] 1========&lt;NSThread: 0x600000463fc0&gt;&#123;number = 4, name = (null)&#125;GCD(OC)[54687:6675229] 3========&lt;NSThread: 0x60400067d400&gt;&#123;number = 6, name = (null)&#125; 解释：除了打印4的是主线，其他又开启了三个线程来执行三个任务，当天开启几个线程是有CPU自己决定的，任务的执行是随机的。 4.4 GCD 重点 只要是串行队列，肯定要等上一个任务执行完成，才能开始下一个任务。但是并行队列当上一个任务开始执行后，下一个任务就可以开始执行。 同步+串行：未开辟新线程，串行执行任务；同步+并行：未开辟新线程，串行执行任务；异步+串行：新开辟一条线程，串行执行任务；异步+并行：开辟多条新线程，并行执行任务；在主线程中同步使用主队列执行任务，会造成死锁。 4.5 GCD其他相关方法 延迟执行方法： void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);指定时间后执行某个任务，dispatch_after函数指定的时间是指多长后将任务加到某个队列中，而不是具体执行时间，具体时间要看CPU执行时间了，可以看做是个大约延迟时间。 123456- (void)after &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 2.0秒后异步追加任务代码到主队列，并开始执行 NSLog(@"after---%@",[NSThread currentThread]); // 打印当前线程 &#125;);&#125; dispatch_once：在生命周期内只执行一次。 123456- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@"就一次%@",[NSThread currentThread]); &#125;);&#125; 不管点击多少次只有一次输出。 GCD的内容很丰富，还有很多函数，2016和2017的WWDC都有专门讲到GCD，想更近一步可以参考：Modernizing Grand Central Dispatch Usage，Concurrent Programming With GCD in Swift 3。 5 NSOperation 和 NSOperationQueue5.1 概念 NSOperation(操作) 和 NSOperationQueue（操作队列） 是苹果对GCD的封装 NSOperation 和 NSOperationQueue 分别相当于 GCD 的 任务 和 队列 NSOperation 只是一个抽象类，不能直接使用，使用其 2 个子类：NSInvocationOperation 和 NSBlockOperation 。 NSOperation的使用除了其现有的子类，还可以自定义子类。 操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。 NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。 NSOperation 需要配合 NSOperationQueue 来使用。否则，NSOperation 单独使用时系统默认同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。 5. 2 NSOperation 实现多线程的步骤 创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。 创建队列：创建 NSOperationQueue 对象。 将操作加入到队列中：将 NSOperation 对象添加到NSOperationQueue 对象中。 之后，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。 5.3 使用NSOperation的子类NSInvocationOperation12NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];[operation start]; 在没有使用NSOperationQueue时，NSInvocationOperation会在当前线程（主线程或其他线程）内运行。 5.4 使用NSOperation的子类NSBlockOperation1234NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"%@", [NSThread currentThread]); &#125;];[operation start]; 结果： 12NSOperation(OC)[97406:5880178] 1---&lt;NSThread: 0x60400006e700&gt;&#123;number = 1, name = main&#125;NSOperation(OC)[97406:5880178] 1---&lt;NSThread: 0x60400006e700&gt;&#123;number = 1, name = main&#125; 在没有使用NSOperationQueue时，NSBlockOperation也会在当前线程（主线程或其他线程）内运行。 另外，NSBlockOperation还提供了一个方法 addExecutionBlock:，用来添加额外的操作： 1234567891011121314151617181920212223242526272829// 1.创建 NSBlockOperation 对象NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程&#125;];// 2.添加额外的操作[op addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程 &#125;];[op addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@"3---%@", [NSThread currentThread]); // 打印当前线程 &#125;];[op addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@"4---%@", [NSThread currentThread]); // 打印当前线程 &#125;];[op addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@"5---%@", [NSThread currentThread]); // 打印当前线程 &#125;];// 3.调用 start 方法开始执行操作[op start]; 某一次的运行结果： 12345NSOperation(OC)[97709:5888750] 1---&lt;NSThread: 0x600000469740&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[97709:5888750] 5---&lt;NSThread: 0x600000469740&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[97709:5888748] 3---&lt;NSThread: 0x600000469e40&gt;&#123;number = 4, name = (null)&#125;NSOperation(OC)[97709:5888498] 4---&lt;NSThread: 0x60400007a600&gt;&#123;number = 1, name = main&#125;NSOperation(OC)[97709:5888758] 2---&lt;NSThread: 0x604000463480&gt;&#123;number = 5, name = (null)&#125; addExecutionBlock:添加的操作和之前blockOperationWithBlock添加的操作是否在主线程或者是否开多线程，是由系统决定，它们的地位是相同的，所以每一次执行的结果可能不同。 5.5 NSOperation的自定义子类除了上面两个子类外，还可以通过重写main方法来自定义子类。12345678910111213#import "AROperation.h"@implementation AROperation- (void)main &#123; if (!self.isCancelled) &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@"自定义Operation---%@", [NSThread currentThread]); &#125; &#125;&#125;@end 使用：12AROperation *op = [[AROperation alloc] init];[op start]; 5.6 NSOperationQueue上面几种情况都是没有操作队列，一般只在主线程运行。而使用操作队列就可以实现多线程了。操作队列分两种： 主队列 : 凡是添加到主队列中的操作，都会放到主线程中执行 自定义队列: 操作自动放到子线程中执行，同时包含了：串行、并发功能。 5.6.1 创建队列12345// 主队列获取方法NSOperationQueue *queue = [NSOperationQueue mainQueue];// 自定义队列创建方法NSOperationQueue *queue = [[NSOperationQueue alloc] init]; 5.6.2 添加操作到队列中两种不同的添加方法： - (void)addOperation:(NSOperation *)op;1234567891011121314151617181920212223242526272829303132333435- (void)addOperationToQueue &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 // 使用 NSInvocationOperation 创建操作1 NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; // 使用 NSInvocationOperation 创建操作2 NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil]; // 使用 NSBlockOperation 创建操作3 NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op3 addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"4---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.使用 addOperation: 添加所有操作到队列中 [queue addOperation:op1]; // [op1 start] [queue addOperation:op2]; // [op2 start] [queue addOperation:op3]; // [op3 start]&#125;- (void) task1 &#123; NSLog(@"1---%@", [NSThread currentThread]);&#125;- (void) task2 &#123; NSLog(@"2---%@", [NSThread currentThread]);&#125; 某一次的运行结果：123456NSOperation(OC)[7557:6218702] 2---&lt;NSThread: 0x60400027f900&gt;&#123;number = 4, name = (null)&#125;NSOperation(OC)[7557:6218699] 1---&lt;NSThread: 0x600000461a00&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[7557:6218701] 4---&lt;NSThread: 0x6040004606c0&gt;&#123;number = 5, name = (null)&#125;NSOperation(OC)[7557:6218700] 3---&lt;NSThread: 0x604000460d40&gt;&#123;number = 6, name = (null)&#125;NSOperation(OC)[7557:6218700] 3---&lt;NSThread: 0x604000460d40&gt;&#123;number = 6, name = (null)&#125;NSOperation(OC)[7557:6218701] 4---&lt;NSThread: 0x6040004606c0&gt;&#123;number = 5, name = (null)&#125; 并发运行，执行次序不确定。 - (void)addOperationWithBlock:(void (^)(void))block; 不需要先创建操作，直接添加block123456789101112131415161718192021222324- (void)addOperationWithBlockToQueue &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.使用 addOperationWithBlock: 添加操作到队列中 [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;];&#125; 某一次的运行结果：123456NSOperation(OC)[7772:6229770] 2---&lt;NSThread: 0x600000277640&gt;&#123;number = 5, name = (null)&#125;NSOperation(OC)[7772:6229772] 1---&lt;NSThread: 0x60400026bfc0&gt;&#123;number = 4, name = (null)&#125;NSOperation(OC)[7772:6229780] 3---&lt;NSThread: 0x6040002686c0&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[7772:6229770] 2---&lt;NSThread: 0x600000277640&gt;&#123;number = 5, name = (null)&#125;NSOperation(OC)[7772:6229780] 3---&lt;NSThread: 0x6040002686c0&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[7772:6229772] 1---&lt;NSThread: 0x60400026bfc0&gt;&#123;number = 4, name = (null)&#125; 5.6.3 maxConcurrentOperationCountNSOperationQueue 提供一个maxConcurrentOperationCount（最大并发操作数）属性来控制串行还是并发。maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。maxConcurrentOperationCount默认情况下为-1，表示不进行限制。 1234567891011121314151617181920212223242526272829303132333435- (void)setMaxConcurrentOperationCount &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.设置最大并发操作数 queue.maxConcurrentOperationCount = 1; // 串行队列 // queue.maxConcurrentOperationCount = 2; // 并发队列 // queue.maxConcurrentOperationCount = 8; // 并发队列 // 3.添加操作 [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"3---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"4---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;];&#125; 当最大并发操作数为1时，也就是串行执行时，控制台中返回的结果顺序是固定的。而大于1时，也就是并发执行，每一次执行的顺序就可能不同（控制台中返回的额结果顺序可能不同）。当然开启的线程数量是有系统决定的。 5.7 NSOperation之间的依赖并行时，各个的操作的执行顺序是有系统决定，程序员不能直接控制。但是NSOperation提高了依赖，来解决这个问题。相关方法和属性： - (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 - (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 1234567891011121314151617181920212223- (void)addDependency &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"1---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@"2---%@", [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.添加依赖 [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，再执行op2 // 4.添加操作到队列中 [queue addOperation:op1]; [queue addOperation:op2];&#125; 运行结果是固定的：1234NSOperation(OC)[8977:6302811] 1---&lt;NSThread: 0x604000277f80&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[8977:6302811] 1---&lt;NSThread: 0x604000277f80&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[8977:6302810] 2---&lt;NSThread: 0x604000274240&gt;&#123;number = 4, name = (null)&#125;NSOperation(OC)[8977:6302810] 2---&lt;NSThread: 0x604000274240&gt;&#123;number = 4, name = (null)&#125; 注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。可以使用 removeDependency 来解除依赖关系。可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。 5.8 NSOperation 常用属性和方法 取消操作方法- (void)cancel; 实质是标记 isCancelled 状态。 判断操作状态方法 - (BOOL)isFinished; 判断操作是否已经结束。 - (BOOL)isCancelled; 判断操作是否已经标记为取消。 - (BOOL)isExecuting; 判断操作是否正在在运行。 - (BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。 操作同步 - (void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。 - (void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。 - (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 - (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 5.9 NSOperationQueue 常用属性和方法 取消/暂停/恢复操作 - (void)cancelAllOperations; 可以取消队列的所有操作。 - (BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。 - (void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。 操作同步 - (void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。 添加/获取操作 - (void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。 - (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束 - (NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。 - (NSUInteger)operationCount; 当前队列中的操作数。 获取队列 + (id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。 + (id)mainQueue; 获取主队列。 6 后记虽然总结了很多，但还有很多内容没有涉及和深入。由于个人能力有限，时间紧凑（实际我已经花了很多时间😒🤦‍♀️🤦‍♀️），文中难免有错误，希望小伙伴批评指正。 示例代码：andyRon/iOS-Multithreading 参考：关于iOS多线程，我说，你听，没准你就懂了！谈iOS多线程(NSThread、NSOperation、GCD)编程iOS多线程：『GCD』详尽总结iOS多线程：『pthread、NSThread』详尽总结iOS多线程：『NSOperation、NSOperationQueue』详尽总结关于iOS多线程，你看我就够了Grand Central Dispatch (GCD) and Dispatch Queues in Swift 3WWDC-2017-Modernizing Grand Central Dispatch Usage]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Multithreading</tag>
        <tag>GCD</tag>
        <tag>NSThread</tag>
        <tag>NSOperation</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC中的键/值编码(KVC)]]></title>
    <url>%2F2018%2Fios-oc-kvc-begin.html</url>
    <content type="text"><![CDATA[1. KVC 的定义键/值编码(Key-value coding，KVC) 可以允许开发者通过Key名访问对象的属性或给对象的属性赋值, 而不需要调用明确的存取方法，并有一组api供开发者使用，像操作字典一样操作对象属性/成员变量/关联对象。这样就可以在 运行时动态地访问和修改 对象的属性。而不是在编译时确定。这种机制不属于Objective-C语言的特性，而是Cocoa提供的一种特性。 通过定义一个NSObject的类别NSKeyValueCoding来实现KVC功能。因此所有继承了NSObject的类都支持KVC。NSKeyValueCoding的四个重要方法： 1234- (nullable id)valueForKey:(NSString *)key; //直接通过Key来取值- (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key来设值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 NSKeyValueCoding还有其它许多方法，我列举一些，详细可查看官方文档 NSKeyValueCoding： 1234567891011121314151617181920+ (BOOL)accessInstanceVariablesDirectly;//默认返回YES，表示如果没有找到set&lt;Key&gt;方法的话，会按照_&lt;key&gt;，_isKey，key，isKey的顺序搜索成员，设置成NO就不这样搜索- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;//KVC提供属性值正确性验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回。- (nullable id)valueForUndefinedKey:(NSString *)key;//在取值时，如果Key不存在，且KVC无法搜索到任何和Key有关的字段或者属性(或者+ (BOOL)accessInstanceVariablesDirectly;方法返回NO时)，则会调用这个方法，默认是抛出 NSUndefinedKeyException异常。- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;//和上一个方法相对应，这个方法是用来设值。- (void)setNilValueForKey:(NSString *)key;//如果你在SetValue方法时面给Value传nil，则会调用这个方法- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。 2 KVC是如何寻找Key2.1 设置值当调用setValue:forKey:方法来设置属性值时，执行机制如下： 先调用setter方法set&lt;Key&gt;：属性值 如果没有找到setter方法，KVC就会检测+ (BOOL)accessInstanceVariablesDirectly的返回值，是默认值YES,就按照_&lt;key&gt;，_isKey，key，isKey的顺序一一查找。只要存在_&lt;key&gt;，无论该变量是在类接口处定义，还是在类实现处定义，也不管是什么访问修饰符，KVC都可以对其访问。 如果没有setter方法，也没找到_&lt;key&gt;，_isKey，key，isKey中的任何一个，KVC就会执行方法- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;，默认是抛出异常。 代码示例（andyRon/KVCDemo1）： 1234567891011121314151617181920212223242526272829303132@interface Dog : NSObject@end@implementation Dog&#123; NSString* toSetName; NSString* isName; NSString* name; NSString* _name; NSString* _isName;&#125;+(BOOL)accessInstanceVariablesDirectly&#123; return NO;&#125;-(id)valueForUndefinedKey:(NSString *)key&#123; NSLog(@"取值出现异常，key为：%@的变量不存在",key); return nil;&#125;-(void)setValue:(id)value forUndefinedKey:(NSString *)key&#123; NSLog(@"设置值出现异常，key为：%@的变量不存在",key);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... Dog* dog = [Dog new]; [dog setValue:@"newNameValue" forKey:@"name"]; NSString* toSetName = [dog valueForKey:@"toSetName"]; NSLog(@"%@",toSetName); &#125; return 0;&#125; 打印结果： 123KVCDemo1[5107:12399654] 设置值出现异常，key为：name的变量不存在KVCDemo1[5107:12399654] 取值出现异常，key为：toSetName的变量不存在KVCDemo1[5107:12399654] (null) 重写+(BOOL)accessInstanceVariablesDirectly方法让其返回NO后,KVC机制就不会实现，就直接调用- (nullable id)valueForUndefinedKey:(NSString *)key;或- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key; 稍微修改以下代码，看示例（andyRon/KVCDemo2）： 123456789101112131415161718192021222324252627282930313233343536@interface Dog : NSObject@end@implementation Dog&#123; NSString* toSetName; NSString* isName; NSString* _name; NSString* _isName;&#125; -(void)setName:(NSString*)name&#123; toSetName = name; &#125;-(NSString*)getName&#123; return toSetName;&#125;+(BOOL)accessInstanceVariablesDirectly&#123; return NO;&#125;-(id)valueForUndefinedKey:(NSString *)key&#123; NSLog(@"取值出现异常，key为：%@的变量不存在",key); return nil;&#125;-(void)setValue:(id)value forUndefinedKey:(NSString *)key&#123; NSLog(@"设置值出现异常，key为：%@的变量不存在",key);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Dog* dog = [Dog new]; [dog setValue:@"newNameValue" forKey:@"name"]; NSString* name = [dog valueForKey:@"name"]; NSLog(@"%@",name); &#125; return 0;&#125; 打印结果： 1KVCDemo2[5323:12426199] newNameValue 虽然+(BOOL)accessInstanceVariablesDirectly方法结果还是NO，但因为有了setter和getter方法就不会出现异常了。当+(BOOL)accessInstanceVariablesDirectly结果为YES，的🌰代码我就不列出了，可查看andyRon/KVCDemo3。 2.2 KVC取值对于取值方法valueForKey:, KVC对key的查询方式不同于setValue:forKey:,如下： 首先按get&lt;Key&gt;,&lt;key&gt;,is&lt;Key&gt;的顺序方法查找getter方法，找到的话会直接调用。如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象。 如果getter没有找到，KVC则会查找countOf&lt;Key&gt;,objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes格式的方法。如果有一个被找到，那么就会返回一个可以响应NSArray所有方法的代理集合(它是NSKeyValueArray，是NSArray的子类)，调用这个代理集合的方法，或者说给这个代理集合发送属于NSArray的方法，就会以countOf&lt;Key&gt;,objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes这几个方法组合的形式调用。还有一个可选的get&lt;Key&gt;:range:方法。所以你想重新定义KVC的一些功能，你可以添加这些方法，需要注意的是你的方法名要符合KVC的标准命名方法，包括方法签名。 如果上面的方法没有找到，那么会同时查找countOf&lt;Key&gt;，enumeratorOf&lt;Key&gt;,memberOf&lt;Key&gt;格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所的方法的代理集合，和上面一样，给这个代理集合发NSSet的消息，就会以countOf&lt;Key&gt;，enumeratorOf&lt;Key&gt;,memberOf&lt;Key&gt;组合的形式调用。 在类自定义了KVC的实现，并且实现了上面的方法，就可以将返回的对象当数组(NSArray)用了 如果还没有找到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，那么和先前的设值一样，会按_&lt;key&gt;, _is&lt;Key&gt;, &lt;key&gt;, is&lt;Key&gt;的顺序搜索成员变量名，这里不推荐这么做，因为这样直接访问实例变量破坏了封装性，使代码更脆弱。如果重写了类方法+ (BOOL)accessInstanceVariablesDirectly返回NO的话，那么会直接调用valueForUndefinedKey: 示例代码（andyRon/KVCDemo4）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@interface TwoTimesArray : NSObject-(void)incrementCount;-(NSUInteger)countOfNumbers;-(id)objectInNumbersAtIndex:(NSUInteger)index;@end@interface TwoTimesArray()@property (nonatomic,readwrite,assign) NSUInteger count;@property (nonatomic,copy) NSString* arrName;@end@implementation TwoTimesArray-(void)incrementCount&#123; self.count ++;&#125;-(NSUInteger)countOfNumbers&#123; return self.count;&#125;-(id)objectInNumbersAtIndex:(NSUInteger)index&#123; //当key使用numbers时，KVC会找到这两个方法。 return @(index * 2);&#125;-(NSInteger)getNum&#123; //第一个,自己一个一个注释试 return 10;&#125;-(NSInteger)num&#123; //第二个 return 11;&#125;-(NSInteger)isNum&#123; //第三个 return 12;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; TwoTimesArray* arr = [TwoTimesArray new]; NSNumber* num = [arr valueForKey:@"num"]; NSLog(@"%@",num); id ar = [arr valueForKey:@"numbers"]; NSLog(@"%@",NSStringFromClass([ar class])); NSLog(@"0:%@ 1:%@ 2:%@ 3:%@",ar[0],ar[1],ar[2],ar[3]); [arr incrementCount]; //count加1 NSLog(@"%lu",(unsigned long)[ar count]); //打印出1 [arr incrementCount]; //count再加1 NSLog(@"%lu",(unsigned long)[ar count]); //打印出2 [arr setValue:@"newName" forKey:@"arrName"]; NSString* name = [arr valueForKey:@"arrName"]; NSLog(@"%@",name); &#125; return 0;&#125; 结果：123456KVCDemo4[25723:3947658] 10KVCDemo4[25723:3947658] NSKeyValueArrayKVCDemo4[25723:3947658] 0:0 1:2 2:4 3:6KVCDemo4[25723:3947658] 1KVCDemo4[25723:3947658] 2KVCDemo4[25723:3947658] newName 3 KVC中使用keyPath一个类的属性可能是另外一个类，可以通过keyPath方式获取或设置这种多层中属性，这种解决方式也是通过NSKeyValueCoding中的方法来实现的。 1234//通过KeyPath来取值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来设值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; 来看看具体代码例子（KVCKeyPathDemo）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445@interface Address : NSObject@end@interface Address()@property (nonatomic,copy)NSString* country;@end@implementation Address- (id)valueForUndefinedKey:(NSString *)key &#123; return key;&#125;@end@interface People : NSObject@end@interface People()@property (nonatomic,copy) NSString* name;@property (nonatomic,strong) Address* address;@property (nonatomic,assign) NSInteger age;@end@implementation People@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; People* people1 = [People new]; Address* add = [Address new]; add.country = @"China"; people1.address = add; NSString* country1 = people1.address.country; NSString * country2 = [people1 valueForKeyPath:@"address.country"]; NSLog(@"country1:%@ country2:%@",country1,country2); [people1 setValue:@"USA" forKeyPath:@"address.country"]; country1 = people1.address.country; country2 = [people1 valueForKeyPath:@"address.country"]; NSString* city = [people1 valueForKeyPath:@"address.city"]; NSLog(@"country1:%@ country2:%@ city:%@",country1, country2, city); &#125; return 0;&#125; 打印结果： 12KVCKeyPathDemo[6330:12568821] country1:China country2:ChinaKVCKeyPathDemo[6330:12568821] country1:USA country2:USA city:city keyPath中，key之间用.分隔，当keyPath出现错误时，就会调用valueForUndefinedKey:key方法。 4 KVC的异常处理两种情况，一种是key或keyPath错误，上面也都提到过，就是调用valueForUndefinedKey:key方法。 另一种情况是在使用setValue:forKey:方法时值设置为nil了，这是不被允许的，会调用setNilValueForKey:方法。 1234567@implementation People-(void)setNilValueForKey:(NSString *)key&#123; NSLog(@"不能将%@设成nil",key);&#125;@end 1[people setValue:nil forKey:@&quot;age&quot;]; 5 KVC处理非对象和自定义对象valueForKey:总是返回一个id对象，如果原本的变量类型是值类型或者结构体，返回值会封装成NSNumber或者NSValue对象。这两个类会处理从数字，布尔值到指针和结构体任何类型。然后开以者需要手动转换成原来的类型。尽管valueForKey：会自动将值类型封装成对象，但是setValue:forKey:却不行。你必须手动将值类型转换成NSNumber或者NSValue类型，才能传递过去。 对于自定义对象，KVC也会正确地设值和取值。因为传递进去和取出来的都是id类型，所以需要开发者自己担保类型的正确性，运行时Objective-C在发送消息的会检查类型，如果错误会直接抛出异常。 6 KVC和容器类对象的属性可以是一对一的，也可以是一对多的。一对多的属性要么是有序的(数组)，要么是无序的(集合)。 不可变的有序容器属性(NSArray)和无序容器属性(NSSet)一般可以使用valueForKey:来获取。但也可以利用更灵活的方法来管理，比如：- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;实例代码（KVCDemo6）: 12345678910111213141516171819202122232425262728293031323334353637383940@interface Demo : NSObject@property (nonatomic,strong) NSMutableArray* arr;@end@implementation Demo-(id)init&#123; if (self == [super init])&#123; _arr = [NSMutableArray new]; [self addObserver:self forKeyPath:@"arr" options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil]; &#125; return self;&#125;// Informs the observing object when the value at the specified key path relative to the observed object has changed.-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; NSLog(@"%@", self.arr);&#125;-(void)dealloc&#123; [self removeObserver:self forKeyPath:@"arr"]; //一定要在dealloc里面移除观察&#125;-(void)addItem&#123; [_arr addObject:@"addItem"];&#125;-(void)addItemObserver&#123; [[self mutableArrayValueForKey:@"arr"] addObject:@"addItemObserver"];&#125;-(void)removeItemObserver&#123; [[self mutableArrayValueForKey:@"arr"] removeLastObject];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Demo* d = [Demo new]; [d addItem]; [d addItemObserver]; [d removeItemObserver]; &#125; return 0;&#125; 结果： 1234567KVCDemo6[11393:3534594] ( addItem, addItemObserver)KVCDemo6[11393:3534594] ( addItem) 当只是普通地调用[_arr addObject:@&quot;addItem&quot;];时，Observer并不会回调，只有[[self mutableArrayValueForKey:@&quot;arr&quot;] addObject:@&quot;addItemObserver&quot;];这样写时才能正确地触发KVO。 对于无序容器属性(NSSet)有对应的方法： - (NSMutableSet *)mutableSetValueForKey:(NSString *)key; 另外还有对应的keyPath方法： 12- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath; 7 KVC和字典KVC与字典相关的方法： 12- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues; 示例代码（KVCDemo7）： 123456789101112131415161718192021222324252627282930313233343536@interface Address : NSObject@end@interface Address()@property (nonatomic,copy)NSString* country;@property (nonatomic,copy)NSString* province;@property (nonatomic,copy)NSString* city;@property (nonatomic,copy)NSString* district;@end@implementation Address@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Address *address = [Address new]; address.country = @"中国"; address.province = @"上海"; address.city = @"上海"; address.district = @"浦东"; NSArray* arr = @[@"country",@"province",@"district"]; NSDictionary* dict = [address dictionaryWithValuesForKeys:arr]; //把对应key所有的属性全部取出来 NSLog(@"%@",dict); NSDictionary* modifyDict = @&#123;@"country":@"美国",@"province":@"加州",@"city":@"旧金山"&#125;; [address setValuesForKeysWithDictionary:modifyDict]; //修改的属性 NSLog(@"country:%@ province:%@ city:%@",address.country, address.province, address.city); &#125; return 0;&#125; 结果： 1234567KVCDemo7[14135:3606256] &#123; country = &quot;\U4e2d\U56fd&quot;; district = &quot;\U6d66\U4e1c&quot;; province = &quot;\U4e0a\U6d77&quot;;&#125;KVCDemo7[14135:3606256] country:美国 province:加州 city:旧金山Program ended with exit code: 0 8 KVC的应用场景 动态取值和设值 用KVC来访问和修改私有变量 Model和字典转换 修改一些控件的内部属性有的时候可以通过KVC修改一些苹果官方没有公开的属性，比如UITextField中的placeHolderText。这个时候用playground能很方便的演示（KVCDemo8）： 没有公开的属性可通过runtime的方式获取(KVCDemo9): 12345678910import UIKitvar count: UInt32 = 0let ivars = class_copyIvarList(UITextField.self, &amp;count)for i in 0 ..&lt; count &#123; let ivar = ivars![Int(i)] let name = ivar_getName(ivar) print(String(cString: name!))&#125;free(ivars) 操作集合 用KVC实现高阶消息传递 用KVC中的函数操作集合 最后参照前辈的文章 iOS开发技巧系列—详解KVC(我告诉你KVC的一切)学习KVC，动手写了各种简单的示例加深理解，由于目前KVC实际项目中运用的还不是很多，有很多地方理解的还不够透彻。 示例代码： andyRon/KVCDemo 参考：iOS开发技巧系列—详解KVC(我告诉你KVC的一切)Key-Value Coding Programming Guide - Apple Developer]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS数据持久化小结]]></title>
    <url>%2F2018%2Fios-persistdata.html</url>
    <content type="text"><![CDATA[持久化就是把数据保存在硬盘上而不是内存里，程序重启后数据不会消失。iOS中数据持久化方法有：plist文件（属性列表）、UserDefaults、NSKeyedArchiver（归档）、SQLite3、CoreData等，另外还有FMDB（用OC封装的SQLite库）、realm（代替SQLite3和CoreData新的数据库）。 plist某些特定的数据类型，可以通过XML形式存储成plist文件。这些数据类型都有write(ToFile:)方法，包括：12345678910NSArray;NSMutableArray;NSDictionary;NSMutableDictionary;NSData;NSMutableData;NSString;NSMutableString;NSNumber;NSDate; 示例代码：1234567891011121314// 获得路径let fileManager = FileManager.defaultlet path = fileManager.urls(for: .documentDirectory, in: .userDomainMask).firstlet fileName = path?.appendingPathComponent("test.plist")// 存储。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写true。let arr: NSArray = [123, 34]try? arr.write(toFile: (fileName?.path)!, atomically: true)// 读取let res = NSArray(contentsOfFile: (fileName?.path)!)print((fileName?.path)!)print(res) UserDefaults123456789101112131415// 获得UserDefaults文件let userDefaults = UserDefaults.standard// 向文件中写入内容userDefaults.set("Andy", forKey: "name")userDefaults.set("male", forKey: "sex")userDefaults.set(100, forKey: "age")// 立即保存userDefaults.synchronize()// 读取文件let name = userDefaults.object(forKey: "name")let sex = userDefaults.object(forKey: "sex")let age = userDefaults.object(forKey: "age")print(name, sex, age) 如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法. UserDefaults适合存储少量的本地数据，比如要保存一个登陆界面的数据，用户名、密码之类的。 相对于plist文件，UserDefaults保存数据方便，不需要创建文件，读取文件。 UserDefaults保存的数据也是plist类型文件，在目录Library/Preferences/里。 NSKeyedArchiver（归档）遵循了NSCoding协议的对象都可以通过NSKeyedArchiver实现序列化 实现NSCoding协议的两个方法 1234567891011121314151617//解档- (id)initWithCoder:(NSCoder *)aDecoder &#123; if ([super init]) &#123; self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;]; self.sex = [aDecoder decodeObjectForKey:@&quot;sex&quot;]; self.age = [aDecoder decodeIntegerForKey:@&quot;age&quot;]; &#125; return self;&#125;//归档- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [aCoder encodeObject:self.name forKey:@&quot;name&quot;]; [aCoder encodeObject:self.sex forKey:@&quot;sex&quot;]; [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];&#125; 归档后的对象存储和读取 1234567891011121314151617181920- (void)save &#123; NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;]; Person *person = [[Person alloc] init]; person.sex = @&quot;male&quot;; person.name = @&quot;Andy&quot;; person.age = 100; [NSKeyedArchiver archiveRootObject:person toFile:file];&#125;- (void)get &#123; NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;]; Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file]; if (person) &#123; NSLog(@&quot;name: %@, sex: %@, age: %ld&quot;, person.name, person.sex, (long)person.age); &#125;&#125; SQLite3 打开数据库并创建一个表 123456789101112131415161718192021222324252627/** * 打开数据库并创建一个表 */- (void)openDatabase &#123; //1.设置文件名 NSString *filename = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;]; //2.打开数据库文件，如果没有会自动创建一个文件 NSInteger result = sqlite3_open(filename.UTF8String, &amp;_sqlite3); if (result == SQLITE_OK) &#123; NSLog(@&quot;打开数据库成功！&quot;); //3.创建一个数据库表 char *errmsg = NULL; sqlite3_exec(_sqlite3, &quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;错误：%s&quot;, errmsg); &#125; else &#123; NSLog(@&quot;创表成功！&quot;); &#125; &#125; else &#123; NSLog(@&quot;打开数据库失败！&quot;); &#125;&#125; 插入数据 12345678910111213141516171819202122/** * 往表中插入1000条数据 */- (void)insertData &#123; NSString *nameStr; NSInteger age; for (NSInteger i = 0; i &lt; 1000; i++) &#123; nameStr = [NSString stringWithFormat:@&quot;andy-%d&quot;, arc4random_uniform(10000)]; age = arc4random_uniform(80) + 20; NSString *sql = [NSString stringWithFormat:@&quot;INSERT INTO t_person (name, age) VALUES(&apos;%@&apos;, &apos;%ld&apos;)&quot;, nameStr, age]; char *errmsg = NULL; sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;错误：%s&quot;, errmsg); &#125; &#125; NSLog(@&quot;插入完毕！&quot;);&#125; 读取数据 123456789101112131415161718192021/** * 从表中读取数据 */- (void)readData &#123; NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1000]; char *sql = &quot;select name, age from t_person;&quot;; sqlite3_stmt *stmt; NSInteger result = sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stmt, NULL); if (result == SQLITE_OK) &#123; while (sqlite3_step(stmt) == SQLITE_ROW) &#123; char *name = (char *)sqlite3_column_text(stmt, 0); NSInteger age = sqlite3_column_int(stmt, 1); NSLog(@&quot;name: %s, age: %d&quot;, name, age); &#125; &#125; sqlite3_finalize(stmt);&#125; CoreData之前的笔记：开始用Swift开发iOS 10 - 17 使用Core Data 代码：LearniOSByProject/115-PersistData 参考： 我要永远地记住你！（iOS中几种数据持久化方案）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>plist</tag>
        <tag>UserDefaults</tag>
        <tag>NSKeyedArchiver</tag>
        <tag>SQLite3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识iOS事情处理机制]]></title>
    <url>%2F2018%2Fios-event-begin.html</url>
    <content type="text"><![CDATA[事件的生命周期： 事件的产生和传递（事件如何从父控件传递到子控件并寻找到最合适的view、寻找最合适的view的底层实现、拦截事件的处理）-&gt;找到最合适的view后事件的处理（touches方法的重写，也就是事件的响应） iOS中的事件可以分为3大类型：触摸事件加速计事件远程控制事件这里只讨论iOS中的触摸事件。 1 响应者对象(UIResponder)在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，我们称之为“响应者对象”。UIApplicationUIViewController,UIView都继承了UIResponder，所以都能接收并处理事件。 UIResponder中处理事件的相关方法1234567891011121314151617// 触摸事件open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)// 加速计事件@available(iOS 3.0, *)open func motionBegan(_ motion: UIEventSubtype, with event: UIEvent?)@available(iOS 3.0, *)open func motionEnded(_ motion: UIEventSubtype, with event: UIEvent?)@available(iOS 3.0, *)open func motionCancelled(_ motion: UIEventSubtype, with event: UIEvent?)// 远程控制事件@available(iOS 4.0, *)open func remoteControlReceived(with event: UIEvent?) 2 触摸事件的处理以UIView为例说明触摸事件的处理12345678// 一根或者多根手指开始触摸view，系统会自动调用open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)// 一根或者多根手指在view上移动，系统会自动调用（随着手指的移动，会持续调用该方法）open func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)// 一根或者多根手指离开view，系统会自动调用open func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用open func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) touches中存放的都是UITouch对象 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan(_:with:)方法，touches参数中装着2个UITouch对象 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan(_:with:)方法，并且每次调用时的touches参数中只包含一个UITouch对象 想处理UIView的触摸事件，必须自定义UIView子类继承自UIView 3 UITouch对象3.1 UITouch的属性和方法12345678910111213141516// 触摸产生时所处的窗口open var window: UIWindow? &#123; get &#125;// 触摸产生时所处的视图open var view: UIView? &#123; get &#125;// 记录了触摸事件产生或变化时的时间，单位是秒open var timestamp: TimeInterval &#123; get &#125;// 当前触摸事件所处的状态open var phase: UITouchPhase &#123; get &#125;// 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击open var tapCount: Int &#123; get &#125;// 返回值表示触摸在view上的位置// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）open func location(in view: UIView?) -&gt; CGPoint// 前一个触摸点的位置open func previousLocation(in view: UIView?) -&gt; CGPoint 3.2 UITouch的作用 保存着跟手指相关的信息，比如触摸的位置、时间、阶段 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置 当手指离开屏幕时，系统会销毁相应的UITouch对象 4 iOS事件的产生 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中,即先进先出，先产生的事件先处理才符合常理。 UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。 5 iOS事件的传递 触摸事件的传递是从父控件传递到子控件，也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件 点击一个UIView或产生一个触摸事件A，这个触摸事件A会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。 UIApplication会从事件对列中取出最前面的事件（此处假设为触摸事件A），把事件A传递给应用程序的主窗口（keyWindow）。 5.1 应用如何找到最合适的控件来处理事件？ 首先判断主窗口（keyWindow）自己是否能接受触摸事件 判断触摸点是否在自己身上 子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤） view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。 如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。 5.2 UIView不能接收触摸事件的三种情况： 不允许交互：userInteractionEnabled = false 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件 透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。 默认UIImageView不能接受触摸事件，因为不允许交互，即userInteractionEnabled = NO。所以如果希望UIImageView可以交互，需要设置UIImageView的userInteractionEnabled = YES。 5.3 事件传递示例 不管视图能不能处理事件，只要点击了视图就都会产生事件，关键在于该事件最终是由谁来处理！也就是说，如果蓝色视图不能处理事件，点击蓝色视图产生的触摸事件不会由被点击的视图（蓝色视图）处理！ 如果设置父控件的透明度或者hidden，会直接影响到子控件的透明度和hidden。如果父控件的透明度为0或者hidden = YES，那么子控件也是不可见的！ 6 如何寻找最合适的view 主窗口接收到应用程序传递过来的事件后，首先判断自己能否接手触摸事件。如果能，那么在判断触摸点在不在窗口自己身上 如果触摸点也在窗口身上，那么窗口会从后往前遍历自己的子控件（遍历自己的子控件只是为了寻找出来最合适的view） 遍历到每一个子控件后，又会重复上面的两个步骤（传递事件给子控件，1.判断子控件能否接受事件，2.点在不在子控件上） 如此循环遍历子控件，直到找到最合适的view，如果没有更合适的子控件，那么自己就成为最合适的view。 6.1 寻找的方法 6.1.1 hitTest(_:with:)方法什么时候调用？只要事件一传递给一个控件,这个控件就会调用它自己的hitTest(_:with:)方法（不管这个控件能不能处理事件） 作用寻找并返回最合适的view(能够响应事件的那个最合适的view) 拦截事件的处理 通过重写hitTest(_:with:)方法，返回指定的view作为最合适的view。 不管点击哪里，最合适的view都是hitTest(_:with:)方法中返回的那个view。 通过重写hitTest(_:with:)，就可以拦截事件的传递过程，想让谁处理事件谁就处理事件。 事件的传递顺序 是： 产生触摸事件 -&gt; UIApplication事件队列 -&gt; UIWindow.hitTest(_:with:) -&gt;返回更合适的view -&gt; 子控件.hitTest(_:with:) -&gt; 返回最合适的view 6.1.2 point(inside:with:) 方法次方法判断点在不在当前view上（方法调用者的坐标系上）如果返回true，代表点在方法调用者的坐标系上;返回false代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。 7 事件的响应事件的传递和响应的区别： 事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。 参考：史上最详细的iOS之事件的传递和响应机制-原理篇iOS触摸事件全家桶史上最详细的iOS之事件的传递和响应机制-实践篇]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 15：实现计算器界面布局--Masonry和SnapKit的学习]]></title>
    <url>%2F2018%2Fios-tutorial-15.html</url>
    <content type="text"><![CDATA[Masonry和SnapKit分别是OC、Swift的界面布局框架，而且开发者相同。分别用这两个框架实现一个简单计算器界面： 完全代码：LearniOSByProject/101-MasonryDemo 和 LearniOSByProject/114-SnapKitDemo 显示区域和键盘区域： 12345678910111213141516171819202122232425262728293031323334//申明区域，displayView是显示区域，keyboardView是键盘区域 UIView *displayView = [UIView new]; [displayView setBackgroundColor:[UIColor blackColor]]; [self.view addSubview:displayView]; UIView *keyboardView = [UIView new]; [self.view addSubview:keyboardView]; //displView（显示结果区域）和 keyboardView（键盘区域） [displayView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.view.mas_top); make.left.and.right.equalTo(self.view); // displView是keyboardView的0.3倍，也就是前者是3份，后者是10份。整个屏幕的占比是前者3/13,后者10/13 make.height.equalTo(keyboardView).multipliedBy(0.3f); &#125;]; [keyboardView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(displayView.mas_bottom); make.bottom.equalTo(self.view.mas_bottom); make.left.and.right.equalTo(self.view); &#125;]; //设置显示位置的数字为0 UILabel *displayNum = [[UILabel alloc]init]; [displayView addSubview:displayNum]; displayNum.text = @&quot;0&quot;; displayNum.font = [UIFont fontWithName:@&quot;HeiTi SC&quot; size:70]; displayNum.textColor = [UIColor whiteColor]; displayNum.textAlignment = NSTextAlignmentRight; [displayNum mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.and.right.equalTo(displayView).with.offset(-10); make.bottom.equalTo(displayView).with.offset(-10); &#125;]; 键盘区域和约束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//定义键盘键名称，？号代表合并的单元格 NSArray *keys = @[@&quot;AC&quot;,@&quot;+/-&quot;,@&quot;%&quot;,@&quot;÷&quot; ,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;x&quot; ,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;-&quot; ,@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;+&quot; ,@&quot;0&quot;,@&quot;?&quot;,@&quot;.&quot;,@&quot;=&quot;]; int indexOfKeys = 0; for (NSString *key in keys)&#123; //循环所有键 indexOfKeys++; int rowNum = (indexOfKeys % 4 == 0) ? indexOfKeys/4 : (indexOfKeys/4 + 1); int colNum = (indexOfKeys % 4 == 0) ? 4 : indexOfKeys % 4; NSLog(@&quot;index is:%d and row:%d,col:%d&quot;,indexOfKeys,rowNum,colNum); //键样式 UIButton *keyView = [UIButton buttonWithType:UIButtonTypeCustom]; [keyboardView addSubview:keyView]; [keyView setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [keyView setTitle:key forState:UIControlStateNormal]; [keyView.layer setBorderWidth:1]; [keyView.layer setBorderColor:[[UIColor blackColor]CGColor]]; [keyView.titleLabel setFont:[UIFont fontWithName:@&quot;Arial-BoldItalicMT&quot; size:30]]; //键约束 [keyView mas_makeConstraints:^(MASConstraintMaker *make) &#123; //处理 0 合并单元格 if([key isEqualToString:@&quot;0&quot;] || [key isEqualToString:@&quot;?&quot;] )&#123; if([key isEqualToString:@&quot;0&quot;])&#123; [keyView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(keyboardView.mas_height).with.multipliedBy(.2f); make.width.equalTo(keyboardView.mas_width).multipliedBy(.5); make.left.equalTo(keyboardView.mas_left); make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.92f); &#125;]; &#125;if([key isEqualToString:@&quot;?&quot;])&#123; [keyView removeFromSuperview]; &#125; &#125; //正常的单元格 else&#123; make.width.equalTo(keyboardView.mas_width).with.multipliedBy(.25f); make.height.equalTo(keyboardView.mas_height).with.multipliedBy(.2f); //按照行和列添加约束，这里添加行约束 switch (rowNum) &#123; case 1: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.12f); &#125; break; case 2: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.32f); &#125; break; case 3: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.52f); &#125; break; case 4: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.72f); &#125; break; case 5: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.92f); &#125; break; default: break; &#125; //按照行和列添加约束，这里添加列约束 switch (colNum) &#123; case 1: &#123; make.left.equalTo(keyboardView.mas_left); &#125; break; case 2: &#123; make.right.equalTo(keyboardView.mas_centerX); &#125; break; case 3: &#123; make.left.equalTo(keyboardView.mas_centerX); &#125; break; case 4: &#123; make.right.equalTo(keyboardView.mas_right); &#125; break; default: break; &#125; &#125; &#125;]; &#125; 参考：忘记记录了😝]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 14：简单的下拉菜单 -- dropDownMenu]]></title>
    <url>%2F2018%2Fios-tutorial-14.html</url>
    <content type="text"><![CDATA[详细代码： dropDownMenu 按钮dropDownBtn: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class dropDownBtn: UIButton, dropDownProtocol &#123; func dropDownPressed(string: String) &#123; self.setTitle(string, for: .normal) self.dismissDropDown() &#125; var dropView = dropDownView() var height = NSLayoutConstraint() override init(frame: CGRect) &#123; super.init(frame: frame) self.backgroundColor = UIColor.darkGray dropView = dropDownView.init(frame: CGRect.init(x: 0, y: 0, width: 0, height: 0)) dropView.translatesAutoresizingMaskIntoConstraints = false dropView.delegate = self &#125; // 本视图被添加到父视图上时调用 override func didMoveToSuperview() &#123; self.superview?.addSubview(dropView) self.superview?.bringSubview(toFront: dropView) dropView.topAnchor.constraint(equalTo: self.bottomAnchor).isActive = true dropView.centerXAnchor.constraint(equalTo: self.centerXAnchor).isActive = true dropView.widthAnchor.constraint(equalTo: self.widthAnchor).isActive = true height = dropView.heightAnchor.constraint(equalToConstant: 0) &#125; var isOpen = false // 刚触摸时调用 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; if isOpen == false &#123; isOpen = true NSLayoutConstraint.deactivate([self.height]) if self.dropView.tableView.contentSize.height &gt; 150 &#123; self.height.constant = 150 &#125; else &#123; self.height.constant = self.dropView.tableView.contentSize.height &#125; NSLayoutConstraint.activate([self.height]) UIView.animate(withDuration: 0.5, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: .curveEaseInOut, animations: &#123; self.dropView.layoutIfNeeded() print(self.center, self.dropView.center, self.dropView.frame.height, self.dropView.frame.width) self.dropView.center.y += self.dropView.frame.height / 2 &#125;, completion: nil) &#125; else &#123; isOpen = false NSLayoutConstraint.deactivate([self.height]) self.height.constant = 0 NSLayoutConstraint.activate([self.height]) UIView.animate(withDuration: 0.5, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: .curveEaseInOut, animations: &#123; self.dropView.center.y -= self.dropView.frame.height / 2 self.dropView.layoutIfNeeded() &#125;, completion: nil) &#125; &#125; func dismissDropDown() &#123; isOpen = false NSLayoutConstraint.deactivate([self.height]) self.height.constant = 0 NSLayoutConstraint.activate([self.height]) UIView.animate(withDuration: 0.5, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: .curveEaseInOut, animations: &#123; self.dropView.center.y -= self.dropView.frame.height / 2 self.dropView.layoutIfNeeded() &#125;, completion: nil) &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125;&#125; 下拉视图dropDownView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class dropDownView: UIView, UITableViewDelegate, UITableViewDataSource &#123; var dropDownOptions = [String]() var tableView = UITableView() var delegate: dropDownProtocol! override init(frame: CGRect) &#123; super.init(frame: frame) tableView.backgroundColor = UIColor.darkGray self.backgroundColor = UIColor.darkGray tableView.delegate = self tableView.dataSource = self tableView.translatesAutoresizingMaskIntoConstraints = false self.addSubview(tableView) tableView.leftAnchor.constraint(equalTo: self.leftAnchor).isActive = true tableView.rightAnchor.constraint(equalTo: self.rightAnchor).isActive = true tableView.topAnchor.constraint(equalTo: self.topAnchor).isActive = true tableView.bottomAnchor.constraint(equalTo: self.bottomAnchor).isActive = true &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return dropDownOptions.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = UITableViewCell() cell.textLabel?.text = dropDownOptions[indexPath.row] cell.backgroundColor = UIColor.darkGray return cell &#125; func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; self.delegate.dropDownPressed(string: dropDownOptions[indexPath.row]) self.tableView.deselectRow(at: indexPath, animated: true) &#125; &#125; 参考：https://www.youtube.com/watch?v=22zu-OTS-3M]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[整理之前学的iOS小项目合集——LearniOSByProject]]></title>
    <url>%2F2018%2Flearniosbyproject.html</url>
    <content type="text"><![CDATA[介绍LearniOSByProject本来是自己学习iOS时的一些非常简单小例子，小项目，或者我个人博客AndyRon’s Blog文章的代码集合。没有按照什么路线学习，就是学到什么就是什么了，看上去特别乱，我自己有时候也非常懵逼，然后看到道长前辈的项目Swift-30-Projects，就整理、筛选一下，这样看着清晰一点，找起来也方便。 语言方面大部分是Swift，个别项目是OC。 以数字为目录只是为了记录项目数和排序，没有特殊意义。 下载单个项目可以参考 DownGit：怎么下载github中某个文件夹？ 总览图 一些项目的预览图]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发关于沙盒]]></title>
    <url>%2F2018%2Fios-sandbox.html</url>
    <content type="text"><![CDATA[每个iOS程序都有一个独立的文件系统（存储空间），而且只能在对应的文件系统中进行操作，此区域被称为沙盒。应用必须待在自己的沙盒里，其他应用不能访问该沙盒。所有的非代码文件都要保存在此，例如属性文件plist、文本文件、图像、图标、媒体资源等。 沙盒中相关路径 AppName.app 应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以不能在运行时对这个目录中的内容进行修改，否则会导致应用程序无法启动。 Documents/ 保存应用程序的重要数据文件和用户数据文件等。用户数据基本上都放在这个位置(例如从网上下载的图片或音乐文件)，该文件夹在应用程序更新时会自动备份，在连接iTunes时也可以自动同步备份其中的数据。 Library：这个目录下有两个子目录,可创建子文件夹。可以用来放置您希望被备份但不希望被用户看到的数据。该路径下的文件夹，除Caches以外，都会被iTunes备份. Library/Caches: 保存应用程序使用时产生的支持文件和缓存文件(保存应用程序再次启动过程中需要的信息)，还有日志文件最好也放在这个目录。iTunes 同步时不会备份该目录并且可能被其他工具清理掉其中的数据。 Library/Preferences: 保存应用程序的偏好设置文件。NSUserDefaults类创建的数据和plist文件都放在这里。会被iTunes备份。 tmp/: 保存应用运行时所需要的临时数据。不会被iTunes备份。iPhone重启时，会被清空。 12345678910111213141516171819// 获取沙盒根目录路径 NSString *homeDir = NSHomeDirectory(); // 获取Documents目录路径 NSString *docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) firstObject]; //获取Library的目录路径 NSString *libDir = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,NSUserDomainMask,YES) lastObject]; // 获取cache目录路径 NSString *cachesDir = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES) firstObject]; // 获取tmp目录路径 NSString *tmpDir =NSTemporaryDirectory(); // 获取应用程序程序包中资源文件路径的方法： NSString *bundle = [[NSBundle mainBundle] bundlePath]; NSLog(@&quot;homeDir=%@ \n docDir=%@ \n libDir=%@ \n cachesDir=%@ \n tmpDir=%@ \n bundle=%@&quot;, homeDir,docDir, libDir, cachesDir, tmpDir, bundle); 结果为：123456homeDir=/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917 docDir=/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917/Documents libDir=/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917/Library cachesDir=/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917/Library/Caches tmpDir=/private/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917/tmp/ bundle=/var/containers/Bundle/Application/4A42EF08-30BA-4C19-B0C9-62903300C2BC/SandboxDemo.app 关于NSSearchPathForDirectoriesInDomains函数FOUNDATION_EXPORT NSArray&lt;NSString *&gt; *NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde); 用于查找目录，返回指定范围内的指定名称的目录的路径集合。有三个参数： NSSearchPathDirectory directory 想要查找的目录，是个枚举值，有很多值，有关于iOS的，有关于macOS，也有关于watchOS的。 123456789101112131415161718192021222324252627282930typedef NS_ENUM(NSUInteger, NSSearchPathDirectory) &#123; NSApplicationDirectory = 1, // supported applications (Applications) NSDemoApplicationDirectory, // unsupported applications, demonstration versions (Demos) NSDeveloperApplicationDirectory, // developer applications (Developer/Applications). DEPRECATED - there is no one single Developer directory. NSAdminApplicationDirectory, // system and network administration applications (Administration) NSLibraryDirectory, // various documentation, support, and configuration files, resources (Library) NSDeveloperDirectory, // developer resources (Developer) DEPRECATED - there is no one single Developer directory. NSUserDirectory, // user home directories (Users) NSDocumentationDirectory, // documentation (Documentation) NSDocumentDirectory, // documents (Documents) NSCoreServiceDirectory, // location of CoreServices directory (System/Library/CoreServices) NSAutosavedInformationDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 11, // location of autosaved documents (Documents/Autosaved) NSDesktopDirectory = 12, // location of user&apos;s desktop NSCachesDirectory = 13, // location of discardable cache files (Library/Caches) NSApplicationSupportDirectory = 14, // location of application support files (plug-ins, etc) (Library/Application Support) NSDownloadsDirectory API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)) = 15, // location of the user&apos;s &quot;Downloads&quot; directory NSInputMethodsDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 16, // input methods (Library/Input Methods) NSMoviesDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 17, // location of user&apos;s Movies directory (~/Movies) NSMusicDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 18, // location of user&apos;s Music directory (~/Music) NSPicturesDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 19, // location of user&apos;s Pictures directory (~/Pictures) NSPrinterDescriptionDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 20, // location of system&apos;s PPDs directory (Library/Printers/PPDs) NSSharedPublicDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 21, // location of user&apos;s Public sharing directory (~/Public) NSPreferencePanesDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 22, // location of the PreferencePanes directory for use with System Preferences (Library/PreferencePanes) NSApplicationScriptsDirectory NS_ENUM_AVAILABLE(10_8, NA) = 23, // location of the user scripts folder for the calling application (~/Library/Application Scripts/code-signing-id) NSItemReplacementDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 99, // For use with NSFileManager&apos;s URLForDirectory:inDomain:appropriateForURL:create:error: NSAllApplicationsDirectory = 100, // all directories where applications can occur NSAllLibrariesDirectory = 101, // all directories where resources can occur NSTrashDirectory API_AVAILABLE(macos(10.8), ios(11.0)) API_UNAVAILABLE(watchos, tvos) = 102 // location of Trash directory&#125;; NSSearchPathDomainMask domainMask 表示“想要从哪个路径区域保护区查找”。 1234567typedef NS_OPTIONS(NSUInteger, NSSearchPathDomainMask) &#123; NSUserDomainMask =1, // 用户的主目录 NSLocalDomainMask =2, // 当前机器的本地目录 NSNetworkDomainMask =4, //在网络中公开可用的位置 NSSystemDomainMask =8, // 被苹果系统提供的，不可更改的位置 (/System) NSAllDomainsMask = 0x0ffff // 上述所有及未来的位置&#125;; BOOL expandTilde 表示是否用波浪线显示部分目录路径。~在 Linux或Unix 系统表示当前用户的Home目录。列如上面获取cache目录路径如果使用NO，那么结果就是cachesDir=~/Library/Caches 参考：沙盒和NSBundleNSSearchPathForDirectoriesInDomains方法使用沙盒和NSBundle文件系统官方手册]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC中的成员变量，实例变量，属性变量]]></title>
    <url>%2F2018%2Foc-property-variables.html</url>
    <content type="text"><![CDATA[12345678@interface MyViewController :UIViewControlle&#123;UIButton *yourButton;int count;id data；&#125;@property (nonatomic, strong) UIButton *myButton;@end 1. 成员变量 成员变量是定义在｛｝号中的变量。（yourButton、count、data都是成员变量） 成员变量用于类内部，无需与外界接触的变量。 2. 实例变量 如果成员变量的数据类型是一个类则称这个变量为实例变量。（yourButton、data是实例变量） 实例变量+基本数据类型变量=成员变量 3. 属性（或者叫属性变量） 有前缀 @property 编译器会为属性自动添加存取方法和适当的实例变量（属性前加下划线） 可以通过“点语法”访问属性，编译器会把“点语法”转换为对存取方法的调用（使用“点语法”的效果与直接调用存取方法相同）。 属性变量是用于与其他对象交互的变量。 正因为属性变量要与其他对象交互，也就有了属性修饰符或者叫属性特质（attribute）。如：nonatomic,readwrite,copy等等 参考： iOS 成员变量，实例变量，属性变量的区别，联系]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS开发：学习Runtime]]></title>
    <url>%2F2018%2Fios-runtime-begin.html</url>
    <content type="text"><![CDATA[学习iOS开发，runtime这个知识点是绕不过去的，但对于我这种学习OC不是太久，写OC的量不够多的人来说，抽象理解runtime的概念或者是看源代码有点枯燥，效果也不好，以例子的方法学习可能会更好，随着代码量的上升，对runtime的理解会越来越深入。详细代码ARRuntimeDemo,开发环境Xcode9.4 Person.h为：123456789101112131415#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject&#123; NSString * firstName;&#125;@property (nonatomic, assign) int age;+(void)run;+(void)study;-(void)f1;-(void)f2;@end Person.m为：12345678910111213141516171819202122232425262728293031323334#import "Person.h"@implementation Person&#123; NSString *lastname; float weight;&#125;-(instancetype)init &#123; self = [super init]; if (self) &#123; firstName = @"Andy"; &#125; return self;&#125;-(void)f1 &#123; NSLog(@"执行f1");&#125;-(void)f2 &#123; NSLog(@"执行f2");&#125;+ (void)run &#123; NSLog(@"跑");&#125;+ (void)study &#123; NSLog(@"学习");&#125;@end 1 获取类的所有变量(包括成员变量和属性变量)12345678910111213// 1. 获取所有变量，包括成员变量和属性变量- (IBAction)getAllVar:(UIButton *)sender &#123; unsigned int count = 0; Ivar *allVariables = class_copyIvarList([Person class], &amp;count); for (int i=0; i&lt;count; i++) &#123; Ivar ivar = allVariables[i]; const char *Variablename = ivar_getName(ivar); const char *VariableType = ivar_getTypeEncoding(ivar); NSLog(@"Name: %s Type: %s", Variablename, VariableType); &#125;&#125; 结果输出(其中firstName、lastname、weight为成员变量，_age为属性变量)：12342018-06-01 17:04:56.275194+0800 ARRuntimeDemo[60670:5448260] Name: firstName Type: @&quot;NSString&quot;2018-06-01 17:04:56.276120+0800 ARRuntimeDemo[60670:5448260] Name: lastname Type: @&quot;NSString&quot;2018-06-01 17:04:56.276503+0800 ARRuntimeDemo[60670:5448260] Name: weight Type: f2018-06-01 17:04:56.276614+0800 ARRuntimeDemo[60670:5448260] Name: _age Type: i 解释： Iva，一个指向objc_ivar结构体指针,包含了变量名、变量类型等信息 像lastname、weight这种定义在@implementation所谓的私有变量也可获取 对应class_copyIvarList还有一个class_copyPropertyList只能获得属性变量的方法 2 获取所有方法（不包括类方法）12345678910111213141516// 2. 获取所有方法，不包括类方法- (IBAction)getAllMethod:(UIButton *)sender &#123; unsigned int count; //获取方法列表，所有在.m文件显式实现的方法都会被找到，包括setter+getter方法； Method *allMethods = class_copyMethodList([Person class], &amp;count); for(int i =0;i&lt;count;i++) &#123; //Method，为runtime声明的一个宏，表示对一个方法的描述 Method md = allMethods[i]; //获取SEL：SEL类型,即获取方法选择器@selector() SEL sel = method_getName(md); //得到sel的方法名：以字符串格式获取sel的name，也即@selector()中的方法名称 const char *methodname = sel_getName(sel); NSLog(@"(Method:%s)",methodname); &#125;&#125; 结果输出:123456782018-06-01 16:54:50.433232+0800 ARRuntimeDemo[60482:5418318] (Method:f1)2018-06-01 16:54:50.433465+0800 ARRuntimeDemo[60482:5418318] (Method:f2)2018-06-01 16:54:50.433930+0800 ARRuntimeDemo[60482:5418318] (Method:.cxx_destruct)2018-06-01 16:54:50.434335+0800 ARRuntimeDemo[60482:5418318] (Method:init)2018-06-01 16:54:50.435163+0800 ARRuntimeDemo[60482:5418318] (Method:height)2018-06-01 16:54:50.435788+0800 ARRuntimeDemo[60482:5418318] (Method:setHeight:)2018-06-01 16:54:50.435990+0800 ARRuntimeDemo[60482:5418318] (Method:setAge:)2018-06-01 16:54:50.436482+0800 ARRuntimeDemo[60482:5418318] (Method:age) 解释： 获得了像height,setHeight这种隐藏的setter、getter方法 Method是一个指向objc_method结构体指针，表示对类中的某个方法的描述。 .cxx_destruct是关于系统自动内存释放的隐藏方法 3 为类添加新属性category只能为类添加新方法，不能添加新属性，但通过runtime配合category就可以达到添加属性效果。首先新建一个类Person的category：.h文件123456789// Person+Category.h#import "Person.h"@interface Person (Category)@property (nonatomic, assign)float height;@end .m文件1234567891011121314151617181920212223242526// Person+Category.m#import "Person+Category.h"#import &lt;objc/runtime.h&gt;const char *key = "myKey";@implementation Person (Category)-(void)setHeight:(float)height &#123; NSNumber *num = [NSNumber numberWithFloat:height]; /* objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy); 第一个参数是需要添加属性的对象； 第二个参数是属性的key，是C字符串就可以; 第三个参数是属性的值,类型必须为id，所以此处height先转为NSNumber类型； 第四个参数是使用策略，是一个枚举值，类似@property属性创建时设置属性修饰符，可从命名看出各枚举的意义； */ objc_setAssociatedObject(self, key, num, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;-(float)height &#123; NSNumber *number = objc_getAssociatedObject(self, key); return [number floatValue];&#125;@end 然后就能访问新属性height了：123456- (IBAction)addVar:(UIButton *)sender &#123; per = [[Person alloc] init]; per.height = 123; NSLog(@"%f", [per height]);&#125; 此时虽然通过上面的获取所有变量方法不能获取height,但通过上面的额获取所有方法可以获取height和setHeight方法了:123456789101112132018-06-01 17:14:36.945742+0800 ARRuntimeDemo[60892:5482950] Name: firstName Type: @&quot;NSString&quot;2018-06-01 17:14:36.948330+0800 ARRuntimeDemo[60892:5482950] Name: lastname Type: @&quot;NSString&quot;2018-06-01 17:14:36.948771+0800 ARRuntimeDemo[60892:5482950] Name: weight Type: f2018-06-01 17:14:36.949166+0800 ARRuntimeDemo[60892:5482950] Name: _age Type: i2018-06-01 17:15:02.198444+0800 ARRuntimeDemo[60892:5482950] (Method:f1)2018-06-01 17:15:02.198620+0800 ARRuntimeDemo[60892:5482950] (Method:f2)2018-06-01 17:15:02.198800+0800 ARRuntimeDemo[60892:5482950] (Method:.cxx_destruct)2018-06-01 17:15:02.198917+0800 ARRuntimeDemo[60892:5482950] (Method:init)2018-06-01 17:15:02.199048+0800 ARRuntimeDemo[60892:5482950] (Method:height)2018-06-01 17:15:02.199150+0800 ARRuntimeDemo[60892:5482950] (Method:setHeight:)2018-06-01 17:15:02.199239+0800 ARRuntimeDemo[60892:5482950] (Method:setAge:)2018-06-01 17:15:02.199356+0800 ARRuntimeDemo[60892:5482950] (Method:age) 4 添加新方法1234567891011121314151617// 4. 添加新方法- (IBAction)addMethod:(UIButton *)sender &#123; /* 动态添加方法： 第一个参数表示Class cls 类型； 第二个参数表示待调用的方法名称； 第三个参数(IMP)myAddingFunction，IMP一个函数指针，这里表示指定具体实现方法myAddingFunction； 第四个参数表方法的参数，0代表没有参数； */ class_addMethod([per class], @selector(NewMethod), (IMP)myAddingFunction, 0); //调用方法 【如果使用[per NewMethod]调用方法，在ARC下会报“no visible @interface"错误】 [per performSelector:@selector(NewMethod)];&#125;//具体的实现（方法的内部都默认包含两个参数Class类和SEL方法，被称为隐式参数。）int myAddingFunction(id self, SEL _cmd)&#123; NSLog(@"已新增方法:NewMethod"); return 1;&#125; 输出：12018-06-01 17:31:56.113168+0800 ARRuntimeDemo[61295:5543319] 已新增方法:NewMethod 5 交换两个方法12345678910111213// 5. 交换两个方法- (IBAction)swapMethod:(UIButton *)sender &#123; [Person run]; [Person study]; Method m1 = class_getClassMethod([Person class], @selector(run)); Method m2 = class_getClassMethod([Person class], @selector(study)); method_exchangeImplementations(m1, m2); [Person run]; [Person study];&#125; 输出：12342018-06-01 17:39:00.497375+0800 ARRuntimeDemo[61448:5566239] 跑2018-06-01 17:39:00.497841+0800 ARRuntimeDemo[61448:5566239] 学习2018-06-01 17:39:00.499255+0800 ARRuntimeDemo[61448:5566239] 学习2018-06-01 17:39:00.499449+0800 ARRuntimeDemo[61448:5566239] 跑 这篇文章我只是做了runtime一些简单使用，并没有相关的使用场景，算是入门了，文末参考提到的文章都是不错，值得以后深入。 参考：iOS开发 – Runtime 的几个小例子OC最实用的runtime总结，面试、工作你看我就足够了！iOS-RunTime，不再只是听说Runtime全方位装逼指南 Objective-C Runtime]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS核心动画小结(swift)]]></title>
    <url>%2F2018%2Fios-coreanimation-swift.html</url>
    <content type="text"><![CDATA[本文所有示例代码都是Swift4，参看文末链接 Core Animation是IOS和OS X平台上负责图形渲染与动画的基础框架。Core Animation可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘画工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用Core Animation的动画效果。Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。 上图少了iOS9才引入的CASpringAnimation, 它继承至CABasicAnimation 一、常用属性这些属性一般是在基类CAAnimation和协议CAMediaTiming中，是几种动画类共用的属性。 duration : 动画的持续时间 beginTime : 动画的开始时间 repeatCount : 动画的重复次数 autoreverses :动画结束时是否执行逆动画 timingFunction : 控制动画的显示节奏系统提供五种值选择，分别是： kCAMediaTimingFunctionLinear 线性动画 kCAMediaTimingFunctionEaseIn 先慢后快（慢进快出） kCAMediaTimingFunctionEaseOut 先块后慢（快进慢出） kCAMediaTimingFunctionEaseInEaseOut 先慢后快再慢 kCAMediaTimingFunctionDefault 默认，也属于中间比较快 delegate ： 动画代理。能够检测动画的执行和结束，在动画执行和结束做一些处理。 1234567public protocol CAAnimationDelegate : NSObjectProtocol &#123; @available(iOS 2.0, *) optional public func animationDidStart(_ anim: CAAnimation) @available(iOS 2.0, *) optional public func animationDidStop(_ anim: CAAnimation, finished flag: Bool)&#125; fillMode 动画在开始和结束时的动作。 kCAFillModeRemoved 这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态 kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态 kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始。 kCAFillModeBoth 这个其实就是上面两个的合成.动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态 二、基础动画（CABasicAnimation）基础动画就是从一个状态值（fromValue）变换成另一个状态值（toValue），特有的属性： fromValue 所改变属性的起始值 toValue 所改变属性的结束时的值 byValue 所改变属性相同起始值的改变量下面的代码是一个简单位置移动动画：12345678910111213let moveView = UIView(frame: CGRect(x: 20, y: 240, width: 70, height: 70))moveView.center = CGPoint(x: 40, y: 200)moveView.backgroundColor = UIColor.redview.addSubview(moveView)let moveAnim = CABasicAnimation(keyPath: &quot;position&quot;)moveAnim.fromValue = NSValue(cgPoint: CGPoint(x: 40, y: 240))moveAnim.toValue = NSValue(cgPoint: CGPoint(x: 300, y: 240))moveAnim.duration = 2moveAnim.repeatCount = Float.infinitymoveAnim.autoreverses = truemoveView.layer.add(moveAnim, forKey: &quot;moveAnim&quot;) 另外CABasicAnimation还可以做旋转、比例缩放、背景颜色变化、内容（图片）变化、透明度变化、圆角变化、指定大小变化等动画。（这些我都写了一些示例代码，链接在文末）这些动画的代码形式基本都差不多，先建立视图，然后创建CABasicAnimation类型动画对象，并指定不同的fromValue、toValue等属性，最后把动画对象加入到视图的CALayer层。 三、关键帧动画（CAKeyframeAnimation）按照指定的一串值进行动画,好像拍电影一样的一帧一帧的效果。 values： 动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧 path ： 可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。设置了path，那么values将被忽略。 keyTimes ： 可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧。当keyTimes没有设置的时候,各个关键帧的时间是平分的。 rotationMode : 旋转样式 CABasicAnimation可看做是最多只有2个关键帧（开始和结束）的CAKeyframeAnimation 下面的代码通过values做成抖动的动画：1234let anima = CAKeyframeAnimation(keyPath: &quot;transform.rotation&quot;)anima.values = [-Double.pi/180*4,Double.pi/180*4, -Double.pi/180*4]anima.repeatCount = Float.infinityanimView.layer.add(anima, forKey: &quot;shake&quot;) 使用path配合贝塞尔曲线就可以做成如下效果： 代码12345678910111213141516171819let tempView = UIView(frame: CGRect(x: 50, y: 100, width: 250, height: 500))let bezierPath = UIBezierPath(ovalIn: tempView.frame)let orbitAnim = CAKeyframeAnimation(keyPath: &quot;position&quot;)orbitAnim.duration = 5orbitAnim.path = bezierPath.cgPathorbitAnim.calculationMode = kCAAnimationPacedorbitAnim.fillMode = kCAFillModeForwardsorbitAnim.repeatCount = Float.infinityorbitAnim.rotationMode = kCAAnimationRotateAutoReverseanimView.layer.add(orbitAnim, forKey: &quot;orbitAnim&quot;)let shapeLayer = CAShapeLayer()shapeLayer.strokeColor = UIColor.purple.cgColorshapeLayer.fillColor = UIColor.clear.cgColorshapeLayer.lineWidth = 0.5shapeLayer.lineJoin = kCALineJoinRoundshapeLayer.lineCap = kCALineCapRoundshapeLayer.path = bezierPath.cgPathview.layer.addSublayer(shapeLayer) 四、组动画（CAAnimationGroup）组动画顾名思义就是把不同的动画组合起来，比如下面的代码：1234567891011121314151617// 位移let anima1 = CABasicAnimation(keyPath: &quot;position&quot;)anima1.fromValue = NSValue(cgPoint: CGPoint(x: 40, y: 240))anima1.toValue = NSValue(cgPoint: CGPoint(x: 300, y: 240))// 缩放let anima2 = CABasicAnimation(keyPath: &quot;transform.scale&quot;)anima2.fromValue = NSNumber.init(value: 0.8)anima2.toValue = NSNumber.init(value: 2.0)// 旋转let anima3 = CABasicAnimation(keyPath: &quot;transform.rotation&quot;)anima3.toValue = Double.pi*4// 组合let groupAnimation = CAAnimationGroup()groupAnimation.animations = [anima1, anima2, anima3]groupAnimation.duration = 3.0animView.layer.add(groupAnimation, forKey: nil) 组合后的动画效果就是在移动的同时，也在缩放和旋转。 五、过渡动画（CATransition）CATransition用于做过渡动画或者转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。 type：动画过渡类型四个系统公开的 系统公开API 效果说明 是否支持方向 kCATransitionFade 淡出效果 是 kCATransitionMoveIn 新视图移动到旧视图上 是 kCATransitionPush 新视图推出旧视图 是 kCATransitionReveal 移开旧视图显示新视图 是 其他还有一些非系统公开的过渡类型：1[&quot;cube&quot;, &quot;suckEffect&quot;, &quot;rippleEffect&quot;, &quot;pageCurl&quot;, &quot;pageUnCurl&quot;, &quot;oglFlip&quot;] subtype : 过渡动画的动画方向 1234kCATransitionFromRight 从右侧进入kCATransitionFromLeft 从左侧进入kCATransitionFromTop 从顶部进入kCATransitionFromBottom 从底部进入 startProgress：动画起点(在整体动画的百分比) endProgress：动画终点(在整体动画的百分比) 六、弹簧动画 CASpringAnimation常用属性 mass： 模拟的是质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大 默认值：1 ; stiffness：刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快。默认值： 100 ； damping：阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快。默认值：10； initialVelocity：初始速率，动画视图的初始速度大小。默认值：0 ；速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反； settlingDuration：估算时间 返回弹簧动画到停止时的估算时间，根据当前的动画参数估算；实例：1234567891011121314151617181920212223242526272829// 不同的keypath，不同的效果let springAnimation = CASpringAnimation(keyPath: "position.y")if springAnimation.keyPath == "position" &#123; springAnimation.fromValue = NSValue.init(cgPoint: self.jellyView.layer.position) springAnimation.toValue = NSValue.init(cgPoint: point)&#125; else if springAnimation.keyPath == "position.x" &#123; springAnimation.fromValue = self.jellyView.layer.position.x springAnimation.toValue = point.x&#125; else if springAnimation.keyPath == "position.y" &#123; springAnimation.fromValue = self.jellyView.layer.position.y springAnimation.toValue = point.y&#125; else if springAnimation.keyPath == "bounds" &#123; springAnimation.fromValue = NSValue.init(cgRect: CGRect(x: point.x, y: point.y, width: 60, height: 60)) springAnimation.toValue = NSValue.init(cgRect: self.jellyView.frame)&#125;springAnimation.mass = 5springAnimation.stiffness = 100springAnimation.damping = 10springAnimation.initialVelocity = 10springAnimation.duration = springAnimation.settlingDurationspringAnimation.isRemovedOnCompletion = falseself.jellyView.layer.add(springAnimation, forKey: "springAnimation") keyPath不同时效果不同： 代码：本文所有的示例代码都在https://github.com/andyRon/iOS-Animation 参考：IOSAnimationDemoiOS动画详解(学习动画看这一篇就够了)一篇文章搞定 CASpringAnimation 弹簧动画Core Animation 官方手册]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS核心动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Masonry学习]]></title>
    <url>%2F2018%2Fmasonry-begin.html</url>
    <content type="text"><![CDATA[Masonry是一个轻量级的OC布局框架， 拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了，并具有高可读性，而且同时支持 iOS 和 Max OS X。 Masonry支持的属性与NSLayoutAttrubute的对照： MASConstraint (Masonry) NSAutoLayout 说明 left NSLayoutAttributeLeft 左侧 top NSLayoutAttributeTop 上侧 right NSLayoutAttributeRight 右侧 bottom NSLayoutAttributeBottom 下侧 leading NSLayoutAttributeLeading 首部 trailing NSLayoutAttributeTrailing 尾部 width NSLayoutAttributeWidth 宽 height NSLayoutAttributeHeight 高 centerX NSLayoutAttributeCenterX 横向中点 centerY NSLayoutAttributeCenterY 纵向中点 baseline NSLayoutAttributeBaseline 文本基线 其中leading与left, trailing与right 在正常情况下是等价的。但是当一些布局是从右至左时(比如阿拉伯文) 则会对调， 换句话说就是基本可以 用left和right就好了。 在Masonry中能够添加AutoLayout约束有三个函数: 12345678/*mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束*/- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block; equalTo 和 mas_equalTo的区别? mas_equalTo是宏，在MASConstraint.h文件中定义： 1#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__))) mas_equalTo 比equalTo多了类型转换操作, 大多数时候两个方法都是 通用的，但是对于数值元素使用mas_equalTo。对于对象或是多个属性的处理，使用equalTo。 以几个🌰学习Masonry： 1 中心点与self.view相同，宽度为300*30012345678910// exp1: 中心点与self.view相同，宽度为300*300-(void)exp1 &#123; UIView *view = [UIView new]; [view setBackgroundColor:[UIColor redColor]]; [self.view addSubview:view]; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self.view); make.size.mas_equalTo(CGSizeMake(300, 300)); &#125;];&#125; 2 上下左右边距都为1012345678910111213141516171819202122-(void)exp2 &#123; UIView *view = [UIView new]; [view setBackgroundColor:[UIColor redColor]]; [self.view addSubview:view]; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; // 写法1 make.edges.equalTo(self.view).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); /* // 写法2 make.top.equalTo(self.view).with.offset(10); make.left.equalTo(self.view).with.offset(10); make.bottom.equalTo(self.view).with.offset(-10); make.right.equalTo(self.view).with.offset(-10); */ /* // 写法3 make.top.left.bottom.and.right.equalTo(self.view).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); */ &#125;];&#125; edges 就是top,left,bottom,right简化写法 写法2中 bottom和right的offset是负数，因为计算的是绝对的数值，也就是view的bottom的y值减去self.view的bottom的y值是-10，view的right的x值减去self.view的right的x值是-10。 and和with什么事件都没做，只是从应用语法看上去很顺。 3 让两个高度为150的view垂直居中且等宽且等间隔排列 间隔为10(自动计算器高度)123456789101112131415161718192021222324252627282930-(void)exp3&#123; UIView *view1 = [UIView new]; [view1 setBackgroundColor:[UIColor redColor]]; [self.view addSubview:view1]; UIView *view2 = [UIView new]; [view2 setBackgroundColor:[UIColor redColor]]; [self.view addSubview:view2]; [view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(self.view.mas_centerY); make.height.mas_equalTo(150); make.width.mas_equalTo(view2.mas_width); make.left.mas_equalTo(self.view.mas_left).with.offset(10); make.right.mas_equalTo(view2.mas_left).offset(-10); &#125;]; [view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(self.view.mas_centerY); make.height.mas_equalTo(150); make.width.mas_equalTo(view1.mas_width); make.left.mas_equalTo(view1.mas_right).with.offset(10); make.right.equalTo(self.view.mas_right).offset(-10); &#125;]; &#125; 4 iOS自带计算器布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150-(void)exp4&#123; //申明区域，displayView是显示区域，keyboardView是键盘区域 UIView *displayView = [UIView new]; [displayView setBackgroundColor:[UIColor blackColor]]; [self.view addSubview:displayView]; UIView *keyboardView = [UIView new]; [self.view addSubview:keyboardView]; //先按1：3分割 displView（显示结果区域）和 keyboardView（键盘区域） [displayView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.view.mas_top); make.left.and.right.equalTo(self.view); make.height.equalTo(keyboardView).multipliedBy(0.3f); &#125;]; [keyboardView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(displayView.mas_bottom); make.bottom.equalTo(self.view.mas_bottom); make.left.and.right.equalTo(self.view); &#125;]; //设置显示位置的数字为0 UILabel *displayNum = [[UILabel alloc]init]; [displayView addSubview:displayNum]; displayNum.text = @&quot;0&quot;; displayNum.font = [UIFont fontWithName:@&quot;HeiTi SC&quot; size:70]; displayNum.textColor = [UIColor whiteColor]; displayNum.textAlignment = NSTextAlignmentRight; [displayNum mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.and.right.equalTo(displayView).with.offset(-10); make.bottom.equalTo(displayView).with.offset(-10); &#125;]; //定义键盘键名称，？号代表合并的单元格 NSArray *keys = @[@&quot;AC&quot;,@&quot;+/-&quot;,@&quot;%&quot;,@&quot;÷&quot; ,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;x&quot; ,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;-&quot; ,@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;+&quot; ,@&quot;0&quot;,@&quot;?&quot;,@&quot;.&quot;,@&quot;=&quot;]; int indexOfKeys = 0; for (NSString *key in keys)&#123; //循环所有键 indexOfKeys++; int rowNum = indexOfKeys %4 ==0? indexOfKeys/4:indexOfKeys/4 +1; int colNum = indexOfKeys %4 ==0? 4 :indexOfKeys %4; NSLog(@&quot;index is:%d and row:%d,col:%d&quot;,indexOfKeys,rowNum,colNum); //键样式 UIButton *keyView = [UIButton buttonWithType:UIButtonTypeCustom]; [keyboardView addSubview:keyView]; [keyView setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [keyView setTitle:key forState:UIControlStateNormal]; [keyView.layer setBorderWidth:1]; [keyView.layer setBorderColor:[[UIColor blackColor]CGColor]]; [keyView.titleLabel setFont:[UIFont fontWithName:@&quot;Arial-BoldItalicMT&quot; size:30]]; //键约束 [keyView mas_makeConstraints:^(MASConstraintMaker *make) &#123; //处理 0 合并单元格 if([key isEqualToString:@&quot;0&quot;] || [key isEqualToString:@&quot;?&quot;] )&#123; if([key isEqualToString:@&quot;0&quot;])&#123; [keyView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(keyboardView.mas_height).with.multipliedBy(.2f); make.width.equalTo(keyboardView.mas_width).multipliedBy(.5); make.left.equalTo(keyboardView.mas_left); make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.9f); &#125;]; &#125;if([key isEqualToString:@&quot;?&quot;])&#123; [keyView removeFromSuperview]; &#125; &#125; //正常的单元格 else&#123; make.width.equalTo(keyboardView.mas_width).with.multipliedBy(.25f); make.height.equalTo(keyboardView.mas_height).with.multipliedBy(.2f); //按照行和列添加约束，这里添加行约束 switch (rowNum) &#123; case 1: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.1f); keyView.backgroundColor = [UIColor colorWithRed:205 green:205 blue:205 alpha:1]; &#125; break; case 2: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.3f); &#125; break; case 3: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.5f); &#125; break; case 4: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.7f); &#125; break; case 5: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.9f); &#125; break; default: break; &#125; //按照行和列添加约束，这里添加列约束 switch (colNum) &#123; case 1: &#123; make.left.equalTo(keyboardView.mas_left); &#125; break; case 2: &#123; make.right.equalTo(keyboardView.mas_centerX); &#125; break; case 3: &#123; make.left.equalTo(keyboardView.mas_centerX); &#125; break; case 4: &#123; make.right.equalTo(keyboardView.mas_right); [keyView setBackgroundColor:[UIColor colorWithRed:243 green:127 blue:38 alpha:1]]; &#125; break; default: break; &#125; &#125; &#125;]; &#125; &#125; 代码: MasonryDemo 参考:Masonry介绍与使用实践(快速上手Autolayout)Masonry的使用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Masonry</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中where的用法总结]]></title>
    <url>%2F2017%2Fswift-where.html</url>
    <content type="text"><![CDATA[不同的版本的Swift中where用法有些不同，以最新的Swift4为准， 1 if, guard, while三个语句中where被去掉了，直接使用,相隔就行了12345678910111213141516if let oldMan: Int = 50, let youngerMan: Int = 18, oldMan &gt; youngerMan &#123; print("odlMan &gt; youngerMan")&#125; else &#123; print("错误判断")&#125;var arrayTwo:[Int]? = []while let arr = arrayTwo, arr.count &lt; 5 &#123; arrayTwo?.append(1)&#125;let string:String? = "小刚"guard let str = string, str != "小明" else &#123; fatalError("看错人了") //&#125;print("确实是小明") 2 do catch1234567891011enum ExceptionError:Error&#123; case httpCode(Int)&#125;func throwError() throws &#123; throw ExceptionError.httpCode(500)&#125;do&#123; try throwError()&#125;catch ExceptionError.httpCode(let httpCode) where httpCode &gt;= 500&#123; print("server error")&#125; 3 switch1234567var value:(Int,String) = (1,"小明")switch value &#123;case let (x,_) where x &lt; 60: print("不及格")default: print("及格")&#125; 4 for in12345let arrayOne = [1,2,3,4,5]let dictionary = [1:"hehe1",2:"hehe2"]for i in arrayOne where dictionary[i] != nil &#123; print(i)&#125; 5 泛型1234567func genericFunction&lt;S&gt;(str:S) where S:ExpressibleByStringLiteral&#123; print(str)&#125;// 也可以不使用where语句，直接在尖括号中定义时做限制func genericFunction2&lt;S:ExpressibleByStringLiteral&gt;(str:S)&#123; print(str)&#125; 6 协议1234567protocol aProtocol&#123;&#125;extension aProtocol where Self:UIView&#123; //只给遵守myProtocol协议的UIView添加了扩展 func getString() -&gt; String&#123; return "string" &#125;&#125; playground文件：andyRon/LearnSwift/Where.playground 参考：Swift where 关键字]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>where</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习：访问修饰符]]></title>
    <url>%2F2017%2Foc-access-modifier.html</url>
    <content type="text"><![CDATA[用来修饰属性，可以限定对象的属性在那一段范围之中访问。 @private : 只能在本类的内部访问。@protected: 只能在本类以及其子类中访问，默认。@package: 当前框架中访问。@public: 在任意地方访问。 如果不为属性指定访问修饰符 默认：protected子类仍然可以继承父类的私有属性。就算父类的属性是private，只不过在子类当中无法直接访问从父类继承过来的私有属性，可以通过set get方法来访问。 访问修饰符只能用来修饰属性，不能用来修饰方法。 访问修饰符的作用域从写访问修饰符的地方开始往下，直到遇到另外一个访问修饰符的或者结束大括弧为止，中间的所有的属性都应用这个访问修饰符。 使用建议@public 无论什么情况下都不要使用，属性不要直接暴漏给外界。@private 如果属性只想在本类中使用，不想再子类中使用。@protected 如果你希望属性只在本类和本类的子类中使用。 description 方法description方法是定义在NSObject之中的。我们通过重写description方法来修改NSLog的输出形式。NSLog的底层就是description方法。]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习：内存中的区域]]></title>
    <url>%2F2017%2Foc-memory-area.html</url>
    <content type="text"><![CDATA[OC中，内存一般分为五大区域 栈 存储局部变量和实参 由编译器自动分配释放 存储空间有限 地址是连续的 地址分配从大到小 访问速度快 堆 允许程序员自己申请的空间，需要程序员自己控制，会出现内存泄漏 使用 new 方法创建的对象保存在堆区 被创建对象的所有成员变量保存在堆区中 地址是不连续的 速度没有栈区快。地址不连续，有一个寻中的过程 BSS段 （静态区） 存储没有初始化的全局变量和静态变量 数据段 （常量区) 用来存储已经初始化的全局变量，静态变量还有常量 代码段 用来存储程序的代码。 参考：3.1 OC特性之 内存五大区域]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习：类方法和对象方法的调用过程]]></title>
    <url>%2F2017%2Foc-class-method-instance-method.html</url>
    <content type="text"><![CDATA[类方法中不能直接访问属性。 在类方法中也不能通过self直接调用当前类的其他的对象方法。 参考： OC-基础总结（一）]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习：对象在内存中是如何存储的？]]></title>
    <url>%2F2017%2Foc-memory.html</url>
    <content type="text"><![CDATA[例：Person *p1 = [Person new]; Person *p1; 会在栈内存中申请一块空间，在栈内存中声明1个Person类型的指针变量p1。p1是一个指针变量，那么只能存储地址。 [person new]; 真正在内存中创建对象的其实是这句代码。 new方法在堆内存中创建一块合适大小的空间，然后在空间中根据类的模板创建对象。类模板中定义了什么属性，就把这些属性依次声明在对象之中。对象中还有另外一个属性，叫做isa ，是一个指针，指向对象所属的类在代码段中的地址。（类中的isa指向父类） 初始化对象的属性，给对象的属性赋默认值。如果属性的类型是基本数据类型，那么就赋值为0。如果属性的类型是c语言的指针类型，那么就赋值为NULL。如果属性的类型为OC语言的类指针类型，那么就赋值为nil。 注意1). 对象中只有属性没有方法，属性包括自己类的属性，外加一个isa指针指向代码段中的类。2). 如何访问对象的属性，指针名-&gt;属性名根据指针，找到指针指向的对象，在找到对象中的属性来访问。3). 如何调用方法。[指针名 方法名];先根据指针名找到对象，对象发现要调用方法，在根据对象的isa指针找到类。然后调用类里的方法。4). 为什么不把方法存储到对象之中。因为每一个对象的方法的代码实现都是一模一样的，没有必要为每一个对象都保存一个方法，这样的话就太浪费空间了，既然都一样，那么就只保存一份在代码段中。5). 对象属性是有默认值的。 参考： OC-基础总结（一）]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习：#import,#include,@class]]></title>
    <url>%2F2017%2Foc-basic-import-include-class.html</url>
    <content type="text"><![CDATA[#import是#inlcude的增强版，能防止同一个文件被多次包含。 #import会包含这个类的所有信息，而@class只是告诉编译器，其后面声明的名称是类的名称。 在头文件中， 一般只需要知道被引用的类的名称，所以@class常用在头文件中。 对比#include与#import 1234#include &lt;xxx.h&gt; #import &lt;xxx.h&gt;#include &quot;xxx.h&quot;#import &quot;xxx.h&quot; 尖括号，编译器会在系统文件目录下查找。 双引号引用，编译器首先会在用户目录下查找，然后去安装目录中查找，最后在系统文件目录中查找。 参考： 如何使用#import #include与@class]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[向CocoaPods发布代码]]></title>
    <url>%2F2017%2Fios-cocoapods-push.html</url>
    <content type="text"><![CDATA[Cocoapods是非常好用的一个iOS依赖管理工具，用它来管理和更新项目中的第三库使iOS开发更加方便。使用别人优秀的代码在程序员开发过程中是非常常见的事，为别人贡献代码也是很有必要的事。 这篇文章是我总结向Cocoapods贡献代码的过程。我以自己一个非常非常简单的项目ARFPSStatus来记录这个过程。ARFPSStatus非常简单，是Swift写的在状态栏显示屏幕的FPS，源码只有一个Swift文件。 来吧！🎉我试着为iOS开发贡献一点绵薄之力吧。🎉 一、安装cocoapods1sudo gem install cocoapods --pre 二、创建代码并上传代码到Github就是要发布的代码了，具体怎么上传代码到Github上我就不重复了。 三、在github上发布一个版本点击这边的release:发布一个版本，假设是0.1.0: 创建podspec文件常见一个&lt;项目名称&gt;.podspec文件，我这边就是ARFPSStatus.podspec文件，内容如下：1234567891011121314Pod::Spec.new do |s| s.name = &quot;ARFPSStatus&quot; s.version = &quot;0.1.0&quot; s.summary = &quot;ARFPSStatus - Show FPS Status on StatusBar in Swift&quot; s.homepage = &quot;https://github.com/andyRon/ARFPSStatus&quot; s.license = &quot;MIT&quot; s.authors = &#123; &quot;andyron&quot; =&gt; &quot;rongming.2008@163.com&quot; &#125; s.source = &#123; :git =&gt; &quot;https://github.com/andyRon/ARFPSStatus.git&quot;, :tag =&gt; &quot;0.1.0&quot; &#125; s.frameworks = &apos;Foundation&apos;, &apos;UIKit&apos; s.platform = :ios, &apos;9.0&apos; s.source_files = &apos;ARFPSStatus/*&apos; s.requires_arc = true end s.name – 项目名称，也就是别人使用Pod时使用的名字，需要唯一，可事先在Cocoapods上查询一下。 s.version – 这是你 Pod 的版本。务必注意，它得和 Github release 的版本号相同，就是刚才发布的版本0.1.0。如果两者不匹配，就会报错。 s.summary 和 s.description – 这两个变量最终会显示在 Cocoapods 页面上。请确保 description 比 summary 更长，否则将会报错。description不是必须的。 s.homepage – 这是 Pod 源代码的 URL。 s.author – 开发者信息，开发者名字和邮箱。 s.source_files – 这是最重要的参数。不是所有Github项目中所有文件都需要提交到CocoaPods里，项目中可能有一些Demo、图片啊等，提交到CocoaPods的只需要源码，就是别人使用时最少所需的代码。例如，我需要提交的是ARFPSStatus/ARFPSStatus.swift文件，s.source_files就是ARFPSStatus/ARFPSStatus.swift，或者之后如果再在ARFPSStatus/目录中添加其他文件，s.source_files就可以是ARFPSStatus/*。当然，还可以是其它一些形式。ARFPSStatus/*.swiftARFPSStatus/*.{swift,plist} Podspec文件的详细语法规则可查看官网的Podspec Syntax Reference 验证项目CocoaPods 需要验证项目有没有错误 pod lib lint12345678$ pod lib lint -&gt; ARFPSStatus (0.1.0) - WARN | [iOS] license: Unable to find a license file - WARN | xcodebuild: /Users/andyron/myfield/github/ARFPSStatus/ARFPSStatus/ARFPSStatus.swift:91:17: warning: variable &apos;label&apos; was never mutated; consider changing to &apos;let&apos; constant[!] ARFPSStatus did not pass validation, due to 2 warnings (but you can use `--allow-warnings` to ignore them).You can use the `--no-clean` option to inspect any issue. 如果想忽略警告，可使用--allow-warnings。 $ pod lib lint --allow-warnings 发布 创建 Trunk 账号关于Trunk可以查看为什么做 Trunk这篇文章创建 Trunk 账号很简单，只要一个邮箱。pod trunk register rongming.2008@163.com邮箱会收到一封确认邮件，确认成功： 推送代码到Podpod trunk push ARFPSStatus.podspec当然也可使用pod trunk push ARFPSStatus.podspec --allow-warnings来忽略一些不必要的警告。成功后：1234567891011$ pod trunk push ARFPSStatus.podspec Updating spec repo `master`-------------------------------------------------------------------------------- 🎉 Congrats 🚀 ARFPSStatus (0.1.0) successfully published 📅 September 28th, 11:33 🌎 https://cocoapods.org/pods/ARFPSStatus 👍 Tell your friends!-------------------------------------------------------------------------------- 使用新发布的代码发布成功和可能需要一段时间才能使用，可以到Cocoapods上查询。 项目的Podfile文件中添加ARFPSStatus,并安装。 123456target &apos;FPSDemo&apos; douse dynamic frameworks use_frameworks! pod &quot;ARFPSStatus&quot; end Pods项目会多出ARFPSStatus目录，里面的Support Files目录不是我添加的，是Cocoapods自动添加的一些相关文件。 参考：基于 Swift 创建 CocoaPods 完全指南Podspec Syntax Reference]]></content>
      <categories>
        <category>iOS</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于iOS开发中的pch文件]]></title>
    <url>%2F2017%2Fios-pch.html</url>
    <content type="text"><![CDATA[.pch文件也是一种头文件，它的内容能被项目中的其他所有源文件共享和访问。是一个预编译文件。 pch文件的作用：1.存放一些全局的宏(整个项目中都用得上的宏) 2.用来包含一些头文件(整个项目中都用得上的头文件) 3.能自动打开或者关闭日志输出功能 Xcode新建pch文件 Xcode配置pch文件 pch文件的简单例子一个小项目的pch文件： 1234567891011121314151617181920212223242526272829303132#ifndef PrefixHeader_pch#define PrefixHeader_pch// Include any system framework and library headers here that should be included in all compilation units.// You will also need to set the Prefix Header build setting of one or more of your targets to reference this file.#import &quot;ARSearchBar.h&quot;#import &lt;FMDB.h&gt;#import &quot;ARSqliteTool.h&quot;#import &lt;AFNetworking.h&gt;#import &lt;SSZipArchive.h&gt;#import &lt;MobileCoreServices/MobileCoreServices.h&gt;#import &lt;SystemConfiguration/SystemConfiguration.h&gt;#define ARUserDefaults [NSUserDefaults standardUserDefaults]#define ARScreenBounds [UIScreen mainScreen].bounds#define ARScreenWidth [UIScreen mainScreen].bounds.size.width#define ARScreenHeight [UIScreen mainScreen].bounds.size.height#define WeakSelf __weak typeof(self) weakSelf = self;/** * 1.返回一个RGBA格式的UIColor对象 */#define RGBA(r, g, b, a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]/** * 2.返回一个RGB格式的UIColor对象 */#define RGB(r, g, b) RGBA(r, g, b, 1.0f)#endif /* PrefixHeader_pch */ 参考：http://www.cnblogs.com/manmq/p/6377882.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>pch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS沙盒和文件管理]]></title>
    <url>%2F2017%2Fios-sandbox-file.html</url>
    <content type="text"><![CDATA[沙盒（sandbox）：iOS系统为每个应用程序创建自己的目录，每个应用程序只能访问自己的目录。所有的非代码文件都要保存在此，例如图像，图标，声音，映像，属性列表，文本文件等。 在Mac的Finder上打开一个目录由于有些目录比较长，不适合直接Finder里点击选取。有两种方法可以用： 在Finder的菜单中选择 前往 &gt; 前往文件夹 在命令行中使用open命令： open /Users/andyron/Library/Developer/CoreSimulator/Devices/F03C84B3-2A5E-44A7-AA51-2142A6397CA7/data/Containers/Data/Application/E83106A7-FCF3-45A6-888E-330BC52B279B/ 应用沙盒的完整目录 Xcode的模拟器的目录类似：1/Users/andyron/Library/Developer/CoreSimulator/Devices/F03C84B3-2A5E-44A7-AA51-2142A6397CA7/data/Containers/Data/Application/E83106A7-FCF3-45A6-888E-330BC52B279B/ Devices/F03C84B3-2A5E-44A7-AA51-2142A6397CA7是Xcode中不同模拟器的区别字符 真机中类似：1/var/mobile/Containers/Data/Application/9AC577C1-08B2-4BAE-9CE2-1211E4994F9E/ 类似Application/9AC577C1-08B2-4BAE-9CE2-1211E4994F9E/这个目录就是每个应用沙盒的根目录。 沙盒中目录结构类似如下：12345678910├── Documents├── Library│ ├── Caches│ │ └── Snapshots│ │ └── com.andyron.Sandbox│ │ ├── 9EEA412B-07C1-44EC-995B-0C12AD87BAF9@2x.ktx│ │ └── D3F89052-27FD-42A1-B246-B416E1772FBB@2x.ktx│ └── Preferences├── SystemData└── tmp 默认情况下，每个沙盒含有3个文件夹：Documents, Library 和 tmp。因为应用的沙盒机制，应用只能在几个目录下读写文件 Documents：苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包括此目录 Library：存储程序的默认设置或其它状态信息； Library/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除 tmp：提供一个即时创建临时文件的地方。 iTunes在与iPhone同步时，备份所有的Documents和Library文件。 iPhone在重启时，会丢弃所有的tmp文件。 获取不同目录12345678910111213141516171819202122// 1、获取程序的Home目录 NSString *homeDirectory = NSHomeDirectory(); NSLog(@&quot;home path:%@&quot;, homeDirectory); // 2、获取document目录 NSArray *Documentspaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *Documentspath = [Documentspaths objectAtIndex:0]; NSLog(@&quot;Documents path:%@&quot;, Documentspath); // 3、获取Cache目录 Library/Caches NSArray *Cachepaths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *Cachepath = [Cachepaths objectAtIndex:0]; NSLog(@&quot;Cache path:%@&quot;, Cachepath);// 4、获取Library目录 NSArray *Librarypaths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES); NSString *Librarypath = [Librarypaths objectAtIndex:0]; NSLog(@&quot;Library path:%@&quot;, Librarypath);// 5、获取Tmp目录 NSString *tmpDir = NSTemporaryDirectory(); NSLog(@&quot;tmpDir:%@&quot;, tmpDir); 文件的写入和读取1234567891011121314151617181920- (void)file_w &#123;// 6、写入文件 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *docDir = [paths objectAtIndex:0]; if (!docDir) &#123; NSLog(@&quot;Documents 目录未找到&quot;); &#125; NSArray *array = [[NSArray alloc] initWithObjects:@&quot;内容&quot;,@&quot;content&quot;,nil]; NSString *filePath = [docDir stringByAppendingPathComponent:@&quot;testFile.txt&quot;]; [array writeToFile:filePath atomically:YES];&#125;- (void)file_r &#123;// 7, 读取文件 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *docDir = [paths objectAtIndex:0]; NSString *filePath = [docDir stringByAppendingPathComponent:@&quot;testFile.txt&quot;]; NSArray *array = [[NSArray alloc]initWithContentsOfFile:filePath]; NSLog(@&quot;%@&quot;, array);&#125; 文件管理文件管理器NSFileManager有判断文件是否存在、创建目录和文件、获取文件名、删除文件等功能。 判断文件是否存在 12345678910// 创建文件管理器NSFileManager * fileManager = [NSFileManager defaultManager];NSString * documents = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];NSString * filePath = [documents stringByAppendingPathComponent:@&quot;testFile.txt&quot;];// 判断一个文件是否存在,传入全路径if ([fileManager fileExistsAtPath:filePath]) &#123; NSLog(@&quot;it is exit&quot;);&#125; 创建目录和文件 123456789101112131415161718// 在Documents里创建目录NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];NSLog(@&quot;documentsDirectory: %@&quot;,documentsDirectory);NSFileManager *fileManager = [NSFileManager defaultManager];NSString *testDirectory = [documentsDirectory stringByAppendingPathComponent:@&quot;test&quot;];// 创建目录[fileManager createDirectoryAtPath:testDirectory withIntermediateDirectories:YES attributes:nil error:nil];// 在目录下创建文件NSString *testPath = [testDirectory stringByAppendingPathComponent:@&quot;test00.txt&quot;];NSString *testPath2 = [testDirectory stringByAppendingPathComponent:@&quot;test22.txt&quot;];NSString *testPath3 = [testDirectory stringByAppendingPathComponent:@&quot;test33.txt&quot;];NSString *string = @&quot;写入内容，write String&quot;;[fileManager createFileAtPath:testPath contents:[string dataUsingEncoding:NSUTF8StringEncoding] attributes:nil];[fileManager createFileAtPath:testPath2 contents:[string dataUsingEncoding:NSUTF8StringEncoding] attributes:nil];[fileManager createFileAtPath:testPath3 contents:[string dataUsingEncoding:NSUTF8StringEncoding] attributes:nil]; 获取目录列里所有文件名subpathsOfDirectoryAtPath 和 subpathsAtPath 两个方法都可以。 12345678910NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];NSLog(@&quot;documentsDirectory: %@&quot;,documentsDirectory);NSFileManager *fileManage = [NSFileManager defaultManager];NSString *myDirectory = [documentsDirectory stringByAppendingPathComponent:@&quot;test&quot;];NSArray *file = [fileManage subpathsOfDirectoryAtPath: myDirectory error:nil];NSLog(@&quot;%@&quot;,file);NSArray *file2 = [fileManage subpathsAtPath: myDirectory ];NSLog(@&quot;%@&quot;,file2); 更改到指定目录下操作changeCurrentDirectoryPath方法。 12345678910//创建文件管理器NSFileManager *fileManager = [NSFileManager defaultManager];NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];//更改到待操作的目录下[fileManager changeCurrentDirectoryPath:[documentsDirectory stringByExpandingTildeInPath]];//创建文件fileName文件名称，contents文件的内容，如果开始没有内容可以设置为nil，attributes文件的属性，初始为nilNSString * fileName = @&quot;testFileNSFileManager.txt&quot;;NSArray *array = [[NSArray alloc] initWithObjects:@&quot;hello world&quot;,@&quot;hello world1&quot;, @&quot;hello world2&quot;,nil];[fileManager createFileAtPath:fileName contents:[NSKeyedArchiver archivedDataWithRootObject:array] attributes:nil]; 删除文件 1[fileManager removeItemAtPath:fileName error:nil]; 代码： Sandbox 参考：沙盒机制与文件(一)沙盒机制与文件(二)沙盒机制与文件(三)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(六)：SDWebImage的简单使用]]></title>
    <url>%2F2017%2Fios-network-6.html</url>
    <content type="text"><![CDATA[SDWebImage一些知识： 对远程图片进行缓存管理（磁盘+内存） 异步加载 同一个URL图片不会重复下载 失效的URL不会被无限重试 图片加载一般使用 SDWebImage通过为UIImageView添加类别，扩展了一些类似的方法，只是参数的多少数目不同，最全的参数的方法是： 1-sd_setImageWithURL:placeholderImage:options:progress:completed: sd_setImageWithURL: URL的图片的URL placeholderImage: 远程图片没有加载完成的占位图片 options: 一个位移枚举(SDWebImageOptions)，可以通过按位或 | 来并列添加参数。SDWebImageOptions的所有选项如下 1234567891011121314151617181920212223242526272829303132//失败后重试SDWebImageRetryFailed = 1 &lt;&lt; 0, //UI交互期间开始下载，导致延迟下载比如UIScrollView减速。SDWebImageLowPriority = 1 &lt;&lt; 1, //只进行内存缓存SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, //这个标志可以渐进式下载,显示的图像是逐步在下载SDWebImageProgressiveDownload = 1 &lt;&lt; 3, //刷新缓存SDWebImageRefreshCached = 1 &lt;&lt; 4, //后台下载SDWebImageContinueInBackground = 1 &lt;&lt; 5, //NSMutableURLRequest.HTTPShouldHandleCookies = YES;SDWebImageHandleCookies = 1 &lt;&lt; 6, //允许使用无效的SSL证书//SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, //优先下载SDWebImageHighPriority = 1 &lt;&lt; 8, //延迟占位符SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, //改变动画形象SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, progress: Block 获取当前图片数据的下载进度 receivedSize：已经下载完成的数据大小 expectedSize：该文件的数据总大小 completed: Block加载完 image:下载得到的图片数据 error:下载出现的错误信息 SDImageCacheType：图片的缓存策略 imageURL：下载的图片的url地址 引入UIImageView+WebCache类别就可以使用SDWebImage加载图片 1#import &quot;UIImageView+WebCache.h&quot; 不同参数方法使用🌰 12345678910111213141516171819[self.imageView sd_setImageWithURL: url];[self.imageView sd_setImageWithURL: url completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123; NSLog(@&quot;图片加载完&quot;);&#125;];[self.imageView sd_setImageWithURL:url placeholderImage:[UIImage imageNamed:@&quot;apple&quot;]];[self.imageView sd_setImageWithURL:url placeholderImage:[UIImage imageNamed:@&quot;apple&quot;] completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123; NSLog(@&quot;图片加载完&quot;);&#125;];[self.imageView sd_setImageWithURL:url placeholderImage:[UIImage imageNamed:@&quot;apple&quot;] options: SDWebImageCacheMemoryOnly];[self.imageView sd_setImageWithURL:url placeholderImage:nil options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123; //计算当前图片的下载进度 NSLog(@&quot;下载进度:%.2f&quot;,1.0 *receivedSize / expectedSize);&#125; completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123;&#125;]; 图片加载过程 缓存大小12NSInteger *cacheSize = [[SDImageCache sharedImageCache] getSize];NSLog(@&quot;缓存大小：%d&quot;, cacheSize); 清理缓存12345// 清理内存缓存[[SDImageCache sharedImageCache] clearMemory];// 清理磁盘缓存[[SDImageCache sharedImageCache] clearDisk]; 查看缓存完整目录1NSLog(@&quot;%s__%d__|%@&quot;,__FUNCTION__,__LINE__,[[SDImageCache sharedImageCache] defaultCachePathForKey:@&quot;http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg&quot;]); 代码：SDWebImageDemo 参考：iOS图片加载框架－SDWebImage解读SDWebImage 的简单使用方法iOS开发SDWebImage的基本使用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(五)：Cookie的使用]]></title>
    <url>%2F2017%2Fios-network-5.html</url>
    <content type="text"><![CDATA[Cookie在Web开发时是非常常用的客户端（浏览器）保存少量信息一种方法。Cookie是网站为了便是终端身份，保存在终端本地的用户凭证信息。Cookie中的字段与意义由服务端进行定义。例如，当用户在某个网站进行了登录操作后，服务端会将Cookie信息返回给终端，终端会将这些信息进行保存，在下一次再次访问这个网站时，终端会将保存的Cookie信息一并发送到服务端，服务端根据Cookie信息是否有效来判断此用户是否可以自动登录。 在iOS同样也有Cookie，Cookie管理的有两个类：NSHTTPCookieStorage 和 NSHTTPCookie。 获取Cookie在请求后获取Cookie 1234NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];for (NSHTTPCookie *cookie in [cookieJar cookies]) &#123; NSLog(@&quot;%@&quot;, cookie);&#125; 例如请求百度后，就会返回几个如下Cookie对象(NSHTTPCookie): 123456789101112&lt;NSHTTPCookie version:0 name:BD_NOT_HTTPS value:1 expiresDate:&apos;2017-09-23 14:14:22 +0000&apos; created:&apos;2017-09-23 14:09:22 +0000&apos; sessionOnly:FALSE domain:www.baidu.com partition:none path:/ isSecure:FALSE path:&quot;/&quot; isSecure:FALSE&gt; 设置Cookie在请求前设置一个如下Cookie： 12345678910// 请求前 设置CookieNSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary];[cookieProperties setObject:@&quot;andyron&quot; forKey:NSHTTPCookieName];[cookieProperties setObject:@&quot;1587&quot; forKey:NSHTTPCookieValue];[cookieProperties setObject:@&quot;andyron.com&quot; forKey:NSHTTPCookieDomain];[cookieProperties setObject:@&quot;andyron.com&quot; forKey:NSHTTPCookieOriginURL];[cookieProperties setObject:@&quot;/&quot; forKey:NSHTTPCookiePath];[cookieProperties setObject:@&quot;0&quot; forKey:NSHTTPCookieVersion];NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties];[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie]; 在请求后获取的几个Cookie对象（服务器本身设置的和服务器从客户端后去的）中就有如下一个： 123456789101112&lt;NSHTTPCookie version:0 name:andyron value:1587 expiresDate:&apos;(null)&apos; created:&apos;2017-09-23 14:43:52 +0000&apos; sessionOnly:TRUE domain:andyron.com partition:none path:/ isSecure:FALSE path:&quot;/&quot; isSecure:FALSE&gt; NSHTTPCookieStorage方法和属性介绍12345678910111213141516171819202122232425262728293031323334//获取单例对象+ (NSHTTPCookieStorage *)sharedHTTPCookieStorage;//所有Cookie数据数组 其中存放NSHTTPCookie对象@property (nullable , readonly, copy) NSArray&lt;NSHTTPCookie *&gt; *cookies;//手动设置一条Cookie数据- (void)setCookie:(NSHTTPCookie *)cookie;//删除某条Cookie信息- (void)deleteCookie:(NSHTTPCookie *)cookie;//删除某个时间后的所有Cookie信息 iOS8后可用- (nullable NSArray&lt;NSHTTPCookie *&gt; *)cookiesForURL:(NSURL *)URL;//获取某个特定URL的所有Cookie数据- (void)removeCookiesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//为某个特定的URL设置Cookie- (void)setCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies forURL:(nullable NSURL *)URL mainDocumentURL:(nullable NSURL *)mainDocumentURL;//Cookie数据的接收协议/*枚举如下：typedef NS_ENUM(NSUInteger, NSHTTPCookieAcceptPolicy) &#123; NSHTTPCookieAcceptPolicyAlways,//接收所有Cookie信息 NSHTTPCookieAcceptPolicyNever,//不接收所有Cookie信息 NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain//只接收主文档域的Cookie信息&#125;;*/@property NSHTTPCookieAcceptPolicy cookieAcceptPolicy; 与Cookie相关的通知： 12345//Cookie数据的接收协议改变时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerAcceptPolicyChangedNotification;//管理的Cookie数据发生变化时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerCookiesChangedNotification; NSHTTPCookie的方法和属性介绍NSHTTPCookie就是Cookie对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445//下面两个方法用于对象的创建和初始化 都是通过字典进行键值设置- (nullable instancetype)initWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;+ (nullable NSHTTPCookie *)cookieWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;//返回Cookie数据中可用于添加HTTP头字段的字典+ (NSDictionary&lt;NSString *, NSString *&gt; *)requestHeaderFieldsWithCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies;//从指定的响应头和URL地址中解析出Cookie数据+ (NSArray&lt;NSHTTPCookie *&gt; *)cookiesWithResponseHeaderFields:(NSDictionary&lt;NSString *, NSString *&gt; *)headerFields forURL:(NSURL *)URL;//Cookie数据中的属性字典@property (nullable, readonly, copy) NSDictionary&lt;NSString *, id&gt; *properties;//请求响应的版本@property (readonly) NSUInteger version;//请求相应的名称@property (readonly, copy) NSString *name;//请求相应的值@property (readonly, copy) NSString *value;//过期时间@property (nullable, readonly, copy) NSDate *expiresDate;//请求的域名@property (readonly, copy) NSString *domain;//请求的路径@property (readonly, copy) NSString *path;//是否是安全传输@property (readonly, getter=isSecure) BOOL secure;//是否只发送HTTP的服务@property (readonly, getter=isHTTPOnly) BOOL HTTPOnly;//响应的文档@property (nullable, readonly, copy) NSString *comment;//相应的文档URL@property (nullable, readonly, copy) NSURL *commentURL;//服务端口列表@property (nullable, readonly, copy) NSArray&lt;NSNumber *&gt; *portList; 代码：Cookie 参考： IOS中http请求使用cookieiOS网络编程之七——本地用户凭证Cookie的应用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSHTTPCookieStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(三)：请求类NSURLRequest和请求响应类NSURLResponse介绍]]></title>
    <url>%2F2017%2Fios-network-3.html</url>
    <content type="text"><![CDATA[NSURLSession和NSURLConnection框架，网络请求都是通过NSURLRequest类发起的。 NSURLRequest请求类除了在初始化时可以设定一些属性，创建出来后则大部分属性都为只读的，无法设置与修改。NSMutableURLRequest相对而言可以更加灵活的设置请求的相关属性（属性修饰符变化），其他方面没有多少区别。 一、NSURLRequest类中常用方法和属性类方法：12345// 创建的请求对象 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s+ (instancetype)requestWithURL:(NSURL *)URL;// 创建的请求对象 创建时设置缓存逻辑和超时时限+ (instancetype)requestWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval; 实例方法：12345// init方法进行对象的创建 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s- (instancetype)initWithURL:(NSURL *)URL;// init方法进行对象的创建- (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval; 属性：1234567891011121314151617181920// 判断是否支持安全编码@property (class, readonly) BOOL supportsSecureCoding;// 只读属性 获取请求对象的URL@property (nullable, readonly, copy) NSURL *URL;// 只读属性 缓存策略@property (readonly) NSURLRequestCachePolicy cachePolicy;//只读属性 获取请求的超时时限@property (readonly) NSTimeInterval timeoutInterval;//主文档地址 这个地址用来存放缓存@property (nullable, readonly, copy) NSURL *mainDocumentURL;// 获取网络请求的服务类型@property (readonly) NSURLRequestNetworkServiceType networkServiceType;//获取是否允许使用服务商蜂窝网络@property (readonly) BOOL allowsCellularAccess; 缓存策略NSURLRequestCachePolicy:12345678910111213141516171819202122232425262728293031typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)&#123; //默认的缓存协议 NSURLRequestUseProtocolCachePolicy = 0, //无论有无本地缓存数据 都进行从新请求 NSURLRequestReloadIgnoringLocalCacheData = 1, //忽略本地和远程的缓存数据 未实现的策略 NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, //无论有无缓存数据 都进行从新请求 NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData, //先检查缓存 如果没有缓存再进行请求 NSURLRequestReturnCacheDataElseLoad = 2, //类似离线模式，只读缓存 无论有无缓存都不进行请求 NSURLRequestReturnCacheDataDontLoad = 3, //未实现的策略 NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented&#125;; 网络请求的服务类型枚举NSURLRequestNetworkServiceType:12345678910111213typedef NS_ENUM(NSUInteger, NSURLRequestNetworkServiceType)&#123; NSURLNetworkServiceTypeDefault = 0, // Standard internet traffic NSURLNetworkServiceTypeVoIP = 1, // Voice over IP control traffic NSURLNetworkServiceTypeVideo = 2, // Video traffic NSURLNetworkServiceTypeBackground = 3, // Background traffic NSURLNetworkServiceTypeVoice = 4 // Voice data&#125;; 二、与HTTP/HTTPS协议相关请求的属性和方法这些属性属于NSMutableURLRequest: 1234567891011121314151617181920212223// HPPT请求方式 默认为“GET”@property (copy) NSString *HTTPMethod;//通过字典设置HTTP请求头的键值数据@property (nullable, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields;//设置http请求头中的字段值- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;//向http请求头中添加一个字段- (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;//设置http请求体 用于POST请求@property (nullable, copy) NSData *HTTPBody;//设置http请求体的输入流@property (nullable, retain) NSInputStream *HTTPBodyStream;//设置发送请求时是否发送cookie数据@property BOOL HTTPShouldHandleCookies;//设置请求时是否按顺序收发 默认禁用 在某些服务器中设为YES可以提高网络性能@property BOOL HTTPShouldUsePipelining; 三、NSURLResponse网络请求成功后，服务器响应信息会存存放在NSURLResponse和其子类NSHTTPURLResponse中: 1234567891011121314151617181920//请求的URL地址@property (nullable, readonly, copy) NSURL *URL;//返回数据的数据类型@property (nullable, readonly, copy) NSString *MIMEType;//获取返回数据的内容长度@property (readonly) long long expectedContentLength;//获取返回数据的编码方式@property (nullable, readonly, copy) NSString *textEncodingName;//返回拼接的数据文件名 以url为名 数据没醒MIMEType为扩展名@property (nullable, readonly, copy) NSString *suggestedFilename;//请求的状态码@property (readonly) NSInteger statusCode;//请求头中所有的字段@property (readonly, copy) NSDictionary *allHeaderFields; 参考：iOS网络编程之四——请求类NSURLRequest使用详解iOS网络编程之五——请求回执类NSURLResponse属性简介]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLRequest</tag>
        <tag>NSURLResponse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(二)：NSURLConnection介绍]]></title>
    <url>%2F2017%2Fios-network-2.html</url>
    <content type="text"><![CDATA[NSURLConnection在iOS7之后基本被NSURLSession，但为了兼容，有必要学习一下。 网络请求分为同步和异步两种： 同步是指在请求结果返回之前，程序代码会卡在请求处，之后的代码不会被执行，请求返回结果后，之后的代码再执行。 异步是指在发送请求之后，一边在子线程中接收返回数据，一边执行之后的代码，当返回数据接收完毕后，采用回调的方式通知主线程做处理。 一、NSURLConnection同步请求12345678// 同步- (void)tongbu &#123; NSURL * url = [NSURL URLWithString:@&quot;https://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; NSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil]; NSLog(@&quot;%@&quot;,data); NSLog(@&quot;继续执行&quot;);&#125; 而、NSURLConnection异步请求 block方式的异步请求 12345678910// block的异步- (void)yibu &#123; NSURL * url = [NSURL URLWithString:@&quot;https://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; //其中的queue参数决定block中的代码在哪个队列中执行 [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; NSLog(@&quot;%@&quot;,data); &#125;]; NSLog(@&quot;继续执行&quot;);&#125; 代理回调方式的异步请求采用协议和声明一个用户接受数据的可变NSData： 1234@interface ViewController ()&lt;NSURLConnectionDataDelegate&gt;&#123; NSMutableData * _data;&#125; 请求代码：1234567// 代理回调的异步- (void)yibu_delegate &#123; _data = [[NSMutableData alloc]init]; NSURL * url = [NSURL URLWithString:@&quot;https://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; [NSURLConnection connectionWithRequest:request delegate:self];&#125; 实现代理方法：123456789101112131415161718-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; //开始接收数据 [_data setLength:0]; NSLog(@&quot;%s&quot;,&quot;开始接收数据&quot;);&#125;-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123; //正在接收数据 [_data appendData:data]; NSLog(@&quot;%s&quot;,&quot;正在接收数据&quot;);&#125;-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123; //接收数据失败 NSLog(@&quot;%@&quot;,error);&#125;-(void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; //接收数据完成 NSLog(@&quot;%@&quot;,_data);&#125; 代码：NSURLConnection 参考：iOS网络编程之三——NSURLConnection的简单使用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLConnection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(四)：缓存类NSURLCache介绍]]></title>
    <url>%2F2017%2Fios-network-4.html</url>
    <content type="text"><![CDATA[网络请求中缓存类NSURLCache常用属性和方法： 1234567891011121314151617181920212223242526272829303132333435363738394041//获取当前应用的缓存管理对象+ (NSURLCache *)sharedURLCache;//设置自定义的NSURLCache作为应用缓存管理对象+ (void)setSharedURLCache:(NSURLCache *)cache;//初始化一个应用缓存对象/*memoryCapacity 设置内存缓存容量diskCapacity 设置磁盘缓存容量path 磁盘缓存路径内容缓存会在应用程序退出后 清空 磁盘缓存不会*/- (instancetype)initWithMemoryCapacity:(NSUInteger)memoryCapacity diskCapacity:(NSUInteger)diskCapacity diskPath:(nullable NSString *)path;//获取某一请求的缓存- (nullable NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request;//给请求设置指定的缓存- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;//移除某个请求的缓存- (void)removeCachedResponseForRequest:(NSURLRequest *)request;//移除所有缓存数据- (void)removeAllCachedResponses;//移除某个时间起的缓存设置- (void)removeCachedResponsesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//内存缓存容量大小@property NSUInteger memoryCapacity;//磁盘缓存容量大小@property NSUInteger diskCapacity;//当前已用内存容量@property (readonly) NSUInteger currentMemoryUsage;//当前已用磁盘容量@property (readonly) NSUInteger currentDiskUsage; 参考：iOS网络编程之六——数据缓存类NSURLCache使用解析]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLCache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(一)：NSURLSession介绍]]></title>
    <url>%2F2017%2Fios-network-1.html</url>
    <content type="text"><![CDATA[NSURLSession是iOS7之后被用来代替NSURLConnection的网络开发框架，前者相对于后者的优势是支持后台处理能力 NSURLSession的配置通过NSURLSessionConfiguration来配置Session的三种类型： Default：提供前台请求相关方法，支持配置缓存，身份凭证等。 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; Ephemeral类型：即时的请求类型，不使用缓存，身份凭证等。 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; Background：后台类型，支持在后台完成请求任务。 NSURLSessionConfiguration * backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;com.andyron.NSURLSession-delegate-&quot;]; backgroundSessionConfigurationWithIdentifier只是标识符。 NSURLSessionConfiguration还可以配置如缓存，网络模式等参数。 NSURLSession的两种进行网络请求方式 通过block的方式获取网络数据 123456789101112//创建session配置对象NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];//创建请求对象NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]];//创建session对象NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration];//添加任务NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@&quot;%@&quot;,response);&#125;];//开始任务[task resume]; 在block中进行数据处理 通过代理回调获取网络数据 首先采用协议 NSURLSessionDataDelegate123@interface ViewController ()&lt;NSURLSessionDataDelegate&gt;@end 配置 1234567NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]];NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration delegate:self delegateQueue:[NSOperationQueue mainQueue]];NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request];[task resume]; 实现代理方法 12345678//开始接受数据-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; NSLog(@&quot;=======%@&quot;,data);&#125;//接受数据结束-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; NSLog(@&quot;完成：error%@&quot;,error);&#125; 后台处理下载任务这是NSURLSession最大的优势。使用代理的方式进行后台处理下载任务。配置和代理方式相同，主要是实现一些代理方法。 下载进度监听的代理方法： 12345// 下载进度监听- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; NSLog(@&quot;######&quot;);&#125; 在下载过程中点击Home键使应用程序进入后台，下载任务依然在进行，当后台下载完成后会与AppDelegate进行交互，会调用AppDelegate中的代理方法 123-(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)(void))completionHandler&#123; NSLog(@&quot;下载任务在后台完成&quot;);&#125; 下载完成后，可查看下载的文件所在位置 1234//此方法只有下载成功才会调用， 文件放在location位置-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location&#123; NSLog(@&quot;下载临时文件的位置%@&quot;, location);&#125; 在后台完成无人所有任务时调用 12345// 后台所有任务都完成-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session&#123; NSLog(@&quot;All tasks are finished&quot;);&#125; 代码：NSURLSession(delegate), NSURLSession(block)深入学习：URL Session Programming Guide 参考iOS网络编程之二——NSURLSession的简单使用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLSession</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Charles抓取iOS的http/https请求数据]]></title>
    <url>%2F2017%2Fios-charles.html</url>
    <content type="text"><![CDATA[关于Charles不做多的介绍了，Charles官网一句话介绍简单明了： Web Debugging Proxy Application for Windows, Mac OS and Linux 一、安装Charleshttps://www.charlesproxy.com/download/ 二、安装Charles根证书打开Charles，在菜单栏的Help中操作： 在钥匙串访问中把Charles的根证书设置为信任： 三、在iOS设备上配置证书 首先在Charles点击 会弹出以一个提示框： 有的版本也会弹出不一样的，比如我的： 没关系，到系统网络查看iP 配置手机网络的HTTP代理为手动，然后更改服务器为电脑的IP，端口为8888. 注意：电脑和手机要在同一局域网内。 手机浏览器中输入 charlesproxy.com/getssl 安装证书 之前如果出现如下，选择允许即可： 此时已经可以抓取iOS的http请求数据了： Structure 按照域名分类显示。sequence按照时间选项分类显示。 域名前面的符合表示请求是否加密了 四、抓取HTTPS请求选择如下： 在弹框中添加，需要查看https请求的域名： 比如我添加了知乎的，查看 知乎首页动态对应的接口： 提醒：不抓包时，把手机的http代理改为自动 手机，电脑，Charles的环境不同可能有所不同，我的环境：Charles v4.0.1macOS Sierra 10.12.6iPhone 6s iOS 11.0 参考：十分钟学会Charles抓包(iOS的http/https请求)使用 Charles 获取 https 的数据]]></content>
      <categories>
        <category>iOS</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习13：文件加载与保存]]></title>
    <url>%2F2017%2Foc-basic-13.html</url>
    <content type="text"><![CDATA[1 属性列表(property list, plist)属性列表可以保存的类型有NSArray,NSDictionary,NSString,NSNumber,NSDate,NSDate以及它们对应的Mutable类。 NSDate 1234NSDate *date = [NSDate date];NSLog(@"today is %@", date);NSDate *yesterday = [NSDate dateWithTimeIntervalSinceNow: -(24*3600)];NSLog(@"yesterday is %@", yesterday); NSDateFormatter用来处理时间格式 NSData 123456const *string = "Hi there, this is a C string!";NSData *data = [NSData dataWithBytes: string length: strlen(string)+1];NSLog(@"data is %@", data);// data is &lt;48692074 68657265 2c207468 69732069 73206120 43207374 72696e67 2100&gt;NSLog(@"%lu byte string is '%s'", [data length], [data bytes]);// 30 byte string is 'Hi there, this is a C string!' 写入和读取属性列表 写入123NSArray *phrase;phrase = [NSArray arrayWithObjects:@"I", @"seem", @"to", @"be", @"a", @"verb", nil];[phrase writeToFile:@"/tmp/verbiage.txt" atomically:YES]; verbiage.txt内容为：123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;array&gt; &lt;string&gt;I&lt;/string&gt; &lt;string&gt;seem&lt;/string&gt; &lt;string&gt;to&lt;/string&gt; &lt;string&gt;be&lt;/string&gt; &lt;string&gt;a&lt;/string&gt; &lt;string&gt;verb&lt;/string&gt;&lt;/array&gt;&lt;/plist&gt; Mac电脑系统中 ~/Library/Preferences下的所有首选项文件和/System/Library/LaunchDaemons/下的系统配置文件都是plist 读取123NSArray *phrase2;phrase2 = [NSArray arrayWithContentsOfFile:@"/tmp/verbiage.txt"];NSLog(@"%@", phrase2); -writeToFile:atomically:方法中的atomically表示是否首先将文件内容保存在临时文件中，再将临时文件和原始文件交换。 修改对象类型NSPropertyListSerialization 2 编码对象无法将对象信息表示为属性列表类。编码和解码(encoding and decoding) 和 序列化与反序列化(serialization and deserialization) 必须采用NSCoding协议在Interface Builder中的的对象就被序列化保存到磁盘中了。NSCoding定义两个方法，用于对象与NSDate之间的转换： 123456@protocol NSCoding- (void)encodeWithCoder:(NSCoder *)aCoder;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; // NS_DESIGNATED_INITIALIZER@end 一个列子123456789101112131415161718@interface Thingie : NSObject &lt;NSCoding&gt;&#123; NSString *name; int magicNumber; float shoeSize; NSMutableArray *subThingies;&#125;@property (copy) NSString *name;@property int magicNumber;@property float shoeSize;@property (retain) NSMutableArray *subThingies;- (id)initWithName: (NSString *) n magicNumber: (int) mn shoeSize: (float) ss;@end // Thingie Thingie采用了NSCoding协议，要实现编码和解码响应的方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@implementation Thingie@synthesize name;@synthesize magicNumber;@synthesize shoeSize;@synthesize subThingies;- (id)initWithName: (NSString *) n magicNumber: (int) mn shoeSize: (float) ss&#123; if (self = [super init]) &#123; self.name = n; self.magicNumber = mn; self.shoeSize = ss; self.subThingies = [NSMutableArray array]; &#125; return (self);&#125;- (void) encodeWithCoder: (NSCoder *) coder&#123; [coder encodeObject: name forKey: @"name"]; [coder encodeInt: magicNumber forKey: @"magicNumber"]; [coder encodeFloat: shoeSize forKey: @"shoeSize"]; [coder encodeObject: subThingies forKey: @"subThingies"]; &#125; // encodeWithCoder- (id) initWithCoder: (NSCoder *) decoder&#123; if (self = [super init]) &#123; self.name = [decoder decodeObjectForKey: @"name"]; self.magicNumber = [decoder decodeIntForKey: @"magicNumber"]; self.shoeSize = [decoder decodeFloatForKey: @"shoeSize"]; self.subThingies = [decoder decodeObjectForKey: @"subThingies"]; &#125; return (self); &#125; // initWithCoder- (NSString *) description&#123; NSString *description = [NSString stringWithFormat: @"%@: %d/%.1f %@", name, magicNumber, shoeSize, subThingies]; return (description); &#125; // description@end // Thingie]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习12：代码块（Block）]]></title>
    <url>%2F2017%2Foc-basic-12.html</url>
    <content type="text"><![CDATA[代码块(Block)/闭包(closure) 是对C语言中函数的扩展。代码块两种类的绑定：自动绑定(automatic binding) 栈内存托管绑定(managed binding) 堆内存 代码块和函数指针函数指针的声明：void (*my_func)(void);*变成^（幂符号）变成代码块定义：void (^my_block)(void); 代码块展示： 123int (^square_block)(int number) = ^(int number) &#123;return (number * number);&#125;;int result = square_block(5);printf("Result = %d\n", result); 等号前面是代码块的定义，而等号后面是实现内容。一般形式： 1&lt;returntype&gt; (^blockname)(list of arguments) = ^(arguments)&#123; body; &#125;; 没有参数时可以简写： 1void (^theBlock)(void) = ^&#123; printf("Hello Blocks!\n"); &#125;; 使用代码块代码块可以访问与它相同的（本地）有效范围内声明的变量。 12345int value = 6;int (^multiply_block)(int number) = ^(int number) &#123; return (value * number);&#125;;value = 8;int result2 = multiply_block(7);printf("Result2 = %d\n", result2); // 是6*7，不是8*7 直接使用代码块 123456NSArray *array = [NSArray arrayWithObjects:@"Amir", @"Mishal", @"Irrum", @"Adam", nil];NSLog(@"Unsorted Array %@", array);NSArray *sorteArray = [array sortedArrayUsingComparator:^(NSString *objet1, NSString *object2) &#123; return [objet1 compare:object2];&#125;];NSLog(@"Sorted Array %@", sorteArray); 使用typedef关键字 12345typedef double (^MKSampleMultiply2BlockRef)(double c, double d);MKSampleMultiply2BlockRef multiply2 = ^(double c, double d) &#123; return c * d; &#125;;printf("%f, %f", multiply2(4, 5), multiply2(5,3));typedef void (^MKSampleVoidBlockRef)(void);typedef void (^MKSampleStringBlockRef)(NSString *); 代码块和变量代码块被声明后会捕捉创建点时的状态。代码块可以访问函数用到的标准类的变量： 全局变量，包括封闭范围内声明的本地静态变量。 全局函数 封闭范围内的参数 函数级别（即与代码块声明时相同的级别）的_block变量。 封闭范围内的非静态变量会被获取为常量。 Objective-C的实例变量 代码块内部的本地变量 本地变量 12345678typedef double (^MKSampleMultiplyBlockRef)(void);double a = 10, b = 20;MKSampleMultiplyBlockRef multiply = ^(void)&#123; return a * b; &#125;;NSLog(@"%f", multiply()); // 200.0a = 20;b = 50;NSLog(@"%f", multiply()); // 200.0 全局变量 1234567typedef double (^MKSampleMultiplyBlockRef)(void);static double a = 10, b = 20;MKSampleMultiplyBlockRef multiply = ^(void)&#123; return a * b; &#125;;NSLog(@"%f", multiply()); // 200.0a = 20; b = 50;NSLog(@"%f", multiply()); // 1000.0 参数变量代码块中的参数变量与函数中的参数变量具有同样的作用。 123typedef double (^MKSampleMultiply2BlockRef)(double c, double d);MKSampleMultiply2BlockRef multiply2 = ^(double c, double d) &#123; return c * d; &#125;;printf("%f, %f", multiply2(4, 5), multiply2(5,3)); __block变量本地变量会被代码块作为常量获取到。在代码块中修改会报错。 123double c = 3;MKSampleMultiplyBlockRef multiply = ^(void) &#123; c = 5; return c; &#125;;//报错： Variable is not assignable (missing __block type specifier) 将本地变量标记为__block，就可以修改了 12__block double c = 3;MKSampleMultiplyBlockRef multiply = ^(void) &#123; c = 5; return c; &#125;; 代码块内部的本地变量]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习11：协议]]></title>
    <url>%2F2017%2Foc-basic-11.html</url>
    <content type="text"><![CDATA[1 正式协议 声明协议 123@protocol NSCoding- (id) copyWithZone: (NSZone *) zone;@end 继承父协议：12@protocol MySuperDuberProtocol &lt;MyParentProtocol&gt;@end 采用协议 123456@interface Car ：NSObject &lt;NSCopying, NSCoding&gt;&#123;// instance variables&#125;// methods@end // Car 实现协议 2 复制浅层复制深层复制 3 @optional @required4 委托方法委托(delegation)是某个对象指定另一个对象处理某些特定任务的设计模式。委托经常与协议共用。]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习10：类别（category）]]></title>
    <url>%2F2017%2Foc-basic-10.html</url>
    <content type="text"><![CDATA[类别（category）是一种为现有的类添加新方法的方式。 1 创建类别一般，只是习惯 把类别代码放在独立的文件中命名：”类名称+类别名称”，如 NSString+NumberConvenience 开始创建类别 生成两个文件，NSString+NumberConvenience.h:12345#import &lt;Foundation/Foundation.h&gt;@interface NSString (NumberConvenience)@end NSString+NumberConvenience.m:12345#import "NSString+NumberConvenience.h"@implementation NSString (NumberConvenience)@end 类别名在括号中。可以在@implementation部分实现自己的方法。任何NSString类的对象都将响应在类别中的方法。正是这种兼容性使类别成为了一种非常强大的概念。 类别的缺陷 文法向类中添加新的实例变量。 名称冲突。类别中的方法与现有的方法重名时，类别中的方法会替代现有的方法。（可在类别名称加前缀） 类别的优势 将类的实现分散到多个不同文件或多个不同框架中 创建对私有方法的前向引用 向对象添加非正式协议 类扩展（class extentsion）：特殊的类别 12345678@interface Things : NSObject@property (assign) NSInteger thing1;@property (readonly, assign) NSInteger thing2;- (void)resetAllValues;@end 12345678@interface Things()&#123; NSInteger thing4; &#125;@property (readwrite, assign) NSInteger thing2;@property (assign) NSInteger thing3;@end 2 利用类别分散实现代码不能将@implementation分散到多个不同的.m文件中。可以通过类别把大型的单个类分散到多个不同的.m文件中。以AppKit中的NSWindow为例，在NSWindow.h中搜索@interface大约能搜到5个类别声明：12345@interface NSWindow(NSEvent)@interface NSWindow(NSCursorRect)@interface NSWindow(NSDrag)@interface NSWindow(NSCarbonExtensions)@interface NSWindow(NSDeprecated) 类别可以访问其继承的类的实例变量。 3 通过类别创建前向引用没有真正的私有方法。不在头文件声明，也可以调用，不过编译器会提示警告，并且app store会拒绝上架。可通过在类别中声明方法避免这种警告。]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习9：属性]]></title>
    <url>%2F2017%2Foc-basic-9.html</url>
    <content type="text"><![CDATA[1 使用属性 接口代码简化没有使用属性：12345678910111213#import "Tire.h"@interface AllWeatherRadial : Tire&#123; // 轮胎在潮湿和积雪的道路上的性能 float rainHandling; float snowHandling;&#125;- (void) setRainHandling:(float)rainHandling;- (float) rainHandling;- (void) setSnowHandling:(float)snowHandling;- (float) snowHandling;@end 使用属性：1234567891011@interface AllWeatherRadial : Tire&#123; // 轮胎在潮湿和积雪的道路上的性能 float rainHandling; float snowHandling;&#125;@property float rainHandling;@property float snowHandling;@end @ property预编译指令的作用是自动声明属性的setter和getter方法。 简化实现代码之前：123456789101112131415161718192021222324252627282930313233343536#import "AllWeatherRadial.h"@implementation AllWeatherRadial-(NSString *)description&#123;// return (@"I am a tire for rain or shine."); NSString *desc; desc = [[NSString alloc] initWithFormat:@"AllWeatherRadial: %.1f / %.1f / %.1f / %.1f.", self.pressure, self.treadDepth, self.rainHandling, self.snowHandling]; return desc;&#125;- (void)setRainHandling:(float)r&#123; rainHandling = r;&#125;- (float)rainHandling&#123; return rainHandling;&#125;- (void)setSnowHandling:(float)s&#123; snowHandling = s;&#125;- (float)snowHandling&#123; return snowHandling;&#125;- (id) initWithPressure:(float)p treadDepth:(float)td&#123; if (self = [super initWithPressure:p treadDepth:td]) &#123; rainHandling = 23.7; snowHandling = 58.1; &#125; return self;&#125;@end 使用属性后的实现代码：1234567891011121314151617181920212223#import "AllWeatherRadial.h"@implementation AllWeatherRadial@synthesize rainHandling;@synthesize snowHandling;-(NSString *)description&#123; NSString *desc; desc = [[NSString alloc] initWithFormat:@"AllWeatherRadial: %.1f / %.1f / %.1f / %.1f.", self.pressure, self.treadDepth, self.rainHandling, self.snowHandling]; return desc;&#125;- (id) initWithPressure:(float)p treadDepth:(float)td&#123; if (self = [super initWithPressure:p treadDepth:td]) &#123; rainHandling = 23.7; snowHandling = 58.1; &#125; return self;&#125;@end @synthesize预编译指令表示通知编译器生成访问方法。当遇到@synthesize xxx；这行代码时，编译器将添加实现-setXxx：和-xxx方法的预编译代码。 该@synthesize预编译指令不同于代码生成。你永远看不到实现-setXxx：和-xxx的代码，但是这些方法确实存在并可以被调用。这种技术使苹果公司可以更加灵活地改变Objective-C中生成访问方法的方式，并获得更安全的实现和更高的的性能。在Xcode4.5以后的版本中，可以不必使用@synthesize了。 所有的属性都是基于变量的，在@synthesize时，编译器会自动创建与属性名称相同的实例变量。 实例变量声明位置： 头文件：有子类，想从子类直接通过属性访问变量。 实现文件：变量只属于当前类。 点表达式之前的[tire setPressure:23+i];可相应变为：tire.rainHandling = 23+i; 2 属性扩展 实例变量和属性不是同一个名称12345678@interface Car : NSObject&#123; NSMutableArray *tires; Engine *engine; NSString *appellation;&#125;@property (copy) NSString *name;@property (retain) Engine *engine; 修改@synthesize指令为： @synthesize name = appellation;编译器仍将创建-setName:和-name方法，但在其实现代码中用的确实appellation实例变量。 只读属性readwrite readonly属性为只读时，编译器只会生成一个getter方法。 属性不支持那些需要接收额外参数的方法。如car对象中tire对象的代码。]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习8：对象初始化]]></title>
    <url>%2F2017%2Foc-basic-8.html</url>
    <content type="text"><![CDATA[1 分配(allocation)对象alloc方法干的事件： 1 从操作系统获得一块内存。2 指定为存储对象的实例变量的位置。3 对内存初始化：BOOL类型被初始化为：NO；int类型被初始化为：0；float类型被初始化为：0.0；所有指针被初始化为nil。 初始化对象init方法Car *car = [[Car alloc] init]; 初始化要做些什么 CarParts程序中初始car对象是，init方法中创建engine对象和全部4个tire对象 懒性求值(lazy evaluation)，只为engine对象和tire对象预留位置 2 便利初始化函数(convenience initializer)以init开头的方法只是遵循命名约定的普通方法。NSString类的初始化方法例子： - (id) init; 1NSString *emptyString = [[NSString alloc] init]; - (instancetype)initWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2); 1NSString *string = [[NSString alloc] initWithFormat:@"%d or %d", 1, 2]; - (nullable instancetype)initWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error; 12345NSError *error = nil;NSString *string1 = [[NSString alloc] initWithContentsOfFile:@"/tmp/words.txt" encoding:NSUTF8StringEncoding error:&amp;error];if (nil != error) &#123; NSLog(@"未能读取文件数据：%@", [error localizedDescription]);&#125; 3 指定初始化函数(designated initializer) 类中的某个初始化方法被指派为指定初始化函数 该类的所有初始化方法都使用指定初始化函数执行初始化操作 子类使用期超类的指定初始化函数进行超类的初始化 通常，接受参数最多的初始化方法是最终的指定的初始化函数]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS与JS(二)：MessageHandler(OC&Swift)]]></title>
    <url>%2F2017%2Fios-js-2.html</url>
    <content type="text"><![CDATA[iOS与JS的相互调用除了URL拦截（iOS与JS(一)：使用URL拦截的方式进行JS与OC互相调用）外，还可以使用WKWebView的中的MessageHandler来实现。 MessageHandler是什么呢？以代码来说明，比较好理解。在OC中初始化WKWebView是，添加如下代码:[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Location&quot;];那么在JS中就可以使用：window.webkit.messageHandlers.Location.postMessage(null);JS中的Location就对应OC中的name，postMessage后的参数就是JS传给OC的参数，类型可以是 NSNumber, NSString, NSDate, NSArray, NSDictionary, and NSNull。JS回调OC时，就回调WKScriptMessageHandler的- (void)userContentController:([WKUserContentController](apple-reference-documentation://hcracoR5p2) *)userContentController didReceiveScriptMessage:([WKScriptMessage](apple-reference-documentation://hcD3KQdcJY) *)message;方法，这边的message是WKScriptMessage， message.name就是“Location”，message.body就是postMessage后的参数。 下面看完整的🌰： html的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf8&quot;&gt; &lt;script language=&quot;javascript&quot;&gt; var ctuapp_share_img=&quot;www.baidu.com&quot;; function locationClick() &#123; window.webkit.messageHandlers.Location.postMessage(null); &#125; function shake() &#123; window.webkit.messageHandlers.Shake.postMessage(null); &#125; function payClick()&#123; window.webkit.messageHandlers.Pay.postMessage(&#123;order_no:&apos;201511120981234&apos;,channel:&apos;wx&apos;,amount:1,subject:&apos;粉色外套&apos;&#125;); &#125; function setLocation(location) &#123; alert(location) document.getElementById(&quot;returnValue&quot;).value = location; &#125; function payResult(str) &#123; alert(str); document.getElementById(&quot;returnValue&quot;).value = str; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是按钮调用&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;获取定位&quot; onclick=&quot;locationClick()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;震动一下&quot; onclick=&quot;shake()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;支付&quot; onclick=&quot;payClick()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是文件上传&lt;/h1&gt; &lt;input type=&quot;file&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是回调结果展示区&lt;/h1&gt; &lt;textarea id =&quot;returnValue&quot; type=&quot;value&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; 初始化WKWebView12345678910111213141516171819- (void)initWKWebView&#123; WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init]; WKPreferences *preferences = [WKPreferences new]; preferences.javaScriptCanOpenWindowsAutomatically = YES; preferences.minimumFontSize = 40.0; configuration.preferences = preferences; self.webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration]; NSString *urlStr = [[NSBundle mainBundle] pathForResource:@&quot;index.html&quot; ofType:nil]; NSURL *fileURL = [NSURL fileURLWithPath:urlStr]; [self.webView loadFileURL:fileURL allowingReadAccessToURL:fileURL]; self.webView.UIDelegate = self; [self.view addSubview:self.webView];&#125; 添加 MessageHandler为了防止循环引用，结束时释放。123456789101112131415161718- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; // addScriptMessageHandler 很容易导致循环引用 // 控制器 强引用了WKWebView,WKWebView copy(强引用了）configuration， configuration copy （强引用了）userContentController [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Location&quot;]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Shake&quot;]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Pay&quot;];&#125;- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;Location&quot;]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;Shake&quot;]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;Pay&quot;];&#125; 实现WKUIDelegate和WKScriptMessageHandler协议方法12345678910111213141516171819202122232425#pragma mark - WKUIDelegate- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提醒&quot; message:message preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@&quot;知道了&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(); &#125;]]; [self presentViewController:alert animated:YES completion:nil];&#125;#pragma mark - WKScriptMessageHandler- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123; // message.body -- Allowed types are NSNumber, NSString, NSDate, NSArray,NSDictionary, and NSNull. NSLog(@&quot;body:%@&quot;,message.body); if ([message.name isEqualToString:@&quot;Location&quot;]) &#123; [self getLocation]; &#125; else if ([message.name isEqualToString:@&quot;Shake&quot;]) &#123; [self shakeAction]; &#125; else if ([message.name isEqualToString:@&quot;Pay&quot;]) &#123; [self payWithParams:message.body]; &#125;&#125; 效果： Swift的和OC类型，代码我也一起写了 代码： 90-iOSJS 中的 OCJSMessageHandler 和 SwiftJSMessageHandler 参考：iOS下JS与OC互相调用（三）–MessageHandler]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>WKWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS与JS(一)：使用URL拦截的方式进行JS与OC互相调用]]></title>
    <url>%2F2017%2Fios-js-1.html</url>
    <content type="text"><![CDATA[关于WKWebView与UIWebView之间的区别，本文就不在说明，本文只使用WKWebView。效果图如下： html代码：12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf8&quot;&gt; &lt;script language=&quot;javascript&quot;&gt; function loadURL(url) &#123; window.location.href = url &#125; function locationClick() &#123; loadURL(&quot;scheme://getLocation&quot;); &#125; function shake() &#123; loadURL(&quot;scheme://shake&quot;); &#125; function setLocation(location) &#123; alert(location) document.getElementById(&quot;returnValue&quot;).value = location; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是按钮调用&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;获取定位&quot; onclick=&quot;locationClick()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;震动一下&quot; onclick=&quot;shake()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是文件上传&lt;/h1&gt; &lt;input type=&quot;file&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是回调结果展示区&lt;/h1&gt; &lt;textarea id =&quot;returnValue&quot; type=&quot;value&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; 以获取定位这个按钮为例说明OC和JS互相调用代码执行流程： 初始化WKWebView加载本地html文件。 点击web中的按钮，web发起URL请求。 URL请求被WKNavigationDelegate中的代理方法拦截。根据自定义的URL识别使用不同的处理方式。如：在- (void)getLocation方法中调用JS的setLocation函数。 JS的setLocation函数执行JS的alert()函数，被WKUIDelegate中的代理方法捕获，调用iOS原生的弹框。 详细代码说明 初始化WKWebView加载本地html文件 123456789101112131415161718192021- (void)initWKWebView&#123; // 1 WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init]; configuration.userContentController = [WKUserContentController new]; WKPreferences *preferences = [WKPreferences new]; preferences.javaScriptCanOpenWindowsAutomatically = YES; preferences.minimumFontSize = 40.0; configuration.preferences = preferences; self.webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration]; // 2 NSString *urlStr = [[NSBundle mainBundle] pathForResource:@&quot;index.html&quot; ofType:nil]; NSURL *fileURL = [NSURL fileURLWithPath:urlStr]; [self.webView loadFileURL:fileURL allowingReadAccessToURL:fileURL]; self.webView.navigationDelegate = self; self.webView.UIDelegate = self; [self.view addSubview:self.webView];&#125; 1 WKWebView的一些参数配置 2 加载本html URL请求被WKNavigationDelegate中的代理方法拦截。也就是JS调用了OC 1234567891011121314#pragma mark - WKNavigationDelegate- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; NSURL *URL = navigationAction.request.URL; NSString *scheme = [URL scheme]; if ([scheme isEqualToString:@&quot;scheme&quot;]) &#123; [self handleCustomAction:URL]; decisionHandler(WKNavigationActionPolicyCancel); return; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; OC 调用 JS 12345678- (void)getLocation&#123; // 将结果返回给js NSString *jsStr = [NSString stringWithFormat:@&quot;setLocation(&apos;%@&apos;)&quot;,@&quot;上海市浦东新区&quot;]; [self.webView evaluateJavaScript:jsStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@&quot;%@----%@&quot;,result, error); &#125;];&#125; JS代码被当成字符串调用 completionHandler是JS代码被调用后回调 JS中alert弹窗被WKUIDelegate中的代理方法捕获，调用iOS原生的弹框。 1234567891011#pragma mark - WKUIDelegate- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提醒&quot; message:message preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@&quot;知道了&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(); &#125;]]; [self presentViewController:alert animated:YES completion:nil];&#125; 最后，html中的文件input可以直接调用iOS的图片库，相机和文件。 代码： 90-iOSJS/OCJS1 参考： iOS下JS与OC互相调用（二）–WKWebView 拦截URL iOS下JS与原生OC互相调用(总结)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>WKWebView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画(三)：核心动画中缩放和旋转(Swift)]]></title>
    <url>%2F2017%2Fios-animation-3.html</url>
    <content type="text"><![CDATA[原理和上一篇是相同的，不同之处是keyPath属性，缩放时是keyPath是 transform.scale，旋转时keyPath是transform.rotation。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113class ScaleRotationViewController: UIViewController &#123; // 用于缩放的layer lazy var redLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 150), backgroundColor: UIColor.red) &#125;() lazy var greenLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 250), backgroundColor: UIColor.green) &#125;() lazy var cyanLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 350), backgroundColor: UIColor.cyan) &#125;() lazy var blueLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 450), backgroundColor: UIColor.blue) &#125;() // 用于旋转的Layer lazy var redRotationLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 300, y: 150), backgroundColor: UIColor.red) &#125;() lazy var greenRotationLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 300, y: 250), backgroundColor: UIColor.green) &#125;() lazy var cyanRotationLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 300, y: 350), backgroundColor: UIColor.cyan) &#125;() override func viewDidLoad() &#123; super.viewDidLoad() // 添加缩放的动画 redLayer.add(createAnimation(keyPath: "transform.scale.x", toValue: 0.5), forKey: nil) greenLayer.add(createAnimation(keyPath: "transform.scale.y", toValue: 0.5), forKey: nil) cyanLayer.add(createAnimation(keyPath: "transform.scale.z", toValue: 0.5), forKey: nil) blueLayer.add(createAnimation(keyPath: "transform.scale", toValue: 0.5), forKey: nil) // 添加旋转的动画 redRotationLayer.add(createAnimation(keyPath: "transform.rotation.x", toValue: CGFloat(Double.pi / 4)), forKey: nil) greenRotationLayer.add(createAnimation(keyPath: "transform.rotation.y", toValue: CGFloat(Double.pi / 4)), forKey: nil) cyanRotationLayer.add(createAnimation(keyPath: "transform.rotation.z", toValue: CGFloat(Double.pi / 4)), forKey: nil) self.creatLabel(title: "缩放", frame: CGRect(x: 100, y: 80, width: 50, height: 20)) self.creatLabel(title: "旋转", frame: CGRect(x: 250, y: 80, width: 50, height: 20)) self.creatLabel(title: "X轴", frame: CGRect(x: 20, y: 125, width: 50, height: 20)) self.creatLabel(title: "Y轴", frame: CGRect(x: 20, y: 225, width: 50, height: 20)) self.creatLabel(title: "Z轴", frame: CGRect(x: 20, y: 325, width: 50, height: 20)) self.creatLabel(title: "XYZ轴", frame: CGRect(x: 20, y: 425, width: 50, height: 20)) &#125; // 创建calayer func createLayer (position: CGPoint, backgroundColor: UIColor) -&gt; CALayer &#123; //创建calayer let layer = CALayer() //设置位置和大小 layer.position = position layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100) //设置背景颜色 layer.backgroundColor = backgroundColor.cgColor //把layer添加到UIView的layer上 self.view.layer.addSublayer(layer) return layer &#125; // 创建基础Animation func createAnimation (keyPath: String, toValue: CGFloat) -&gt; CABasicAnimation &#123; //创建动画对象 let scaleAni = CABasicAnimation() //设置动画属性 scaleAni.keyPath = keyPath //设置动画的起始位置。也就是动画从哪里到哪里。不指定起点，默认就从positoin开始 scaleAni.toValue = toValue //动画持续时间 scaleAni.duration = 2; //动画重复次数 scaleAni.repeatCount = Float(CGFloat.greatestFiniteMagnitude) return scaleAni; &#125; //创建Label fileprivate func creatLabel (title: String, frame: CGRect) -&gt; ()&#123; let label = UILabel() label.text = title label.frame = frame label.textColor = UIColor.darkGray label.font = UIFont.systemFont(ofSize: 12) self.view.addSubview(label) &#125;&#125; 代码： 89-Animation/CABasic Animation 参考：第五篇：CABasic Animation。iOS动画系列之五：基础动画之缩放篇&amp;旋转篇]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画(二)：核心动画中的基础移动(Swift)]]></title>
    <url>%2F2017%2Fios-animation-2.html</url>
    <content type="text"><![CDATA[简单的移动 新建一个CALayer。 12345678910lazy var redLayer: CALayer = &#123; return self.createLayer()&#125;()func createLayer() -&gt; CALayer &#123; let redLayer = CALayer() redLayer.position = CGPoint(x: 200, y: 200) redLayer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100) redLayer.backgroundColor = UIColor.red.cgColor return redLayer&#125; 把新建的CALayer添加的view的layer中。 1view.layer.addSublayer(redLayer) 遵守协议CAAnimationDelegate class BasicPostionViewController: UIViewController, CAAnimationDelegate { 创建动画CABasicAnimation,并添加的CALayer中。 12345678910111213141516171819func createCABasicAnimation() -&gt; CABasicAnimation &#123; let basicAni = CABasicAnimation() // 设置动画属性 basicAni.keyPath = "position" basicAni.fromValue = NSValue.init(cgPoint: CGPoint(x: 0, y: 0)) basicAni.toValue = NSValue.init(cgPoint: CGPoint(x: 300, y: 300)) basicAni.duration = 2 basicAni.fillMode = kCAFillModeForwards basicAni.isRemovedOnCompletion = false basicAni.delegate = self return basicAni&#125; 12let basicAni = createCABasicAnimation()self.redLayer.add(basicAni, forKey: "basicPosition") forKey 是动画对象的名字，只是用来标识，没有特殊意义。 稍微复杂的移动 原理和上面相同，都是先创建CALayer，然后添加CABasicAnimation。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class BasicPostion2ViewController: UIViewController, CAAnimationDelegate&#123; lazy var redLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 150), backgroundColor: UIColor.red) &#125;() lazy var greenLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 250), backgroundColor: UIColor.green) &#125;() lazy var cyanLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 350), backgroundColor: UIColor.cyan) &#125;() lazy var blueLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 450), backgroundColor: UIColor.blue) &#125;() override func viewDidLoad() &#123; super.viewDidLoad() redLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 150), toValue: CGPoint(x: 300, y: 150), timingFunction: kCAMediaTimingFunctionLinear), forKey: "basicAnimation") view.layer.addSublayer(redLayer) greenLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 250), toValue: CGPoint(x: 300, y: 250), timingFunction: kCAMediaTimingFunctionEaseIn), forKey: "basicAnimation") view.layer.addSublayer(greenLayer) cyanLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 350), toValue: CGPoint(x: 300, y: 350), timingFunction: kCAMediaTimingFunctionEaseOut), forKey: "basicAnimation") view.layer.addSublayer(cyanLayer) blueLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 450), toValue: CGPoint(x: 300, y: 450), timingFunction: kCAMediaTimingFunctionEaseInEaseOut), forKey: "basicAnimation") view.layer.addSublayer(blueLayer) &#125; func createLayer(postion: CGPoint, backgroundColor: UIColor) -&gt; CALayer &#123; let layer = CALayer() layer.position = postion layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100) layer.backgroundColor = backgroundColor.cgColor return layer &#125; func createBasicAnimation (fromValue: CGPoint, toValue: CGPoint, timingFunction: String) -&gt; CABasicAnimation &#123; let basicAni = CABasicAnimation() basicAni.keyPath = "position" basicAni.fromValue = fromValue basicAni.toValue = toValue basicAni.duration = 2 // basicAni.fillMode = kCAFillModeForwards // basicAni.isRemovedOnCompletion = false // 1 basicAni.timingFunction = CAMediaTimingFunction(name: timingFunction) basicAni.delegate = self return basicAni &#125;&#125; 1 timingFunction代表移动模式： kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉 kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开 kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地 kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。 代码： 89-Animation/CABasic Animation 参考： 第三篇：iOS动画系列之三：Core Animation。介绍了Core Animation的常用属性和方法。 第四篇：CABasic Animation。iOS动画系列之四：基础动画之平移篇]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画(一)：时钟动画(Swift)]]></title>
    <url>%2F2017%2Fios-animation-1-clock.html</url>
    <content type="text"><![CDATA[一、直接做动画 新建项目clock 加载表盘图片。在viewDidLoad中添加： 123456let dialLayer = CALayer()dialLayer.bounds = CGRect(x: 0, y: 0, width: 150, height: 150)dialLayer.position = self.view.centerdialLayer.contents = UIImage(named: "clock")?.cgImageview.layer.addSublayer(dialLayer) 懒加载秒针、分针、时针视图。懒加载机制是Swift中一种存储属性：延迟存储属性，具体可擦看 以撸代码的形式学习Swift-10：Properties 1234567891011121314151617181920212223242526272829303132// 秒针lazy var secondHandView: UIView = &#123; let secondHandView = UIView() secondHandView.backgroundColor = UIColor.red secondHandView.bounds = CGRect(x: 0, y: 0, width: 1, height: 60) secondHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1) return secondHandView&#125;()// 分针lazy var minuteHandView: UIView = &#123; let minuteHandView = UIView() minuteHandView.backgroundColor = UIColor.darkGray minuteHandView.bounds = CGRect(x: 0, y: 0, width: 3, height: 60) minuteHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1) return minuteHandView&#125;()// 时针lazy var hourHandView: UIView = &#123; let hourHandView = UIView() hourHandView.backgroundColor = UIColor.darkGray hourHandView.bounds = CGRect(x: 0, y: 0, width: 3, height: 45) hourHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1) return hourHandView&#125;() 把秒针、分针、时针添加到view中。在viewDidLoad中添加： 123456secondHandView.center = view.centerself.view.addSubview(secondHandView)minuteHandView.center = view.centerself.view.addSubview(minuteHandView)hourHandView.center = view.centerself.view.addSubview(hourHandView) 创建CADisplayLink，并将其添加到主线程中。在viewDidLoad中添加： 12let link = CADisplayLink(target: self, selector: #selector(ViewController.clockRunning))link.add(to: RunLoop.main, forMode: .defaultRunLoopMode) 添加方法clockRunning: 123456789101112131415161718func clockRunning() &#123; let tZone = TimeZone.current var calendar = Calendar.current let currentDate = Date() calendar.timeZone = tZone let currentTime = calendar.dateComponents([Calendar.Component.hour, Calendar.Component.minute, Calendar.Component.second], from: currentDate) // 根据当前秒、分、时数分别计算秒针、分针、时针偏转弧度 let secondAngle = CGFloat ( Double(currentTime.second!) * (Double.pi * 2.0 / 60) ) secondHandView.transform = CGAffineTransform(rotationAngle: secondAngle) let minuteAngle = CGFloat ( Double(currentTime.minute!) * (Double.pi * 2.0 / 60) ) minuteHandView.transform = CGAffineTransform(rotationAngle: minuteAngle) let hourAngle = CGFloat ( Double(currentTime.hour!) * (Double.pi * 2.0 / 12) ) hourHandView.transform = CGAffineTransform(rotationAngle: hourAngle)&#125; 现在就完成了文章开头的效果。 二、代码说明 关于anchorPoint（锚点）如果注释掉分针和时针视图，并且关掉动画效果和锚点设置：123456789// secondHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1)// minuteHandView.center = view.center// self.view.addSubview(minuteHandView)// hourHandView.center = view.center// self.view.addSubview(hourHandView) // 创建CADisplayLink，并将其添加到主线程中// let link = CADisplayLink(target: self, selector: #selector(ViewController.clockRunning))// link.add(to: RunLoop.main, forMode: .defaultRunLoopMode) 加上secondHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1)后： anchorPoint的官方描述： Defines the anchor point of the layer’s bounds rectangle. Animatable.You specify the value for this property using the unit coordinate space. The default value of this property is (0.5, 0.5), which represents the center of the layer’s bounds rectangle. All geometric manipulations to the view occur about the specified point. For example, applying a rotation transform to a layer with the default anchor point causes the layer to rotate around its center. Changing the anchor point to a different location would cause the layer to rotate around that new point. anchorPoint的值在 (0,0) 和 (1,1)之间。默认是 (0.5, 0.5),代表锚点在中心位置。 (0,0) 和 (1,1)分别代表左上角和右上角。 关于CALayer的属性position和anchorPoint position类似UIView 的center position决定了layer在父视图上的位置 anchorPoint决定了position在自身的位置。All geometric manipulations to the view occur about the specified point. CADisplayLink 与 NSTimer CADisplayLink精确度高 NSTimer占用系统资源较多 代码和图片位置： 89-Animation/clock 参考： iOS动画系列之一：通过实战学习CALayer和透视的原理。做一个带时分秒指针的时钟动画(上) iOS动画系列之二：通过实战学习CALayer和透视的原理。做一个带时分秒指针的时钟动画。包含了OC和Swift两种源代码(下)]]></content>
      <categories>
        <category>iOS-Animation</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Core ML：建立一个简单的图片内容识别应用]]></title>
    <url>%2F2017%2Fintroducing-coreml.html</url>
    <content type="text"><![CDATA[Xcode 9 beta &amp; iOS11 beta &amp; Swift4 Core ML是一个能集成机器学习模型到app中的框架。 一、新建初始项目 新建项目CoreMLDemo，以single-view application template模板 建立如下如下UI 二、实现照相和获取图片库功能 遵守两个协议：class ViewController: UIViewController, UINavigationControllerDelegate, UIImagePickerControllerDelegate { 添加两个接口，并关联。 12@IBOutlet var imageView: UIImageView!@IBOutlet var classifier: UILabel! 实现两个Action 1234567891011121314151617181920@IBAction func camera(_ sender: Any) &#123; if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; let cameraPicker = UIImagePickerController() cameraPicker.delegate = self cameraPicker.sourceType = .camera cameraPicker.allowsEditing = false present(cameraPicker, animated: true, completion: nil)&#125;@IBAction func openLibrary(_ sender: Any) &#123; let picker = UIImagePickerController() picker.allowsEditing = false picker.delegate = self picker.sourceType = .photoLibrary present(picker, animated: true)&#125; 实现协议UIImagePickerControllerDelegate中的方法： 123func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil)&#125; 在Info.plist中添加📷使用请求，Privacy – Camera Usage Description and Privacy 三、集成Core ML Data Model 到Apple机器学习官网 Machine Learning下载Core ML models，目前有6个Model，识别图片的使用Inception v3。下载得到一个mlmodel结尾的文件，直接拖到项目中，会自动生成对应model名的swift的类文件，可以直接在代码中使用。 在ViewController.swift中引入Core ML:import CoreML 初始Inceptionv3: 12345var model: Inceptionv3!override func viewWillAppear(_ animated: Bool) &#123; model = Inceptionv3()&#125; 实现UIImagePickerControllerDelegate协议的imagePickerController(_:didFinishPickingMediaWithInfo)方法： 12345678910111213141516171819202122232425262728293031323334func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; picker.dismiss(animated: true) classifier.text = "Analyzing Image..." guard let image = info["UIImagePickerControllerOriginalImage"] as? UIImage else &#123; return &#125; UIGraphicsBeginImageContextWithOptions(CGSize(width: 299, height: 299), true, 2.0) image.draw(in: CGRect(x: 0, y: 0, width: 299, height: 299)) let newImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() let attrs = [kCVPixelBufferCGImageCompatibilityKey: kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey: kCFBooleanTrue] as CFDictionary var pixelBuffer : CVPixelBuffer? let status = CVPixelBufferCreate(kCFAllocatorDefault, Int(newImage.size.width), Int(newImage.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer) guard (status == kCVReturnSuccess) else &#123; return &#125; CVPixelBufferLockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) let pixelData = CVPixelBufferGetBaseAddress(pixelBuffer!) let rgbColorSpace = CGColorSpaceCreateDeviceRGB() let context = CGContext(data: pixelData, width: Int(newImage.size.width), height: Int(newImage.size.height), bitsPerComponent: 8, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer!), space: rgbColorSpace, bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue) //3 context?.translateBy(x: 0, y: newImage.size.height) context?.scaleBy(x: 1.0, y: -1.0) UIGraphicsPushContext(context!) newImage.draw(in: CGRect(x: 0, y: 0, width: newImage.size.width, height: newImage.size.height)) UIGraphicsPopContext() CVPixelBufferUnlockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) imageView.image = newImage 使用Core ML在上面imagePickerController(_:didFinishPickingMediaWithInfo)方法最后添加： 1234guard let prediction = try? model.prediction(image: pixelBuffer!) else &#123; return&#125;classifier.text = "I think this is a \(prediction.classLabel)." 现在就可运行识别图片内容了，我已几个简单的做了实验，效果还可以： 能识别🐶的种类，哈巴狗pug 🍌应该相对而言简单： 朋友家的猫，我也不知道猫的种类，识别为波斯猫(Persian cat): 这个我就不知道是怎么识别为浓咖啡(espresso)的了🤔 当然识别相差比较奇怪的。小米手环识别成听诊器（stethoscope）😢 kindle识别不出😢😢😢 四、Core ML学习资源官方文档 official Core ML documentation WWDC 2017： Introducing Core ML Core ML in Depth 代码 CoreMLDemo （由于Inceptionv3.mlmodel比较大，我就没有上传到github上，直接到 Machine Learning然后拖到项目中即可） 参考：Introduction to Core ML: Building a Simple Image Recognition App]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Core ML</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github和hexo创建免费的静态个人博客网站]]></title>
    <url>%2F2017%2Fgithub-hexo.html</url>
    <content type="text"><![CDATA[之前刚学编程，接触PHP时，出于学习的目的，兴致勃勃地买了域名、主机、学了Wordpress，找了主题，折腾了好久建了个网站，也写了一些文章，然后就没有然后了，这是从入门到放弃系列的典型案例。前段时间收到主机要到期的通知，正好我也接触到了简书，支持markdown，感觉蛮好，平常也习惯使用markdown格式记录笔记。就觉得不再续费主机了，就主要使用简书，个人博客就使用github和hexo这种支持markdown生成静态网页形式就行了。 已经有很多小伙伴这样搭建自己的个人博客，并写了相关文章，这边我就做一个搭建过程中的简单记录。开始之前需要安装git和nodejs，有github账号，程序员小伙伴一般都会有了，我就不啰嗦了。 关于GitHub PagesGitHub Pages原本是为托管在github上的项目提供介绍页面的一个功能，非常适合托管一些功能简单或者是静态页面的网站。考虑到访问速度，可以考虑国内的coding。 按照GitHub Pages步骤建立自己的GitHub Pages库。 hexohexo文档很详细，也有中文，很方便。 安装 hexonpm install hexo-cli -g 建站123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新生成的目录结构为： _config.yml 是网站的站点配置文件 node_modules 是nodejs库文件目录，就是npm install命令安装的文件位置 package.json是程序信息 scaffolds 新建文章的模板 source 存放用户资源的地方，404、favicon、CNAME 等堵在此处，这是我们主要工作的地方。其中，_posts文件是写文章地方，除_posts文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹（之后生成），而其他文件会被拷贝过去。 themes 是主题存储地方。 配置网站信息_config.yml 文件提供了很多配置，详细可看官网配置信息。先配置两方面的，之后需要再配置。 网站基本信息 1234567# Sitetitle: 欣欣向戎subtitle: AndyRon&apos;s Blogdescription: Just for fun.author: AndyRonlanguage: zh-Hanstimezone: Asia/Shanghai 部署，注意字段，repo就是个人GitHub Pages的地址库。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: git repo: https://github.com/andyRon/andyRon.github.io.gitbranch: master 新建文章 hexo new [layout] &lt;title&gt; ： 也就是在source/_posts/下按照模板新建了一个markdown文件，layout就是指scaffolds文件夹中的模板，也可以直接在_posts中新建markdown文件。 在本地服务器测试hexo server ：在浏览器打开http://localhost:4000/ ，就可以查看 生成静态文件hexo generate（hexo g） ：这个命令会新建一个public文件夹，在其中生成静态文件，这个目录相当于网站的根目录。 发布到githubhexo deploy（hexo d）：把public文件夹内的内容上传到github上。现在访问https://yourname.github.io (我的是https://andyron.github.io )就能访问刚建立的网站了。如果出现ERROR Deployer not found的问题，可通过npm install hexo-deployer-git --save解决。 其他hexo命令hexo clean ：删除public文件夹内容，和清理一些缓存。调试网站可以使用。 域名绑定（如有必要） 在source/下添加文件CNAME，内容只为如andyron.com（没有http和www） 部署到github上：hexo generate，hexo deploy 域名解析。不同的域名服务商大同小异，我的是阿里云，为了防止解析出问题，我把其他默认一些邮件解析等都删了，就添加两个： 可能需要等一短时间（10分钟以上），就可以用 http://andyron.com 访问了。 hexo主题hexo有很多主题，很多网友为hexo贡献了很多主题，可到主题上寻找。我选择的是next主题，这个使用主题用的人比较多，文档很全，也比较简洁。主题的使用非常简单： 将主题文件拷贝至站点目录的themes 目录下 修改站点配置文件： theme: 主题名 主题的一些设置： 设置RSS 安装 hexo-generator-feed插件，在hexo init初始化的目录下执行npm install hexo-generator-feed --save 在站点配置文件添加： 123456feed:type: atompath: atom.xmllimit: 20hub:content: hexo generate 设置搜索有很多搜索方式，这只是一种简单方式 安装hexo-generator-searchdb，在hexo的根目录下：$ npm install hexo-generator-searchdb --save 在站点配置文件添加： 12345search: path: search.xml field: post format: html limit: 10000 在主题配置文件（themes/next/_config.yml）修改：12local_search: enable: true 添加标签页面 $hexo new page tags：结果生成新文件夹source/tags/，并在其中有一个index.md。 在主题配置文件的menu中打开标签 添加分类页面 $hexo new page categories：结果生成新文件夹source/categories，并在其中有一个index.md。 在主题配置文件的menu中打开分类。 添加关于我页面 $hexo new page about：结果生成新文件夹source/about，并在其中有一个index.md，在index.md中直接编写关于我的内容。 在主题配置文件的menu中打开分类。 添加百度分析 注册 百度统计，并添加自己的网站 复制 hm.js? 后面那串统计脚本 id 在主题配置文件中添加字段baidu_analytics，职位上面的脚本id 参考http://blog.csdn.net/zuoziji416/article/details/53204478]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 传感器(一)：总的介绍和距离传感器]]></title>
    <url>%2F2017%2Fios-sensor-1.html</url>
    <content type="text"><![CDATA[关于传感器（Sensor），Apple官方好像并没有专门列出来介绍过，我只能从前辈的文章寻找，很多文章中都给iOS传感器进行过很详细的分类介绍，但有的传感器只是有过介绍，没有介绍使用方法或API，当然也有可能是我没搜索到，比如湿度传感器很多文章都提到，但详细使用方式就未曾看到过，还有这边的湿度传感器是指iPhone内部的？还是指iPhone所在外部环境的？ iPhone的传感器是经过长时间不停的变化和改进的，因为传感器一听名字就知道这种变化和改进十之八九是要与硬件有关系的。知乎中有一遍文章介绍的很详细，iPhone这十年在传感器上的演进- 知乎专栏。 iOS中传感器分类我姑且按照我查看的资料对iOS传感器进行一个不精确分类。 传感器类型 说明 加速计 Core Motion，感应设备的运动（摇一摇、计步器） 陀螺仪 Core Motion，感应设备的持握方式（赛车类游戏） 步数计 Core Motion 气压计 Core Motion 磁力计 Core Motion 距离传感器 感应是否有其他物体靠近设备屏幕（打电话自动屏） 环境光线传感器 感应周边环境光线的强弱（自动调节屏幕亮度） 内部温度传感器 感应设备内部的温度（提醒用户降温，防止损伤设备） 湿度传感器 感应设备是否进水（方便维修人员） 距离传感器和光线传感器知乎知友 Hi-iD 的答案介绍过这两个传感器的关系，本人简单总结如下： iPhone 5/5s/6之后光线/距离感应器就是iPhone顶部中心一个孔 光线传感器和距离传感器是两个独立的传感器，但两者都是对光作出反应。 距离传感器是基于红外光，距离传感器自身发射出的红外光，经外界反射后折回的红外光被距离传感器进行识别判断，所以距离传感器会有两个单元（反射和接收） 距离传感器的使用距离传感器的使用的使用相对简单：1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() UIDevice.current.isProximityMonitoringEnabled = true NotificationCenter.default.addObserver(self, selector: #selector(ViewController.sensorStateChange(notification:)), name: Notification.Name.UIDeviceProximityStateDidChange, object: nil) &#125; @objc func sensorStateChange(notification: NotificationCenter) &#123; if UIDevice.current.proximityState == true &#123; print("接近") &#125; else &#123; print("远离") &#125; &#125; 现在对iPhone顶部中心一个孔进行遮挡，就能感受的距离传感器。 Core MotionCore Motion是关于accelerometers(加速计), gyroscopes(陀螺仪), pedometers(步数计), magnetometers( 磁力计), and barometers(气压计)等5个传感器使用的框架， 暂时就按照字面意思翻译成核心运动框架。官方文档的介绍： Core Motion reports motion- and environment-related data from the onboard hardware of iOS devices, including from the accelerometers(加速计), gyroscopes(陀螺仪), pedometers(步数计), magnetometers( 磁力计), and barometers(气压计). You use this framework to access hardware-generated data so that you can use it in your app. For example, a game might use accelerometer and gyroscope data to control onscreen game behavior. 之后的文章就学习Core Motion的使用。😋 参考：1 https://www.zhihu.com/question/25526443/answer/310408872 iPhone这十年在传感器上的演进- 知乎专栏3 iOS开发之传感器4 扒一扒iPhone6的手机传感器5 非典型技术宅 的传感器系列文章 iOS传感器：实现一个随屏幕旋转的图片]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 13：手势处理]]></title>
    <url>%2F2017%2Fios-tutorial-13.html</url>
    <content type="text"><![CDATA[iOS手势处理由UIGestureRecognizer控制，不同手势有这个类的不同子类处理，不同手势处理有不同的相关属性。 子类 描述 UITapGestureRecognizer 点击手势 UIPanGestureRecognizer 跟着手移动手势 UIPinchGestureRecognizer 缩放手势 UIRotationGestureRecognizer 旋转手势 UISwipeGestureRecognizer 轻扫手势 UILongPressGestureRecognizer 长按手势 UIScreenEdgePanGestureRecognizer 屏幕边缘滑动手势 手势处理的步骤一般： 初始化手势，并添加到需要手势的View中 添加手势回调方法 UITapGestureRecognizer属性numberOfTapsRequired表示点击次数，属性numberOfTouchesRequired表示点击手指数。 12345678910111213141516171819202122var isChange = false...let tap = UITapGestureRecognizer(target: self, action: #selector(ViewController.tap(tap:)))tap.numberOfTapsRequired = 2...imageView.addGestureRecognizer(tap)...@objc func tap(tap: UITapGestureRecognizer) &#123; let center = imageView.center if isChange &#123; imageView.frame.size.width /= 2 imageView.frame.size.height /= 2 imageView.center = center isChange = false &#125; else &#123; imageView.frame.size.width *= 2 imageView.frame.size.height *= 2 imageView.center = center isChange = true &#125;&#125; UIPanGestureRecognizer1let pan = UIPanGestureRecognizer(target: self, action: #selector(ViewController.pan(pan:))) 12345678910@objc func pan(pan: UIPanGestureRecognizer) &#123; if pan.state == .began || pan.state == .changed &#123; // 移动后的变化（变化值类似向量） let translation = pan.translation(in: imageView.superview) print(translation) imageView.center = CGPoint(x: imageView.center.x + translation.x, y: imageView.center.y + translation.y) // view移动后，把上一步的移动值变为0，否则移动值为递增 pan.setTranslation(CGPoint.zero, in: imageView.superview) &#125;&#125; UIRotationGestureRecognizer1let rotation = UIRotationGestureRecognizer(target: self, action: #selector(ViewController.rotation(rotation:))) 12345@objc func rotation(rotation: UIRotationGestureRecognizer) &#123; if rotation.state == .began || rotation.state == .changed &#123; imageView.transform = CGAffineTransform(rotationAngle: rotation.rotation) &#125;&#125; UISwipeGestureRecognizer123let swipe = UISwipeGestureRecognizer(target: self, action: #selector(ViewController.swipe(swipe:)))swipe.direction = .upswipe.numberOfTouchesRequired = 3 123@objc func swipe(swipe: UISwipeGestureRecognizer) &#123; print("扫的方向：\(swipe.direction),扫的手指数：\(swipe.numberOfTouchesRequired)")&#125; UILongPressGestureRecognizernumberOfTouchesRequired 长按的指头数minimumPressDuratio 长按最小时间（秒） 123456789let long = UILongPressGestureRecognizer(target: self, action: #selector(ViewController.long(long:)))long.numberOfTouchesRequired = 2long.minimumPressDuration = 1...@objc func long(long: UILongPressGestureRecognizer) &#123; print("长按手势，长按字头数为\(long.numberOfTouchesRequired)")&#125; UIScreenEdgePanGestureRecognizer12let screenEdge = UIScreenEdgePanGestureRecognizer(target: self, action: #selector(ViewController.screenEdage(screenEdage:)))screenEdge.edges = .left 123@objc func screenEdage(screenEdage: UIScreenEdgePanGestureRecognizer) &#123; print("屏幕边缘滑动手势：\(screenEdage.edges)")&#125; 详细代码： GestureDemo]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
      <tags>
        <tag>手势</tag>
        <tag>UIGestureRecognizer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 12：视频背景]]></title>
    <url>%2F2017%2Fios-tutorial-12.html</url>
    <content type="text"><![CDATA[新建项目 BackgroundVideoDemo 新建BackgroundVideo.swift文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import Foundationimport AVKitimport AVFoundationenum BackgroundVideoErrors: Error &#123; case invalidVideo&#125;class BackgroundVideo &#123; var isMuted = true private var player : AVPlayer? private var videoURL: URL? private var viewController: UIViewController? private var hasBeenUsed: Bool = false init (on viewController: UIViewController, withVideoURL URL: String) &#123; self.viewController = viewController // parse the video string to split it into name and extension let videoNameAndExtension:[String]? = URL.characters.split&#123;$0 == &quot;.&quot;&#125;.map(String.init) if videoNameAndExtension!.count == 2 &#123; if let videoName = videoNameAndExtension?[0] , let videoExtension = videoNameAndExtension?[1] &#123; if let url = Bundle.main.url(forResource: videoName, withExtension: videoExtension) &#123; self.videoURL = url // initialize our player with our fetched video url self.player = AVPlayer(url: self.videoURL!) &#125; else &#123; print(BackgroundVideoErrors.invalidVideo) &#125; &#125; &#125; else &#123; print(&quot;Wrong video name format&quot;) &#125; &#125; deinit&#123; if self.hasBeenUsed &#123; NotificationCenter.default.removeObserver(self, name: .AVPlayerItemDidPlayToEndTime, object: nil) NotificationCenter.default.removeObserver(self, name: .UIApplicationWillEnterForeground, object: nil) &#125; &#125; public func setUpBackground()&#123; self.player?.actionAtItemEnd = .none self.player?.isMuted = isMuted //add the video to your view .. let loginView: UIView = self.viewController!.view//get our view controllers view let playerLayer = AVPlayerLayer(player: self.player) playerLayer.videoGravity = AVLayerVideoGravityResizeAspectFill // preserve aspect ratio and resize to fill screen playerLayer.zPosition = -1 // set it&apos;s possition behined anything in our view playerLayer.frame = loginView.frame // set our player frame to our view&apos;s frame loginView.layer.addSublayer(playerLayer) // prevent video from disturbing audio services from other apps do &#123; try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryAmbient) &#125; catch &#123; print(&quot;failed setting AVAudioSession Category to AVAudioSessionCategoryAmbient&quot;) &#125; self.player?.play() // start the video /// 向通知中心发送视频结束后再次从头播放 NotificationCenter.default.addObserver(self, selector: #selector(self.loopVideo), name: .AVPlayerItemDidPlayToEndTime, object: nil) // 视频进入Foreground后从头播放 NotificationCenter.default.addObserver(self, selector: #selector(self.loopVideo), name: .UIApplicationWillEnterForeground, object: nil) self.hasBeenUsed = true &#125; // 循环播放视频 @objc private func loopVideo() &#123; self.player?.seek(to: kCMTimeZero) self.player?.play() &#125; &#125; 在所需要的视图控制器中定义变量var backgroundPlayer : BackgroundVideo?，然后再在viewDidLoad中定义： 12345678910 override func viewDidLoad() &#123; super.viewDidLoad() let backgroundPlayer = BackgroundVideo(on: self, withVideoURL: &quot;test.mp4&quot;) //是否打开静音// backgroundPlayer?.isMuted = false backgroundPlayer.setUpBackground() &#125; 详细代码： BackgroundVideoDemo 参考：BackgroundVideoiOS]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 11：照片横屏滑动]]></title>
    <url>%2F2017%2Fios-tutorial-11.html</url>
    <content type="text"><![CDATA[知识点： UICollectionView UIVisualEffectView UICollectionViewDataSource 新建项目Carousel Effect 在IB构建UI。Collection View 里的 Scroll Direction 设置成水平滚动。UIVisualEffectView是用来添加模糊效果的，也可以使用类似如下的代码构建： 1234let blurEffect = UIBlurEffect(style: .dark)let blurEffectView = UIVisualEffectView(effect: blurEffect)blurEffectView.frame = view.boundsbackgroundImageView.addSubview(blurEffectView) 创建数据类Interest 创建UICollectionViewCell 实现UICollectionViewDataSource的方法（有点类似UITableViewDataSource）。12345678910111213141516171819202122232425262728293031323334353637class ViewController: UIViewController, UICollectionViewDataSource &#123; @IBOutlet weak var backgroundImageView: UIImageView! @IBOutlet weak var collectionView: UICollectionView! var interests = Interest.createInterests() override func viewDidLoad() &#123; super.viewDidLoad() collectionView.dataSource = self collectionView.dataSource = self &#125; override var preferredStatusBarStyle : UIStatusBarStyle &#123; return UIStatusBarStyle.lightContent &#125; func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123; return 1 &#125; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return interests.count &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let CellIdentifier = &quot;InterestCell&quot; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CellIdentifier, for: indexPath) as! InterestCollectionViewCell cell.interest = self.interests[indexPath.item] return cell &#125;&#125; 详细代码： Carousel Effect 参考：30DaysofSwift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
      <tags>
        <tag>UICollectionView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 10：UIScrollView滚动视图]]></title>
    <url>%2F2017%2Fios-tutorial-10-uiscrolview.html</url>
    <content type="text"><![CDATA[知识点: UIScrollView 当视图超过屏幕大小时，可通过把视图放在UIScrollView中让视图可以上下滚动的功能。以一张大图片为例。 新建项目 ScrollViewTutorial 代码：12345678910111213141516171819202122class ViewController: UIViewController &#123; var imageView: UIImageView! var scrollView: UIScrollView! override func viewDidLoad() &#123; super.viewDidLoad() imageView = UIImageView(image: UIImage(named: &quot;strandvagen.jpg&quot;)) scrollView = UIScrollView(frame: view.bounds) scrollView.backgroundColor = UIColor.black scrollView.contentSize = imageView.bounds.size scrollView.addSubview(imageView) view.addSubview(scrollView) &#125; &#125; 详细代码：ScrollViewTutorial 参考：Scroll View Tutorial in iOS8 with Swift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
      <tags>
        <tag>UIScrollView</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 9：本地视频播放]]></title>
    <url>%2F2017%2Fios-tutorial-9.html</url>
    <content type="text"><![CDATA[新建项目PlayLocalVideo 在IB中使View ControllerEmbed In &gt; Navigation Controller,并在View Controller**中添加UITableView和UITableViewCell。 在上面的UITableViewCell的中添加一个UIImageView作为视频的预览图、一个UIButton作为开始播放、两个UILabel分别用于显示视频的名称和来源。并修改一定样式和添加一定约束 添加几张图片和一个视频 添加一个cell的类，并添加三个接口。 12345class VideoCell: UITableViewCell &#123; @IBOutlet var previewImageView: UIImageView! @IBOutlet var nameLabel: UILabel! @IBOutlet var sourceLabel: UILabel! 添加一个video枚举，用来存储视频信息。 12345struct video &#123; let image: String let title: String let source: String&#125; 使ViewController符合table view代理和数据的协议，并实现所需方法： 12345678910111213141516171819202122232425func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; return 220 &#125; func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123; return 2 &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return data.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! VideoCell let video = data[indexPath.row] cell.previewImageView.image = UIImage(named: video.image) cell.nameLabel.text = video.title cell.sourceLabel.text = video.source return cell &#125; 引入播放视频所需框架，并定义相关变量。 1234567import AVFoundationimport AVKit... var playViewController : AVPlayerViewController? var playerView : AVPlayer? 实现视频播放按钮方法。 12345678910111213@IBAction func playVideo(_ sender: UIButton) &#123; let path = Bundle.main.path(forResource: &quot;KL&quot;, ofType: &quot;mp4&quot;) playerView = AVPlayer(url: URL(fileURLWithPath: path!)) playViewController = AVPlayerViewController() playViewController?.player = playerView present(playViewController!, animated: true, completion: &#123; self.playViewController?.player?.play() &#125;) &#125; 详细代码： PlayLocalVideo 参考： 30DaysofSwift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Alamofire：Swift的HTTP 网络库]]></title>
    <url>%2F2017%2Falamofire-introduce.html</url>
    <content type="text"><![CDATA[安装 CocoaPods和Carthage都很方便安装安装完，如果出现加载不到Alamofire，可以查看Cannot load underlying module for ‘Alamofire’ #441，问题应该可以解决。 手动安装 下载Alamofire 将Alamofire.xcodeproj拖进到项目中 在“Embedded Binaries中添加 command + B 编译后就可以使用 关于 https://httpbin.org/ 网站 https://httpbin.org/ 网站可用来做http的各种请求测试使用，不过遗憾的是没有POST等提交类型请求的测试 基本使用一个简单的请求： 123import AlamofireAlamofire.request("https://httpbin.org/get") http中有请求(Request) 和 响应(Response)两个重要概念。大部分http框架，都会使用request和response作为方法名。看看Alamofire的request方法的详细参数： 12345678public func request( _ url: URLConvertible, method: HTTPMethod = .get, parameters: Parameters? = nil, encoding: ParameterEncoding = URLEncoding.default, headers: HTTPHeaders? = nil) -&gt; DataRequest&#123; 有url,method,parameters,encoding,headers五个参数，与http是相互对应的。其中只有url是必须的，其它都有默认值。 请求后的响应处理向http发送请求后，就需对响应结果进行处理。 Alamofire采用链式调用的方式处理响应，这种链式调用的方式最初应该是起源jQuery。响应处理的一般形式如下，response就是响应结果。 123Alamofire.request("https://httpbin.org/get").responseJSON &#123; response in&#125; Alamofire 提供了五种不同的响应处理： 123456789101112131415161718192021222324252627282930// Response Handler - Unserialized Responsefunc response( queue: DispatchQueue?, completionHandler: @escaping (DefaultDataResponse) -&gt; Void) -&gt; Self// Response Data Handler - Serialized into Datafunc responseData( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Data&gt;) -&gt; Void) -&gt; Self// Response String Handler - Serialized into Stringfunc responseString( queue: DispatchQueue?, encoding: String.Encoding?, completionHandler: @escaping (DataResponse&lt;String&gt;) -&gt; Void) -&gt; Self// Response JSON Handler - Serialized into Anyfunc responseJSON( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void) -&gt; Self// Response PropertyList (plist) Handler - Serialized into Anyfunc responsePropertyList( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void)) -&gt; Self 五种方法的参数不同，但最后一参数都是一个回调的闭包，都可以写成尾随闭包形式。除了response方法的回调参数是DefaultDataResponse，其它都是DataResponse: 1234567891011121314151617181920212223public struct DataResponse&lt;Value&gt; &#123; /// The URL request sent to the server. public let request: URLRequest? /// The server's response to the URL request. public let response: HTTPURLResponse? /// The data returned by the server. public let data: Data? /// The result of response serialization. public let result: Result&lt;Value&gt; /// The timeline of the complete lifecycle of the request. public let timeline: Timeline /// Returns the associated value of the result if it is a success, `nil` otherwise. public var value: Value? &#123; return result.value &#125; /// Returns the associated error value if the result if it is a failure, `nil` otherwise. public var error: Error? &#123; return result.error &#125; var _metrics: AnyObject? DataResponse与DefaultDataResponse最大的不同就是多了两个属性result和value，value值就是格式化的不同类型。 响应处理的一些例子 response 123456789Alamofire.request("https://httpbin.org/get").response &#123; response in print("Request: \(response.request)") print("Response: \(response.response)") print("Error: \(response.error)") if let data = response.data, let utf8Text = String(data: data, encoding: .utf8) &#123; print("Data: \(utf8Text)") &#125;&#125; response方法的响应结果response是DefaultDataResponse，没有进行过格式化处理。 responseData 1234567Alamofire.request("https://httpbin.org/get").responseData &#123; response in debugPrint("All Response Info: \(response)") if let data = response.result.value, let utf8Text = String(data: data, encoding: .utf8) &#123; print("Data: \(utf8Text)") &#125;&#125; responseData方法对响应结果进行了处理，response.result.value就是我们属性的Data类型。 链式调用 1234567Alamofire.request("https://httpbin.org/get").responseString &#123; response in print("Response String: \(response.result.value)")&#125;.responseJSON &#123; response in print("Response JSON: \(response.result.value)")&#125; 响应验证http响应结果中的不同状态码(100..&lt;600)表示不同结果。 手动验证 1234567891011 Alamofire.request("https://httpbin.org/get").validate(statusCode: 200..&lt;300).validate(contentType: ["application/json"]).responseData &#123; response in switch response.result &#123; case .success: print("Validation Successful") case .failure(let error): print(error) &#125;&#125; 自动验证状态码在200..&lt;300的为正确，其它为错误。12345678Alamofire.request("https://httpbin.org/get").validate().responseJSON &#123; response in switch response.result &#123; case .success: print("Validation Successful") case .failure(let error): print(error) &#125;&#125; HTTP不同请求方式request方法的method参数表示不同的方法。 12345Alamofire.request("https://httpbin.org/get") // method defaults to `.get`Alamofire.request("https://httpbin.org/post", method: .post)Alamofire.request("https://httpbin.org/put", method: .put)Alamofire.request("https://httpbin.org/delete", method: .delete) 请求参数编码GET的参数按照固定格式写到URL中，其他类型则按照不同格式写到请求body中。 GET参数编码 12345678let parameters: Parameters = ["foo": "bar"]// All three of these calls are equivalentAlamofire.request("https://httpbin.org/get", parameters: parameters) // encoding defaults to `URLEncoding.default`Alamofire.request("https://httpbin.org/get", parameters: parameters, encoding: URLEncoding.default)Alamofire.request("https://httpbin.org/get", parameters: parameters, encoding: URLEncoding(destination: .methodDependent))// https://httpbin.org/get?foo=bar POST参数编码 12345678910111213141516let parameters: Parameters = [ "foo": "bar", "baz": ["a", 1], "qux": [ "x": 1, "y": 2, "z": 3 ]]// All three of these calls are equivalentAlamofire.request("https://httpbin.org/post", method: .post, parameters: parameters)Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: URLEncoding.default)Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: URLEncoding.httpBody)// HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3 JSON编码 123456789101112let parameters: Parameters = [ "foo": [1,2,3], "bar": [ "baz": "qux" ]]// Both calls are equivalentAlamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: JSONEncoding.default)Alamofire.request("https://httpbin.org/post", method: .post, parameters: parameters, encoding: JSONEncoding(options: []))// HTTP body: &#123;"foo": [1, 2, 3], "bar": &#123;"baz": "qux"&#125;&#125; 添加请求HTTP头部12345678let headers: HTTPHeaders = [ "Authorization": "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==", "Accept": "application/json"]Alamofire.request("https://httpbin.org/headers", headers: headers).responseJSON &#123; response in debugPrint(response)&#125; HTTP认证12345678let user = "user"let password = "password"Alamofire.request("https://httpbin.org/basic-auth/\(user)/\(password)") .authenticate(user: user, password: password) .responseJSON &#123; response in debugPrint(response)&#125; 下载文件12345Alamofire.download("https://httpbin.org/image/png").responseData &#123; response in if let data = response.result.value &#123; let image = UIImage(data: data) &#125;&#125; 另外可以下文件保存在本地：12345678910111213141516let destination: DownloadRequest.DownloadFileDestination = &#123; _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent("pig.png") return (fileURL, [.removePreviousFile, .createIntermediateDirectories])&#125;Alamofire.download("https://httpbin.org/image/png", to: destination).response &#123; response in print(response) if response.error == nil, let imagePath = response.destinationURL?.path &#123; let image = UIImage(contentsOfFile: imagePath) self.imageView.image = image self.tableView.reloadData() &#125;&#125; 上传 上传 Data 12345let imageData = UIImagePNGRepresentation(image!)!Alamofire.upload(imageData, to: "https://httpbin.org/post").responseJSON &#123; response in debugPrint(response)&#125; 上传文件 12345let fileURL = Bundle.main.url(forResource: "video", withExtension: "mov")Alamofire.upload(fileURL!, to: "https://httpbin.org/post").responseJSON &#123; response in debugPrint(response)&#125; 上传Multipart Form Data（表单提交） 1234567891011121314151617Alamofire.upload( multipartFormData: &#123; multipartFormData in multipartFormData.append(unicornImageURL, withName: "unicorn") multipartFormData.append(rainbowImageURL, withName: "rainbow")&#125;, to: "https://httpbin.org/post", encodingCompletion: &#123; encodingResult in switch encodingResult &#123; case .success(let upload, _, _): upload.responseJSON &#123; response in debugPrint(response) &#125; case .failure(let encodingError): print(encodingError) &#125;&#125;) 请求中花费的各种时间123Alamofire.request("https://httpbin.org/get").responseJSON &#123; response in print(response.timeline)&#125; 结果：1Timeline: &#123; "Latency": 1.527 secs, "Request Duration": 1.528 secs, "Serialization Duration": 0.001 secs, "Total Duration": 1.529 secs &#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Alamofire</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Swift中的问号三种用法]]></title>
    <url>%2F2017%2Fswift-question.html</url>
    <content type="text"><![CDATA[三目运算符(Ternary Conditional Operator)这在大部分语言中都比较常见布尔值 ? &quot;true&quot; : &quot;false&quot; 可选值可选值?和 !是一对。?用在某个类型后面，可以通俗的理解为，这个值不太确实是否是这个类型，如果不是就给个nil吧；!可以理解为，一定要给个类型我，要不老子分分钟挂给你看了。😎 空合运算符(Nil Coalescing Operator) ??这个我在其他语言没见过。e ?? f 相当于 e != nil ? e! : f， 可选类型e不是nil时，就e!,否则为f。 123var e: String?var f = "我是fuck"e ?? f // `e != nil ? e! : f` ， 可选类型`e`不是`nil`时，就`e!`,否则为`f`。（注意`??`前后要空格）]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 8：使用IBInspectable 和 IBDesignable定制UI]]></title>
    <url>%2F2017%2Fios-tutorial-8-ibinspectable-ibdesignable.html</url>
    <content type="text"><![CDATA[例子代码：https://github.com/andyRon/LearniOSByProject/tree/master/P077-FancyButton 理解IBInspectable 和 IBDesignable简单地说，IBInspectable 就是允许开发者在IB的属性检查器中添加额外的选项。IBDesignable 能够让 IBInspectable 添加的额外选项产生的变化在IB中实时显示。以Button的圆角为例说明。 正常情况下，Button的圆角需要代码：12button.layer.cornerRadius = 10.0button.layer.masksToBounds = true 或者直接在IB的Identity检查器的 user defined runtime attributes中添加： 注意到，这种修改不是实时，在IB中Button还是直角，只有运行后才是圆角。 以IBInspectable的方式。定义个继承至UIButton的类。12345678class RoundedCornerButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125;&#125; 然后把button的class属性修改成RoundedCornerButton: 发现这个button的属性检查器中多了Corner Radius。 注意： cornerRadius属性变成了Corner Radius，RoundedCornerButton类变成了 Rounded Corner Button，这是Xcode自动转变的，开发者只需要依照swift的命名规范就可以了（类名是大写开头的驼峰命名规则，属性名是小写开头的驼峰命名规则） cornerRadius的类型是CGFloat，在属性检查器中就对应数字的选择。当然不是所有类型都可以添加属性检查器中的，IBInspectable支持如下类型：12345678910IntCGFloat Double String Bool CGPoint CGSize CGRect UIColor UIImage 如果在类RoundedCornerButton前添加@IBDesignable，那在属性检查器中自定义的属性变化就可以在IB中实时显示了。12345678@IBDesignable class RoundedCornerButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125;&#125; 创建Fancy Button创建Fancy Button来更加深入的了解IBInspectable 和 IBDesignable 创建新项目FancyButton 下载图标，也可以随意图标，拖进asset catalog 新建类FancyButton，继承至UIButton 圆角，边宽，边的颜色。 更新FancyButton：12345678910111213141516171819@IBDesignableclass FancyButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125; @IBInspectable var borderWidth: CGFloat = 0.0 &#123; didSet &#123; layer.borderWidth = borderWidth &#125; &#125; @IBInspectable var borderColor: UIColor = .black &#123; didSet &#123; layer.borderColor = borderColor.cgColor &#125; &#125;&#125; Title在FancyButton继续添加属性：1234567891011121314151617181920@IBInspectable var titleLeftPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.left = titleLeftPadding &#125;&#125;@IBInspectable var titleRightPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.right = titleRightPadding &#125;&#125;@IBInspectable var titleTopPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.top = titleTopPadding &#125;&#125;@IBInspectable var titleBottomPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.bottom = titleBottomPadding &#125;&#125; 通过圆角可创建圆形button Image Padding添加图片边距的属性：123456789101112131415161718192021@IBInspectable var imageLeftPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.left = imageLeftPadding &#125;&#125;@IBInspectable var imageRightPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.right = imageRightPadding &#125;&#125;@IBInspectable var imageTopPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.top = imageTopPadding &#125;&#125;@IBInspectable var imageBottomPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.bottom = imageBottomPadding &#125;&#125; 图片靠右对齐根据下图关系，应有imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding。 在FancyButton中添加如下代码： 123456789@IBInspectable var enableImageRightAligned: Bool = falseoverride func layoutSubviews() &#123; super.layoutSubviews() if enableImageRightAligned, let imageView = imageView &#123; imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding &#125;&#125; + `enableImageRightAligned`属性又来自动计算 `imageEdgeInsets.left` 颜色渐变添加三个@IBInspectable属性，并更新layoutSubviews:1234567891011121314151617181920@IBInspectable var enableGradientBackground: Bool = false@IBInspectable var gradientColor1: UIColor = UIColor.black@IBInspectable var gradientColor2: UIColor = UIColor.whiteoverride func layoutSubviews() &#123; super.layoutSubviews() if enableImageRightAligned, let imageView = imageView &#123; imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding &#125; if enableGradientBackground &#123; let gradientLayer = CAGradientLayer() gradientLayer.frame = self.bounds gradientLayer.colors = [gradientColor1.cgColor, gradientColor2.cgColor] gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5) gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5) self.layer.insertSublayer(gradientLayer, at: 0) &#125;&#125; 渐变色需要运行后才能看到 参考：appcode网站的书《Intermediate iOS Programming with Swift》 的Chapter 36]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 1 前言和目录]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-1.html</url>
    <content type="text"><![CDATA[这是我学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的记录，章节和原书不同。 开发环境是Xcode 8，Swift 3，iOS 10。 我的代码在github上，andyRon/Beginning-iOS-Programming-with-Swift 目录 开始用Swift开发iOS 10 - 1 前言和目录 开始用Swift开发iOS 10 - 2 Hello World！第一个Swift APP 开始用Swift开发iOS 10 - 3 介绍Auto Layout 开始用Swift开发iOS 10 - 4 用Stack View设计UI 开始用Swift开发iOS 10 - 5 原型的介绍 开始用Swift开发iOS 10 - 6 创建简单的Table Based App 开始用Swift开发iOS 10 - 7 定制Table Views 开始用Swift开发iOS 10 - 8 Table View和UIAlertController的交互 开始用Swift开发iOS 10 - 9 Table Row的删除, UITableViewRowAction和UIActivityViewController的使用 开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue 开始用Swift开发iOS 10 - 11 面向对象编程介绍 开始用Swift开发iOS 10 - 12 丰富Detail View和定制化Navigation Bar 开始用Swift开发iOS 10 - 13 Self Sizing Cells and Dynamic Type 开始用Swift开发iOS 10 - 14 基础动画，模糊效果和Unwind Segue 开始用Swift开发iOS 10 - 15 使用地图 开始用Swift开发iOS 10 - 16 介绍静态Table Views，UIImagePickerController和NSLayoutConstraint 开始用Swift开发iOS 10 - 17 使用Core Data 开始用Swift开发iOS 10 - 18 Search Bar 和 UISearchController 开始用Swift开发iOS 10 - 19 使用UIPageViewController构建介绍页面 开始用Swift开发iOS 10 - 20 使用Tab Bar Controller 和 拆分Storyboard 开始用Swift开发iOS 10 - 21 使用WKWebView和SFSafariViewController 开始用Swift开发iOS 10 - 22 使用CloudKit 开始用Swift开发iOS 10 - 24 使用TestFlight进行Beta测试 开始用Swift开发iOS 10 - 25 使用3D Touch 开始用Swift开发iOS 10 - 26 使用本地用户通知]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DownGit：怎么下载github中某个文件夹？]]></title>
    <url>%2F2017%2Fdowngit.html</url>
    <content type="text"><![CDATA[怎么下载github中某个文件夹？ github只提供了整个项目下载。下载一个项目中的某个文件夹的内容，这种需求在使用github时，还是经常使用的。 比如：在一些大的项目下，只想看某个文件的内容时。又比如，像我这种andyRon/LearniOSByProject，就是我一些学习iOS的小项目或者Demo的集合，如果只想查看某个小项目，而不下载整个项目时。 方法很简单，早就有前辈想到了，DownGit这个网站就提供这个功能，只要把目录链接（比如：https://github.com/andyRon/LearniOSByProject/tree/master/76 ）拷贝，然后点击download就可以下载目录的压缩文件。]]></content>
      <categories>
        <category>暂时没想到怎么分类</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS本地化(swift)]]></title>
    <url>%2F2017%2Fios-localize.html</url>
    <content type="text"><![CDATA[示例代码在github上localizationsDemo 1 项目中需要配置的语言这就是项目中其他不同形式本地化可以添加的语种设置。 如下图为项目添加不同语种 弹框中显示要为两个Storyboard文件添加语种信息 添加完多语种后，相关需要本地化的文件会产生一组文件 实际在目录结构中是根据不同语言生成不同的*.lproj目录，再在*.lproj目录中生成了不同的.strings文件。 2 应用名称本地化App的名称在不同语种下显示不同。 新建一个.strings文件，名为InfoPlist.strings。 选中InfoPlist.strings，在右侧的文件检查器中点击Localize，在弹框中可以选择语种，对应项目中需要配置的语言中配置的语种。 可选中需要本地化的应用名称的语种： 在InfoPlist.strings的不同语种文件中添加字段CFBundleDisplayName，表示应用的名称。CFBundleDisplayName = &quot;简体中文名称&quot;; 在模拟器中，可通过Edit Scheme...编辑语种： 3 代码中的字符串的本地化类似应用名称本地化，代码中的字符串的本地也是利用.strings文件存储翻译信息。然后再在代码中利用NSLocalizedString（翻译信息默认在Localizable.strings文件）或NSLocalizedString(_:tableName:bundle:value:comment:)（翻译信息在tableName对应的.strings文件）文件标注。 NSLocalizedString(_:tableName:bundle:value:comment:)这种方式可根据需要把翻译信息保存在自定义的文件中，在多人开发时可以很好的防止冲突。 新建一个名为Localizable.strings的.strings文件。 类似InfoPlist.strings文件的配置方式，配置不同语种。 在代码中需要本地化的字符串修改为类似NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)或NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;) 4 图片的本地化这边所说的图片的本地化就是指，同一个名称图片，在不同语种下显示不同图片。 随意添加一张图片到项目，比如Swift_Logo.png 选中上面的图片，在右侧的文件检查器中点击Localize，类似之前的做法，添加所需的不同语种。 在Finder中的不同语种的*.lproj目录中添加，相同名字但不同的图片 在代码中添加类似的代码： self.imageView.image = UIImage(named: NSLocalizedString(&quot;Swift_Logo&quot;, comment: &quot;&quot;)) 最后的英文中的状态结果为： 5 优化本地化代码书写方式本地化时，NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)或NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;)这两种方法代码写法有点繁琐，参考stackoverflow中一个问题What’s NSLocalizedString equivalent in Swift?Ask的一个答案，扩展一下String：12345678910111213extension String &#123; var localized: String &#123; return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: "", comment: "") &#125; func localized(withComment:String) -&gt; String &#123; return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: "", comment: withComment) &#125; func localized(tableName: String) -&gt; String&#123; return NSLocalizedString(self, tableName: tableName, bundle: Bundle.main, value: "", comment: "") &#125;&#125; 然后，原本下面的写法：123self.label.text = NSLocalizedString("labelName", comment: "Label")self.label2.text = NSLocalizedString("labelName", tableName: "andy", bundle: Bundle.main, value: "", comment: "Label")self.imageView.image = UIImage(named: NSLocalizedString("Swift_Logo", comment: "")) 就可以写成：123self.label.text = "labelName".localizedself.label2.text = "labelName".localized(tableName: "andy")self.imageView.image = UIImage(named: "Swift_Logo".localized) 参考：【iOS】浅谈多语言本地化(国际化)3分钟实现iOS语言本地化/国际化（图文详解）What’s NSLocalizedString equivalent in Swift?Ask]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSLocalizedString</tag>
        <tag>InfoPlist.strings</tag>
        <tag>本地化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习7：内存管理]]></title>
    <url>%2F2017%2Foc-basic-7.html</url>
    <content type="text"><![CDATA[1 对象生命周期 诞生（通过alloc或new方法实现） -&gt; 生存（接收消息并执行操作） -&gt; 交友（通过复合以及向方法传递参数） -&gt; 死去（被释放掉） 引用计数(reference counting) / 保留计数(retain counting) alloc, new, copy: 创建对象，保留计数被设置为1 retain: 保留计数加1。如[[car retain] setTire: tire atIndex:2];表示要求car对象将其保留计数的值加1并执行setTire操作。 release: 保留计数减1 dealloc: 保留计数归0时自动调用 retainCount: 获得对象保留计数当前值 1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &lt;Foundation/Foundation.h&gt;@interface RetainTracker : NSObject@end@implementation RetainTracker- (id) init&#123; if (self = [super init]) &#123; NSLog(@"init: Retain count of %lu .", [self retainCount]); &#125; return self;&#125; // init- (void)dealloc&#123; NSLog(@"dealloc called. Bye Bye."); [super dealloc];&#125; // dealloc@end // RetainTrackerint main(int argc, const char * argv[]) &#123; RetainTracker *a = [RetainTracker new]; [a retain]; NSLog(@"%lu", [a retainCount]); [a retain]; NSLog(@"%lu", [a retainCount]); [a release]; NSLog(@"%lu", [a retainCount]); [a release]; NSLog(@"%lu", [a retainCount]); [a release]; NSLog(@"%lu", [a retainCount]); // 为什么此处是 1 不是 0吗？ return 0;&#125; 对象所有权(object ownership)如果一个对象内有指向其他对象的实例变量，则称 该对象拥有这些对象。 访问方法中的保留和释放所有对象放入池中 @autoreleasepool/NSAutoreleasePool： 自动释放池 NSObject提供autorelease方法：- (id) autorelease; 2 Cocoa的内存管理规则 3 异常与异常有关的关键字 @try @catch @finally @throw 捕捉不同类型的异常123456@try &#123;&#125; @catch (MyCustomException *custom) &#123;&#125; @catch (NSException *exception) &#123;&#125; @catch (id value) &#123;&#125; @finally &#123;&#125; 抛出异常抛出异常的两种方式： @throw异常名 向某个NSException对象发送raise消息1234NSException *theException = [NSException exceptionWithName: ...];@throw theException;[theException raise]; 区别：raise只对NSException对象有效，@throw异常名可用在其他对象上。 异常也需要内存管理异常和自动释放池]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Carthage的使用]]></title>
    <url>%2F2017%2Fcarthage-introduce.html</url>
    <content type="text"><![CDATA[Carthage与CocoaPods的简单比较 CocoaPods 的优势： 使用方便，除编写 Podfile 以外其他几乎都是自动完成； 软件包数量多，主流支持； CocoaPods 的缺点： 每次更新环境都需要连接到中心仓库，比较耗时； 开发者使用比较简单，但是如果创建兼容 CocoaPods 的库，就会相对繁琐一些（尽管有了命令行）； 每次干净编译都会把所有第三方库都重新编译一次（看似很正确，直到我遇见 Carthage…） Carthage 的优势 第三方库不是每一次都重新编译，节省时间； 去中心化，没有中心服务器，这意味着每次配置和更新环境，只会去更新具体的库，而不会有一个向中心服务器获取最新库的索引这么个过程，节省时间； 与 CocoaPods 无缝集成； 结构标准的项目天然就是 Carthage 库； 安装Carthagebrew install carthage 使用Carthage 进入项目文件夹，比如建立新项目 carthageDemo 创建空文件Cartfile，命令：touch Cartfile 编辑Cartfile文件(xcode，或其它文本编辑器)，以SVProgressHUD为例，Cartfile文件内容大致如下： 1github &quot;SVProgressHUD/SVProgressHUD&quot; ~&gt; 1.0 Cartfile文件格式说明: 依赖源有两种，github和git，就是告诉 Carthage到哪里下载第三方库，例子如下：1234567891011121314151617181920212223# Require version 2.3.1 or latergithub &quot;ReactiveCocoa/ReactiveCocoa&quot; &gt;= 2.3.1# Require version 1.xgithub &quot;Mantle/Mantle&quot; ~&gt; 1.0 # (1.0 or later, but less than 2.0)# Require exactly version 0.4.1github &quot;jspahrsummers/libextobjc&quot; == 0.4.1# Use the latest versiongithub &quot;jspahrsummers/xcconfigs&quot;# Use the branchgithub &quot;jspahrsummers/xcconfigs&quot; &quot;branch&quot;# Use a project from GitHub Enterprisegithub &quot;https://enterprise.local/ghe/desktop/git-error-translations&quot;# Use a project from any arbitrary server, on the &quot;development&quot; branchgit &quot;https://enterprise.local/desktop/git-error-translations2.git&quot; &quot;development&quot;# Use a local projectgit &quot;file:///directory/to/project&quot; &quot;branch&quot; 从上面的例子中有很详细的版本号例子： == 1.0 使用1.0版本 &gt;= 1.0 使用1.0或更高的版本 ~&gt; 1.0 使用高于1.0但低于2.0的最新版本 没有的是使用最新版本 branch名称/tag名称/commit名称 使用特定分支/标签/提交版本 运行Carthage carthage update [--platform iOS]--platform iOS是针对iOS的，可选项。在项目根目录下会生成一个Cartfile.resolved文件和Carthage文件夹，Carthage文件夹中的Build目录下有编译好的framework文件，Checkouts目录第三库的源文件。 把库添加到项目中 把编译好的framework文件拖动到Linked Frameworks and Libraries或者点击+选择。 在Build Phases中添加一个Run Script。命令为 /usr/local/bin/carthage copy-frameworks。Input Files下的条目为$(SRCROOT)/Carthage/Build/iOS/SVProgressHUD.framework。具体操作如下图： 编译就可以使用第三方库了 其他 新加库时在Cartfile文件中添加后，然后操作类似上面的 更新指定库：carthage update SVProgressHUD --platform iOS 参考：Carthage的安装和使用【译】Carthage的使用Carthage 初探：四大优势与四大劣势Carthage官方地址]]></content>
      <categories>
        <category>iOS</category>
        <category>工具</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
        <tag>Carthage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 26 使用本地用户通知]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-26.html</url>
    <content type="text"><![CDATA[iOS 10 之前用户通知相对而言是简单的，iOS 10让用户通知更加丰富了，可以有静态图片，动态gif，视频，音频等。 用户通知可以出现在通知中心，主屏，锁屏时，当用户错过了用户通知时，可以在通知中心查看。 用户通知分为两类： 本地通知。 是通过应用本身和用户设备本身触发的。比如：基于用户位置的app，在用户进入某个特殊区域发送通知；to-do list的app在某些特定时间发送通知。 远程通知。 是远程服务器端首先向苹果推送服务器（Apple Push Notification Service ，APNS）发送，然后再经过APNS推送通知到用户设备。 这一篇只讨论本地通知。 三种不同触发的本地通知： 特定数量的时间。 比如是10分钟后。 特定日期和时间点。 特定位置。 询问用户授权向用户发送通知是要得到用户允许的。 在AppDelegate.swift中添加 import UserNotifications 在application(_:didFinishLaunchingWithOptions:)方法中添加授权12345678UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge], completionHandler: &#123; (granted, error) in if granted &#123; print(&quot;User notifications are allowed.&quot;) &#125; else &#123; print(&quot;User notifications are not allowed.&quot;) &#125;&#125;) 创建通知通知的一般结构： 通知用UNMutableNotificationContent类来表示。 在RestaurantTableViewController中添加一个方法 12345678910111213141516171819202122func prepareNotification() &#123; // Make sure the restaurant array is not empty if restaurants.count &lt;= 0 &#123; return &#125; // 1 let randomNum = Int(arc4random_uniform(UInt32(restaurants.count))) let suggestedRestaurant = restaurants[randomNum] // 2 let content = UNMutableNotificationContent() content.title = &quot;Restaurant Recommendation&quot; content.subtitle = &quot;Try new food today&quot; content.body = &quot;I recommend you to check out \(suggestedRestaurant.name!).The restaurant is one of your favorites. It is located at \(suggestedRestaurant.location!). Would you like to give it a try?&quot; content.sound = UNNotificationSound.default() // 3 let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 10, repeats: false) let request = UNNotificationRequest(identifier: &quot;foodpin.restaurantSuggestion&quot;, content: content, trigger: trigger) // Schedule the notification UNUserNotificationCenter.current().add(request, withCompletionHandler: nil) &#125; 1 获得一个随机的restaurant 2 通过UNMutableNotificationContent获得一个通知，配置参数，sound表示需要通知声音。 3 UNTimeIntervalNotificationTrigger是一个时间触发，为了好测试，表示10s后通知一次。 在viewDidLoad中实现上面函数。prepareNotification() 现在运行，注意在应用内是不能接受本应用通知，所以运行后立即进入主屏或锁屏。通知本身有高度限制，内容过长会不显示，只要向下滑动就可以显示完整。 向通知中添加图片图片等富文本内容通过UNMutableNotificationContent的attachments属性添加，attachments属性是UNNotificationAttachment的数组。UNNotificationAttachment可以是图片、音频、音效、视频文件。 在prepareNotification中的触发之前添加代码： 123456789101112// 1let tempDirURL = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)let tempFileURL = tempDirURL.appendingPathComponent(&quot;suggested-restaurant.jpg&quot;)if let image = UIImage(data: suggestedRestaurant.image! as Data) &#123; // 2 try? UIImageJPEGRepresentation(image, 1.0)?.write(to: tempFileURL) if let restaurantImage = try? UNNotificationAttachment(identifier: &quot;restaurantImage&quot;, url: tempFileURL, options: nil) &#123; content.attachments = [restaurantImage] &#125;&#125; 1 由于使用Core Data，图片以NSData形式存储了，所以使用NSTemporaryDirectory来生成临时目录存储临时图片文件 2 UIImageJPEGRepresentation用来生成jpg图片文件 运行查看，同样向下滑动可查看完整。 和通知的交互之前只要点击通知进入应用的交互，这是默认的交互。 在prepareNotification中的触发之前添加代码： 123456789101112 // 1let categoryIdentifer = &quot;foodpin.restaurantaction&quot;// 3let makeReservationAction = UNNotificationAction(identifier: &quot;foodpin.makeReservation&quot;, title: &quot;Reserve a table&quot;, options: [.foreground])let cancelAction = UNNotificationAction(identifier: &quot;foodpin.cancel&quot;, title: &quot;Later&quot;, options: [])// 4let category = UNNotificationCategory(identifier: categoryIdentifer, actions:[makeReservationAction, cancelAction], intentIdentifiers: [], options: [])// 5UNUserNotificationCenter.current().setNotificationCategories([category])// 2 content.categoryIdentifier = categoryIdentifer 1,2 categoryIdentifier是让通知和category关联起来 3 UNNotificationAction有点类似UIAlertAction，options: [.foreground]表示让应用到前台，就是启动应用 4 UNNotificationCategory有点类似UIAlertController 5 把UNNotificationCategory注册到用户中心 处理Actions上面的options: [.foreground]只是启动了应用，没有实现具体操作。UNUserNotificationCenterDelegate中的userNotificationCenter(_:didReceive:withCompletionHandler:)方法在UNNotificationAction被选择时调用，在这个方法内部可实现具体操作。 让AppDelegate符合协议UNUserNotificationCenterDelegate 实现userNotificationCenter(_:didReceive:withCompletionHandler:) 123456789101112131415161718func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) &#123; // 1 if response.actionIdentifier == &quot;foodpin.makeReservation&quot; &#123; print(&quot;Make reservation...&quot;) // 2 if let phone = response.notification.request.content.userInfo[&quot;phone&quot;] &#123; let telURL = &quot;tel://\(phone)&quot; if let url = URL(string: telURL) &#123; if UIApplication.shared.canOpenURL(url) &#123; print(&quot;calling \(telURL)&quot;) // 3 UIApplication.shared.open(url) &#125; &#125; &#125; &#125; completionHandler()&#125; 1 对应之前创建UNNotificationAction时的identifier。 2 response.notification.request.content对应之前创建通知prepareNotification函数中的UNMutableNotificationContent，userInfo属性可用来存储通知想传递的数据。比如在prepareNotification函数中添加content.userInfo = [&quot;phone&quot;: suggestedRestaurant.phone!]，这边就可获得。 3 拨打电话。 在content.userInfo = [&quot;phone&quot;: suggestedRestaurant.phone!]中添加UNUserNotificationCenter.current().delegate = self。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 25 使用3D Touch]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-25.html</url>
    <content type="text"><![CDATA[接着上一篇 开始用Swift开发iOS 10 - 24 使用TestFlight进行Beta测试 ，这一篇学习使用3D Touch。 自从iPhone 6s和iPhone 6s Plus开始，Apple介绍了一种新的交互方式就是3D Touch。这新的特性需要硬件的支持，是iPhone屏幕不仅能感应到触摸，还能感应到压力。 现在3D Touch主要有三类交互方式： Quick Action ：点击应用图标后的快捷操作。👇是例子： Peek(preview) 和 Pop(commit)一般是一起的 ：主要应用于app中快速查看详细内容。自带的Photos app是很好的例子： 微信公众号也是不错的例子： Home Screen Quick Action Quick Action分两种： 静态的：在Info.plist中编写，固定不变的。 动态的：在代码中创建和更新。以自带的News app为例： 不同的频道是随着时间而变化的。 静态的Quick Action 静态的Quick Action只需要在Info.plist中配置UIApplicationShortcutItems数组就可以了，数组的每一项（字典）就是一个Action，每一个Action有6个类型的字段配置： UIApplicationShortcutItemType(必须) UIApplicationShortcutItemTitle(必须) UIApplicationShortcutItemSubtitle(可选) UIApplicationShortcutItemIconType(可选) UIApplicationShortcutItemIconFile(可选) UIApplicationShortcutItemUserInfo(可选)如果是下面配置： 结果就是： 动态的Quick Action动态的的Quick Action配置只要在AppDelegate.swift的application(:didFinishLaunchingWithOptions)中添加如下代码即可： 12let shortcutItem = UIApplicationShortcutItem(type: &quot;com.andyron.NewRestaurant&quot;, localizedTitle: &quot;New Restaurant&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(type: .add), userInfo: nil)UIApplication.shared.shortcutItems = [shortcutItem] 使用动态的Quick Action配置我的FoodPin应用由于我之前使用UIPageViewController创建了开始结束页面，如果在在AppDelegate.swift的application(:didFinishLaunchingWithOptions)中添加动态的Quick Action就会出现直接跳过介绍页面的情况，所以要在看完结束也之后再添加Quick Action。 下载图标，拖进Assets.xcassets 在WalkthroughContentViewController的nextButtonTapped方法的case 2: 里添加3个Action： 123456789101112// 1if traitCollection.forceTouchCapability == UIForceTouchCapability.available &#123; let bundleIdentifier = Bundle.main.bundleIdentifier // 2 let shortcutItem1 = UIApplicationShortcutItem(type: &quot;\(bundleIdentifier).OpenFavorites&quot;, localizedTitle: &quot;Show Favorites&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(templateImageName: &quot;favortie-shortcut&quot;), userInfo: nil) let shortcutItem2 = UIApplicationShortcutItem(type: &quot;\(bundleIdentifier).OpenDiscover&quot;, localizedTitle: &quot;Discover restaurants&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(templateImageName: &quot;discover-shortcut&quot;), userInfo: nil) let shortcutItem3 = UIApplicationShortcutItem(type: &quot;\(bundleIdentifier).NewRestaurant&quot;, localizedTitle: &quot;New Restaurant&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(type: .add), userInfo: nil) // 3 UIApplication.shared.shortcutItems = [shortcutItem1, shortcutItem2, shortcutItem3]&#125; 1 判断设备是否支持3D Touch 2 UIApplicationShortcutIcon可以使用系统的图标，也可以使用外部图标 3 shortcutItems数组顺序对应从靠近图标开始向上或向下显示 实现Quick Action的具体跳转动作UIApplicationDelegate协议中的application(_:performActionFor:completionHandler:)方法会在Quick Action被点击后调用。 在AppDelegate.swift文件中定义一个QuickAction枚举。列举出quick action相关动作。 123456789101112enum QuickAction: String &#123; case OpenFavorites = &quot;OpenFavorites&quot; case OpenDiscover = &quot;OpenDiscover&quot; case NewRestaurant = &quot;NewRestaurant&quot; init?(fullIdentifier: String) &#123; guard let shortcutIdentifier = fullIdentifier.components(separatedBy: &quot;.&quot;).last else &#123; return nil &#125; self.init(rawValue: shortcutIdentifier) &#125;&#125; 在AppDelegate中实现application(_:performActionFor:completionHandler:)方法： 12345678910111213141516171819202122232425262728func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123; completionHandler(handleQuickAction(shortcutItem: shortcutItem))&#125;private func handleQuickAction(shortcutItem: UIApplicationShortcutItem) -&gt; Bool &#123; let shortcutType = shortcutItem.type guard let shortcutIdentifier = QuickAction(fullIdentifier: shortcutType) else &#123; return false &#125; guard let tabBarController = window?.rootViewController as? UITabBarController else &#123; return false &#125; switch shortcutIdentifier &#123; case .OpenFavorites: tabBarController.selectedIndex = 0 case .OpenDiscover: tabBarController.selectedIndex = 1 case .NewRestaurant: if let navController = tabBarController.viewControllers?[0] &#123; let restaurantTableViewController = navController.childViewControllers[0] restaurantTableViewController.performSegue(withIdentifier: &quot;addRestaurant&quot;, sender: restaurantTableViewController) &#125; else &#123; return false &#125; &#125; return false&#125; Peek 和 Pop 在RestaurantTableViewController的viewDidLoad方法中添加如下代码。使用UIViewController中的registerForPreviewing方法注册使用peek和pop。 1234// 如果3D Touch可以用，就注册本控制器可以peek和popif traitCollection.forceTouchCapability == .available &#123; registerForPreviewing(with: self as! UIViewControllerPreviewingDelegate, sourceView: view)&#125; 让RestaurantTableViewController符合UIViewControllerPreviewingDelegate协议： class RestaurantTableViewController: UITableViewController, NSFetchedResultsControllerDelegate, UISearchResultsUpdating, UIViewControllerPreviewingDelegate { 实现UIViewControllerPreviewingDelegate协议的方法： 1234567891011121314151617181920212223242526272829// 当按压时调用（peek）func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? &#123; // 1 guard let indexPath = tableView.indexPathForRow(at: location) else &#123; return nil &#125; // 2 guard let cell = tableView.cellForRow(at: indexPath) else &#123; return nil &#125; // 3 guard let restaurantDetailViewController = storyboard?.instantiateViewController(withIdentifier: &quot;RestaurantDetailViewController&quot;) as? RestaurantDetailViewController else &#123; return nil &#125; let selectedRestaurant = restaurants[indexPath.row] restaurantDetailViewController.restaurant = selectedRestaurant // 4 restaurantDetailViewController.preferredContentSize = CGSize(width: 0.0, height: 450.0) previewingContext.sourceRect = cell.frame return restaurantDetailViewController&#125;// pop时调用func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewController) &#123; show(viewControllerToCommit, sender: self)&#125; 1 通过按压的位置获得indexPath 2 通过indexPath获得cell 3 通过控制器的Storyboard ID获得控制器，之前如果没有填写Storyboard ID，现在也可填写合适Storyboard ID。 4 给peek的预览页面一个高度限制，非必须。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 24 使用TestFlight进行Beta测试]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-24.html</url>
    <content type="text"><![CDATA[Beta测试是在产品发布之前所进行的软件测试活动，它是技术测试的最后一个阶段，通过了验收测试，产品就会进入发布阶段。 在iOS 8 时，Apple发布TestFlight用于Beta测试。之前TestFlight一直是独立用户mobile app测试的mobile平台，在2014年2月，Apple收购的TestFlight母公司Burstly。现在TestFlight已经集成到iTunes Connect中，允许开发只通过邮件地址邀请Beta测试用户。 在iTunes Connect中创建一个App Record iTunes Connect 是为iOS开发者提供在App Store管理销售他们apps的Web应用工具。 在上传app之前，必须要在 iTunes Connect中有App Record。 需要提供下列信息： Platform App name Primary language Bundle ID SKU 创建成果后会跳到下一个页面 App信息这一步主要选择一下App分类的类别。 价格与销售范围 准备提交这一步主要添加截图、app描述、app图标、联系信息等信息 预览图和截图提高至少一张5.5 英寸的截图(1242x2208 pixels) ，iTunes Connect会自动生成其他屏幕尺寸的图片。详细可参考iTunes Connect Developer Guide 或 iTunes Connect 开发人员帮助（中文） app描述填写一些相关描述，关键词（以逗号分隔），URL等 App 综合信息 这边的App Store 图标要求是1024x1024 pixels，不能包含隐藏元素。 App 审核信息 版本发布 更新Build string回到Xcode，确认版本数字与iTunes Connect中一致。 准备App Icon和启动页图片 利用类似图标工场这种移动应用图标生成工具，可生成一些大小的图标。 可以在Finder中直接复制AppIcon.appiconset目录替代即可。 在默人的启动开始页面LaunchScreen.storyboard中，添加一个图片。 打包和验证App在上传app到iTunes Connect之前，如要创建app包，这在Xcode 8之后已经非常容易了。 在主菜单中选择Product &gt; Scheme &gt; Edit Scheme：确认Build Configuration是Release： 在主菜单中选择Product &gt; Archive，可能需要等待一段时间。 打包成功后，在主菜单中打开Window &gt; Organizer，出现如下界面： 选择Validate…，然后选择自己的开发者账号： 点击Validate，之后可能需要一段时间： 上传应用到iTunes Connect 上面的验证成功后，点击Upload to App Store…，然后在点击Upload，这个过程可能也需要比较长的时间。 管理内部测试用户 内部用户也就是 iTunes Connect 用户，最多可添加25个。可在用户和职能中添加。 添加iTunes Connect 用户 添加内部测试用户后，内部测试用户会收到邮件，内面有验证码。 下载 TestFlight 应用然后在 Redeem中输入验证码，即可下载安装应用测试。 管理外部测试用户（Beta测试用户）以前是最大限制2000，现在可以邀请10000名外部测试人员。外部测试用户不需要事先添加。 填写完整测试信息 新建群组，比如就叫外部测试员： 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 22 使用CloudKit]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-22.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 21 使用WKWebView和SFSafariViewController 学习打开网页，这一篇学习使用CloudKit。 iCloud最初乔布斯在WWDC2011是发布的，只为了给Apps、游戏能够在云端数据保存，让Mac和iOS之间数据自动同步所用。 最近几年才渐渐成长为云服务。如果想创建社交类型的，可以分享用户之间数据的app，就可考虑使用iCloud，这样就不需要自己再去构建一个后端APIs了。虽然可能由于国内的网络环境，iCloud实际应用效果并不好，不过还是有必要学一下的🙂。 如果开发了Web应用，同样也可以访问iOS应用的iCloud中数据。Apple分别提供了CloudKit JS和CloudKit库。 CloudKit默认给我们的app提供一些免费的空间： 当app的用户的活跃数提高，免费空间也会随之提高，详细可查看官网介绍。 理解CloudKit框架CloudKit框架不仅提供了存储功能，还提供了开发者与iCloud之间的各种交互。Containers和database是CloudKit框架的基础元素。 默认，一个app就是一个container，代码中就是CKContainer，一个container中包括三个database(CKDatabase)： 一个public database： app中所有用户都能查看 一个shared database：app中一组用户能查看（iOS 10） 一个private database：app中单个用户查看 为应用添加CloudKit 首先需要开发者账号。 然后在Capabilities中打开iCloud。 在CloudKit Dashboard中管理 Record 点击上图中的CloudKit Dashboard，或者直接访问https://icloud.developer.apple.com/dashboard/。最新的CloudKit Dashboard的页面有了一些变化。首先进去的是应用列表（也就是container列表），点击一个就进入如下页面： 点击Development的data，类似下面 选择Record Types（有点像关系数据中的表），创建新的类型Restaurant，并添加几个Field的。 选择Records（类型表中的数据），添加几条数据，注意选择public database。 使用 Convenience API获取public DatabaseCloudKit提供两种APIs让开发与iCloud交互：the convenience API 和 the operational API。 Convenience API的通常调用方式： 12345678let cloudContainer = CKContainer.default()let publicDatabase = cloudContainer.publicCloudDatabaselet predicate = NSPredicate(value: true)let query = CKQuery(recordType: &quot;Restaurant&quot;, predicate: predicate)publicDatabase.perform(query, inZoneWith: nil, completionHandler: &#123; (results, error) -&gt; Void in// Process the records&#125;) CKContainer.default()获取应用的Container。 publicCloudDatabase表示默认的public database。 NSPredicate和CKQuery是搜索条件 新建DiscoverTableViewController，继承至UITableViewController，关联discover.storyboard中的table view的控制器； 并修改其prototype cell的identifier为Cell。 在DiscoverTableViewController.swift中加入import CloudKit，并定义一个CKRecord的数组变量： var restaurants:[CKRecord] = [] 添加获取Records的函数： 12345678910111213141516171819202122232425func fetchRecordsFromCloud() &#123; let cloudContainer = CKContainer.default() let publicDatabase = cloudContainer.publicCloudDatabase let predicate = NSPredicate(value: true) let query = CKQuery(recordType: &quot;Restaurant&quot;, predicate: predicate) publicDatabase.perform(query, inZoneWith: nil, completionHandler: &#123; (results, error) -&gt; Void in if error != nil &#123; print(error) return &#125; if let results = results &#123; print(&quot;Completed the download of Restaurant data&quot;) self.restaurants = results OperationQueue.main.addOperation &#123; self.spinner.stopAnimating() self.tableView.reloadData() &#125; &#125; &#125;)&#125; 在perform中，当确定获取到了数据后，赋值给restaurants，并刷新table。 在viewDidLoad中添加： fetchRecordsFromCloud()。 添加table view相关代理方法： 12345678910111213141516171819202122override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return restaurants.count&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for:indexPath) // Configure the cell... let restaurant = restaurants[indexPath.row] cell.textLabel?.text = restaurant.object(forKey: &quot;name&quot;) as? String if let image = restaurant.object(forKey: &quot;image&quot;) &#123; let imageAsset = image as! CKAsset if let imageData = try? Data.init(contentsOf: imageAsset.fileURL) &#123; cell.imageView?.image = UIImage(data: imageData) &#125; &#125; return cell&#125; object(forKey:)是CKRecord中获取Record Field值的方法。 图片对象转换为CKAsset。 为什么慢？测试以上代码，发现fetchRecordsFromCloud函数中的打印信息”Completed the download of Restaurant data”已经显示在控制台了，但是还需要过一段时间App中才能显示，也就是说向iCloud中获取完数据后才开始准备table view加载。 这边就需要使用到多线程的概念。在iOS中，UI更新（像table重新加载）必须在主线程执行。这样获取iCloud数据的线程在进行时，UI更新也在同步进行。 123OperationQueue.main.addOperation &#123; self.tableView.reloadData()&#125; 使用operational API获取public Database Convenience API只适合简单和少量的查询。 更新fetchRecordsFromCloud方法： 123456789101112131415161718192021222324252627func fetchRecordsFromCloud() &#123; let cloudContainer = CKContainer.default() let publicDatabase = cloudContainer.publicCloudDatabase let predicate = NSPredicate(value: true) let query = CKQuery(recordType: &quot;Restaurant&quot;, predicate: predicate) // Create the query operation with the query let queryOperation = CKQueryOperation(query: query) queryOperation.desiredKeys = [&quot;name&quot;, &quot;image&quot;] queryOperation.queuePriority = .veryHigh queryOperation.resultsLimit = 50 queryOperation.recordFetchedBlock = &#123; (record) -&gt; Void in self.restaurants.append(record) &#125; queryOperation.queryCompletionBlock = &#123; (cursor, error) -&gt; Void in if let error = error &#123; print(&quot;Failed to get data from iCloud - \(error.localizedDescription)&quot;) return &#125; print(&quot;Successfully retrieve the data from iCloud&quot;) OperationQueue.main.addOperation &#123; self.tableView.reloadData() &#125; &#125; // Execute the query publicDatabase.add(queryOperation)&#125; 通过CKQueryOperation代替perform方法,它提供了许多查询选项。 desiredKeys代表需要查询的字段。 resultsLimit代表依次查询最大Record数目 加载指示（菊花转） 可以在viewDidLoad中添加类型如下代码： 123456let spinner:UIActivityIndicatorView = UIActivityIndicatorView()spinner.activityIndicatorViewStyle = .grayspinner.center = view.centerspinner.hidesWhenStopped = trueview.addSubview(spinner)spinner.startAnimating() 也可以通过在discover.storyboard中添加： 添加完发现 activity indicator view在控制器上面，这在Xcode中叫The Extra Views 在DiscoverTableViewController中添加接口，并关联。 @IBOutlet var spinner: UIActivityIndicatorView! 在viewDidLoad中添加代码： 1234spinner.hidesWhenStopped = truespinner.center = view.centertableView.addSubview(spinner)spinner.startAnimating() 数据加载完要隐藏加载提示：1234OperationQueue.main.addOperation &#123; self.spinner.stopAnimating() self.tableView.reloadData() &#125; 懒加载图片懒加载图片就是先加载一个本地默认图片，暂时不加载远程图片，当图片准备好在去更新图片视图。 修改请求字段desireKeys，让开始时不加图片: queryOperation.desiredKeys = [&quot;name&quot;] 更新 tableView(_:cellForRowAt:)： 1234567891011121314151617181920212223242526272829303132333435override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) let restaurant = restaurants[indexPath.row] cell.textLabel?.text = restaurant.object(forKey: &quot;name&quot;) as? String // Set the default image cell.imageView?.image = UIImage(named: &quot;photoalbum&quot;) // Fetch Image from Cloud in background let publicDatabase = CKContainer.default().publicCloudDatabase let fetchRecordsImageOperation = CKFetchRecordsOperation(recordIDs:[restaurant.recordID]) fetchRecordsImageOperation.desiredKeys = [&quot;image&quot;] fetchRecordsImageOperation.queuePriority = .veryHigh fetchRecordsImageOperation.perRecordCompletionBlock = &#123; (record, recordID, error) -&gt; Void in if let error = error &#123; print(&quot;Failed to get restaurant image: \(error.localizedDescription)&quot;) return &#125; if let restaurantRecord = record &#123; OperationQueue.main.addOperation() &#123; if let image = restaurantRecord.object(forKey: &quot;image&quot;) &#123; let imageAsset = image as! CKAsset print(imageAsset.fileURL) if let imageData = try? Data.init(contentsOf: imageAsset.fileURL) &#123; cell.imageView?.image = UIImage(data: imageData) &#125; &#125; &#125; &#125; &#125; publicDatabase.add(fetchRecordsImageOperation) return cell&#125; CKFetchRecordsOperation通过recordID获得特定的Record。 CKFetchRecordsOperation一些方法类似CKQueryOperation。 懒加载后发现，图片在其它视图显示后慢慢先后加载显示。 下拉刷新UIRefreshControl提供了标准的下拉刷新特性。 在DiscoverTableViewController的viewDidLoad中添加：12345// Pull To Refresh ControlrefreshControl = UIRefreshControl()refreshControl?.backgroundColor = UIColor.whiterefreshControl?.tintColor = UIColor.grayrefreshControl?.addTarget(self, action: #selector(fetchRecordsFromCloud), for: UIControlEvents.valueChanged) 每一次下拉是显示菊花转，并且调用fetchRecordsFromCloud方法。 在fetchRecordsFromCloud方法的queryCompletionBlock添加数据加载完成后去除菊花转代码： 12345if let refreshControl = self.refreshControl &#123; if refreshControl.isRefreshing &#123; refreshControl.endRefreshing() &#125;&#125; 刷新会出现重复数据，要在fetchRecordsFromCloud方法开始时，清理数据： 12restaurants.removeAll()tableView.reloadData() 使用CloudKit保存数据到iCloudCKDatabase的save(_:completionHandler:)的方法可用来保存数据到iCloud。实现用户新加数据时，既保存在本地的Core Data，有保存在iCloud中。 在AddRestaurantController中添加：import CloudKit。 在AddRestaurantController添加方法： 12345678910111213141516171819202122232425262728// 保存到Core Data的同时也保存的iCloud中func saveRecordToCloud(restaurant:RestaurantMO!) -&gt; Void &#123; // Prepare the record to save let record = CKRecord(recordType: &quot;Restaurant&quot;) record.setValue(restaurant.name, forKey: &quot;name&quot;) record.setValue(restaurant.type, forKey: &quot;type&quot;) record.setValue(restaurant.location, forKey: &quot;location&quot;) record.setValue(restaurant.phone, forKey: &quot;phone&quot;) let imageData = restaurant.image as! Data // Resize the image let originalImage = UIImage(data: imageData)! let scalingFactor = (originalImage.size.width &gt; 1024) ? 1024 / originalImage.size.width : 1.0 let scaledImage = UIImage(data: imageData, scale: scalingFactor)! // Write the image to local file for temporary use let imageFilePath = NSTemporaryDirectory() + restaurant.name! let imageFileURL = URL(fileURLWithPath: imageFilePath) try? UIImageJPEGRepresentation(scaledImage, 0.8)?.write(to: imageFileURL) // Create image asset for upload let imageAsset = CKAsset(fileURL: imageFileURL) record.setValue(imageAsset, forKey: &quot;image&quot;) // Get the Public iCloud Database let publicDatabase = CKContainer.default().publicCloudDatabase // Save the record to iCloud publicDatabase.save(record, completionHandler: &#123; (record, error) -&gt; Void in try? FileManager.default.removeItem(at: imageFileURL) &#125;)&#125; 在save方法的dismiss(animated:completion:)的前面添加： saveRecordToCloud(restaurant: restaurant) 排序CKQuery有属性sortDescriptors可用来排序。在DiscoverTableViewController的fetchRecordsFromCloud方法，query定义后添加： query.sortDescriptors = [NSSortDescriptor(key: &quot;creationDate&quot;, ascending: false)] creationDate是默认的创建时间字段。 Exercise：修改Discover样式 新建一个DiscoverTableViewCell，继承至UITableViewCell，并关联Discover的cell。 修改cell合适的样式，比如下面 在DiscoverTableViewCell中新建四个接口，并关联。 1234@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!@IBOutlet var thumbnailImageView: UIImageView! 更新tableView(_:cellForRowAt:)和fetchRecordsFromCloud相关代码 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 21 使用WKWebView和SFSafariViewController]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-21.html</url>
    <content type="text"><![CDATA[上一篇开始用Swift开发iOS 10 - 20 使用Tab Bar Controller 和 拆分Storyboard学习了工具栏和Storyboard的拆分，这一篇学习怎么在app中显示网页内容。由于原书中使用了的网站在国内不好访问，我就用了我的简书、博客、Github代替🙂。 设计about view 下载图片拖进Assets.xcasset。 打开about.storyboard，拖进一个Image View到table view header，height为190，image为about-logo，content mode为Aspect fit。选择table view cell，identifier为Cell，style为Basic。 新建AboutTableViewController继承至UITableViewController，关联about中的table view controller。 在AboutTableViewController，添加：123var sectionTitles = [&quot;Leave Feedback&quot;, &quot;Follow Us&quot;]var sectionContent = [[&quot;Rate us on App Store&quot;, &quot;Tell us your feedback&quot;], [&quot;Jianshu&quot;, &quot;Blog&quot;, &quot;Github&quot;]]var links = [&quot;http://www.jianshu.com/u/efce1a2a95ab&quot;, &quot;http://andyron.com&quot;, &quot;https://github.com/andyRon&quot;] table view的相关代理协议方法实现，这次使用俩个section，tableView(_:titleForHeaderInSection:)是获取section的title方法。1234567891011121314151617181920override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return sectionTitles.count&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // #warning Incomplete implementation, return the number of rows return sectionContent[section].count&#125;override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123; return sectionTitles[section]&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) cell.textLabel?.text = sectionContent[indexPath.section][indexPath.row] return cell&#125; 移除Tableview下面分割线，在viewDidLoad中添加： tableView.tableFooterView = UIView(frame: CGRect.zero) 用Mobile Safari打开Web可直接给出网址，通过Mobile Safari打开网站，UIApplication.shared.open(_:options:completionHandler:)。 123456789101112131415override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; switch indexPath.section &#123; case 0: if indexPath.row == 0 &#123; if let url = URL(string: &quot;http://www.apple.com/itunes/charts/paid-apps/&quot;) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125; &#125; default: break &#125; // 取消被选中状态 tableView.deselectRow(at: indexPath, animated: false)&#125; 使用WKWebView载入Web使用使用WKWebView载入Web的例子1234if let url = URL(string: &quot;http://andyron.com&quot;) &#123; let request = URLRequest(url: url) webView.load(request)&#125; 直接载入本地html文件的例子：123let url = URL(fileURLWithPath: &quot;about.html&quot;)let request = URLRequest(url: url)webView.load(request) 在about.storyboard中拖进一个新的View Controller，用来展示Web内容。使用ctrl-drag建立Show类型的segue，identifier为 showWebView。 新建WebViewController继承至UIViewController，关联上面的用来显示Web内容的View Controller。 在WebViewController.swift中添加import WebKit，变量var webView: WKWebView!。 更新 viewDidLoad： 123456789override func viewDidLoad() &#123; super.viewDidLoad() if let url = URL(string: &quot;http://andyron.com&quot;) &#123; let request = URLRequest(url: url) webView.load(request) &#125;&#125; 添加loadView，这个方法会在viewDidLoad之前调用创建WKWebView。 1234override func loadView() &#123; webView = WKWebView() view = webView&#125; 更新AboutTableViewController中的tableView(_didSelectRowAtIndexPath:)： 123456789101112131415161718override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; switch indexPath.section &#123; case 0: if indexPath.row == 0 &#123; if let url = URL(string: &quot;http://www.apple.com/itunes/charts/paid-apps/&quot;) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125; &#125; else if indexPath.row == 1 &#123; performSegue(withIdentifier: &quot;showWebView&quot;, sender: self) &#125; default: break &#125; // 取消被选中状态 tableView.deselectRow(at: indexPath, animated: false)&#125; 由于自从iOS 9之后，出于安全考虑，默认只能访问HTTPS的网站，如果需要访问HTTP的网站，就需要在plist文件中添加许可： 使用SFSafariViewController载入Web在AboutTableViewController.swift中加入import SafariServices，然后更新tableView(_didSelectRowAtIndexPath:)，只用通过url创建一个SFSafariViewController对象，然后使用present方法展示就可以了。1234567891011121314151617181920212223override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; switch indexPath.section &#123; case 0: if indexPath.row == 0 &#123; if let url = URL(string: &quot;http://www.apple.com/itunes/charts/paid-apps/&quot;) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125; &#125; else if indexPath.row == 1 &#123; performSegue(withIdentifier: &quot;showWebView&quot;, sender: self) &#125; case 1: if let url = URL(string: links[indexPath.row]) &#123; let safariController = SFSafariViewController(url: url) present(safariController, animated: true, completion: nil) &#125; default: break &#125; // 取消被选中状态 tableView.deselectRow(at: indexPath, animated: false)&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 20 使用Tab Bar Controller 和 拆分Storyboard]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-20.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 19 使用UIPageViewController构建介绍页面构建了开始介绍页面，这一篇学习使用Tab Bar Controller和拆分Storyboard。 创建 Tab Bar Controller 选择开始的Navigation Controller，Editor &gt; Embed in &gt; Tab Bar Controller，然后自动添加一个新的Tab Bar Controller 作为初始的控制器，之前Navigation Controller变成Tab Bar Controller的一部分了。 在Navigation Controller中选择 tab item，修改System Item为Favorites。 隐藏 Tab Bar工具栏在其他页面隐藏，选择Detail View，勾选Hide Bottom Bar on Push就可以。 也可以用代码形式，在RestaurantTableViewController中的prepare(for:)中添加： destinationController.hidesBottomBarWhenPushed = true 添加新的Tabs 添加一个新的Navigation Controller， 选中tab item，修改System Item为Recents；table view的navigation item的title为Discover 把新加的Navigation Controller加入到 Tab Bar Controller。用ctrl+drag从Tab Bar Controller到新的Navigation Controller，选择Relationship Segue - View Controllers。 改变新的Navigation Controller的tab bar的title为Recent，修改system item为Recents 同样的方式添加一个新的Navigation Controller， 选中tab item，修改System Item为More；table view的navigation item的title为About。也用ctrl+drag与Tab Bar Controller建立关系。 最终创建有三个Tab Bar Item的Tab Bar。 定制Tab Bar的样式修改Tab Bar的样式在application(_:didFinishLaunchingWithOptions:)中进行，类似下面的代码，详细的API可参考官方文档：123UITabBar.appearance().tintColor = UIColor(red: 235.0/255.0, green: 75.0/255.0,blue: 27.0/255.0, alpha: 1.0)UITabBar.appearance().barTintColor = UIColor.black 改变 Tab Bar Item的图片 从图片下载图片到Assets.xcasset。 在SB中修改三个Tab Bar Item的System Item都为Custom，修改Title和Image为想要的值，类似下图 在application(_:didFinishLaunchingWithOptions:)中修改样式：12UITabBar.appearance().tintColor = UIColor(red: 235.0/255.0, green: 75.0/255.0, blue: 27.0/255.0, alpha: 1.0)UITabBar.appearance().barTintColor = UIColor(red: 236/255.0, green: 240.0/255.0, blue: 241.0/255.0, alpha: 1.0) 改变选择指示图片（Selection Indicator Image）Selection Indicator Image就是指tab bar item被选中后与其它tab bar item不同的样式,在代码中和SB中都可以修改。 UITabBar.appearance().selectionIndicatorImage = UIImage(named: &quot;tabitem-selected&quot;) 最终效果： 拆分Storyboard当项目变大时，一个Storyboard就会很大，如果是项目中有很多人合作的话，一个Storyboard也很难管理。从Xcode7之后，新功能storyboard references解决了这个问题。 在Main.storyboard中选择，about相关的两个view controller，然后Editor &gt; Refactor to Storyboard…，新建名为about.storyboard的storyboard文件，就把这个两个独立出去了。 把about相关的view controller拆分出去后，在Main.storyboard里有一个关联图标，双击就可以跳转到about.storyboard中。 同样的方法，独立出discover相关view controller，生成discover.storyboard文件。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-tutorial-7：解析XML(swift)]]></title>
    <url>%2F2017%2Fios-tutorial-7-xml.html</url>
    <content type="text"><![CDATA[使用XMLParser解析XML文件，然后用table展示数据。 以Single View Application模板新建项目XMLParserTutorial。 删除SB中的View Controller，拖进一个Navigation Controller。选择新的View Controller为 “Is Initial View Controller”。设置Navigation Bar的title为Books。 新建一个继承至UITableViewController，名为TableViewController的控制器文件，并与SB的控制器关联。 新建一个xml文件Books.xml，用于之后解析，文件内容为: 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot;?&gt;&lt;catalog&gt; &lt;book id=&quot;1&quot;&gt; &lt;title&gt;To Kill a Mockingbird&lt;/title&gt; &lt;author&gt;Harper Lee&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;2&quot;&gt; &lt;title&gt;1984&lt;/title&gt; &lt;author&gt;George Orwell&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;3&quot;&gt; &lt;title&gt;The Lord of the Rings&lt;/title&gt; &lt;author&gt;J.R.R Tolkien&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;4&quot;&gt; &lt;title&gt;The Catcher in the Rye&lt;/title&gt; &lt;author&gt;J.D. Salinger&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;5&quot;&gt; &lt;title&gt;The Great Gatsby&lt;/title&gt; &lt;author&gt;F. Scott Fitzgerald&lt;/author&gt; &lt;/book&gt;&lt;/catalog&gt; 新建一个文件 Book.swift： 123456import Foundationclass Book &#123; var bookTitle: String = &quot;&quot; var bookAuthor: String = &quot;&quot;&#125; 在TableViewController中添加几个变量： 1234var books: [Book] = []var eName: String = &quot;&quot;var bookTitle = &quot;&quot;var bookAuthor = &quot;&quot; 在viewDidLoad方法中，添加读取XMl文件代码： 123456789override func viewDidLoad() &#123; super.viewDidLoad() if let path = Bundle.main.url(forResource: &quot;Books&quot;, withExtension: &quot;xml&quot;) &#123; if let parser = XMLParser(contentsOf: path) &#123; parser.delegate = self parser.parse() &#125; &#125; 添加Table View的数据源代理方法： 1234567891011121314151617override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return books.count&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) let book = books[indexPath.row] cell.textLabel?.text = book.bookTitle cell.detailTextLabel?.text = book.bookAuthor return cell&#125; 让TableViewController采纳XMLParserDelegate协议： class TableViewController: UITableViewController, XMLParserDelegate 实现XMLParserDelegate中的三个方法： 12345678910111213141516171819202122232425262728293031323334// 解析XMl元素开始时func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String] = [:]) &#123; print(&quot;开始 \(elementName)&quot;) eName = elementName if elementName == &quot;book&quot; &#123; bookTitle = &quot;&quot; bookAuthor = &quot;&quot; &#125;&#125;// 正在解析XMl元素func parser(_ parser: XMLParser, foundCharacters string: String) &#123; print(&quot;ing \(eName)&quot;) let data = string.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines) if (!data.isEmpty) &#123; if eName == &quot;title&quot; &#123; bookTitle += data &#125; else if eName == &quot;author&quot; &#123; bookAuthor += data &#125; &#125;&#125;// 结束解析XMl元素func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) &#123; print(&quot;结束 \(elementName)&quot;) if elementName == &quot;book&quot; &#123; let book = Book() book.bookTitle = bookTitle book.bookAuthor = bookAuthor books.append(book) &#125;&#125; 三个方法分别在XMl元素开始解析、正在解析、结束解析时调用，也就是说有很多元素时就不停在调用这三个方法。 代码XMLParserTutorial 参考：Parsing XML Tutorial]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 19 使用UIPageViewController构建介绍页面]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-19.html</url>
    <content type="text"><![CDATA[继续上一篇 开始用Swift开发iOS 10 - 18 Search Bar 和 UISearchController ，这一篇使用UIPageViewController构建介绍页面，与使用LaunchScreen.storyboard的启动页不同。 向Storyboard中添加UIPageViewController 在Storyboard拖进一个UIPageViewController。修改相关属性。 修改UIPageViewController的 storyboard ID 为 WalkthroughController。 类似UINavigationController，UIPageViewController也是一种容器类型的控制器。这种容器类型的控制器是用来管理其它多个控制器的。 如果容器内的控制器页面元素类似（上图就是这种情况），可以通过一个控制器重复利用。 设计介绍页 下载介绍页所需的图片，拖到Assets.xcasset。 拖动一个新的View Controller到SB中（作为重复使用的控制器），做一些UI设计： 设置背景为红色 添加一个Label名为Personalize，选择合适的字体和大小，居中。 添加一个Image View，300*232，居中。 添加另一个Label名为Pin your favorite restaurants and create your own food guide，282*64，行数为0，居中，选择合适的字体和大小。 添加一些约束 设置新的View Controller的 storyboard ID 为 WalkthroughContentViewController。最后大概如下： 创建WalkthroughContentViewController 创建WalkthroughContentViewController类文件，继承至UIViewController，并关联上面添加的新View Controller。 添加三个接口，关联两个Label和一个image view；添加四个变量，其中index是指多个介绍页的索引。 12345678@IBOutlet var headingLabel: UILabel!@IBOutlet var contentLabel: UILabel!@IBOutlet var contentImageView: UIImageView!var index = 0var heading = &quot;&quot;var imageFile = &quot;&quot;var content = &quot;&quot; 修改viewDidLoad为： 1234567override func viewDidLoad() &#123; super.viewDidLoad() headingLabel.text = heading contentLabel.text = content contentImageView.image = UIImage(named: imageFile)&#125; 实现 UIPageViewController 新建类WalkthroughPageViewController，继承至UIPageViewController。 让WalkthroughPageViewControlle符合UIPageViewControllerDataSource协议。 class WalkthroughPageViewController: UIPageViewController, UIPageViewControllerDataSource 新建几个变量，用于显示介绍页中的内容。 123var pageHeadings = [&quot;Personalize&quot;, &quot;Locate&quot;, &quot;Discover&quot;]var pageImages = [&quot;foodpin-intro-1&quot;, &quot;foodpin-intro-2&quot;, &quot;foodpin-intro-3&quot;]var pageContent = [&quot;Pin your favorite restaurants and create your own foodguide&quot;, &quot;Search and locate your favourite restaurant on Maps&quot;, &quot;Find restaurants pinned by your friends and other foodies around the world&quot;] 实现UIPageViewControllerDataSource协议的两个方法，分别在介绍页翻到下一个和翻到上一个时调用。contentViewController函数的作用是根据介绍页的索引获取不同的数据。instantiateViewController方法根据storyboard的中storyboard ID生成视图控制器。 1234567891011121314151617181920212223242526272829303132func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -&gt; UIViewController? &#123; var index = (viewController as! WalkthroughContentViewController).index index -= 1 return contentViewController(at: index)&#125;func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -&gt; UIViewController? &#123; var index = (viewController as! WalkthroughContentViewController).index index += 1 return contentViewController(at: index)&#125;func contentViewController(at index: Int) -&gt; WalkthroughContentViewController? &#123; if index &lt; 0 || index &gt;= pageHeadings.count &#123; return nil &#125; if let pageContentViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughContentViewController&quot;) as? WalkthroughContentViewController &#123; pageContentViewController.imageFile = pageImages[index] pageContentViewController.heading = pageHeadings[index] pageContentViewController.content = pageContent[index] pageContentViewController.index = index return pageContentViewController &#125; return nil&#125; 修改viewDidLoad： 12345678override func viewDidLoad() &#123; super.viewDidLoad() dataSource = self if let startingViewController = contentViewController(at: 0) &#123; setViewControllers([startingViewController], direction: .forward, animated: true, completion: nil) &#125;&#125; setViewControllers方法是设置UIPageViewController管理的视图控制器。 让介绍页在首页显示后跳出。 在RestaurantTableViewControlle中添加：123456override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) if let pageViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughController&quot;) as? WalkthroughPageViewController &#123; present(pageViewController, animated: true, completion: nil) &#125;&#125; 添加默认页面指示页面指示就是一般在页面下用于分辨当前是第一个页面的几个小点。实现UIPageViewControllerDataSource协议的两个方法：presentationCount(for:)表示总共有几个小点（页面）。presentationIndex(for:)表示当前页面的索引。12345678910func presentationCount(for pageViewController: UIPageViewController) -&gt; Int &#123; return pageHeadings.count&#125;func presentationIndex(for pageViewController: UIPageViewController) -&gt; Int &#123; if let pageContentViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughContentViewController&quot;) as? WalkthroughContentViewController &#123; return pageContentViewController.index &#125; return 0&#125; 修改页面指示的样式不用默认的页面指示，就要把上面两个方法删除，然后使用UIPageControl。 删除上面实现的两个方法。从对象库中拖一个Page Control到walkthrough content view controller底部，在属性检查器中修改适当属性，并添加约束。 在WalkthroughContentViewController中添加接口@IBOutlet var pageControl: UIPageControl!并与Page Control关联。在viewDidLoad中添加pageControl.currentPage = index 添加NEXT/DONE按钮 在walkthrough content view controller右下角添加一个按钮名为NEXT。 在WalkthroughContentViewController中添加接口，并按钮关联。 @IBOutlet var forwardButton: UIButton! 在viewDidLoad中添加根据索引判断按钮名的代码： 12345switch index &#123;case 0...1: forwardButton.setTitle(&quot;NEXT&quot;, for: .normal)case 2: forwardButton.setTitle(&quot;DONE&quot;, for: .normal)default: break&#125; 添加点击按钮的action，并与按钮关联 12345678910@IBAction func nextButtonTapped(sender: UIButton) &#123; switch index &#123; case 0...1: let pageViewController = parent as! WalkthroughPageViewController pageViewController.forward(index: index) case 2: dismiss(animated: true, completion: nil) default: break &#125;&#125; 在WalkthroughPageViewController中添加方法： 12345func forward(index: Int) &#123; if let nextViewController = contentViewController(at: index + 1) &#123; setViewControllers([nextViewController], direction: .forward, animated: true, completion: nil) &#125;&#125; 完成类似下面： 但因为之前是利用RestaurantTableViewController的viewDidAppear方法显示介绍页的，而viewDidAppear方法是页面显示后就调用一下，这样就出现不停进入介绍页。实际上只需要第一次打开app的时显示介绍页就可以了。 UserDefaults的使用UserDefaults是用来管理应用和用户相关的设置的。也就是可以用UserDefaults存储一些用户相关的少量数据，比如上面的是否看过介绍页，也就是是否点击过DONE按钮了。UserDefaults也是通过单例模式进行操作的，通过类属性standard获取单例。 nextButtonTapped中点击DONE按钮时设置一个值标志： 1234567891011@IBAction func nextButtonTapped(sender: UIButton) &#123; switch index &#123; case 0...1: let pageViewController = parent as! WalkthroughPageViewController pageViewController.forward(index: index) case 2: UserDefaults.standard.set(true, forKey: &quot;hasViewedWalkthrough&quot;) dismiss(animated: true, completion: nil) default: break &#125;&#125; 再到RestaurantTableViewController的viewDidAppear判断对应key值。 123456789override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) if UserDefaults.standard.bool(forKey: &quot;hasViewedWalkthrough&quot;) &#123; return &#125; if let pageViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughController&quot;) as? WalkthroughPageViewController &#123; present(pageViewController, animated: true, completion: nil) &#125;&#125; 完成介绍页。学习了UIPageViewController和UserDefaults。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 18 Search Bar 和 UISearchController]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-18.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 17 使用Core Data 是使用Core Data存储数据，这一篇是添加搜索功能。 使用 UISearchControllerUISearchController是一个简洁的创建搜索条和管理搜索结果的API。通常情况下，为以table为基础的app添加搜索条只需要下面三行代码就可以了，searchResultsController为nil时搜索结果显示就在当前搜索的页面以当前的样式显示。123searchController = UISearchController(searchResultsController: nil)searchController.searchResultsUpdater = selftableView.tableHeaderView = searchController.searchBar 为我的FoodPin应用添加搜索条: 在RestaurantTableViewController中添加一个变量： var searchController: UISearchController! 在viewDidLoad中初始化： searchController = UISearchController(searchResultsController: nil) tableView.tableHeaderView = searchController.searchBar 这样就添加了搜索条，但还每天添加搜索逻辑，搜索没效。 筛选内容 在RestaurantTableViewController中继续添加一个变量，用户存储筛选结果： var searchResults: [RestaurantMO] = [] 添加筛选方法： 1234567891011func filterContent(for searchText: String) &#123; searchResults = restaurants.filter(&#123; (restaurant) -&gt; Bool in if let name = restaurant.name &#123; let isMatch = name.localizedCaseInsensitiveContains(searchText) return isMatch &#125; return false &#125;)&#125; filter是数组的一个方法，它遍历数组的每一项进行闭包中的操作，根据结果判断是否删除对应项，最后得到一个筛选的数组。localizedCaseInsensitiveContains方法用来判断name中是否包含searchText（忽略大小写） 更新搜索结果 让RestaurantTableViewController “符合” UISearchResultsUpdating协议： class RestaurantTableViewController: UITableViewController, NSFetchedResultsControllerDelegate, UISearchResultsUpdating 实现UISearchResultsUpdating协议：中的updateSearchResults(for:)方法，这个方法在搜索条被选则和输入搜索字时调用： 123456func updateSearchResults(for searchController: UISearchController) &#123; if let searchText = searchController.searchBar.text &#123; filterContent(for: searchText) tableView.reloadData() &#125;&#125; 更新tableView(_:numberOfRowsInSection:)。UISearchController有一个isActive属性用来判断搜索控制器当前活跃状态。 1234567override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; if searchController.isActive &#123; return searchResults.count &#125; else &#123; return restaurants.count &#125;&#125; 更新tableView(_:cellForRowAt:)。根据UISearchController的状态判断是从restaurants中获取数据还是searchResults。 1234567891011121314151617override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell let restaurant = (searchController.isActive) ? searchResults[indexPath.row] : restaurants[indexPath.row] cell.nameLabel.text = restaurant.name cell.thumbnailImageView.image = UIImage(data: restaurant.image! as Data) cell.thumbnailImageView.layer.cornerRadius = 30.0 cell.thumbnailImageView.clipsToBounds = true cell.locationLabel.text = restaurant.location cell.typeLabel.text = restaurant.type cell.accessoryType = restaurant.isVisited ? .checkmark: .none return cell&#125; 实现一个新的方法，让table在搜索状态下不可以滑动编辑。 1234567override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool &#123; if searchController.isActive &#123; return false &#125; else &#123; return true &#125;&#125; 更新prepare(for:)，让segue在传输数据到detail view时的数据也相对应。 destinationController.restaurant = searchController.isActive ? searchResults[indexPath.row] : restaurants[indexPath.row 在viewDidLoad中添加两行代码： 12searchController.searchResultsUpdater = selfsearchController.dimsBackgroundDuringPresentation = false 现在就完成了搜索功能。 定制搜索条的样式UISearchBar提供一些属性用来定制。在viewDidLoad中添加：1234searchController.searchBar.placeholder = &quot;Search restaurants...&quot;searchController.searchBar.tintColor = UIColor.whitesearchController.searchBar.barTintColor = UIColor(red: 218.0/255.0, green:100.0/255.0, blue: 70.0/255.0, alpha: 1.0) Exercise：添加地址搜索只需要更改搜索函数filterContent：12345678910111213searchResults = restaurants.filter(&#123; (restaurant) -&gt; Bool in if let name = restaurant.name, let location = restaurant.location &#123; let isMatchName = name.localizedCaseInsensitiveContains(searchText) let isMatchLocation = location.localizedCaseInsensitiveContains(searchText) if isMatchName || isMatchLocation &#123; return true &#125; &#125; return false &#125;) 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 17 使用Core Data]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-17.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 16 介绍静态Table Views，UIImagePickerController和NSLayoutConstraint 中添加新建restaurant页面，但最后数据并没有保存下来，这一篇使用Core Data方式来持久化保存数据。 数据持久化一般是指数据库保存。在Web开发中，常用Oracle或MySQL等关系数据库来保存数据，通过SQL语句查询。在iOS中对应的数据库是SQLite。Core Data不是数据库，它是让开发者通过面向对象方式与数据库进行交互的库。 使用Core Data的例子新建一个使用Core Data的项目，在AppDelegate类中会比平常多了一个变量和一方法，另外还多了一个文件CoreDataDemo.xcdatamodeld。 123456789101112131415161718192021222324252627282930313233343536373839404142lazy var persistentContainer: NSPersistentContainer = &#123; /* The persistent container for the application. This implementation creates and returns a container, having loaded the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail. */ let container = NSPersistentContainer(name: &quot;CoreDataDemo&quot;) container.loadPersistentStores(completionHandler: &#123; (storeDescription, error) in if let error = error as NSError? &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. /* Typical reasons for an error here include: * The parent directory does not exist, cannot be created, or disallows writing. * The persistent store is not accessible, due to permissions or data protection when the device is locked. * The device is out of space. * The store could not be migrated to the current model version. Check the error message to determine what the actual problem was. */ fatalError(&quot;Unresolved error \(error), \(error.userInfo)&quot;) &#125; &#125;) return container&#125;()// MARK: - Core Data Saving supportfunc saveContext () &#123; let context = persistentContainer.viewContext if context.hasChanges &#123; do &#123; try context.save() &#125; catch &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nserror = error as NSError fatalError(&quot;Unresolved error \(nserror), \(nserror.userInfo)&quot;) &#125; &#125;&#125; 变量persistentContainer是NSPersistentContainer的实例，let container = NSPersistentContainer(name: &quot;CoreDataDemo&quot;)对应CoreDataDemo.xcdatamodeld文件，如果是自己添加时名字需要对应。 当数据变化(insert/update/delete)时 ，调用saveContext方法保存数据。 向项目中添加Data Model 右击FoodPin文件夹，选择新建Data Model文件，文件名为FoodPin。 选中新生成的FoodPin.xcdatamodeld，添加一个Restaurant Entity，然后再在此Entity下添加一些属性。 选中特定属性后可在右侧检查器中设置相关特性，比如是否强制需要。 创建Managed ObjectsCore Data框架中的 Managed Objects与Entity之间的关系，有点像代码中 接口变量 和 UI objects之间的关系。xcode可自动生成Managed Objects。 选中Restaurant Entity，在检查器中修改class的name为RestaurantMO，Codegen 为 Class Definition。 command-R 或 comman-B一下，表面上没有什么变化，在project navigator中没有多出文件。实际上已经生成RestaurantMO类，代码已经可以使用了，如果使用command+点击 RestaurantMO，就可以看到RestaurantMO的代码： 修改相关受影响的代码 RestaurantTableViewController.swift重新定义restaurants: var restaurants:[RestaurantMO] = []由于CoreData中存储图片是二进制，引用时不能用文件名: 12cell.thumbnailImageView.image = UIImage(data: restaurants[indexPath.row].imageas! Data) 12 if let imageToShare = UIImage(data: self.restaurants[indexPath.row].image as!Data) &#123; 由于RestaurantMO的属性值是可选值，使用时需要解包： 1let defaultText = &quot;Just checking in at &quot; + self.restaurants[indexPath.row].name! RestaurantDetailViewController.swift 1var restaurant:RestaurantMO! 1restaurantImageView.image = UIImage(data: restaurant.image as! Data) 12 geoCoder.geocodeAddressString(restaurant.location!, completionHandler: &#123;placemarks, error in MapViewController.swift 1var restaurant:RestaurantMO! 1leftIconView.image = UIImage(data: restaurant.image as! Data) ReviewViewController.swift 1var restaurant:RestaurantMO! 1restaurantImageView.image = UIImage(data: restaurant.image as! Data) 现在能成功运行，发现是没有数据的。 保存新数据到数据库 在AddTableViewController.swift中引入Core Data：import CoreData。添加变量var restaurant:RestaurantMO!。 在AppDelegate中加入上面例子一个变量和一方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// MARK: - Core Data stack lazy var persistentContainer: NSPersistentContainer = &#123; /* The persistent container for the application. This implementation creates and returns a container, having loaded the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail. */ let container = NSPersistentContainer(name: &quot;FoodPin&quot;) container.loadPersistentStores(completionHandler: &#123; (storeDescription, error) in if let error = error as NSError? &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. /* Typical reasons for an error here include: * The parent directory does not exist, cannot be created, or disallows writing. * The persistent store is not accessible, due to permissions or data protection when the device is locked. * The device is out of space. * The store could not be migrated to the current model version. Check the error message to determine what the actual problem was. */ fatalError(&quot;Unresolved error \(error), \(error.userInfo)&quot;) &#125; &#125;) return container &#125;() // MARK: - Core Data Saving support func saveContext () &#123; let context = persistentContainer.viewContext if context.hasChanges &#123; do &#123; try context.save() &#125; catch &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nserror = error as NSError fatalError(&quot;Unresolved error \(nserror), \(nserror.userInfo)&quot;) &#125; &#125; &#125; 在AddTableViewController的save方法的dismiss之前插入： 123456789101112131415161718// 1if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; restaurant = RestaurantMO(context: appDelegate.persistentContainer.viewContext) restaurant.name = nameTextField.text restaurant.type = typeTextField.text restaurant.location = locationTextField.text restaurant.isVisited = isVisited if let restaurantImage = photoImageView.image &#123; // 2 if let imageData = UIImagePNGRepresentation(restaurantImage) &#123; restaurant.image = NSData(data: imageData) &#125; &#125; print(&quot;Saving data to context ...&quot;) appDelegate.saveContext()&#125; UIApplication.shared这种形式是iOS SDK中比较常用单例模式，就是通过一个类属性shared获取整个app运行过程只需要一个实例的方法。UIApplication.shared.delegate as? AppDelegate就获取了AppDelegate对象。 获取图片的二进制数据对象。 运行，添加新的restaurant后并没有在Food Pin中显示，实际已经添加到数据库中，在RestaurantTableViewController里没有向数据库获取。 通过CoreData获取数据 在RestaurantTableViewController.swift中添加import CoreData。实现协议NSFetchedResultsControllerDelegate，这个协议中有方法，任何时候当获取来的数据有变化时立即通知代理。class RestaurantTableViewController: UITableViewController, NSFetchedResultsControllerDelegate 定义一个变量var fetchResultController: NSFetchedResultsController&lt;RestaurantMO&gt;! 在viewDidLoad中添加 123456789101112131415161718192021// 1 let fetchRequest: NSFetchRequest&lt;RestaurantMO&gt; = RestaurantMO.fetchRequest()// 2let sortDescriptor = NSSortDescriptor(key: &quot;name&quot;, ascending: true)fetchRequest.sortDescriptors = [sortDescriptor]if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; let context = appDelegate.persistentContainer.viewContext fetchResultController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: context, sectionNameKeyPath: nil, cacheName: nil) fetchResultController.delegate = self&#125;do &#123; // 3 try fetchResultController.performFetch() if let fetchedObjects = fetchResultController.fetchedObjects &#123; // 4 restaurants = fetchedObjects &#125;&#125; catch &#123; print(error)&#125; 1 从RestaurantMO对象获得数据请求对象NSFetchRequest。 2 通过NSSortDescriptor来设置获取结果的排序方式。 3 performFetch方法执行从数据库中获取数据请求。 4 把请求结果复制给变量restaurants。 数据库中数据变化，将调用来自NSFetchedResultsControllerDelegate三个方法，调用三个方法的时间可以简单的理解分别为数据将要改变、数据正在改变、数据改变后：controllerWillChangeContent(_:)controller(_:didChange:at:for:newIndexPath:)controllerDidChangeContent(_:) 方法的实现，也分别对table view有不同处理： 123456789101112131415161718192021222324252627282930func controllerWillChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) &#123; tableView.beginUpdates()&#125;func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) &#123; switch type &#123; case .insert: if let newIndexPath = newIndexPath &#123; tableView.insertRows(at: [newIndexPath], with: .fade) &#125; case .delete: if let indexPath = indexPath &#123; tableView.deleteRows(at: [indexPath], with: .fade) &#125; case .update: if let indexPath = indexPath &#123; tableView.reloadRows(at: [indexPath], with: .fade) &#125; default: tableView.reloadData() &#125; if let fetchedObjects = controller.fetchedObjects &#123; restaurants = fetchedObjects as! [RestaurantMO] &#125;&#125;func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) &#123; tableView.endUpdates()&#125; 现在运行程序，添加新的Restaurant就能同步显示了。 通过CoreData删除数据更新RestaurantTableViewController的tableView(_:editActionsForRowAt:_)方法中的 deleteAction。1234567891011let deleteAction = UITableViewRowAction(style: .default, title: &quot;Delete&quot;, handler: &#123; (action, indexPath) -&gt; Void in if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; let context = appDelegate.persistentContainer.viewContext let restaurantToDelete = self.fetchResultController.object(at: indexPath) context.delete(restaurantToDelete) appDelegate.saveContext() &#125; &#125;) 现在删除一项后，重新启动后，数据消失。 更新数据更新RestaurantDetailViewController的中的ActionratingButtonTapped: ：12345678910111213141516171819202122@IBAction func ratingButtonTapped(segue: UIStoryboardSegue) &#123; if let rating = segue.identifier &#123; restaurant.isVisited = true switch rating &#123; case &quot;great&quot;: restaurant.rating = &quot;Absolutely love it! Must try.&quot; case &quot;good&quot;: restaurant.rating = &quot;Pretty good.&quot; case &quot;dislike&quot;: restaurant.rating = &quot;I don&apos;t like it.&quot; default: break &#125; &#125; if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; appDelegate.saveContext() &#125; tableView.reloadData()&#125; 现在评价一项后，重新启动后评价就会保留。 Exercise：添加新字段之前新建Restaurant页面没有Phone字段，现在添加 在SB的New Restaurant添加新Cell，在AddRestaurantController中添加相关接口并关联。 更新AddRestaurantController中的save:Action相关代码。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-0：说明和目录]]></title>
    <url>%2F2017%2Fswift-0.html</url>
    <content type="text"><![CDATA[这是我学习Swift的一个笔记和总结，以playground的形式放在我的github上，学习的版本是swift 3 。 学习资源 官方文档 The Swift Programming Language任何好的技术官方文档总是最好的学习资源。😋 官方文档的中文版好多小伙伴一起合作翻译，从swift刚才来就很快翻译，以后不断更新，发起者在开始发起翻译时还是个在校学生，很厉害，真的非常感谢。 这是raywenderlich.com网站出的书，不过是收费的。😑 有需要的小伙伴可私信我😎 为什么是playground的形式很多概念单用文字描述不大好理解，playground方便利用Xcode查看和调试。很多时候一些不常用的语法很容易忘记，通过playground很方便温习。 目录 以撸代码的形式学习Swift-1：The Basics 以撸代码的形式学习Swift-2：Basic Operators 以撸代码的形式学习Swift-3：Strings and Characters 以撸代码的形式学习Swift-4：Collection Type 以撸代码的形式学习Swift-5：Control Flow 以撸代码的形式学习Swift-6：Functions 以撸代码的形式学习Swift-7：Closure 以撸代码的形式学习Swift-8：Enumerations 以撸代码的形式学习Swift-9：Classes and Structures 以撸代码的形式学习Swift-10：Properties 以撸代码的形式学习Swift-11：Methods 以撸代码的形式学习Swift-12：Subscripts 以撸代码的形式学习Swift-13：Inheritance 以撸代码的形式学习Swift-14：Initialization 以撸代码的形式学习Swift-15：(类的)Deinitialization 以撸代码的形式学习Swift-16：Automatic Reference Counting 以撸代码的形式学习Swift-17：Optional Chaining 以撸代码的形式学习Swift-18：Error Handling 以撸代码的形式学习Swift-19：Type Casting(类型转换) 以撸代码的形式学习Swift-20：Nested Types(嵌套类型) 以撸代码的形式学习Swift-21：Extensions 以撸代码的形式学习Swift-22：Protocols 以撸代码的形式学习Swift-23：Generics 以撸代码的形式学习Swift-24：Access Control 以撸代码的形式学习Swift-25：Advanced Operators]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 15 使用地图]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-15.html</url>
    <content type="text"><![CDATA[继续上一盘开始用Swift开发iOS 10 - 14 基础动画，模糊效果和Unwind Segue，这一篇使用地图。添加MapKit框架： 添加Map到应用中效果图如下： 在Detail view的table view底部添加一个Map View。高度设置为135，取消一些属性zooming, scrolling, rotating等，使地图没有交互功能。 删除之前去掉table view底部的代码，让底部显示。tableView.tableFooterView = UIView(frame: CGRect.zero) 添加新的视图控制器，并在其中添加Map View，调整大小为全屏。 control-drag从detail视图控制器到新的地图视图控制器，选择show。因为table view的头部和底部是不能选择的，所有不能从table view的底部control-drag到地图视图控制器。 为了能检测的table view底部map的是否被接触，需要为地图添加UITapGestureRecognizer 。在RestaurantDetailViewController.swift中引入 import MapKit;定义地图接口@IBOutlet var mapView: MKMapView!，并关联;在viewDidLoad中添加：12let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(showMap))mapView.addGestureRecognizer(tapGestureRecognizer) 另外添加方法：123func showMap() &#123; performSegue(withIdentifier: &quot;showMap&quot;, sender: self)&#125; 用Geocoder转换地址到经纬度类似下面：1234567let geoCoder = CLGeocoder()geoCoder.geocodeAddressString(&quot;上海东方明珠&quot;, completionHandler: &#123; placemarks, error in for p in placemarks! &#123; print(p.location?.coordinate) &#125;&#125;) placemarks是CLPlacemark的数组。 地图标注（annotation）介绍通过地址文本获得经纬度后就可在地图上标注指示，类似下面的样子： 地图标注的代码一般如下，先通过地址文本生成的经纬度，规定MKPointAnnotation的经纬度，然后把MKPointAnnotation添加到地图视图中即可。12345let annotation = MKPointAnnotation()if let location = placemark.location &#123; annotation.coordinate = location.coordinate mapView.addAnnotation(annotation)&#125; 为没有交互的地图添加标注在RestaurantDetailViewController.swift的viewDidLoad中添加：123456789101112131415161718192021222324252627let geoCoder = CLGeocoder()geoCoder.geocodeAddressString(restaurant.location, completionHandler: &#123; placemarks, error in if error != nil &#123; print(error) return &#125; if let placemarks = placemarks &#123; let placemark = placemarks[0] let annotation = MKPointAnnotation() if let location = placemark.location &#123; annotation.coordinate = location.coordinate self.mapView.addAnnotation(annotation) // 规定地图显示半径 250米 let region = MKCoordinateRegionMakeWithDistance(annotation.coordinate, 250, 250) self.mapView.setRegion(region, animated: false) &#125; &#125;&#125;)``` ### 为全屏的地图添加标注- 新建一个视图控制器`MapViewController`，关联全屏地图控制器，引入地图框架 `import MapKit`。- 第一个地图接口和`restaurant`变量 @IBOutlet var mapView: MKMapView!var restaurant:Restaurant!1- 更新`viewDidLoad`： override func viewDidLoad() { super.viewDidLoad() let geoCoder = CLGeocoder() geoCoder.geocodeAddressString(restaurant.location, completionHandler: { placemarks, error in if error != nil { print(error) return } if let placemarks = placemarks { // Get the first placemark let placemark = placemarks[0] // 1 let annotation = MKPointAnnotation() annotation.title = self.restaurant.name annotation.subtitle = self.restaurant.type if let location = placemark.location { annotation.coordinate = location.coordinate // 2 self.mapView.showAnnotations([annotation], animated: true) self.mapView.selectAnnotation(annotation, animated: true) } } }) } 123456 + 1 设置`MKPointAnnotation`一些属性 + 2 在地图展示标注。地图上课展示很多标注。`selectAnnotation:`方法是标注显示被选中的样式。### 在标注中添加图片- 让`MapViewController`实现`MKMapViewDelegate`协议，并在`viewDidLoad`中设置`mapView.delegate = self`- 添加`mapView(_:viewFor:)`方法，当地图每次需要annotation时调用： func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? { let identifier = &quot;MyPin&quot; // 1 if annotation.isKind(of: MKUserLocation.self) { return nil } // 2 var annotationView: MKPinAnnotationView? = mapView.dequeueReusableAnnotationView(withIdentifier: identifier) as? MKPinAnnotationView if annotationView == nil { annotationView = MKPinAnnotationView(annotation: annotation, reuseIdentifier: identifier) annotationView?.canShowCallout = true } // 3 let leftIconView = UIImageView(frame: CGRect(x: 0, y: 0, width: 53, height: 53)) leftIconView.image = UIImage(named: restaurant.image) annotationView?.leftCalloutAccessoryView = leftIconView // 4 annotationView?.pinTintColor = UIColor.orange return annotationView } ` 1 判断是否用户当前位置。用户当前位置算是一种特殊的标注，是当前位置，就不需要另外添加标注了。 2 创建MKPinAnnotationView。有点类似创建table view cell。 3 在MKPinAnnotationView上添加图片。 4 改变标注针的颜色。 地图定制mapView.showsCompass = true mapView.showsScale = true mapView.showsTraffic = true showsCompass表示在右上角显示罗盘。showsScale 表示在左上角显示缩放比例尺。 showsTraffic表示显示交通信息。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 16 介绍静态Table Views，UIImagePickerController和NSLayoutConstraint]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-16.html</url>
    <content type="text"><![CDATA[继续上一篇开始用Swift开发iOS 10 - 15 使用地图，这一篇通过添加一个新建Restaurant页面来介绍静态Table Views，UIImagePickerController，NSLayoutConstraint。静态Table Views就是固定cell数目的Table Views；UIImagePickerController用来从设备图片库中获取图片；NSLayoutConstraint就是约束类，用来用代码形式添加约束。 添加新的Table View Controller 拖动一个Table View Controller到SB中。 修改成Table View的content为static cells。 选中Table View Section，修改Rows成5。 下载 图片，拖进Assets 修改第一个Cell高度为250。添加Image View， image为photoalbum，大小64*64，水平和垂直居中。 第二个cell高度为72。添加一个Label文本NAME。添加一个Text Field,placeholder为Restaurant Name，border style为 none，宽度为339。添加适当约束。 第三个和第四个Cell与第二个类似，Label文本分别为TYPE LOCATION，Text Field的 placeholder 分别为Restaurant Type，Restaurant Location。 第五个 高度为72。 添加一个Label文本Have You Been Here 。添加两个Button，title分别为YES、NO，字体颜色都为white，背景颜色分别为red，gray。 添加segue 在Food Pin Controller的Navigation bar的右边添加一个bar button item，System Item为Add。 把上面新建是我table view controller内嵌在一个Navigation controller中，选中table view controller，在菜单栏中选择Editor &gt; Embed in &gt; Navigation Controller，设置其navigation bar的title为New Restaurant。 关联Add按钮和New Restaurant Controller的Navigation controller，segue类型present modally，identifier为addRestaurant。 在New Restaurant Controller的Navigation bar的左边添加一个bar button item，System Item为 Cancel，tint为white。 在RestaurantTableViewController中添加unwind segue的action。用control-drag关联。 12@IBAction func unwindToHomeScreen(segue:UIStoryboardSegue) &#123;&#125; 使用UIImagePickerController调用相册 新建AddRestaurantController，继承至UITableViewController。关联New Restaurant Controller。 删除除了viewDidLoad方法的其他方法，静态类型不需要了。 添加tableView(_:didSelectRowAt:)：1234567891011override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; if indexPath.row == 0 &#123; if UIImagePickerController.isSourceTypeAvailable(.photoLibrary) &#123; let imagePicker = UIImagePickerController() imagePicker.allowsEditing = false imagePicker.sourceType = .photoLibrary present(imagePicker, animated: true, completion: nil) &#125; &#125;&#125; 选择第一个cell，也就是图片，通过isSourceTypeAvailable方法判断是否有图库可用。 在Info.plist中添加使用图库的请求描述， Privacy - Photo Library Usage Description -&gt; You need to grant the app access to your photo library so you can pick your favorite restaurant photo. 。 实现UIImagePickerControllerDelegate协议 添加UIImagePickerControllerDelegate 和UINavigationControllerDelegate class AddRestaurantController: UITableViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate { 添加接口@IBOutlet var photoImageView: UIImageView!，并关联。 添加函数imagePickerController(_:didFinishPickingMediaWithInfo:)，当用户从图库中选择图片时调用。 12345678910func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let selectedImage = info[UIImagePickerControllerOriginalImage] as? UIImage &#123; photoImageView.image = selectedImage photoImageView.contentMode = .scaleAspectFill photoImageView.clipsToBounds = true &#125; dismiss(animated: TUREAD, completion: nil)&#125; 在tableView(_:didSelectRowAt:)中的imagePicker定义后添加： imagePicker.delegate = self 用代码的方式定义约束之前都是通过storyboard设置约束，其实也可以通过代码的形式设置。 之前的地图的约束例子，storyboard 中的Map View.leading = leading等价于： let leadingConstraint = NSLayoutConstraint(item: mapView, attribute: NSLayoutAttribute.leading, relatedBy: .equal, toItem: mapView.superview, attribute: .leading, multiplier: 1, constant: 0) leadingConstraint.isActive = true 在添加imagePickerController(_:didFinishPickingMediaWithInfo:)的dismiss(animated: true, completion: nil)之前添加4个约束代码。 123456789let leadingConstraint = NSLayoutConstraint(item: photoImageView, attribute: .leading, relatedBy: .equal, toItem: photoImageView.superview, attribute: .leading, multiplier: 1, constant: 0) leadingConstraint.isActive = true let trailingConstrain = NSLayoutConstraint(item: photoImageView, attribute: .trailing, relatedBy: .equal, toItem: photoImageView.superview, attribute: .trailing, multiplier: 1, constant: 0) trailingConstrain.isActive = true let topConstraint = NSLayoutConstraint(item: photoImageView, attribute: .top, relatedBy: .equal, toItem: photoImageView.superview, attribute: .top, multiplier: 1, constant: 0) let buttomConstraint = NSLayoutConstraint(item: photoImageView, attribute: .bottom, relatedBy: .equal, toItem: photoImageView.superview, attribute: .bottom, multiplier: 1, constant: 0) 添加约束前后对比： Exercise：验证添加数据 在New Restaurant Controller的Navigation controller的有右上角添加Save按钮。 在AddRestaurantController中添加五个接口和一个变量，并关联。 123456@IBOutlet var nameTextField:UITextField!@IBOutlet var typeTextField:UITextField!@IBOutlet var locationTextField:UITextField!@IBOutlet var yesButton:UIButton!@IBOutlet var noButton:UIButton! var isVisited: Bool = true 添加一个Action，关联save按钮。 1234567891011121314@IBAction func save(_ sender: Any) &#123; if (nameTextField.text?.isEmpty)! || (typeTextField.text?.isEmpty)! || (locationTextField.text?.isEmpty)! &#123; let alertController = UIAlertController(title: &quot;Oops&quot;, message: &quot;We can&apos;t proceed because one of the fields is blank....&quot;, preferredStyle: .alert) let alertAction = UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil) alertController.addAction(alertAction) present(alertController, animated: true, completion: nil) &#125; else &#123; print(nameTextField.text, typeTextField.text, locationTextField.text, isVisited) dismiss(animated: true, completion: nil)// performSegue(withIdentifier: &quot;unwindToHomeScreen&quot;, sender: self) &#125;&#125; 去除 Add Restaurant view controller回到主界面有两种方法，一是dismiss(animated: true, completion: nil)，而是利用unwind segue。 添加一个Action toggleBeenHereButton:，用于yesButton和noButton的操作。1234567891011@IBAction func toggleBeenHereButton(sender: UIButton) &#123; if sender == yesButton &#123; isVisited = true yesButton.backgroundColor = UIColor.red noButton.backgroundColor = UIColor.gray &#125; else &#123; isVisited = false yesButton.backgroundColor = UIColor.gray noButton.backgroundColor = UIColor.red &#125;&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 14 基础动画，模糊效果和Unwind Segue]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-14.html</url>
    <content type="text"><![CDATA[动画是通过一系列静态图片（帧）快速显示来模拟动作和形状的变化过程。 在iOS中，创建基础动画很简单，只需要利用UIView的类型方法：animate(withDuration:animations:)。这个方法的原理就是，设置好开始状体和结束状态，然后 UIView animation 创建中间的过程效果。继续上一篇开始用Swift开发iOS 10 - 13 Self Sizing Cells and Dynamic Type。 添加评级Button 下载图片包，添加到xcassets里。 在detail view右上角添加一个Button，设置其内容为空，image为更添加的图片check（一个对勾图标），type为system，tint为white。 为Button添加四个约束，右、上两个spacing约束，宽度和高度约束。 创建Restaurant Review视图控制器 在storyboard中新建一个View Controller。 在新建视图控制器中添加Image View，并改变其大小为整个view，先设置image属性为一个随机图片，比如cafeloisl。 并设置一些约束。 按照下图设置之后是UI： 在Review的图片上添加一个UIView，x、y、宽度、高度分别是53、40、269、420。 添加Image View，宽度和高度分别为269，200，随机设置image 添加一个内容为You&#39;ve dined here. What do you think?的Label。字体风格为Light，大小为27，居中退器，行数为2。 添加三个按钮内容分别为Absolutely love it!，Good，I don&#39;t like it。背景为红色，tint为white，字体是Light和16。 设置三个按钮为一个stack view，改变distribution为Fill Equally，spaing为5。 为上面添加的UIView添加四个约束。上左右的spacing约束分别为20，37，37。高度约束为420。 为label添加左右下三个spacing约束，值都是15。 为stack view天机左右下三个spacing约束，分别为8，8，10。 创建Present modally类型的Segue在开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue中介绍过Segue类型。Present modally是新页面将以动画形式从底部出现到覆盖整个手机屏幕。 contrl-drag从对勾button到Review视图控制，选择Present modally。并设置新生成segue的identifier为showReview。 定义如何退出Review View Controller在Navigation Controller中自带了返回按钮，这边需要自己设置unwind segue。 在Review View Controller中的UIView的右上角添加一个关闭按钮，类似于对勾按钮，添加右上和宽度高度约束。 为了实现unwind segue，需要做两件事：首先，在返回的的视图控制器（RestaurantDetailViewController）中定义一个方法，定义这个方法是为了告诉xcode这个segue是可以返回的。12@IBAction func close(segue:UIStoryboardSegue) &#123;&#125; 其次在IB中关联返回。control+drag关闭按钮到Exit，选择closeWithSegue:。 为背景图片添加模糊效果UIVisualEffectView 新建ReviewViewController继承至UIViewController，关联上面新建视图控制器。 在ReviewViewController中添加背景图片结构，并关联图片。@IBOutlet var backgroundImageView: UIImageView! 在ReviewViewController的viewDidLoad中添加：1234let blurEffect = UIBlurEffect(style: .dark)let blurEffectView = UIVisualEffectView(effect: blurEffect)blurEffectView.frame = view.boundsbackgroundImageView.addSubview(blurEffectView) 模糊效果有点像在要添加的视图上面添加一个视图(UIVisualEffectView)，这图有模糊效果(UIBlurEffect)，模糊样式通过UIBlurEffectStyle控制，有三种extraLight, light, dark。 实现 UIView Animation 为准备实现动画效果的UIView添加接口，并关联。@IBOutlet var containerView: UIView! 定义初始状态：在ReviewViewController的viewDidLoad中添加:containerView.transform = CGAffineTransform.init(scaleX: 0, y: 0) 定义介绍状态：在ReviewViewController的viewDidAppear中添加：12345override func viewDidAppear(_ animated: Bool) &#123; UIView.animate(withDuration: 0.3, animations: &#123; self.containerView.transform = CGAffineTransform.identity &#125;)&#125; CGAffineTransform.identity表示原本设置的大小和位置状态。 Spring 动画只要修改一下结束状态就可以了：123UIView.animate(withDuration: 0.4, delay: 0.0, usingSpringWithDamping: 0.3, initialSpringVelocity: 0.2, options: .curveEaseInOut, animations: &#123; self.containerView.transform = CGAffineTransform.identity&#125;, completion: nil) 从上向下的动画只要修改一下初始状态，把初始位置设置在上面即可：1containerView.transform = CGAffineTransform.init(translationX: 0, y: -1000) 组合两种变化把containerView.transform = CGAffineTransform.init(translationX: 0, y: -1000)修改成：1234let scaleTransform = CGAffineTransform.init(scaleX: 0, y: 0)let translateTransform = CGAffineTransform.init(translationX: 0, y: -1000)let combineTransform = scaleTransform.concatenating(translateTransform)containerView.transform = combineTransform Unwind Segues 和数据传输在Review View中点击三个不同评价按钮也通过Unwind Segues返回并传输数据。 在RestaurantDetailViewController在添加另外一个unwind action方法。 12@IBAction func ratingButtonTapped(segue: UIStoryboardSegue) &#123;&#125; 分别对三个按钮control+drag到Exit，选择ratingButtonTappedWithSegue:，并分别把三个unwind segue的identifier改成 great good dislike。 在Restaurant中添加rating属性： var rating = &quot;&quot; 更新 ratingButtonTapped(segue:)： 1234567891011121314151617@IBAction func ratingButtonTapped(segue: UIStoryboardSegue) &#123; if let rating = segue.identifier &#123; restaurant.isVisited = true switch rating &#123; case &quot;greate&quot;: restaurant.rating = &quot;Absolutely love it! Must try.&quot; case &quot;good&quot;: restaurant.rating = &quot;Pretty good.&quot; case &quot;dislike&quot;: restaurant.rating = &quot;I don&apos;t like it.&quot; default: break &#125; &#125; tableView.reloadData()&#125; 更新RestaurantDetailViewController的tableView(_:cellForRowAt:)中当fieldLabel为“Been here”的valueLabel的值： cell.valueLabel.text = (restaurant.isVisited) ? &quot;Yes, I&apos;ve been herebefore. \(restaurant.rating)&quot; : &quot;No&quot; 修改ReviewViewController中的图片为相应的图片 在ReviewViewController中添加一个属性：var restaurant: Restaurant! 在RestaurantDetailViewController中添加prepare(for:sender:)方法，作为RestaurantDetailViewController到ReviewViewController的segue时调用，用于传输数据。 123456override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showReview&quot; &#123; let destinationController = segue.destination as! ReviewViewController destinationController.restaurant = self.restaurant &#125;&#125; 在ReviewViewController 中添加图片接口。@IBOutlet var topImageView: UIImageView! 在ReviewViewController的viewDidLoad中显示图片：123let image = UIImage(named: self.restaurant.image)backgroundImageView.image = imagetopImageView.image = image 为closeButton添加动画效果 添加接口@IBOutlet var closeButton: UIButton! 在viewDieLoad中添加：closeButton.transform = CGAffineTransform.init(scaleX: 1000, y: 0) 在 viewDidAppear:添加：12345UIView.animate(withDuration: 0.5, delay: 0.5, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.3, options: .curveEaseInOut, animations: &#123; self.closeButton.transform = CGAffineTransform.identity &#125;, completion: nil) 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 13 Self Sizing Cells and Dynamic Type]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-13.html</url>
    <content type="text"><![CDATA[接着上一遍开始用Swift开发iOS 10 - 12 丰富Detail View和定制化Navigation Bar的代码稍作修改，为Restaurant多加一个phone属性,修改过location的长度。 修改RestaurantTableViewController中的restaurants变量（添加字段phone，location字段内容增多）： 1234567891011121314151617181920212223var restaurants:[Restaurant] = [ Restaurant(name: &quot;Cafe Deadend&quot;, type: &quot;Coffee &amp; Tea Shop&quot;,location: &quot;G/F, 72 Po Hing Fong, Sheung Wan, Hong Kong&quot;, phone: &quot;232-923423&quot;,image: &quot;cafedeadend.jpg&quot;, isVisited: false), Restaurant(name: &quot;Homei&quot;, type: &quot;Cafe&quot;, location: &quot;Shop B, G/F, 22-24A Tai Ping San Street SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;348-233423&quot;, image:&quot;homei.jpg&quot;, isVisited: false), Restaurant(name: &quot;Teakha&quot;, type: &quot;Tea House&quot;, location: &quot;Shop B, 18 Tai Ping Shan Road SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;354-243523&quot;, image: &quot;teakha.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe loisl&quot;, type: &quot;Austrian / Causual Drink&quot;, location: &quot;Shop B, 20 Tai Ping Shan Road SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;453-333423&quot;, image: &quot;cafeloisl.jpg&quot;, isVisited: false), Restaurant(name: &quot;Petite Oyster&quot;, type: &quot;French&quot;, location: &quot;24 Tai Ping Shan Road SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;983-284334&quot;, image: &quot;petiteoyster.jpg&quot;, isVisited: false), Restaurant(name: &quot;For Kee Restaurant&quot;, type: &quot;Bakery&quot;, location: &quot;Shop J-K., 200 Hollywood Road, SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;232-434222&quot;, image: &quot;forkeerestaurant.jpg&quot;, isVisited: false), Restaurant(name: &quot;Po&apos;s Atelier&quot;, type: &quot;Bakery&quot;, location: &quot;G/F, 62 Po Hing Fong, Sheung Wan, Hong Kong&quot;, phone: &quot;234-834322&quot;, image: &quot;posatelier.jpg&quot;, isVisited: false), Restaurant(name: &quot;Bourke Street Backery&quot;, type: &quot;Chocolate&quot;, location: &quot;633 Bourke St Sydney New South Wales 2010 Surry Hills&quot;, phone: &quot;982-434343&quot;, image:&quot;bourkestreetbakery.jpg&quot;, isVisited: false), Restaurant(name: &quot;Haigh&apos;s Chocolate&quot;, type: &quot;Cafe&quot;, location: &quot;412-414 George St Sydney New South Wales&quot;, phone: &quot;734-232323&quot;, image: &quot;haighschocolate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Palomino Espresso&quot;, type: &quot;American / Seafood&quot;, location: &quot;Shop 1 61 York St Sydney New South Wales&quot;, phone: &quot;872-734343&quot;, image: &quot;palominoespresso.jpg&quot;, isVisited: false), Restaurant(name: &quot;Upstate&quot;, type: &quot;American&quot;, location: &quot;95 1st Ave New York, NY 10003&quot;, phone: &quot;343-233221&quot;, image: &quot;upstate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Traif&quot;, type: &quot;American&quot;, location: &quot;229 S 4th St Brooklyn, NY 11211&quot;, phone: &quot;985-723623&quot;, image: &quot;traif.jpg&quot;, isVisited: false), Restaurant(name: &quot;Graham Avenue Meats&quot;, type: &quot;Breakfast &amp; Brunch&quot;, location: &quot;445 Graham Ave Brooklyn, NY 11211&quot;, phone: &quot;455-232345&quot;, image: &quot;grahamavenuemeats.jpg&quot;, isVisited: false), Restaurant(name: &quot;Waffle &amp; Wolf&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;413 Graham Ave Brooklyn, NY 11211&quot;, phone: &quot;434-232322&quot;, image: &quot;wafflewolf.jpg&quot;, isVisited: false), Restaurant(name: &quot;Five Leaves&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;18 Bedford Ave Brooklyn, NY 11222&quot;, phone: &quot;343-234553&quot;, image: &quot;fiveleaves.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe Lore&quot;, type: &quot;Latin American&quot;, location: &quot;Sunset Park 4601 4th Ave Brooklyn, NY 11220&quot;, phone: &quot;342-455433&quot;, image: &quot;cafelore.jpg&quot;, isVisited: false), Restaurant(name: &quot;Confessional&quot;, type: &quot;Spanish&quot;, location: &quot;308 E 6th St New York, NY 10003&quot;, phone: &quot;643-332323&quot;, image: &quot;confessional.jpg&quot;, isVisited: false), Restaurant(name: &quot;Barrafina&quot;, type: &quot;Spanish&quot;, location: &quot;54 Frith Street London W1D 4SL United Kingdom&quot;, phone: &quot;542-343434&quot;, image: &quot;barrafina.jpg&quot;, isVisited: false), Restaurant(name: &quot;Donostia&quot;, type: &quot;Spanish&quot;, location: &quot;10 Seymour Place London W1H 7ND United Kingdom&quot;, phone: &quot;722-232323&quot;, image: &quot;donostia.jpg&quot;, isVisited: false), Restaurant(name: &quot;Royal Oak&quot;, type: &quot;British&quot;, location: &quot;2 Regency Street London SW1P 4BZ United Kingdom&quot;, phone: &quot;343-988834&quot;, image: &quot;royaloak.jpg&quot;, isVisited: false), Restaurant(name: &quot;CASK Pub and Kitchen&quot;, type: &quot;Thai&quot;, location: &quot;22 Charlwood Street London SW1V 2DY Pimlico&quot;, phone: &quot;432-344050&quot;, image: &quot;caskpubkitchen.jpg&quot;, isVisited: false)] 为Restaurant添加属性phone。 修改RestaurantDetailViewController中两个table view方法：123456789101112131415161718192021222324252627282930313233func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 5&#125;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! RestaurantDetailTableViewCell // Configure the cell... switch indexPath.row &#123; case 0: cell.fieldLabel.text = &quot;Name&quot; cell.valueLabel.text = restaurant.name case 1: cell.fieldLabel.text = &quot;Type&quot; cell.valueLabel.text = restaurant.type case 2: cell.fieldLabel.text = &quot;Location&quot; cell.valueLabel.text = restaurant.location case 3: cell.fieldLabel.text = &quot;Phone&quot; cell.valueLabel.text = restaurant.phone case 4: cell.fieldLabel.text = &quot;Been here&quot; cell.valueLabel.text = (restaurant.isVisited) ? &quot;Yes, I&apos;ve been herebefore&quot; : &quot;No&quot; default: cell.fieldLabel.text = &quot;&quot; cell.valueLabel.text = &quot;&quot; &#125; cell.backgroundColor = UIColor.clear return cell&#125; 使Cell自适应 在RestaurantDetailViewController中的viewDidLoad中添加： 12tableView.estimatedRowHeight = 36.0 tableView.rowHeight = UITableViewAutomaticDimension estimatedRowHeight是cell的预计高度，这边就设置成原本prototype cell的高度。 UITableViewAutomaticDimension表示超过预计高度后自动适应高度。 修改Value label的numberOfLines属性为0，就是不限制行数。 添加spacing约束当value label超过两行，文本显示出问题： 这是因为虽然value label的高度自适应了合适的高度，但是stack view的高度没有约束，不能计算的出来，因此要给stack view添加两个上下的相等spcing约束。 这样不管value label是多少行，高度都会自适应了。 Dynamic TypeDynamic Type当在手机设置 &gt;通用 &gt; 辅助功能 &gt; 更大字体设置字体大小时，app中的应用也相应的变化。只要把字体设置成text style - Headline就会有Dynamic Type功能。目前只有name label的字体设置成了text style - Headline，其他设置成固定大小的字体，不会随着在手机设置 &gt;通用 &gt; 辅助功能 &gt; 更大字体设置字体大小时而变化。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习6：Fondation-Kit介绍]]></title>
    <url>%2F2017%2Foc-basic-6.html</url>
    <content type="text"><![CDATA[12macOS -&gt; Cocoa -&gt; Foundation, AppKitiOS -&gt; Cocoa Touch -&gt; Foundation, UIKit(UIView, UIController) Foundation框架的基础是CoreFoundation（C语言），如果函数或变量是以CF开头，就是CoreFoundation框架中的。 Foundation中一些有用的数据类型范围： NSRange1234typedef struct _NSRange &#123; NSUInteger location; NSUInteger length;&#125; NSRange; 表示相关事务的范围。有三种方式初始化： 直接给字段赋值： 123NSRange range;range.location = 12;range.length = 5; 应用C语言的聚合结构赋值：NSRange range = {17, 4} 函数NSMakeRange()：NSRange range3 = NSMakeRange(12, 5);这个方法的好处是可以在任何能够使用函数的地方直接使用：[anObject flarbulateWithRange: NSMakeRange(13, 15)]; 几何数据类型CG前缀，表示Core Graphics框架（C语言），用来进行2D渲染。 CGPoint表示坐标 12345struct CGPoint&#123; float x; float y;&#125; CGSize表示大小，用来存储长度和宽度 12345struct CGSize&#123; float width; float height;&#125; CGRect 表示矩形，由坐标和大小复合而成 12345struct CGRect&#123; CGPoint origin; CGSize size;&#125; 对应创建函数： CGPointMake(), CGSizeMake(), CGRectMake() 集合数据类型是C语言结构体而不是类，是考虑性能的原因。 字符串字符串类： NSString。 通过格式字符串和参数创建NSString： 12NSString *height;height = [NSString stringWithFormat:@"%d, %d", 4, 3]; 类方法： 以+为起始符的。 字符长度，实例方法length： - (NSUInteger) length; 字符串比较 (BOOL)isEqualToString:(NSString *)aString;，表示字符串内容是否相同，返回BooL；==判断字符串的指针是否相同，也就是是否是同一个事务。 12345678910NSString *thing1 = @"hello 5";NSString *thing2 = [NSString stringWithFormat:@"hello %d", 5]; if ([thing1 isEqualToString:thing2]) &#123; NSLog(@"两个字符串内容相同");&#125;if (thing1 == thing2) &#123; NSLog(@"两个字符串是同一个对象");&#125; - (NSComparisonResult)compare:(NSNumber *)decimalNumber;，逐个比较字符串的每个字符，判断大小。返回一个枚举类型NSComparisonResult，三个枚举值分别表示左小于右，左等于右，左大于右。 - (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;，根据options的不同值有不同的功能。 字符串内是否还包含别的字符串检测字符串是否以另一个字符开头或结尾： 12- (BOOL)hasPrefix:(NSString *)str;- (BOOL)hasSuffix:(NSString *)str; 一个字符串在另一个字符串内的返回：- (NSRange)rangeOfString:(NSString *)searchString; 可变性NSString是不可变的。也就是一旦被创建，就不能以删除字符或添加字符的方式改变它。NSMutableString是NSString的子类，可以改变。 可通过类方法stringWithCapacity:来创建，表示分配一块内存用于存储字符串，+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;。NSMutableString *string = [NSMutableString stringWithCapacity:1]; appendString:和appendFormat: 添加字符串： 123NSMutableString *string = [NSMutableString stringWithCapacity:50];[string appendString:@"Hello there "];[string appendFormat:@"human %d!", 39]; // Hello there human 39! deleteCharactersInRange: 删除字符串，经常和rangeOfString:一起使用。 12345NSMutableString *friends = [NSMutableString stringWithCapacity:50]; [friends appendString:@"James BethLynn Jack Evan"]; NSRange jackRange = [friends rangeOfString:@"Jack"]; jackRange.length++; [friends deleteCharactersInRange:jackRange]; // James BethLynn Evan 集合 NSArray两个限制：只能存储OC对象；不能存储nil。 创建类方法arrayWithObjects:(nil表示结束)：NSArray *array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;, nil];直接字面量：NSArray *array2 = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; 数组对象个数： [array count]; 按索引获取对象： 12[array objectAtIndex:1];array[1]; 字符串切分成数组，数组合并成字符串。 123NSMutableString *string2 = @"oop:ack:bork:greeble:ponies"; NSArray *chunks = [string2 componentsSeparatedByString:@":"]; string2 = [chunks componentsJoinedByString:@":-)"]; // oop:-)ack:-)bork:-)greeble:-)ponies NSMutableArrayNSArray包含的对象个数是不能变化的（包含的对象是可以变化的）。NSMutableArray是可以变化数目。 创建: + (instancetype)arrayWithCapacity:(NSUInteger)numItems; 末尾添加 - (void) addObject: (id) anObject; 删除特定索引的对象 - (void)removeObjectAtIndex:(NSIndexSet *)index; 枚举：对数组进行遍历。NSEnumerator 1234NSEnumerator *emumerator = [array objectEnumerator];while (id thingie = [emumerator nextObject]) &#123; &#125; 快速枚举 123for (NSString *string in array) &#123; NSLog()&#125; NSDictionary同样也有对应的NSMutableDictionary。 123456789101112131415161718 // 创建 NSDictionary Tire *t1 = [Tire new]; Tire *t2 = [Tire new]; Tire *t3 = [Tire new]; Tire *t4 = [Tire new]; NSDictionary *tires = [NSDictionary dictionaryWithObjectsAndKeys:t1, @"front-left", t2, @"front-right", t3, @"back-left", t4, @"back-right", nil];// NSDictionary *tires = @&#123;@"front-left": t1, @"front-right": t2, @"back-left": t3,@"back-right": t4,&#125;; // 访问特定key的对象 Tire *tire = [tires objectForKey:@"back-right"];// Tire *tire = tires[@"back-right"]; // 创建NSMutableDictionary NSMutableDictionary *tires_m = [NSMutableDictionary dictionaryWithCapacity:10];// NSMutableDictionary *tires_m = [NSMutableDictionary dictionary]; // 为NSMutableDictionary添加元素 [tires_m setObject:t1 forKey:@"front-left"]; // 从NSMutableDictionary中删除元素 [tires_m removeObjectForKey:@"front-left"]; 其他数据类型NSArray和NSDictionary只能存储对象，不能直接存储任何基本类型的数据，如int、float、和struct。 NSNumber NSValue NSNull]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习5：源文件组织]]></title>
    <url>%2F2017%2Foc-basic-5.html</url>
    <content type="text"><![CDATA[将程序拆分为多个小文件有助于更快地找到重要的代码，而且其他人在查看项目时也能有个大致的了解。 拆分接口和实现根据@interface和@implementation，OC的代码通常放在两种文件里： 接口部分(.h)：类的@interface指令、公共struct定义、enum常量、#defines和extern全局变量等。 实现部分(.m): 类的@implementation指令、全局变量的定义、私有struct等。 另外，复杂的项目可以拥有多个目标，它们源文件的配置各不相同，构建规则也不同。群组关系仅仅是有Xcode负责管理的一项奇妙的功能。 拆分Car程序 #import 带尖号的是导入系统头文件(只读)，如#import &lt;Foundation/Foundation.h&gt;；双引号是项目本地的代码文件，如#import &quot;Engine.h&quot;。 拆分上一篇中的Car程序首先拆分继承自NSObject的类：Tire和Engine。 1234567// Tire.h#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end 1234567891011// Tire.m#import "Tire.h"@implementation Tire//#pragma mark -- (NSString *)description &#123; return (@"I am a Tire.");&#125; //description@end 1234567// Engine.h#import &lt;Foundation/Foundation.h&gt;@interface Engine : NSObject@end 12345678// Engine.m#import "Engine.h"@implementation Engine- (NSString *)description &#123; return (@"I am a Engine.");&#125; //description@end 使用跨文件依赖关系 @class 是告诉编译器：“这是一个类，只会通过指针来引用它，不需要关注此类的更多信息”。可减少必须导入的头文件的数量，从而缩短编译时间。拆分Car类： 1234567891011121314// Car.h#import &lt;Foundation/Foundation.h&gt;@class Engine;@class Tire;@interface Car : NSObject- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Car.m#import "Car.h"#import "Tire.h"#import "Engine.h"@implementation Car&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@"bad index (%d) in setTire:atIndex", index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@"bad index (%d) in setTire:atIndex", index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@"%@", engine); NSLog(@"%@", tires[0]); NSLog(@"%@", tires[1]); NSLog(@"%@", tires[2]); NSLog(@"%@", tires[3]);&#125;@end //Car 编译器需要先知道所有关于超类的信息才能成功地为其子类编译@interface部分。拆分Slant6和AllWeatherRadial： 1234567// Slant6.h#import "Engine.h"@interface Slant6 : Engine@end 123456789// Slant6.m#import "Slant6.h"@implementation Slant6- (NSString *)description &#123; return (@"I am a slant-6.VROOM!");&#125;@end 1234567// AllWeatherRadial.h#import "Tire.h"@interface AllWeatherRadial : Tire@end 12345678910// AllWeatherRadial.m#import "AllWeatherRadial.h"@implementation AllWeatherRadial-(NSString *)description&#123; return (@"I am a tire for rain or shine.");&#125;@end 最后是main.m文件：123456789101112131415161718192021222324// main.m#import &lt;Foundation/Foundation.h&gt;#import "Car.h"#import "Tire.h"#import "Engine.h"#import "Slant6.h"#import "AllWeatherRadial.h"int main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习4：复合（composition）]]></title>
    <url>%2F2017%2Foc-basic-4-composition.html</url>
    <content type="text"><![CDATA[复合: 对象间的组合（类中中包括类）composition在音乐中翻译为作曲：将多个组件组合在一起，配合使用，从而得到完整的作品。在OC中，复合是通过包含作为实例变量的对象指针实现的。1234567@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;* (void)print;@end //Car 自定义NSLog()NSLog()使用%@格式说明符表示输出对象，也就是NSLog()会给这个对象发送了description消息，然后对象的description方法生成一个NSString并将其返回。在类中提供description方法就可以自定义NSLog()如何输出对象。 123456789101112131415@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@"I am a tire.");&#125;@endint main(int argc, const char * argv[]) &#123; Tire *tire = [Tire new]; NSLog(@"%@", tire); // 输出 "I am a tire." return 0;&#125; 存取方法 存取(accessor) 方法是用来读取或改变某个对象属性的方法。分为 getter方法 和 setter方法。 应该尽量使用对象提供的存取方法，不要直接改变对象里面的值。存取方法总是成对出现的。命名方式：setter方法在要更改属性的加上前缀set；getter方法直接是属性名称。 1234567891011@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 在OC中所有对象间的交互都是通过指针实现的。 复合还是继承继承的关系：“Is a”（是一个）。如三角形是一个形状，Slant6是一个发动机……复合的关系：“has a”（有一个）。如形状有个填充颜色，汽车有个发动机和四个轮胎…… 详细代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@"I am a tire.");&#125;@end@interface Engine : NSObject@end //Engine@implementation Engine- (NSString *)description &#123; return (@"I am a Engine.");&#125; //description@end@interface Slant6 : Engine@end //slant-6型号的发动机@implementation Slant6- (NSString *)description &#123; return (@"I am a slant-6型号的发动机.VROOM!");&#125;@end@interface AllWeatherRadial : Tire@end // 新型轮胎@implementation AllWeatherRadial-(NSString *)description&#123; return (@"I am a tire for rain or shine.");&#125;@end@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car@implementation Car- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@"bad index (%d) in setTire:atIndex", index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@"bad index (%d) in setTire:atIndex", index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@"%@", engine); NSLog(@"%@", tires[0]); NSLog(@"%@", tires[1]); NSLog(@"%@", tires[2]); NSLog(@"%@", tires[3]);&#125;@endint main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习3：继承(inheritance)]]></title>
    <url>%2F2017%2Foc-basic-3-inheritance.html</url>
    <content type="text"><![CDATA[为何使用继承 UML(Unified Modeling Language, 统一建模语言) 是一种用图表来表示类、类的内容以及它们之间关系。 将重复的代码合并到一处。 继承的语法格式 只能继承一个 只有代码精简，bug才无处藏身 没有声明实例变量时可以省略花括号 相关术语 refactoring (重构) superclass parent class subclass child class override 继承的工作机制OOP一个强大之处：可以对一个程序做一些重大改变，程序仍然可以正常运行。 方法调度：当代码发送信息时，将在当前的类中搜索相应方法，如果无法在接收消息的对象的类文件中找到相应的文件，就会在该对象的超类中进行查找。 实例变量 在创建一个新类时，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。 polymorphism(多态性) self：指向接收消息的对象的指针 重写方法 super 调用继承的方法可以确保获得方法实现的所有特性]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习2：面向对象编程的基础知识]]></title>
    <url>%2F2017%2Foc-basic-2.html</url>
    <content type="text"><![CDATA[间接(indirection) “只要再多添加一层间接，计算机科学中就没有解决不了的问题。” 例子 电话薄 让他人代替你自己去完成工作 编写一段代码来查询其他代码，并通过它继续访问另一层代码。 推诿 变量与间接 使用文件名的间接 在面向对象编程中使用间接 使用间接来调用代码，不是直接调用某个函数，而是间接调用。 过程式编程(Procedual Programming) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kCircle, kRectangle, kEgg,&#125; ShapeType;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//图形结构typedef struct &#123; ShapeType type; ShapeColor fillColor; ShapeRect bounds;&#125; Shape;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @"red"; break; case kGreenColor: return @"green"; break; case kBlueColor: return @"blue"; break; &#125; return @"no clue";&#125;//绘制图形void drawCircle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@"drawing a Circle at (%d %d %d %d) in %@", bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawRectangle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@"drawing a Rectangle at (%d %d %d %d) in %@", bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawEgg(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@"drawing a Egg at (%d %d %d %d) in %@", bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawShapes(Shape shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; switch (shapes[i].type) &#123; case kCircle: drawCircle(shapes[i].bounds, shapes[i].fillColor); break; case kRectangle: drawRectangle(shapes[i].bounds, shapes[i].fillColor); break; case kEgg: drawEgg(shapes[i].bounds, shapes[i].fillColor); break; default: break; &#125; &#125;&#125;int main(int argc, const char * argv[]) &#123; Shape shapes[3]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0].type = kCircle; shapes[0].fillColor = kRedColor; shapes[0].bounds = rect0; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1].type = kRectangle; shapes[1].fillColor = kGreenColor; shapes[1].bounds = rect1; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2].type = kEgg; shapes[2].fillColor = kBlueColor; shapes[2].bounds = rect2; drawShapes(shapes, 3); return 0;&#125; 修改过去正常工作的代码很可能会引入新的错误。建立在函数之上，数据为函数服务。代码例子 3.2.1 Shapes-Procedural 面向对象编程 以数据为中心，函数为数据服务 代码例子 3.2.2 Shapes-Object id是一种泛型，可以用来引用任何类型的对象(id实际上是一个指向结构体的指针)。 方括号在OC中其他意义：用于通知某个对象该去做什么。[shape draw];表示通知shape对象执行draw操作 发送消息（调用方法）：通知对象执行某种操作。 类是一种能够实例化成对象的结构体。 如果在运行时改变某个类，则该类的所有对象自动继承这些变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @"red"; break; case kGreenColor: return @"green"; break; case kBlueColor: return @"blue"; break; &#125; return @"no clue";&#125;@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@"drawing a Circle at (%d %d %d %d) in %@", bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Rectangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Rectangle@implementation Rectangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@"drawing a Rectangle at (%d %d %d %d) in %@", bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Egg : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Egg@implementation Egg- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@"drawing a Egg at (%d %d %d %d) in %@", bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end// 补充一个三角形@interface Triangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Triangle@implementation Triangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@"drawing a Triangle at (%d %d %d %d) in %@", bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@endvoid drawShapes(id shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; id shape = shapes[i]; [shape draw]; &#125;&#125;int main(int argc, const char * argv[]) &#123; id shapes[4]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0] = [Circle new]; [shapes[0] setBounds:rect0]; [shapes[0] setFillColor:kRedColor]; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1] = [Rectangle new]; [shapes[1] setBounds:rect1]; [shapes[1] setFillColor:kGreenColor]; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2] = [Egg new]; [shapes[2] setBounds:rect2]; [shapes[2] setFillColor:kBlueColor]; ShapeRect rect3 = &#123;3, 4, 5, 0&#125;; shapes[3] = [Triangle new]; [shapes[3] setBounds:rect3]; [shapes[3] setFillColor:kBlueColor]; drawShapes(shapes, 4); return 0;&#125; 有关术语 class object instance message method method dispatcher interface implementation OC中的OOP123456789101112131415161718192021222324252627@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@"drawing a Circle at (%d %d %d %d) in %@", bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end @interface OC编译器需要一些有关类的信息 @ 可以看成是对C语言的扩展 instance variable(实例变量) ： @interface下的花括号的内容： 12345&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125; method declaration(方法声明)。有点像C语言中的函数原型。-表示对象方法，+表示类方法。(void)表示返回类型。 123- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw; + **infix notation**(中缀符) ： *方法的名称及其参数都是合在一起的* `[circle setFillColor: kRedColor]` 表示调用带一个参数的方法 + 如果方法使用参数，则需要冒号，否则不需要冒号 + 提倡@end语言后添加注释来注明类的名称 @implementation @implementation中可以定义在@interface中声明过和没有声明过的方法 OC中不存在真正的私有方法 实例化对象 instantiation（实例化） [Circle new] 发送new消息 软件实体应该对扩展开放，而对修改关闭。 —- 开放/关闭原则(Bertrand Meyer)]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习1：对C的扩展]]></title>
    <url>%2F2017%2Foc-basic-1-c.html</url>
    <content type="text"><![CDATA[分析最简单的Hello Objective-C程序1234567#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; NSLog(@"Hello, World!"); return 0;&#125; // main OC本质上就是C语言，它用来声明main()和返回数值的语法和C语言是一样的。 扩展名.m代表 message 与C类似，OC使用 头文件 来包含结构体、符号常量和函数原型等元素的声明。 #import类似于C的#include，但#import可保证头文件只被包含一次。 #import &lt;Foundation/Foundation.h&gt;语句告诉编译器查找Foundation框架中的Foundation.h头文件。 int argc, const char * argv[]中 argc是指命令行参数个数，argv[0]是指可执行文件的路径，argv[1]是指命令行第一个参数，argv[2]是指命令行第二个参数，以此类推。 框架 ：一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。 如Cocoa, Carbon, QuickTime, OpenGL Cocoa包括Foundation和Application Kit(AppKit) 每一个框架都有一个主头文件，它包含了框架内所有的头文件。 Foundation的头文件 1MB 14000行 100多文件 。通过#import &lt;Foundation/Foundation.h&gt; 就获得了整个集合 Xcode使用预编译头文件（一种经过压缩的，摘要形式的头文件）来加快读取速度。 NSLog()和@”字符串” NS前缀是NextSTEP（很早之前苹果公司收购的公司） NSLog()类似于C的printf() @符号是Objective-C在标准C语言基础上添加的特性，意味着引号内的字符串应作为Cocoa的NSString元素来处理 @符号可以看成之后是对C语言的扩展 布尔类型OC中的布尔值YES是1， NO是0，是与C语言中不同的。]]></content>
      <categories>
        <category>iOS</category>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 12 丰富Detail View和定制化Navigation Bar]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-12.html</url>
    <content type="text"><![CDATA[上一篇开始用Swift开发iOS 10 - 11 面向对象编程介绍对代码做了一点修改，这一篇来丰富一下详情页和定制化Navigation Bar。 重新设计详细页面 选中Main.storyboard，删除Image View和三个Label。 添加Table View，修改其大小为整个View，并且添加一些约束。设置prototype cells为1；table view cell的identifier为Cell，row height为36。 在table view的头部添加一个image view，给变其高度为300，宽度为View的宽度。 连接image view和RestaurantDetailViewController中的restaurantImageView接口。 修改Image View的content mode为 Aspect Fit，并勾选Clip to Bounds 定制 Prototype Cell 增加两个label，分别命名为Field，Value ，字体修改成自己想要的。把它们组成一个Stack View。 为Stack View添加一些约束。在cell中垂直居中；Trailing Space 和 Leading Space都为零。 用Ctrl-drag从FieldLabel到ValueLabel，选择Equal Widths，生成一个FieldLabel与ValueLabel宽度相同的约束。修改Multiplier值为0.5，就是FieldLabel的宽度是ValueLabel的一半。 新建RestaurantDetailTableViewCell类文件，继承至UITableViewCell。添加两个接口，并关联上面的两个Label。12@IBOutlet var fieldLabel:UILabel!@IBOutlet var valueLabel:UILabel! 更新 RestaurantDetailViewController 实现UITableViewDataSource和UITableViewDelegate: class RestaurantDetailViewController: UIViewController, UITableViewDataSource, UITableViewDelegate { 实现UITableViewDataSource的相关方法： 123456789101112131415161718192021222324252627282930func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 4&#125;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! RestaurantDetailTableViewCell // Configure the cell... switch indexPath.row &#123; case 0: cell.fieldLabel.text = &quot;Name&quot; cell.valueLabel.text = restaurant.name case 1: cell.fieldLabel.text = &quot;Type&quot; cell.valueLabel.text = restaurant.type case 2: cell.fieldLabel.text = &quot;Location&quot; cell.valueLabel.text = restaurant.location case 3: cell.fieldLabel.text = &quot;Been here&quot; cell.valueLabel.text = (restaurant.isVisited) ? &quot;Yes, I&apos;ve been herebefore&quot; : &quot;No&quot; default: cell.fieldLabel.text = &quot;&quot; cell.valueLabel.text = &quot;&quot; &#125; cell.backgroundColor = UIColor.clear return cell&#125; 把table view的delegate和dataSource接口设置成Restaurant Detail View Controller 。 定制table view 的样式 在RestaurantDetailViewController中添加一个接口变量，并关联storyboard中的table view。@IBOutlet var tableView:UITableView! 设置table view的背景颜色，在viewDidLoad中添加:tableView.backgroundColor = UIColor(red: 240.0/255.0, green: 240.0/255.0, blue: 240.0/255.0, alpha: 0.2)新加的颜色是亮灰色（和白色相近，可以设置成其他深颜色做对比），运行后不是整个table view都变色。这是因为，每一个cell都是重新添加的，cell的背景颜色还是默认的白色，覆盖了table view的背景颜色，要在tableView(_:cellForRowAt:)的return之前添加：cell.backgroundColor = UIColor.clear 移除table view中空cell的分割线，在viewDidLoad中添加: tableView.tableFooterView = UIView(frame: CGRect.zero) 改变分割线的颜色， 在viewDidLoad中添加:tableView.separatorColor = UIColor(red: 240.0/255.0, green: 240.0/255.0, blue: 240.0/255.0, alpha: 0.8) 定制Navigation Bar的样式通过UINavigationBar.appearance()修改Navigation Bar的样式。 Navigation Bar的样式修改是整体修改的，所以修改Navigation Bar的样式代码要写在application(_:didFinishLaunchingWithOptions:)方法中。 修改navigation bar的背景颜色：UINavigationBar.appearance().barTintColor = UIColor(red: 216.0/255.0, green: 74.0/255.0, blue: 32.0/255.0, alpha: 1.0) 修改title样式：123if let barFont = UIFont(name: &quot;Avenir-Light&quot;, size: 24.0) &#123; UINavigationBar.appearance().titleTextAttributes = [NSForegroundColorAttributeName:UIColor.white, NSFontAttributeName:barFont]&#125; Avenir-Light是字体名称，详细的iOS字体可查 http://iosfonts.com 。 tintColor控制Navigation items和bar button items的颜色UINavigationBar.appearance().tintColor = UIColor.white 目前，Navigation bar的返回按钮是一个&lt;和Food Pin，想删除Food Pin，需要修改RestaurantTableViewController的backBarButtonItem属性。 在 RestaurantTableViewController的viewDidLoad中添加： navigationItem.backBarButtonItem = UIBarButtonItem(title: &quot;&quot;, style: .plain, target: nil, action: nil) 为 detail view 的 Navigation bar 添加title，在 RestaurantDetailViewController的viewDidLoad中添加：title = restaurant.name 隐藏Navigation Bar 自从iOS 8后，Navigation Bar可以在不同情况下隐藏，在storyboard中选择Navigation Controller修改。（On Swipe是向上滑） 但这种设置整个app的Navigation Bar都会隐藏。如果只想在restaurant table view controller中隐藏，在detail view中不隐藏，就需要在两个控制器的viewDidLoad分别设置：navigationController?.hidesBarsOnSwipe = true 和 navigationController?.hidesBarsOnSwipe = false 。 运行反复测试后发现两个问题： 当从detail view返回后，restaurant table view controller的 Navigation Bar不能隐藏。 当restaurant table view controller的 Navigation Bar隐藏后进入detail view后， Navigation Bar消失不能再显示。 首先明确两个控制器中的navigationController属性指的是同一个Navigation Controller ，viewDidLoad方法是view第一次加载时调用，之后就不再调用了。 也就是说当从detail view返回，hidesBarsOnSwipe已经被设置为false，而到restaurant table view controller的viewDidLoad不再调用，所以Navigation Bar不能再隐藏。 解决办法是使用viewWillAppear，这个方法是在视图每一次显示时调用。在RestaurantTableViewController中添加：1234override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) navigationController?.hidesBarsOnSwipe = true&#125; 在RestaurantDetailViewController中添加：12345override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) navigationController?.hidesBarsOnSwipe = false navigationController?.setNavigationBarHidden(false, animated: true)&#125; 修改Status Bar样式app中Status Bar的默认样式是黑色。 在Info.plist中添加一个key为View controller-based status bar appearance，值为NO。然后application(_:didFinishLaunchingWithOptions:)中添加：UIApplication.shared.statusBarStyle = .lightContent。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 6：使用Quick Look框架预览文件(Swift)]]></title>
    <url>%2F2017%2Fios-tutorial-6-quicklook.html</url>
    <content type="text"><![CDATA[iOS SDK中有很多不常见，却非常好用的库，Quick Look框架就是一个非常好的例子。Quick Look框架提供了预览很多不同类型文件的功能，而不需要打开不同的APP查看，有点像Mac中的空格键功能。 Quick Look框架可以预览的文件类型： iWork documents (Pages, Numbers and Keynote) Microsoft Office documents (as long as they’ve been created with Office 97 or any other newer version) PDF files Images Text files Rich-Text Format documents Comma-Separated Value files (csv) 开始项目到开始项目处下载开始项目，这是原文提供了一个开始项目，代码是老版本的，需要转换一下。这个开始项目中包括了六种不同的类型的文件，一个navigation controller，一个table view controller（FileListViewController），另外还做了一些初始化工作。之后代码就在FileListViewController中完成。 文件和文件的URLS 在FileListViewController中定义一个文件名字的数组变量：let fileNames = [&quot;AppCoda-PDF.pdf&quot;, &quot;AppCoda-Pages.pages&quot;, &quot;AppCoda-Word.docx&quot;, &quot;AppCoda-Keynote.key&quot;, &quot;AppCoda-Text.txt&quot;, &quot;AppCoda-Image.jpeg&quot;] 继续定义一个数组变量，用户存储不同的文件的URL：var fileURLs = [NSURL]() 创建一个方法prepareFileURLs()，用于为fileURLs添加值： 123456789101112func prepareFileURLs() &#123; for file in fileNames &#123; // 1 let fileParts = file.components(separatedBy: &quot;.&quot;) if let fileURL = Bundle.main.url(forResource: fileParts[0], withExtension: fileParts[1]) &#123; // 2 if FileManager.default.fileExists(atPath: fileURL.path) &#123; fileURLs.append(fileURL as NSURL) &#125; &#125; &#125;&#125; 1 components(separatedBy:)方法用于把String按照给定的分隔符，分解成[String]。 2 判断文件地址是否真实存在。 在 viewDidLoad()中实现上面的函数： 12345override func viewDidLoad() &#123; ... prepareFileURLs()&#125; 展示文件用table view展示不同的文件： 根据文件的URL，获得文件名和文件后缀（文件类型），添加函数extractAndBreakFilenameInComponents(:)。 12345678910func extractAndBreakFilenameInComponents(fileURL: NSURL) -&gt; (fileName: String, fileExtension: String) &#123; let fileURLParts = fileURL.path!.components(separatedBy: &quot;/&quot;) let fileName = fileURLParts.last let filenameParts = fileName?.components(separatedBy: &quot;.&quot;) return (filenameParts![0], filenameParts![1])&#125; 修改 tableView(tableView:cellForRowAtIndexPath)： 123456789func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCellWithIdentifier(&quot;idCellFile&quot;, forIndexPath: indexPath) let currentFileParts = extractAndBreakFilenameInComponents(fileURLs[indexPath.row]) cell.textLabel?.text = currentFileParts.fileName return cell&#125; 根据不同的后缀名，定义不同的文件类型名称，添加函数getFileTypeFromFileExtension(:)： 12345678910111213141516171819202122232425func getFileTypeFromFileExtension(fileExtension: String) -&gt; String &#123; var fileType = &quot;&quot; switch fileExtension &#123; case &quot;docx&quot;: fileType = &quot;Microsoft Word document&quot; case &quot;pages&quot;: fileType = &quot;Pages document&quot; case &quot;jpeg&quot;: fileType = &quot;Image document&quot; case &quot;key&quot;: fileType = &quot;Keynote document&quot; case &quot;pdf&quot;: fileType = &quot;PDF document&quot; default: fileType = &quot;Text document&quot; &#125; return fileType&#125; 回到tableView(tableView:cellForRowAtIndexPath)，添加一段cell配置： cell.detailTextLabel?.text = getFileTypeFromFileExtension(fileExtension: currentFileParts.fileExtension) 修改每个section中row的数目为文件数目： 123func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return fileNames.count&#125; QLPreviewControllerDataSource 引入框架Quick Look​ import QuickLook 定义QLPreviewController​ let quickLookController = QLPreviewController() 让FileListViewController实现QLPreviewControllerDataSource协议 实现QLPreviewControllerDataSource协议的必须要实现的方法。第一方法表示有多少个文件需要预览： 123func numberOfPreviewItems(in controller: QLPreviewController) -&gt; Int &#123; return fileURLs.count&#125; 第二个方法：123func previewController(_ controller: QLPreviewController, previewItemAt index: Int) -&gt; QLPreviewItem &#123; return fileURLs[index]&#125; 在viewDidLoad()中添加： ​ quickLookController.dataSource = self 预览文件在table view中选中文件，就要跳转的预览页面。实现方法tableView(_:didSelectRowAt:)：123456func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; if QLPreviewController.canPreview(fileURLs[indexPath.row]) &#123; quickLookController.currentPreviewItemIndex = indexPath.row navigationController?.pushViewController(quickLookController, animated: true) &#125; &#125; navigationController?.pushViewController(quickLookController, animated: true)可用presentViewController(quickLookController, animated: true, completion: nil)代替。 运行可预览文件： 观察上图，可发现 Quick Look Preview Controller自带了toolbar，左边一个是分享按钮(通过UIActivityViewController实现的)，右边一个是类似目录功能，当有很多预览文件时，来跳转到不同预览文件。 代码QuickLookDemo 参考 Using Quick Look Framework for Previewing Documents]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-25：高级运算符(Advanced Operators)]]></title>
    <url>%2F2017%2Fswift-25-advanced-operators.html</url>
    <content type="text"><![CDATA[1 位运算符 按位取反运算符 12let initialBits: UInt8 = 0b00001111let invertedBits = ~initialBits // 等于 0b11110000 按位与运算符 123let firstSixBits: UInt8 = 0b11111100let lastSixBits: UInt8 = 0b00111111let middleFourBits = firstSixBits &amp; lastSixBits // 等于 00111100 按位或运算符 123let someBits: UInt8 = 0b10110010let moreBits: UInt8 = 0b01011110let combinedbits = someBits | moreBits // 等于 11111110 按位异或运算符 123let firstBits: UInt8 = 0b00010100let otherBits: UInt8 = 0b00000101let outputBits = firstBits ^ otherBits // 等于 00010001 按位左移、右移运算符 123456let shiftBits: UInt8 = 4 // 00000100shiftBits &lt;&lt; 1 // 00001000shiftBits &lt;&lt; 2 // 00010000shiftBits &lt;&lt; 5 // 10000000shiftBits &lt;&lt; 6 // 00000000shiftBits &gt;&gt; 2 // 00000001 使用移位运算对颜色进行RGB分解 1234let pink: UInt32 = 0xCC6699let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16 // redComponent 是 0xCC，即 204let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent 是 0x66， 即 102let blueComponent = pink &amp; 0x0000FF // blueComponent 是 0x99，即 153 有符号整数的移位运算 2 溢出运算符在默认情况下，当向一个整数赋予超过它容量的值时，Swift默认会报错，而不是生成一个无效的数。1234567var potentialOverflow = Int16.max // potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数//potentialOverflow += 1 // 这里会报错// 可以选择让系统在数值溢出的时候采取截断处理，而非报错。 `&amp;+` `&amp;-` `&amp;*`var unsignedOverflow = UInt8.max // unsignedOverflow 等于 UInt8 所能容纳的最大整数 255 unsignedOverflow = unsignedOverflow &amp;+ 1 // 此时 unsignedOverflow 等于 0var unsignedOverflow2 = UInt8.min // unsignedOverflow 等于 UInt8 所能容纳的最小整数 0unsignedOverflow2 = unsignedOverflow2 &amp;- 1 // 此时 unsignedOverflow 等于 255 3 优先级和结合性4 运算符函数运算符重载: 类和结构体可以为现有的运算符提供自定义的实现。 例子：向量的相加1234567891011121314151617181920212223242526272829303132struct Vector2D &#123; var x = 0.0, y = 0.0&#125;extension Vector2D &#123; static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y + right.y) &#125; static prefix func - (vector: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: -vector.x, y: -vector.y) &#125; static func += (left: inout Vector2D, right: Vector2D) &#123; left = left + right &#125; static func == (left: Vector2D, right: Vector2D) -&gt; Bool &#123; return (left.x == right.x) &amp;&amp; (left.y == right.y) &#125; static func != (left: Vector2D, right: Vector2D) -&gt; Bool &#123; return !(left == right) &#125;&#125;let vector = Vector2D(x: 3.0, y: 1.0)let anotherVector = Vector2D(x: 2.0, y: 4.0)let combinedVector = vector + anotherVector // combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)let negative = -vector // negative 是一个值为 (-3.0, -1.0) 的 Vector2D 实例var original = Vector2D(x: 1.0, y: 2.0)let vectorToAdd = Vector2D(x: 3.0, y: 4.0)original += vectorToAdd // original 的值现在为 (4.0, 6.0)let twoThree = Vector2D(x: 2.0, y: 3.0)let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)if twoThree == anotherTwoThree &#123; print("These two vectors are equivalent.")&#125; 5 自定义运算符1234567891011121314151617181920212223prefix operator +++extension Vector2D &#123; static prefix func +++ (vector: inout Vector2D) -&gt; Vector2D &#123; vector += vector return vector &#125;&#125;var toBeDoubled = Vector2D(x: 1.0, y: 4.0)let afterDoubling = +++toBeDoubled// toBeDoubled now has values of (2.0, 8.0)// afterDoubling also has values of (2.0, 8.0)infix operator +-: AdditionPrecedenceextension Vector2D &#123; static func +- (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y - right.y) &#125;&#125;let firstVector = Vector2D(x: 1.0, y: 2.0)let secondVector = Vector2D(x: 3.0, y: 4.0)let plusMinusVector = firstVector +- secondVector// plusMinusVector is a Vector2D instance with values of (4.0, -2.0) playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-10.html</url>
    <content type="text"><![CDATA[接着上一篇开始用Swift开发iOS 10 - 9 Table Row的删除, UITableViewRowAction和UIActivityViewController的使用的代码，继续学习Navigation Controller和Segue。 创造Navigation Controller 选中Restaurant Table View Controller然后点击菜单栏中的Editor &gt; Embed in &gt; Navigation Controller；生成了新的一Scene（Navigation Controller Scene）。 选中之前Scene中的Navigation bar，修改其title为Food Pin。 添加 Detail View Controller之前添加导航栏，现在添加另一个view controller，用来显restaurant的详细内容。 拖动一个新的View Controller。 拖动一个image View，调整合适大小，并添加相关约束。Content Mode属性修改为 Aspect Fill。 用segue连接prototype cell和detail scene。 Ctrl-drag从prototype cell到detail scene。如果不方便选择prototype cell，可以在document outline中拖动。选择Show连接风格。 iOS 10中有几种sugue类型： Show：新的view controller将被添加view controller栈的顶部。跳转的页面有Navigation bar，并且有返回原来页面的返回按钮。这是非常常用的的类型。 Show detail：在view controller栈中，新的view controller将被替代原来的view controller。跳转的页面没有Navigation bar，也没有返回原来页面的返回按钮。 Present modally：新页面将以动画形式从底部出现到覆盖整个手机屏幕。这种形式最常见的列子是iOS自带的日历应用： Present as popover：以带有箭头锚点的弹框显示。通常使用的iPad应用中 不再需要action sheet，去除tableView(_:didSelectRowAt:)方法 创建新类文件RestaurantDetailViewController，继承至UIViewController。是新建scene与RestaurantDetailViewController的联系。 在RestaurantDetailViewController中加入一个outlet和一个变量，outlet关联Image View，restaurantImage用与接受table view传来的图像名称数据。 12345678@IBOutlet var restaurantImageView:UIImageView!var restaurantImage = &quot;&quot;override func viewDidLoad() &#123; super.viewDidLoad() restaurantImageView.image = UIImage(named: restaurantImage)&#125; 通过segues传递数据segue管理view controller之间的过渡。当segue触发时，storyboard会通知源view controller（如RestaurantTableViewController）调用方法prepare(for:sender:)，可以通过此方法传递数据。 当storyboard中结构复杂时，segue可能会有很多，同一个view controller可能与各级view controller之间有segue，这种情况最好给segue一个唯一identifier。设置segue的identifier为 showRestaurantDetail。 在RestaurantTableViewController中添加prepareForSegue: 12345678override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showRestaurantDetail&quot; &#123; if let indexPath = tableView.indexPathForSelectedRow &#123; let destinationController = segue.destination as! RestaurantDetailViewController destinationController.restaurantImage = restaurantImages[indexPath.row] &#125; &#125;&#125; 为详情页面添加三个标签 添加三个标签，Text分别为Name，Location，Type（注意：虽然Text会被替代，但不要开始留空，因为留空会使之后生成stack view时，大小不确定）；三个label生成一个stack view，调整字体和大小，添加适当的约束。 添加三个outlet，和三个与之对应的变量。 12345678910111213141516@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!var nameText = &quot;&quot;var locationText = &quot;&quot;var typeText = &quot;&quot;override func viewDidLoad() &#123; super.viewDidLoad() restaurantImageView.image = UIImage(named: restaurantImage) nameLabel.text = nameText locationLabel.text = locationText typeLabel.text = typeText&#125; 修改RestaurantTableViewController中的prepareForSegue方法： 1234567891011override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showRestaurantDetail&quot; &#123; if let indexPath = tableView.indexPathForSelectedRow &#123; let destinationController = segue.destination as! RestaurantDetailViewController destinationController.restaurantImage = restaurantImages[indexPath.row] destinationController.nameText = restaurantNames[indexPath.row] destinationController.locationText = restaurantLocations[indexPath.row] destinationController.typeText = restaurantTypes[indexPath.row] &#125; &#125;&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 11 面向对象编程介绍]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-11.html</url>
    <content type="text"><![CDATA[关于面向对象编程（Object Oriented Programming ，OOP）的知识就不多介绍了，这不是一门编程语言中的概念，而是编程方法。OOP最好的一地方是，它让复杂的软件分解成一个个小的部分，方便程序员开放和管理。 这一篇文章就把上一篇文章开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue的代码整理成OOP形式。 重新修改FoodPin项目 之前在RestaurantTableViewController类中，定义了restaurantNames,restaurantImages, restaurantLocations,restaurantTypes四个数组变量，分别表示restaurant的名字，图片名称，位置，类型。每个restaurant的信息分散在四个数组中，而且数组的内容顺序要对应，现在把四个信息组成在一个类中Restaurant。 添加类文件Restaurant.swift 123456789101112131415161718import Foundationclass Restaurant &#123; var name = &quot;&quot; var type = &quot;&quot; var location = &quot;&quot; var image = &quot;&quot; var isVisited = false // 1 init(name: String, type: String, location: String, image: String, isVisited: Bool) &#123; self.name = name self.type = type self.location = location self.image = image self.isVisited = isVisited &#125;&#125; 1 自定义的初始化方法。在Swift中，类的所有变量都需要被初始化，或者声明为可选值。 用Restaurant对象数组代替RestaurantTableViewController中的几个数组变量。 var restaurants:[Restaurant] = [ Restaurant(name: &quot;Cafe Deadend&quot;, type: &quot;Coffee &amp; Tea Shop&quot;, location: &quot;HongKong&quot;, image: &quot;cafedeadend.jpg&quot;, isVisited: false), Restaurant(name: &quot;Homei&quot;, type: &quot;Cafe&quot;, location: &quot;Hong Kong&quot;, image:&quot;homei.jpg&quot;, isVisited: false), Restaurant(name: &quot;Teakha&quot;, type: &quot;Tea House&quot;, location: &quot;Hong Kong&quot;, image:&quot;teakha.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe loisl&quot;, type: &quot;Austrian / Causual Drink&quot;, location: &quot;Hong Kong&quot;, image: &quot;cafeloisl.jpg&quot;, isVisited: false), Restaurant(name: &quot;Petite Oyster&quot;, type: &quot;French&quot;, location: &quot;Hong Kong&quot;, image: &quot;petiteoyster.jpg&quot;, isVisited: false), Restaurant(name: &quot;For Kee Restaurant&quot;, type: &quot;Bakery&quot;, location: &quot;HongKong&quot;, image: &quot;forkeerestaurant.jpg&quot;, isVisited: false), Restaurant(name: &quot;Po&apos;s Atelier&quot;, type: &quot;Bakery&quot;, location: &quot;Hong Kong&quot;, image: &quot;posatelier.jpg&quot;, isVisited: false), Restaurant(name: &quot;Bourke Street Backery&quot;, type: &quot;Chocolate&quot;, location: &quot;Sydney&quot;, image: &quot;bourkestreetbakery.jpg&quot;, isVisited: false), Restaurant(name: &quot;Haigh&apos;s Chocolate&quot;, type: &quot;Cafe&quot;, location: &quot;Sydney&quot;, image: &quot;haighschocolate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Palomino Espresso&quot;, type: &quot;American / Seafood&quot;, location: &quot;Sydney&quot;, image: &quot;palominoespresso.jpg&quot;, isVisited: false), Restaurant(name: &quot;Upstate&quot;, type: &quot;American&quot;, location: &quot;New York&quot;, image: &quot;upstate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Traif&quot;, type: &quot;American&quot;, location: &quot;New York&quot;, image: &quot;traif.jpg&quot;, isVisited: false), Restaurant(name: &quot;Graham Avenue Meats&quot;, type: &quot;Breakfast &amp; Brunch&quot;, location: &quot;New York&quot;, image: &quot;grahamavenuemeats.jpg&quot;, isVisited: false), Restaurant(name: &quot;Waffle &amp; Wolf&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;NewYork&quot;, image: &quot;wafflewolf.jpg&quot;, isVisited: false), Restaurant(name: &quot;Five Leaves&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;New York&quot;,image: &quot;fiveleaves.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe Lore&quot;, type: &quot;Latin American&quot;, location: &quot;New York&quot;, image: &quot;cafelore.jpg&quot;, isVisited: false), Restaurant(name: &quot;Confessional&quot;, type: &quot;Spanish&quot;, location: &quot;New York&quot;, image: &quot;confessional.jpg&quot;, isVisited: false), Restaurant(name: &quot;Barrafina&quot;, type: &quot;Spanish&quot;, location: &quot;London&quot;, image: &quot;barrafina.jpg&quot;, isVisited: false), Restaurant(name: &quot;Donostia&quot;, type: &quot;Spanish&quot;, location: &quot;London&quot;, image: &quot;donostia.jpg&quot;, isVisited: false), Restaurant(name: &quot;Royal Oak&quot;, type: &quot;British&quot;, location: &quot;London&quot;, image: &quot;royaloak.jpg&quot;, isVisited: false), Restaurant(name: &quot;CASK Pub and Kitchen&quot;, type: &quot;Thai&quot;, location: &quot;London&quot;, image: &quot;caskpubkitchen.jpg&quot;, isVisited: false) ] 更新 tableView(_:numberOfRowsInSection:) : 1234override func tableView(_ tableView: UITableView, numberOfRowsInSectionsection: Int) -&gt; Int &#123; return restaurants.count&#125; 更新 tableView(_:cellForRowAtIndexPath:) ： 12345678910111213141516override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell // Configure the cell... cell.nameLabel.text = restaurants[indexPath.row].name cell.thumbnailImageView.image = UIImage(named: restaurants[indexPath.row].image) cell.thumbnailImageView.layer.cornerRadius = 30.0 cell.thumbnailImageView.clipsToBounds = true cell.locationLabel.text = restaurants[indexPath.row].location cell.typeLabel.text = restaurants[indexPath.row].type cell.accessoryType = restaurants[indexPath.row].isVisited ? .checkmark : .none return cell&#125; 更新tableView(_:commit:forRowAt:) : 123456override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; restaurants.remove(at: indexPath.row) &#125; tableView.deleteRows(at: [indexPath], with: .fade)&#125; 更新 tableView(_:editActionsForRowAt:) ： override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? { let shareAction = UITableViewRowAction(style: .default, title: &quot;Share&quot;, handler: { (action, indexPath) -&gt; Void in let defaultText = &quot;Just checking in at &quot; + self.restaurants[indexPath.row].name if let imageToShare = UIImage(named: self.restaurants[indexPath.row].image) { let activityController = UIActivityViewController(activityItems: [defaultText, imageToShare], applicationActivities: nil) self.present(activityController, animated: true, completion: nil) } }) let deleteAction = UITableViewRowAction(style: .default, title: &quot;Delete&quot;, handler: { (action, indexPath) -&gt; Void in self.restaurants.remove(at: indexPath.row) tableView.deleteRows(at: [indexPath], with: .fade) }) shareAction.backgroundColor = UIColor(red: 48.0/255.0, green: 173.0/255.0, blue: 99.0/255.0, alpha: 1.0) deleteAction.backgroundColor = UIColor(red: 202.0/255.0, green: 202.0/255.0, blue: 203.0/255.0, alpha: 1.0) return [deleteAction,shareAction] } RestaurantDetailViewController中的四个变量： 1234var nameText = &quot;&quot;var locationText = &quot;&quot;var typeText = &quot;&quot;var restaurantImage = &quot;&quot; 更新为：var restaurant: Restaurant! 与之对应的viewDidLoad()也修改为： override func viewDidLoad() { super.viewDidLoad() restaurantImageView.image = UIImage(named: restaurant.image) nameLabel.text = restaurant.name locationLabel.text = restaurant.location typeLabel.text = restaurant.type } 最后prepare(for:sender:)方法也做对应修改： 12345678override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showRestaurantDetail&quot; &#123; if let indexPath = tableView.indexPathForSelectedRow &#123; let destinationController = segue.destination as! RestaurantDetailViewController destinationController.restaurant = restaurants[indexPath.row] &#125; &#125;&#125; 运行没有问题。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 5：关于地理定位和特定区域(Swift)]]></title>
    <url>%2F2017%2Fios-tutorial-5.html</url>
    <content type="text"><![CDATA[用户带着iPhone进入某个区域，并在某些区域待多久在开发肯能会有很大用处。 初始化项目 创建新的项目GeoTargeting，使用Single View Appliction模板 添加一个Map View，大小为整个页面 添加相关outlet 实现两个协议 123class ViewController: UIViewController, MKMapViewDelegate, CLLocationManagerDelegate &#123; @IBOutlet weak var mapView: MKMapView! 设置CLLocationManager和MKMapView。 1234567891011121314151617// 1let locationManager = CLLocationManager()override func viewDidLoad() &#123; super.viewDidLoad() // 2 locationManager.delegate = self locationManager.distanceFilter = kCLLocationAccuracyNearestTenMeters locationManager.desiredAccuracy = kCLLocationAccuracyBest // 3 mapView.delegate = self mapView.showsUserLocation = true mapView.userTrackingMode = .follow setupData() &#125; 1 创建一个CLLocationManager的实例，用于检测用户的位置变化 2 设置locationManager一些参数，确定精确性 在viewDidAppear中核查用户授权状态1234567891011121314151617override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) let authorizationStatus = CLLocationManager.authorizationStatus() // 1 if authorizationStatus == .notDetermined &#123; locationManager.requestAlwaysAuthorization() &#125; // 2 else if authorizationStatus == .denied &#123; showAlert(&quot;Location services &quot;) &#125; // 3 else if authorizationStatus == .authorizedAlways &#123; locationManager.startUpdatingLocation() &#125;&#125; 1 如果用户授权状态是不确定，就检查是否是一直的状态。 2 如果用户授权状态是拒绝，就用弹框显示信息给用户看。showAlert(title:)是弹框函数： 1234567891011func showAlert(_ title: String) &#123; print(title) let alertController = UIAlertController(title: title, message: nil, preferredStyle: .alert) let action = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler: nil) alertController.addAction(action) present(alertController, animated: true, completion: nil) &#125; 3 如果用户授权状态是一直，就开始更新地理位置。 另外，还需要在.plist文件中添加key为NSLocationAlwaysUsageDescription的提示信息 需要一直能获取你的位置 才可以。在调用requestAlwaysAuthorization()时这个key是必须的。允许获取当前位置。 添加函数setupData()1234567891011121314151617181920212223242526272829303132333435func setupData() &#123; // 1 if CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) &#123; // 2 let title = &quot;全季酒店&quot; let coordinate = CLLocationCoordinate2DMake(31.1849700000,121.6303200000) let regionRadius = 300.0 // 3 let region = CLCircularRegion(center: CLLocationCoordinate2D(latitude: coordinate.latitude, longitude: coordinate.longitude), radius: regionRadius, identifier: title) locationManager.startMonitoring(for: region) // 4 let restaurantAnnotation = MKPointAnnotation() restaurantAnnotation.coordinate = coordinate restaurantAnnotation.title = title mapView.addAnnotation(restaurantAnnotation) // 5 let circle = MKCircle(center: coordinate, radius: regionRadius) mapView.add(circle) &#125; else &#123; print(&quot;不能追踪区域&quot;) &#125;&#125;// 6func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123; let circleRenderer = MKCircleRenderer(overlay: overlay) circleRenderer.strokeColor = UIColor.red circleRenderer.lineWidth = 1.0 return circleRenderer&#125; 1 判断是否监控区域功能是否可用。当用户拒绝状态，或用户不让app背景下刷新，或飞行模式时这个功能不可用 2 随意构建一个位置（如全季酒店），经纬度可通过经纬度查询查询，并设置区域半径regionRadius，单位是米。 3 初始化CLCircularRegion。 4 添加一个注解，类似大头针形状。 5 添加区域圆圈标志。 6 这是MKMapViewDelegate的方法，用户画圆 CLRegionCLRegion就是上面标定的圆形区域。下面添加两个CLLocationManagerDelegate的回调方法，分别在是设备的定位位置进和出标定的区域时调用。12345678// MARK:- CLLocationManagerDelegatefunc locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;)&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;)&#125; Xcode中的位置调试上面设备的位置，不可能拿着手机到处跑，Xcode提高了方便的调式方式。可以建立位置文件.GPX: xcode也提供世界上一些常用的位置文件：点击上图调试栏最后的位置标志就可以调式了。 复杂逻辑下的位置处理如果位置不停变化，在监控区域停留时间比较短，或者监控区域比较多是，处理位置问题就比较复杂了。更新部分代码：123456789101112131415161718// 1var monitoredRegions: Dictionary&lt;String, NSDate&gt; = [:] func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;) // 2 monitoredRegions[region.identifier] = NSDate()&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;) // 3 monitoredRegions.removeValue(forKey: region.identifier)&#125;// 4func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; updateRegions()&#125; 1 定义以字典用于存储用户进入监控区的时间。 2 记录进入时间。 3 删除进入时间。 4 用户位置变化后调用 加入函数updateRegions()代码：1234567891011121314151617181920func updateRegions() &#123; // 1 let regionMaxVisiting = 10.0 var regionsToDelete: [String] = [] // 2 for regionIdentifier in monitoredRegions.keys &#123; // 3 if NSDate().timeIntervalSince(monitoredRegions[regionIdentifier]! as Date) &gt; regionMaxVisiting &#123; showAlert(&quot;谢谢访问&quot;) regionsToDelete.append(regionIdentifier) &#125; &#125; // 4 for regionIdentifier in regionsToDelete &#123; monitoredRegions.removeValue(forKey: regionIdentifier) &#125;&#125; 1 加的用户到某个区域10s，就确定用户已经到访问过这个区域。regionsToDelete用来存储即将删除的区域的identifier，也就用户待过超过10s的区域。 2 遍历所有监控区域 3 timeIntervalSince用来计算某个时间到当前时间的差值，单位为秒。 4 删除用户待过超过regionMaxVisiting的区域。 代码GeoTargeting 参考 Building a Geo Targeting iOS App in Swift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 4：CALayer介绍(swift)]]></title>
    <url>%2F2017%2Fios-tutorial-4-calayer.html</url>
    <content type="text"><![CDATA[Layers是Core Animation Framework的一部分。Core Animation Framework在iOS架构的位置： 访问CALayer凡是继承至UIView的都将有一个属性layer来表示CALayer。myView.layer 初始化项目 新建CALayerDemo，single View Application模板 新建一个UIView和一个UILabel 圆角CALayer的cornerRadius属性大小表示UIView圆角处圆的半径大小。类似于box.layer.cornerRadius = 20，就形成了圆角，数字越大圆角效果越大，当cornerRadius等于box半径时，box就会变成一个园。 阴影效果1234box.layer.shadowOffset = CGSize(width: 5, height: 5)box.layer.shadowOpacity = 0.7box.layer.shadowRadius = 10box.layer.shadowColor = UIColor.blue.cgColor shadowOffset表示阴影偏移大小，也就是阴影向box的下放偏移5和向右方偏移5距离。 shadowOpacity是阴影透明度 shadowRadius是阴影涉及的半径，并且这个半径越大，阴影的颜色深浅就会越来越小。shadowRadius与shadowOffset是共同作用的 设置边的宽度和颜色12box.layer.borderColor = UIColor.black.cgColorbox.layer.borderWidth = 3 展示图片123box.layer.contents = UIImage(named: &quot;tree.jpg&quot;)?.cgImagebox.layer.contentsGravity = kCAGravityResizebox.layer.masksToBounds = true CALayer的contents属性是open var contents: Any?，可以设置为图片 contentsGravity设置成kCAGravityResize，表示contents的内容会调整大小以适应layer。如果设置成其他值可能出现大小不适的形象，比如kCAGravityBottomRight，将是： masksToBounds为true表示按照layer的边框范围显示内容；如果是false，将会是如下结果 背景颜色和透明度12box.layer.backgroundColor = UIColor.green.cgColorbox.layer.opacity = 0.5 代码CALayerDemo 参考 A Beginner’s Guide to CALayer]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-24：访问控制(Access Control)]]></title>
    <url>%2F2017%2Fswift-24-access-control.html</url>
    <content type="text"><![CDATA[可以明确地给单个类型(类、结构体、枚举)设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。为某些典型场景提供了默认的访问级别实体(entities) : 对于代码中可以设置访问级别的特性(属性、基本类型、函数等)一种统称 1 模块和源文件 模块：独立的代码单元 框架或应用程序会作为一个独立的模块来构建和发布 一个模块可以使用import关键字导入另外一个模块 Xcode的每个target(例如框架或应用程序)都被当作独立的模块处理 源文件：Swift中的源代码文件 2 访问级别（低→高） open: 类似public。可以被访问和被继承 public: 可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。可以被访问不可以被继承 internal: 可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为internal级别。 fileprivate: 限制实体只能在所在的源文件内部使用。 private: 只在定义的实体中使用 访问级别基本原则: 不可以在某个实体中定义访问级别更高的实体 函数的访问级别不能高于它的参数类型和返回类型的访问级别。 一般，默认为 internal 级别 在导入应用程序模块的语句前使用 @testable 特性，然后在允许测试的编译设置( Build Options -&gt; Enable Testability )下编译这个应用程序模块，单元测试 target 就可以访问应用程序模块中所有 internal 级别的实体。 3 访问控制语法4 自定义类型 一个类型的访问级别也会影响到类型成员(属性、方法、构造器、下标)的默认访问级别。 元组：元组的访问级别将由元组中访问级别最严格的类型来决定。 函数：函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。 枚举类型：枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。 12345678910111213141516171819public class SomePublicClass &#123; // explicitly public class public var somePublicProperty = 0 // explicitly public class member var someInternalProperty = 0 // implicitly internal class member fileprivate func someFilePrivateMethod() &#123;&#125; // explicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125;class SomeInternalClass &#123; // implicitly internal class var someInternalProperty = 0 // implicitly internal class member fileprivate func someFilePrivateMethod() &#123;&#125; // explicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125;fileprivate class SomeFilePrivateClass &#123; // explicitly file-private class func someFilePrivateMethod() &#123;&#125; // implicitly file-private class member private func somePrivateMethod() &#123;&#125; // explicitly private class member&#125;private class SomePrivateClass &#123; // explicitly private class func somePrivateMethod() &#123;&#125; // implicitly private class member&#125; 5 子类 子类的访问级别不得高于父类的访问级别。 可以在符合当前访问级别的条件下重写任意类成员(方法、属性、构造器、下标等)。 12345678public class A &#123; fileprivate func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123; super.someMethod() &#125;&#125; 6 常量、变量、属性、下标常量、变量、属性访问级别不能高于它们所属的类型。 12345678910111213141516171819202122struct TrackedString &#123; private(set) var numberOfEdits = 0 var value: String = "" &#123; didSet &#123; numberOfEdits += 1 &#125; &#125;&#125;var stringToEdit = TrackedString()stringToEdit.value = "This string will be tracked."stringToEdit.value += " This edit will increment numberOfEdits."stringToEdit.value += " So will this one."print("The number of edits is \(stringToEdit.numberOfEdits)") // 打印 “The number of edits is 3”public struct TrackedString2 &#123; public private(set) var numberOfEdits = 0 // Getter的访问级别是public，Setter的访问级别是private。 public var value: String = "" &#123; didSet &#123; numberOfEdits += 1 &#125; &#125; public init() &#123;&#125;&#125; 7 构造器 必要构造器 的访问级别必须和所属类型相同。 8 协议9 扩展10 泛型11 类型别名类型别名的访问级别不可高于其表示的类型的访问级别 playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 3：Speech Framework的简单使用]]></title>
    <url>%2F2017%2Fios-tutorial-3-speechframework.html</url>
    <content type="text"><![CDATA[在WWDC 2016时，Apple介绍了Speech framework，这是一个很有用的声音识别框架。实际上这是利用Siri进行声音识别。 初始化项目 新建SpeechToTextDemo，模板是Single View Application。 添加简单的UI 分别定义UITextView和UIButton的两个outlet，为textView和microphoneButton。 再为UIButton添加一个action：123@IBAction func microphoneTapped(_ sender: AnyObject) &#123;&#125; 使用Speech Framework import Speech 实现SFSpeechRecognizerDelegate协议 用户授权获取声音数据是要获得用户的授权的。 在ViewController类中定义一个变量，作为语音识别器。参数identifier是识别的语种，可参考这个列表，中文是“ zh_Hans_CN”。private let speechRecognizer = SFSpeechRecognizer(locale: Locale.init(identifier: &quot;zh_Hans_CN&quot;)) 在viewDidLoad()中： 1234567891011121314151617181920212223242526272829override func viewDidLoad() &#123; super.viewDidLoad() // 1 microphoneButton.isEnabled = false speechRecognizer?.delegate = self // 2 SFSpeechRecognizer.requestAuthorization&#123; (authStatus) in var isButtionEnabled = false switch authStatus &#123; case .authorized: isButtionEnabled = true case .denied: isButtionEnabled = false print(&quot;用户拒绝接受语音识别&quot;) case .notDetermined: isButtionEnabled = false print(&quot;语音识别功能没有经过认可&quot;) case .restricted: isButtionEnabled = false print(&quot;当前设备不能语音识别&quot;) &#125; self.microphoneButton.isEnabled = isButtionEnabled &#125; startRecording()&#125; 1 默认按钮设成不可用 2 授权结果回调 Apple需要每个app如要用户授权时，都应该定制一个反馈信息（info.plist）。在info.plist中添加两个key，分别是麦克风和语音识别的授权，Privacy - Microphone Usage Description和Privacy - Speech Recognition Usage Description。 处理语音识别 在ViewController类中添加三个变量 123private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest? //识别请求private var recognitionTask: SFSpeechRecognitionTask? // 提供识别请求的结果private let audioEngine = AVAudioEngine() // SFSpeechAudioBufferRecognitionRequest对象处理语音识别的请求，代表语音进入语音识别器。 SFSpeechRecognitionTask 识别任务，用于操作识别器的停止和开始 AVAudioEngine 语音引擎，提供语音输出 创建新函数startRecording()，这个函数在点击button后调用，也就是microphoneTapped(:)中最后调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162func startRecording() &#123; // 1 if recognitionTask != nil &#123; recognitionTask?.cancel() recognitionTask = nil &#125; // 2 let audioSession = AVAudioSession.sharedInstance() do &#123; try audioSession.setCategory(AVAudioSessionCategoryRecord) try audioSession.setMode(AVAudioSessionModeMeasurement) try audioSession.setActive(true, with: .notifyOthersOnDeactivation) &#125; catch &#123; print(&quot;audioSession的属性设置失败&quot;) &#125; // 3 recognitionRequest = SFSpeechAudioBufferRecognitionRequest() // 4 guard let inputNode = audioEngine.inputNode else &#123; fatalError(&quot;Audio engine has no input node&quot;) &#125; // 5 guard let recognitionRequest = recognitionRequest else &#123; fatalError(&quot;Unable to create an SFSpeechAudioBufferRecognitionRequest object&quot;) &#125; // 6 recognitionRequest.shouldReportPartialResults = true // 7 recognitionTask = speechRecognizer?.recognitionTask(with: recognitionRequest, resultHandler: &#123; (result, error) in var isFinal = false if result != nil &#123; self.textView.text = result?.bestTranscription.formattedString isFinal = (result?.isFinal)! &#125; if error != nil || isFinal &#123; self.audioEngine.stop() inputNode.removeTap(onBus: 0) self.recognitionRequest = nil self.recognitionTask = nil self.microphoneButton.isEnabled = true &#125; &#125;) let recordingFormat = inputNode.outputFormat(forBus: 0) inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) &#123; (buffer, when) in self.recognitionRequest?.append(buffer) &#125; audioEngine.prepare() do &#123; try audioEngine.start() &#125; catch &#123; print(&quot;audioEngine couldn&apos;t start beacause of an error.&quot;) &#125; textView.text = &quot;Say something, I&apos;m listening!&quot;&#125; 1 开始录音时的初始化 2 AVAudioSession提供语音录音，设置一些参数 3 初始化SFSpeechAudioBufferRecognitionRequest 4 核查audioEngine是否可用 5 核查recognitionRequest 7 检测的音频后的回调方法，也就是开始录音后，有音频进入后都调用 语音识别的开关 实现代理方法speechRecognizer(_:availabilityDidChange:)。这个方法在语音识别器可用性发生变化时被调用。 1234567func speechRecognizer(_ speechRecognizer: SFSpeechRecognizer, availabilityDidChange available: Bool) &#123; if available &#123; microphoneButton.isEnabled = true &#125; else &#123; microphoneButton.isEnabled = false &#125;&#125; 点击button时的操作： 1234567891011@IBAction func microphoneTapped(_ sender: AnyObject) &#123; if audioEngine.isRunning &#123; audioEngine.stop() recognitionRequest?.endAudio() microphoneButton.isEnabled = false microphoneButton.setTitle(&quot;Start Recording&quot;, for: .normal) &#125; else &#123; startRecording() microphoneButton.setTitle(&quot;Stop Recording&quot;, for: .normal) &#125; &#125; 总结语音识别在iPhone的自带键盘中有这个功能，中文识别率很高，如果不高兴或不方便打字，很方便使用。 代码SpeechToTextDemo 参考： Building a Speech-to-Text App Using Speech Framework in iOS 10]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-23：泛型(Generics)]]></title>
    <url>%2F2017%2Fswift-23-generics.html</url>
    <content type="text"><![CDATA[泛型是 Swift 最强大的特性之一，许多 Swift 标准库是通过泛型代码构建的。例如， Swift 的数组和字典都是泛型集合。你可以创建一个存有整型值或者字符串值的数组，有必要的话，还可以创建一个任何 Swift 支持类型的数组。类似的，你也可以创建一个字典用于存储任意指定类型的值。 1 泛型函数T是一个占位类型，其他字母也可以，只要在尖括号中就行。可以理解为：在定义的时候还不知道是啥类型，那就假设是T类型，等到调用时，给过来什么类型的参数，那T就是上面类型。12345678910111213func swapValue&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let tmp = a a = b b = tmp&#125;var a = 1var b = 3swapValue(&amp;a, &amp;b)print(a,b)var s1 = "word"var s2 = "单词"swapValue(&amp;s1, &amp;s2)print(s1, s2) 2 类型参数T就是类型参数。可以定义多个类型参数。 3 命名类型参数：就是把类型参数命名为一个容易阅读的名字（大写字母开头的驼峰命名法）。12Dictionary&lt;Key, Value&gt;Array&lt;Element&gt; 4 泛型类型1234567891011121314struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125;&#125;var stackOfStrings = Stack&lt;String&gt;()stackOfStrings.push(item: "uno")stackOfStrings.push(item: "dos")stackOfStrings.push(item: "tres")stackOfStrings.push(item: "cuatro") 5 扩展一个泛型类型不需要在扩展的定义中提供类型参数列表。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。12345extension Stack &#123; var topItem: Element? &#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125; 6 类型约束：指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。1234567891011func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // 这里是泛型函数的函数体部分&#125;func findIndex&lt;T&gt;(array: [T], _ valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 不是所有的 Swift类型都可以用等式符(==)进行比较。Swift标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符( == )及不等符( != )。 12345678func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; 7 关联类型关联类型为协议中的 某个类型提供了一个占位名(或者说别名)，其代表的实际类型在协议被采纳时才会被指定。1234567891011121314151617181920212223242526protocol Container &#123; associatedtype ItemType mutating func append(item: ItemType) var count: Int &#123; get &#125; subscript(i: Int) -&gt; ItemType &#123; get &#125;&#125;struct Stack2&lt;Element&gt;: Container &#123; // Stack&lt;Element&gt; 的原始实现部分 var items = [Element]() mutating func push(item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; // Container 协议的实现部分 mutating func append(item: Element) &#123; self.push(item: item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Element &#123; // swift 可以推断出ItemType就是Element return items[i] &#125;&#125; playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-22：协议(Protocols)]]></title>
    <url>%2F2017%2Fswift-22-protocols.html</url>
    <content type="text"><![CDATA[协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。类、结构体或枚举都可以采纳协议，并为协议定义的这些要求提供具体实现。xx conform xxx protocol (xx“符合”xxx协议) 1 属性要求可以要求提供特定名称和类型的实例属性或类型属性12345678910111213141516171819202122232425protocol SomeProtocol &#123; var mustBeSettable: Int &#123; get set &#125; var doesNotNeedToBeSettable: Int &#123; get &#125;&#125;protocol AnotherProtocol &#123; static var someTypeProperty: Int &#123; get set &#125;&#125;protocol FullyNamed &#123; var fullName: String &#123; get &#125;&#125;struct Person: FullyNamed &#123; var fullName: String&#125;let john = Person(fullName: "John Appleseed")class Starship: FullyNamed &#123; var prefix: String? var name: String init(name: String, prefix: String? = nil) &#123; self.name = name self.prefix = prefix &#125; var fullName: String &#123; return (prefix != nil ? prefix! + " " : "") + name &#125;&#125; 2 方法要求不需要大括号和方法体; 不支持为协议中的方法的参数提供默认值123456protocol SomeProtocol2 &#123; static func someTypeMethod()&#125;protocol RandomNumberGenerator &#123; func random() -&gt; Double&#125; 线性同余生成器(linear congruential generator)的伪随机数算法。1234567891011class LinearCongruentialGenerator: RandomNumberGenerator &#123; var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -&gt; Double &#123; // a.truncatingRemainder(dividingBy:m) = b 相当于 x*m + b = a。（a是浮点数，x是整数） lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m)) return lastRandom / m &#125;&#125; 3 Mutating 方法要求实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。12345678910111213141516protocol Togglable &#123; mutating func toggle()&#125;enum OnOffSwitch: Togglable &#123; case Off, On mutating func toggle() &#123; switch self &#123; case .Off: self = .On case .On: self = .Off &#125; &#125;&#125;var lightSwitch = OnOffSwitch.OfflightSwitch.toggle() 4 构造器要求12345678protocol SomeProtocol3 &#123; init(someParameter: Int)&#125;class SomeClass: SomeProtocol3 &#123; required init(someParameter: Int) &#123; // 必须要加required &#125;&#125; 5 协议作为类型1 作为函数、方法或构造器中的参数类型或返回值类型2 作为常量、变量或属性的类型3 作为数组、字典或其他容器中的元素类型 12345678910111213141516171819class Dice &#123; // 骰子 let sides: Int let generator: RandomNumberGenerator init(sides: Int, generator: RandomNumberGenerator) &#123; self.sides = sides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(generator.random() * Double(sides)) + 1 &#125;&#125;var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())for _ in 1...5 &#123; print("Random dice roll is \(d6.roll())")&#125;let a = 8.625a.truncatingRemainder(dividingBy: 0.75)let b = 5.5b.truncatingRemainder(dividingBy: 3) 6 委托(代理)模式委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。委托模式的实现: 定义协议来封装那些需要被委托的功能，这样就能确保采纳协议的类型能提供这些功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960protocol DiceGame &#123; var dice: Dice &#123; get &#125; func play()&#125;protocol DiceGameDelegate &#123; func gameDidStart(game: DiceGame) func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll:Int) func gameDidEnd(game: DiceGame)&#125;class SnakesAndLadders: DiceGame &#123; let finalSquare = 25 let dice = Dice(sides: 6, generator: LinearCongruentialGenerator()) var square = 0 var board: [Int] init() &#123; board = [Int](repeating: 0, count: finalSquare + 1) board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02 board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08 &#125; var delegate: DiceGameDelegate? func play() &#123; square = 0 delegate?.gameDidStart(game: self) gameLoop: while square != finalSquare &#123; let diceRoll = dice.roll() delegate?.game(game: self, didStartNewTurnWithDiceRoll: diceRoll) switch square + diceRoll &#123; case finalSquare: break gameLoop case let newSquare where newSquare &gt; finalSquare: continue gameLoop default: square += diceRoll square += board[square] &#125; &#125; delegate?.gameDidEnd(game: self) &#125;&#125;class DiceGameTracker: DiceGameDelegate &#123; var numberOfTurns = 0 func gameDidStart(game: DiceGame) &#123; numberOfTurns = 0 if game is SnakesAndLadders &#123; print("Started a new game of Snakes and Ladders") &#125; print("The game is using a \(game.dice.sides)-sided dice") &#125; func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) &#123; numberOfTurns += 1 print("Rolled a \(diceRoll)") &#125; func gameDidEnd(game: DiceGame) &#123; print("The game lasted for \(numberOfTurns) turns") &#125;&#125;let tracker = DiceGameTracker()let game = SnakesAndLadders()game.delegate = trackergame.play() 7 通过扩展添加协议一致性通过扩展令已有类型采纳并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。12345678910protocol TextRepresentable &#123; var textualDescription: String &#123; get &#125;&#125;extension Dice: TextRepresentable &#123; var textualDescription: String &#123; return "A \(sides)-sided dice" &#125;&#125;let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())print(d12.textualDescription) 8 通过扩展采纳协议当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空扩展体的扩展来采纳该协议123456789struct Hamster &#123; var name: String var textualDescription: String &#123; return "A hamster named \(name)" &#125;&#125;extension Hamster: TextRepresentable &#123;&#125;let simonTheHamster = Hamster(name: "Simon")let somethingTextRepresentable: TextRepresentable = simonTheHamster 9 协议类型的集合1234let things: [TextRepresentable] = [ d12, simonTheHamster] for thing in things &#123; print(thing.textualDescription)&#125; 10 协议的继承123protocol PrettyTextRepresentable: TextRepresentable &#123; var prettyTextualDescription: String &#123; get &#125;&#125; 11 类类型专属协议12345protocol SomeClassOnlyProtocol: class &#123; // 只能类可以实现这个协议 &#125;//struct SomeStruct: SomeClassOnlyProtocol &#123;//&#125; 12 协议合成12345678910111213141516protocol Named &#123; var name: String &#123; get &#125;&#125;protocol Aged &#123; var age: Int &#123; get &#125;&#125;struct Person2: Named, Aged &#123; var name: String var age: Int&#125;// 参数celebrator的类型是`Named &amp; Aged`，意味着它不关心参数的具体类型，只要参数符合这两个协议即可func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123; print("Happy birthday, \(celebrator.name), you're \(celebrator.age)!")&#125;let birthdayPerson = Person2(name: "Malcolm", age: 21)wishHappyBirthday(to: birthdayPerson) 13 检查协议一致性检查和转换到某个协议类型在语法上和类型的检查和转换完全相同: • is 用来检查实例是否符合某个协议，若符合则返回 true ，否则返回 false 。 • as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil 。 • as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。 1234567891011121314151617181920212223242526272829protocol HasArea &#123; var area: Double &#123; get &#125;&#125;class Circle: HasArea &#123; let pi = 3.1415927 var radius: Double var area: Double &#123; return pi * radius * radius &#125; init(radius: Double) &#123; self.radius = radius &#125;&#125;class Country: HasArea &#123; var area: Double init(area: Double) &#123; self.area = area &#125;&#125;class Animal &#123; var legs: Int init(legs: Int) &#123; self.legs = legs &#125;&#125;let objects: [AnyObject] = [ Circle(radius: 2.0), Country(area: 243_610), Animal(legs: 4)]for object in objects &#123; if let objectWithArea = object as? HasArea &#123; print("Area is \(objectWithArea.area)") &#125; else &#123; print("Something that doesn't have an area") &#125;&#125; 14 可选的协议要求12345678910111213141516171819202122232425import Foundation@objc protocol CounterDataSource &#123; @objc optional func increment(forCount count: Int) -&gt; Int @objc optional var fixedIncrement: Int &#123; get &#125;&#125;class Counter &#123; var count = 0 var dataSource: CounterDataSource? func increment() &#123; if let amount = dataSource?.increment?(forCount: count) &#123; count = count + amount &#125; else if let amount = dataSource?.fixedIncrement &#123; count = count + amount &#125; &#125;&#125;class ThreeSource: NSObject, CounterDataSource &#123; let fixedIncrement = 3&#125;var counter = Counter()counter.dataSource = ThreeSource()for _ in 1...4 &#123; counter.increment() print(counter.count)&#125; 15 协议扩展协议可以通过扩展来为采纳协议的类型提供属性、方法以及下标的实现。12345678extension RandomNumberGenerator &#123; func randomBool() -&gt; Bool &#123; return random() &gt; 0.5 &#125;&#125;let generator = LinearCongruentialGenerator()print("Here's a random number: \(generator.random())")print("And here's a random Boolean: \(generator.randomBool())") 提供默认实现。如果符合PrettyTextRepresentable协议某个类、结构体或枚举，有属性prettyTextualDescription的实现，那属性prettyTextualDescription的结果就是这个实现，否则就会使用扩展当中的实现。12345extension PrettyTextRepresentable &#123; var prettyTextualDescription: String &#123; return textualDescription &#125;&#125; 为协议扩展添加限制条件1234567891011extension Collection where Iterator.Element: TextRepresentable &#123; var textualDescription: String &#123; let itemsAsText = self.map &#123; $0.textualDescription &#125; return "[" + itemsAsText.joined(separator: ", ") + "]" &#125;&#125;let murrayTheHamster = Hamster(name: "Murray")let morganTheHamster = Hamster(name: "Morgan")let mauriceTheHamster = Hamster(name: "Maurice")let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]print(hamsters.textualDescription) playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[swift的文档注释]]></title>
    <url>%2F2017%2Fswift-document.html</url>
    <content type="text"><![CDATA[在Xcode中Quick Help 为开发者提供方便快捷的简洁文档查看方式。option+点击查看弹框，option+command+2在检查器中查看。swift的中有两种注释方式，让Xcode在Quick Help中显示。这种注释可以认为是将文档以某种规范的格式嵌入在实际代码的上方，这样就可以通过某些工具自动生成漂亮的文档文件。这种内嵌式的文档在现代编程中是很普遍的。在swift中，这两种注释方式是： /** */ /// 这些注释中还可以有其他一些规范 可以支持markdown 关键词 三个关键词：parameter， returns， throws。这三个关键词会在最左边显示。 还有一些关键词会被提取到description中作为一些特殊字段显示，其他都会在description正常显示：author, authors, copyright, date；since, version；attention, important, note, remark, warning；bug, TODO, experiment； complexity； precondition, postcondition, requires, invariant see* 参考http://swifter.tips/documentation/http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 2：用Core Image进行面部识别(Swift)]]></title>
    <url>%2F2017%2Fios-tutorial-2-facerecognition.html</url>
    <content type="text"><![CDATA[面部识别API不仅可以是识别面部，也可识别面部的特殊细节，例如微笑甚至眨眼睛。 建立初始项目原文建好了初始项目，我自己新建了初始项目 新建项目Detector 删除IB中原本View Controller Scene。 拖动UITabBarController到IB中，得到三个Scene。选择UITabBarController的Is Initial View Controller，使其作为初始控制器。 修改Item 1的title和其Bar Item都为Photo，修改其Class为ViewController。 向Assets中添加几张人物图片 想Photo Scene中添加一个Image View，Content Mode改为Aspect Fit，选择一个图片。在ViewController添加图片对应@IBOutlet：@IBOutlet var personPic: UIImageView! 选中Item 2，点击菜单栏EDitor &gt; Embed In &gt; Navigation Controller，新生成一个与之关联的Scene。 新建CameraViewController类，继承至UIViewController。修改上面生成的Scene的Class属性为CameraViewController。 拖动一个UIBarButtonItem到Camera View Controller Scene的UINavigationItem的右边，并选择System Item为Camera 在CameraViewController中建立outlet和Action 识别照片的面部 在 ViewController.swift中引入CoreImage:import CoreImage 在 ViewController.swift中添加函数detect(): 12345678910111213141516171819202122232425262728293031func detect() &#123; // 1 guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; // 2 let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // 3 for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) let faceBox = UIView(frame: face.bounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) // 4 if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 1 根据UIImage获取CoreImage中图片对象。guard与if功能类似，区别可查看以撸代码的形式学习Swift-5：Control Flow的6 guard 与 if。 2 初始化检测器CIDetector， accuray是检查器配置选项，表示精确度；因为CIDetector可以进行几种类型的检测，所以CIDetectorTypeFace用来表示面部检测；features方法返回具体的检测结果 3 给每个检测到的脸添加红色框 4 检测是否有左眼位置 在viewDidLoad中添加 detect()，运行结果类似： 打印结果，显示检测到的面部位置是不对的：Found bounds are (177.0, 416.0, 380.0, 380.0)这是因为UIKit的坐标系统与Core Image的坐标系统是不同的： 把Core Image的坐标系统转换为UIKit的坐标系统，修改detect()为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func detect() &#123; guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // let ciImageSize = personciImage.extent.size var transform = CGAffineTransform(scaleX: 1, y: -1) transform = transform.translatedBy(x: 0, y: -ciImageSize.height) for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) // Apply the transform to convert the coordinates var faceViewBounds = face.bounds.applying(transform) // Calculate the actual position and size of the rectangle in the image view let viewSize = personPic.bounds.size let scale = min(viewSize.width / ciImageSize.width, viewSize.height / ciImageSize.height) let offsetX = (viewSize.width - ciImageSize.width * scale) / 2 let offsetY = (viewSize.height - ciImageSize.height * scale) / 2 faceViewBounds = faceViewBounds.applying(CGAffineTransform(scaleX: scale, y: scale)) faceViewBounds.origin.x += offsetX faceViewBounds.origin.y += offsetY let faceBox = UIView(frame: faceViewBounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 运行可看到正确识别位置： 相机拍照后的脸部识别之前是项目中照片识别，现在是拍完照再识别，原理是相同的，就是多一个拍完照，取照片的过程。 更新CameraViewController类的代码 1234567891011121314151617181920212223242526272829303132333435363738// 1class CameraViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate &#123; @IBOutlet var imageView: UIImageView! // 2 let imagePicker = UIImagePickerController() override func viewDidLoad() &#123; super.viewDidLoad() imagePicker.delegate = self &#125; @IBAction func takePhoto(_ sender: AnyObject) &#123; // 3 if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; imagePicker.allowsEditing = false imagePicker.sourceType = .camera present(imagePicker, animated: true, completion: nil) &#125; // 4 //MARK: -UIImagePickerControllerDelegate func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage &#123; imageView.contentMode = .scaleAspectFit imageView.image = pickedImage &#125; dismiss(animated: true, completion: nil) self.detect() &#125; // 5 func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil) &#125;&#125; 1 实现UIImagePickerControllerDelegate协议，用于拍照相关代理。 2 初始化UIImagePickerController。UIImagePickerController是照相或摄影界面和功能管理的类。 3 判断设备照相机是否可用。 4 实现一个UIImagePickerControllerDelegate中的代理方法，当拍摄完备确实使用照片时调用。 5 也是UIImagePickerControllerDelegate中的代理方法，取消拍摄时调用。 添加detect()代码，与ViewController中不同的是，不用红色框框处识别出的面部，而是识别出面部的细节，并用UIAlertController弹出显示。 1234567891011121314151617181920212223242526272829303132333435363738394041func detect() &#123; let imageOptions = NSDictionary(object: NSNumber(value: 5) as NSNumber, forKey: CIDetectorImageOrientation as NSString) let personciImage = CIImage(cgImage: imageView.image!.cgImage!) let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage, options: imageOptions as? [String : AnyObject]) if let face = faces?.first as? CIFaceFeature &#123; print(&quot;found bounds are \(face.bounds)&quot;) var message = &quot;有个脸&quot; if face.hasSmile &#123; print(&quot;脸是笑的&quot;) message += &quot;,脸是笑的&quot; &#125; if face.hasMouthPosition &#123; print(&quot;有嘴唇&quot;) message += &quot;,有嘴唇&quot; &#125; if face.hasLeftEyePosition &#123; print(&quot;左眼镜的位置是 \(face.leftEyePosition)&quot;) message += &quot;,左眼镜的位置是 \(face.leftEyePosition)&quot; &#125; if face.hasRightEyePosition &#123; print(&quot;右眼镜的位置是 \(face.rightEyePosition)&quot;) message += &quot;,右眼镜的位置是 \(face.rightEyePosition)&quot; &#125; let alert = UIAlertController(title: &quot;嘿嘿&quot;, message: message, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; else &#123; let alert = UIAlertController(title: &quot;没脸了&quot;, message: &quot;没有检测到脸&quot;, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; &#125; 运行就可以识别照片的面部具体细节CIFaceFeature还提供了其他很多面部细节：1234567891011121314151617181920212223242526272829open var hasLeftEyePosition: Bool &#123; get &#125;open var leftEyePosition: CGPoint &#123; get &#125;open var hasRightEyePosition: Bool &#123; get &#125;open var rightEyePosition: CGPoint &#123; get &#125;open var hasMouthPosition: Bool &#123; get &#125;open var mouthPosition: CGPoint &#123; get &#125;open var hasTrackingID: Bool &#123; get &#125;open var trackingID: Int32 &#123; get &#125;open var hasTrackingFrameCount: Bool &#123; get &#125;open var trackingFrameCount: Int32 &#123; get &#125;open var hasFaceAngle: Bool &#123; get &#125;open var faceAngle: Float &#123; get &#125;open var hasSmile: Bool &#123; get &#125;open var leftEyeClosed: Bool &#123; get &#125;open var rightEyeClosed: Bool &#123; get &#125; 代码Detector 参考：Face Detection in iOS Using Core Image]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-21：扩展(Extensions)]]></title>
    <url>%2F2017%2Fswift-21-extensions.html</url>
    <content type="text"><![CDATA[为一个已有的类、结构体、枚举类型或者协议类型添加新功能。包括在没有权限获取原始源代码的情况下扩展类型的能力(即逆向建模)扩展可以为一个类型添加新的功能，但是不能重写已有的功能。 1 扩展的语法(Extension Syntax)1234567extension SomeType &#123; // 为 SomeType 添加的新功能写到这里&#125;// 扩展一个已有类型，使其实现一些协议。extension SomeType: SomeProtocol, AnotherProctocol &#123; // 协议实现写到这里&#125; 如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。 2 计算型属性(Computed Properties) 12345678extension Double &#123; var km: Double &#123; return self * 1_000.0 &#125; var m : Double &#123; return self &#125; var cm: Double &#123; return self / 100.0 &#125; var mm: Double &#123; return self / 1_000.0 &#125; var ft: Double &#123; return self / 3.28084 &#125;&#125;let oneInch = 25.4.mm 扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。 3 构造器(Initializers)1234567891011121314151617181920struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size()&#125;let defaultRect = Rect()let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))extension Rect &#123; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125;let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0)) 4 方法(Methods)1234567891011extension Int &#123; func repetitions(task: () -&gt; Void) &#123; // 将闭包中的任务执行整数对应的次数 for _ in 0..&lt;self &#123; task() &#125; &#125;&#125;5.repetitions(task: &#123; print("Hello!")&#125;) 可变实例方法(Mutating Instance Methods)1234567extension Int &#123; mutating func square() &#123; self = self * self &#125;&#125;var someInt = 3someInt.square() // 不能直接用字面量`3.square()` 5 下标(Subscripts)12345678910extension Int &#123; subscript(digitIndex: Int) -&gt;Int &#123; var decimalBase = 1 for _ in 0..&lt;digitIndex &#123; decimalBase *= 10 &#125; return (self/decimalBase) % 10 &#125;&#125;12345678[2] 6 嵌套类型(Nested Types)1234567891011121314151617181920212223242526272829extension Int &#123; enum Kind &#123; case Negative, Zero, Positive &#125; var kind: Kind &#123; switch self &#123; case 0: return .Zero case let x where x &gt; 0: return .Positive default: return .Negative &#125; &#125;&#125;func printIntegerKinds(numbers: [Int]) &#123; for number in numbers &#123; switch number.kind &#123; case .Negative: print("- ", terminator: "") case .Zero: print("0 ", terminator: "") case .Positive: print("+ ", terminator: "") &#125; &#125; print("")&#125;printIntegerKinds(numbers: [3, 19, -27, 0, -6, 0, 7]) playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 9 Table Row的删除, UITableViewRowAction和UIActivityViewController的使用]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-9.html</url>
    <content type="text"><![CDATA[上一篇开始用Swift开发iOS 10 - 8 Table View和UIAlertController的交互是Table Row选择的操作，这一篇继续上一篇的代码实现删除操作。 滑动删除 实现UITableViewDataSource中相应方法：123override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; &#125; 此时滑动有删除按钮： 删除数据123456789override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; restaurantNames.remove(at: indexPath.row) restaurantLocations.remove(at: indexPath.row) restaurantTypes.remove(at: indexPath.row) restaurantIsVisited.remove(at: indexPath.row) restaurantImages.remove(at: indexPath.row) &#125;&#125; UITableViewCellEditingStyle有两种insert和delete。运行后发现删除动作后，相应的table view row被没有消失，因为上面的删除只是删除了相应数组中的数据，并没有在视图上显示，如要重新加载才会删除。 重新加载UITableView在tableView(_:commit:forRowAt:)后添加：tableView.reloadData()另外，更好的刷新table view的方法是使用UITableView的deleteRows(at:with:)方法，还有动画效果：tableView.deleteRows(at: [indexPath], with: .fade) 用UITableViewRowAction为滑动产生更多动作1234567891011121314151617181920212223override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? &#123; // 1 let shareAction = UITableViewRowAction(style: .default, title: &quot;Share&quot;, handler: &#123; (action, indexPath) -&gt; Void in // 3 let defaultText = &quot;Just checking in at &quot; + self.restaurantNames[indexPath.row] let activityController = UIActivityViewController(activityItems: [defaultText], applicationActivities: nil) self.present(activityController, animated: true, completion: nil) &#125;) // 1 let deleteAction = UITableViewRowAction(style: .default, title: &quot;Delete&quot;, handler: &#123; (action, indexPath) -&gt; Void in self.restaurantNames.remove(at: indexPath.row) self.restaurantLocations.remove(at: indexPath.row) self.restaurantTypes.remove(at: indexPath.row) self.restaurantIsVisited.remove(at: indexPath.row) self.restaurantImages.remove(at: indexPath.row) &#125;) // 2 return [deleteAction, shareAction] &#125; 1 UITableViewRowAction的用法和UIAlertAction类似。style相同，具体功能是在回调闭包中实现的。 UIActivityViewController继承是UIViewController，提供一些服务，例如拷贝到剪贴板，分享内容到社交媒体，通过Messages发送项目等。 一旦实现了tableView(_:editActionsForRowAt:)方法，tableView(_:commit:forRowAt:)方法产生delete按钮将不再产生，所以要在tableView(_:commit:forRowAt:)中添加delete按钮。 2 返回的UITableViewRowAction的数组，action的显示顺序是，按照数组的顺序在屏幕从有到左显示。 3 defaultText是分享的内容，不仅可以是文本，也可以添加图片对象UIImage。此处代码修改一下：12345let defaultText = &quot;Just checking in at &quot; + self.restaurantNames[indexPath.row]if let imageToShare = UIImage(named: self.restaurantImages[indexPath.row]) &#123; let activityController = UIActivityViewController(activityItems: [defaultText, imageToShare], applicationActivities: nil) self.present(activityController, animated: true, completion: nil)&#125; 定制UITableViewRowAction可以修改背景颜色：1234shareAction.backgroundColor = UIColor(red: 48.0/255.0, green: 173.0/255.0, blue: 99.0/255.0, alpha: 1.0) deleteAction.backgroundColor = UIColor(red: 202.0/255.0, green: 202.0/255.0, blue: 203.0/255.0, alpha: 1.0) 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 8 Table View和UIAlertController的交互]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-8.html</url>
    <content type="text"><![CDATA[继续上一部分开始用Swift开发iOS 10 - 7 定制Table Views项目FoodPin的代码，添加两个功能： 点击cell时，产生弹框，弹框中有两个功能选项 Call 和 Check-in 当点击Check-in选项时，为cell加上对号 理解UITableViewDelegate协议代理模式在iOS编程中非常常见的。每个代理负责特定的角色或任务，维持系统的简单和干净。当一个对象需要完成特定任务时，可以依靠另一个对象完成。这在软件设计模式中通常叫做“separation of concerns”。UITableViewController就应用了代理模式。两个协议完成不同的任务。UITableViewDataSource协议负责提供和管理table的数据。UITableViewDelegate协议负责设置table的section headings 和 footers，以及操作cell selections和cell recording。 阅读文档 怎么知道UITableViewDelegate中有那些方法呢？ 阅读Apple的官方iOS开发文档(https://developer.apple.com/library/ios/))。作为iOS开发者，需要经常阅读API 文档。目前没有单个的书籍可覆盖所有iOS SDK。 Xcode中提供方便的查看文档的方法，在相关代码处option+点击，出现弹框展示文档简介，再在弹框上点击相关代码就直接进入详细文档处。文档对不同方法进行了分类，比如UITableViewDelegate的文档就有上面提到的Managing Selections：12func tableView(UITableView, willSelectRowAt: IndexPath)func tableView(UITableView, didSelectRowAt: IndexPath) 实现协议中管理列选项方法 在RestaurantTableViewController类中实现tableView(_:didSelectRowAt:)方法： 123456789101112override func tableView(_ tableView: UITableView, didSelectRowAt indexPath:IndexPath) &#123; // 1 let optionMenu = UIAlertController(title: nil, message: &quot;What do you wantto do?&quot;, preferredStyle: .actionSheet) // 2 let cancelAction = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler:nil) optionMenu.addAction(cancelAction) // 3 present(optionMenu, animated: true, completion: nil)&#125; 1 创建了UIAlertController。UIAlertController是从iOS8被引入，用来替代以前的UIAlertView和UIActionSheet，向用户弹出警示信息；preferredStyle参数有两个值：.actionSheet 和 .alert，表示替代的两种样式。 2 创建一个cancel样式的UIAlertAction。UIAlertController的警示弹出框一般是由最上面的title+message（都不是非必须的）和一些Action组成，cancel action在最下面。 3 present是UIViewController中的方法，用于展示。 添加Actions到ALert Controller中 Call action1234567891011let callActionHandler = &#123; (action:UIAlertAction!) -&gt; Void in let alertMessage = UIAlertController(title: &quot;Service Unavailable&quot;, message:&quot;Sorry, the call feature is not available yet. Please retry later.&quot;,preferredStyle: .alert) alertMessage.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler:nil)) self.present(alertMessage, animated: true, completion: nil)&#125;let callAction = UIAlertAction(title: &quot;Call &quot; + &quot;123-000-\(indexPath.row)&quot;,style: .default, handler: callActionHandler)optionMenu.addAction(callAction) callActionHandler是swift闭包结构的一种写法，关于闭包可查看以撸代码的形式学习Swift-7：Closure。这个代码块在Call action被点击是执行。 Check-in action12345678// Check-in actionlet checkInAction = UIAlertAction(title: &quot;Check in&quot;, style: .default, handler:&#123; (action:UIAlertAction!) -&gt; Void in let cell = tableView.cellForRow(at: indexPath) cell?.accessoryType = .checkmark&#125;)optionMenu.addAction(checkInAction) 当用户点击“Check in”action时，为选中的cell增加一个对号，表明是用户喜欢的。accessoryType包括disclosureIndicator, detailDisclosureButton, checkmark 和 detailButton。当cell被选中后，这个cell会一直灰色高亮。去掉：tableView.deselectRow(at: indexPath, animated: false) 解决Bug现在应用运行后，check-in某一cell时，可能会出现其他cell同时也被check-in。这个问题是因为cell重复使用导致的。当一个屏幕滚动时，新进的cell就会利用滚出的得cell，以提高效率。解决方法：为每个cell创造一个是否被check-in的标志。 在RestaurantTableViewController中创建一个Boolean类型的数组：var restaurantIsVisited = Array(repeating: false, count: 21) check-in后就把对应的标志修改为true： 1234567let checkInAction = UIAlertAction(title: &quot;Check in&quot;, style: .default, handler:&#123; (action:UIAlertAction!) -&gt; Void in let cell = tableView.cellForRow(at: indexPath) cell?.accessoryType = .checkmark self.restaurantIsVisited[indexPath.row] = true&#125; 在每一次生成cell是也要检查是否check-in，在tableView(_:cellForRowAt:)放的return cell之前加入：cell.accessoryType = restaurantIsVisited[indexPath.row] ? .checkmark : .none 练习当选中也被check-in的cell时，check-in Action的文本变成Undo Check in，点击后取消其对号。修一下check-in代码：123456789101112131415161718let cell = tableView.cellForRow(at: indexPath)if cell?.accessoryType == .checkmark &#123; let checkInAction = UIAlertAction(title: &quot;Undo Check in&quot;, style: .default, handler: &#123; (action:UIAlertAction!) -&gt; Void in cell?.accessoryType = .none self.restaurantIsVisited[indexPath.row] = false &#125;) optionMenu.addAction(checkInAction)&#125; else &#123; let checkInAction = UIAlertAction(title: &quot;Check in&quot;, style: .default, handler: &#123; (action:UIAlertAction!) -&gt; Void in cell?.accessoryType = .checkmark self.restaurantIsVisited[indexPath.row] = true &#125;) optionMenu.addAction(checkInAction)&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-20：嵌套类型(Nested Types)]]></title>
    <url>%2F2017%2Fswift-20-nested-types.html</url>
    <content type="text"><![CDATA[1 🌰1234567891011121314151617181920212223242526272829303132333435363738struct BlackjackCard &#123; // 二十一点 // nested Suit enumeration enum Suit: Character &#123; // 描述扑克牌的四种花色 case spades = "♠", hearts = "♡", diamonds = "♢", clubs = "♣" &#125; // nested Rank enumeration enum Rank: Int &#123; case two = 2, three, four, five, six, seven, eight, nine, ten case jack, queen, king, ace struct Values &#123; // 用来反映Ace的两个数值() let first: Int, second: Int? &#125; var values: Values &#123; switch self &#123; case .ace: return Values(first: 1, second: 11) case .jack, .queen, .king: return Values(first: 10, second: nil) default: return Values(first: self.rawValue, second: nil) &#125; &#125; &#125; // BlackjackCard properties and methods let rank: Rank, suit: Suit var description: String &#123; var output = "suit is \(suit.rawValue)," output += " value is \(rank.values.first)" if let second = rank.values.second &#123; output += " or \(second)" &#125; return output &#125;&#125;let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)print("theAceOfSpades: \(theAceOfSpades.description)") 2 引用嵌套类型let heartsSymbol = BlackjackCard.Suit.hearts.rawValue playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 7 定制Table Views]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-7.html</url>
    <content type="text"><![CDATA[开始用Swift开发iOS 10 - 6 创建简单的Table Based App是basic风格的Table，这一部分将： 使用UITableViewController 代替 UITableView 展示table view cell中不同的图片显示方式 设计定制的table view cell来替代basic的table view cell 使用UITableViewController新建一个Table View App 新建项目FoodPin，模板为”Single View application” 删除Main.storyboard中的 view controller，删除ViewController.swift 拖动一个Table View Controller到IB中，选中其Is Initial View Controller 新建类RestaurantTableViewController，继承至UITableViewController。将Table View Controller的Class属性设置为RestaurantTableViewController。 在simpletable-image1.zip和simpletable-image2.zip处下载图片，拖到asset catalog 在类RestaurantTableViewController中添加以变量 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats&quot;,&quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;, &quot;Barrafina&quot;,&quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 在类RestaurantTableViewController中添加代码： 123456789override func tableView(_ tableView: UITableView, cellForRowAt indexPath:IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier,for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;)return cell &#125; 插入代码 123456789101112131415161718 override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;) return cell &#125; override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSectionsection: Int) -&gt; Int &#123; return restaurantNames.count &#125; 在类RestaurantTableViewController中加入图片名称变量： 123456var restaurantImages = [&quot;cafedeadend.jpg&quot;, &quot;homei.jpg&quot;, &quot;teakha.jpg&quot;,&quot;cafeloisl.jpg&quot;, &quot;petiteoyster.jpg&quot;, &quot;forkeerestaurant.jpg&quot;, &quot;posatelier.jpg&quot;,&quot;bourkestreetbakery.jpg&quot;, &quot;haighschocolate.jpg&quot;, &quot;palominoespresso.jpg&quot;,&quot;upstate.jpg&quot;, &quot;traif.jpg&quot;, &quot;grahamavenuemeats.jpg&quot;, &quot;wafflewolf.jpg&quot;,&quot;fiveleaves.jpg&quot;, &quot;cafelore.jpg&quot;, &quot;confessional.jpg&quot;, &quot;barrafina.jpg&quot;,&quot;donostia.jpg&quot;, &quot;royaloak.jpg&quot;, &quot;caskpubkitchen.jpg&quot;] 并修改对应代码：cell.imageView?.image = UIImage(named: restaurantImages[indexPath.row]) 定制Table View Cells 修改Table View Cell的Sytle变为Custom，Identifier为Cell 修改Table View 的Row Height为80 确认Table View Cell 的Custom被选择和Row Height为80 拖动image view到Cell中 拖动三个label到Cell中，文本分别是Name，Location，Type。Name 的font为Headline；Location的font style为Light，font size为14，font color为Dark Gray；Type**font style为Light，font size**为13。 把三个label设置成一个vertical stack view，其spacing为1 把vertical stack view和Image View设置成一个horizontal stack view，其spacing为10 为vertical stack view设置上下左右边距约束；为图片设置宽和高的约束 处理约束问题 为Custom Cell创建类 创建继承至UITableViewCell的类RestaurantTableViewCell 在RestaurantTableViewCell中建立四个outlet，分别对应图片和三个label 1234@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!@IBOutlet var thumbnailImageView: UIImageView! 建立代码中接口与storyboard之间的联系 修改Table View Controller代码 由于已经为Custom Cell创建了类RestaurantTableViewCell，所以Table View Controller中生成Cell的待修改为： 12let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell 由于Cell的风格不是sytle了，而是定制的，所以文本和图片代码要做出修改： 12cell.nameLabel.text = restaurantNames[indexPath.row]cell.thumbnailImageView.image = UIImage(named: restaurantImages[indexPath.row]) 图片圆角 可通过UIView的layer属性（CALayer）修改图片圆脚，cornerRadius表示圆角的半径，由于图片的尺寸是60*60，所以圆角的半径设置为30后，图片看上去是个圆。12cell.thumbnailImageView.layer.cornerRadius = 30.0cell.thumbnailImageView.clipsToBounds = true 练习 添加“Type”和“Location”。添加如下两个数组变量：1234var restaurantLocations = [&quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;NewYork&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;] var restaurantTypes = [&quot;Coffee &amp; Tea Shop&quot;, &quot;Cafe&quot;, &quot;Tea House&quot;, &quot;Austrian Causual Drink&quot;, &quot;French&quot;, &quot;Bakery&quot;, &quot;Bakery&quot;, &quot;Chocolate&quot;, &quot;Cafe&quot;, &quot;American Seafood&quot;, &quot;American&quot;, &quot;American&quot;, &quot;Breakfast &amp; Brunch&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Latin American&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;British&quot;, &quot;Thai&quot;] 然后再在Cell时赋值即可：12cell.locationLabel.text = restaurantLocations[indexPath.row] cell.typeLabel.text = restaurantTypes[indexPath.row] 重新设计界面： 修改Table View和Table View Cell的Row Height都为300。 重新设计图片与label的之间的层次结构，并修改图片的大小和其他一些约束。 删除图片圆角 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-19：类型转换(Type Casting)]]></title>
    <url>%2F2017%2Fswift-19-type-casting.html</url>
    <content type="text"><![CDATA[1 定义一个类层次作为例子12345678910111213141516171819202122232425262728293031class MediaItem &#123; var name: String init(name: String) &#123; self.name = name &#125;&#125;class Movie: MediaItem &#123; var director: String init(name: String, director: String) &#123; self.director = director super.init(name: name) &#125;&#125;class Song: MediaItem &#123; var artist: String init(name: String, artist: String) &#123; self.artist = artist super.init(name: name) &#125;&#125;let library = [ Movie(name: "Casablanca", director: "Michael Curtiz"), Song(name: "Blue Suede Shoes", artist: "Elvis Presley"), Movie(name: "Citizen Kane", director: "Orson Welles"), Song(name: "The One And Only", artist: "Chesney Hawkes"), Song(name: "Never Gonna Give You Up", artist: "Rick Astley")]// 数组 library 的类型被推断为 [MediaItem]for v in library &#123; // v 在此处是 MediaItem 类型 print(v.name)&#125; 2 检查类型(Checking Type) is123456789var movieCount = 0var songCount = 0for item in library &#123; if (item is Movie) &#123; movieCount += 1 &#125; else if (item is Song) &#123; songCount += 1 &#125;&#125; 3 向下转型(Downcasting) as? as!条件形式(conditional form) as? 返回一个你试图向下转成的类型的可选值(optional value) 强制形式 as! 把试图向下转型和强制解包(force-unwraps)转换结果结合为一个操作。 1234567for item in library &#123; if let movie = item as? Movie &#123; print("Movie: '\(movie.name)', dir. \(movie.director)") &#125; else if let song = item as? Song &#123; print("Song: '\(song.name)', by \(song.artist)") &#125;&#125; 4 Any和AnyObject的类型转换AnyObject可以表示任何类类型的实例 Any可以表示任何类型，包括函数类型 playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode中Scene里的名称]]></title>
    <url>%2F2017%2Fxcode-scene-name.html</url>
    <content type="text"><![CDATA[默认的Scene名称 Xcode中新建一个控制器对象后会产生一个Scene，而Scene的名称就与其关联的控制器名称相关，比如默认的View Controller的对象的Scene的名称就是View Controller Scene。 如果把控制器改成SFSafariViewController，那么Scene的名字就会变成Safari View Scene。 如果把控制器改成自建的，Scene名字也会随着变化，比如ASAndyViewController对应的Scene名字是 Andy View Scene 总的来说，apple在程序中代码命名规范，一般是前面连续大写的是框架名称，然后后面使用驼峰命名法。要显示时就把框架前缀去掉，然后根据驼峰命名规则分隔显示。 自定义Scene的名称Scene的名称也是可以自定义的，在其属性检查器中，修改title即可，当然这种修改只是停留在IB中，为了开发时便于查看，不影响代码中的名称。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 1： 识别二维码（swift3）]]></title>
    <url>%2F2017%2Fios-tutorial-1-arcode.html</url>
    <content type="text"><![CDATA[这是一篇使用AVFoundation框架识别二维码的文章，原文提供了初始化项目QRCodeReaderStarter，我重新建立项目，图片是从原文提供的初始化项目中copy的。 初始化项目 新建一个名为QRCodeReader的单页项目 删除ViewController.swift文件，在项目目录处右击新建文件，新建一个QRCodeViewController类继承自UIViewController。 点击Main.storyboard，选中View Controller，修改其属性Class为QRCodeViewController，使两者关联。 向Main.storyboard中拖动一个View Controller对象，以1的方法新建一个继承自UIViewController的类QRScannerController，然后与Main.storyboard中新建的View Controller关联。 下载图片。从原文的初始化项目QRCodeReaderStarter复制。 修改Code View Controller Scene的view背景颜色做修改；添加一个label，名称改为Quick Scan，字体，和字体大小也做修改；添加button，删除文本，大小为150*150，Type为System，image为focus，Tint为黄色；添加一些约束。 Scanner Controller Scene： 在顶部添加一个View，在这个View中添加以label和button，button的image为cross；在顶部添加一个label；添加一些约束。 构建 segue 用control-drag从Code View Controller Scene中的button到Scanner Controller Scene，选择Present Modally 在QRCodeViewController中添加代码： 1234@IBAction func unwindToHomeScreen(segue: UIStoryboardSegue) &#123; //去除模态视图 dismiss(animated: true, completion: nil) &#125; 在Scanner Controller Scene 中，用control-drag从button到Exit，选择unwindToHomeScreenWithSegue: 6和7中样式和约束，合适即可。 加载 AVFoundation 框架 在QRScannerController.swift文件中引入AVFoundation Framework：import AVFoundation QRScannerController实现AVCaptureMetadataOutputObjectsDelegate协议：class QRScannerController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {表示当捕获的元数据产生时，需要一些回调方法。 QRScannerController中添加三个变量：123var captureSession: AVCaptureSession?var videoPreviewLayer: AVCaptureVideoPreviewLayer?var qrCodeFrameView: UIView? 实现视频捕获 在QRScannerController的viewDidLoad中添加代码： 123456789101112131415161718192021222324252627// 1let captureDevice = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)do &#123; // 2 let input = try AVCaptureDeviceInput(device: captureDevice) // 3 captureSession = AVCaptureSession() // 4 captureSession?.addInput(input) // 5 let captureMetadataOutput = AVCaptureMetadataOutput() captureSession?.addOutput(captureMetadataOutput) // 6 captureMetadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main) captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode] videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession) videoPreviewLayer?.videoGravity = AVLayerVideoGravityResizeAspectFill videoPreviewLayer?.frame = view.layer.bounds view.layer.addSublayer(videoPreviewLayer!) captureSession?.startRunning()&#125; catch &#123; print(error) return&#125; 1 初始化AVCaptureDevice，它表示物理捕获设备；AVMediaTypeVideo是Media types，表示视频类型，还有AVMediaTypeAudio，AVMediaTypeText等其他类型 2 根据AVCaptureDevice初始化捕获设备的输入数据对象AVCaptureDeviceInput。这边的try是swift中错误处理的标识，对应public init(device: AVCaptureDevice!) throws。 3 AVCaptureSession 用于协调输入与输出之间的数据流。 4 为AVCaptureSession 添加输入数据 5 定义输出数据对象AVCaptureMetaDataOutput，并把它添加给AVCaptureSession 6 设置self为输出数据对象的代理，这就对应了QRScannerController类实现AVCaptureMetadataOutputObjectsDelegate协议。metadataObjectTypes是识别的元数据类型，AVMetadataObjectTypeQRCode表示二维码类型。 在Info.plist中添加key为NSCameraUsageDescription或”Privacy – Camera Usage Description”，值为 为了扫描二维码，需要使用你的相机。 运行应用时，点击scan button后，使用了相机，但messageLabel和tapbar没有了，因为被AVCaptureVideoPreviewLayer覆盖了，加入两行代码就可以显示了：12view.bringSubview(toFront: messageLabel)view.bringSubview(toFront: topbar) 实现二维码读取当检测到二维码时，用绿色框高亮；然后二维码被解码成文本信息展示在messagelabel中。 初始化绿色框。继续在上述代码后添加:12345678qrCodeFrameView = UIView() if let qrCodeFrameView = qrCodeFrameView &#123; qrCodeFrameView.layer.borderColor = UIColor.green.cgColor qrCodeFrameView.layer.borderWidth = 2 view.addSubview(qrCodeFrameView) view.bringSubview(toFront: qrCodeFrameView)&#125; 由于qrCodeFrameView没有设置大小，默认是0，所以不会显示，当之后发现二维码时再让它显示。 解码二维码当AVCaptureMetadataOutput识别出二维码时，AVCaptureMetadataOutputObjectsDelegate中的代理方法将被调用：​ optional public func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!)回调方法定义： func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) { ​ if metadataObjects == nil || metadataObjects.count == 0 { qrCodeFrameView?.frame = CGRect.zero messageLabel.text = “没有二维码/条形码” return } let metadataObj = metadataObjects[0] as! AVMetadataMachineReadableCodeObject if metadataObj.type == AVMetadataObjectTypeQRCode { // 1 let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil { // 2 messageLabel.text = metadataObj.stringValue } } } 第二个参数metadataObjects是个数组，就是所有被识别出来的元数据对象。如果这个参数为nil或数组为空数组，就表示没有识别出对象。 1 通过transformedMetadataObject方法获得AVMetadataObject对象，更加这个对象可以获得二维码的位置，然后显示绿框。 2 把二维码信息显示在messagelabel上。 识别条形码除了识别二维码以外，还可以识别条形码。只要在captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode]添加更多的元数据类型。，然后回调方法中修改检测类型就可以。 123456789101112131415161718192021222324let supportedCodeTypes = [AVMetadataObjectTypeUPCECode, AVMetadataObjectTypeCode39Code, AVMetadataObjectTypeCode39Mod43Code, AVMetadataObjectTypeCode93Code, AVMetadataObjectTypeCode128Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeAztecCode, AVMetadataObjectTypePDF417Code, AVMetadataObjectTypeQRCode ]captureMetadataOutput.metadataObjectTypes = supportedCodeTypes// ....if supportedCodeTypes.contains(metadataObj.type) &#123; let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil &#123; messageLabel.text = metadataObj.stringValue &#125;&#125; 代码QRCodeReader]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS应用程序的状态]]></title>
    <url>%2F2017%2Fios-application-status.html</url>
    <content type="text"><![CDATA[iOS应用程序一共有五种状态： Not Running 程序还没运行 Inactive 程序运行在foreground但没有接收事件 Active 程序运行在foreground接收事件 Background 程序运行在background正在执行代码 Suspended 程序运行在background没有执行代码 iOS应用程序状态变化会回调APPDelegate中的方法，但不是每一种状态变化都会有对应的方法(上图的红框的两个变化就没有对应的方法) application:didFinishLaunchingWithOptions: Not Running -&gt; Inactive applicationDidBecomeActive: Inactive -&gt; Active applicationWillResignActive: Active -&gt; Inactive applicationDidEnterBackground: Background -&gt; Suspended applicationWillEnterForeground: Background -&gt; Inactive applicationWillTerminate: Suspended -&gt; Not Running 常见的应用状态变化场景 程序第一次启动（或者被杀掉以后启动）： Not Running -&gt; Inactive -&gt; Active 点击Home键（没有在Inof.plist中设置Application does not run in background）： Active -&gt; Inactive -&gt; Background -&gt; Suspended 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 挂起重新运行 Suspended -&gt; Background -&gt; Inactive -&gt; Active 内存清除（杀掉应用或删除应用） Suspended -&gt; Not Running 应用之间的切换 Active -&gt; Inactive Inactive -&gt; Active 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 可通过在APPDelegate的回调方法中打印数据，来查看应用状态变化 123456789101112131415161718192021222324252627282930func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; print("`application:didFinishLaunchingWithOptions:` Not Running -&gt; Inactive") return true&#125;func applicationWillResignActive(_ application: UIApplication) &#123; print("`applicationWillResignActive:` Active -&gt; Inactive")&#125;func applicationDidEnterBackground(_ application: UIApplication) &#123; print("`applicationDidEnterBackground:` Background -&gt; Suspended")&#125;func applicationWillEnterForeground(_ application: UIApplication) &#123; print("`applicationWillEnterForeground:` Background -&gt; Inactive")&#125;func applicationDidBecomeActive(_ application: UIApplication) &#123; print("`applicationDidBecomeActive:` Inactive -&gt; Active")&#125;func applicationWillTerminate(_ application: UIApplication) &#123; print("`applicationWillTerminate:` Suspended -&gt; Not Running")&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 6 创建简单的Table Based App]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-6.html</url>
    <content type="text"><![CDATA[table view应该是iOS应用中最常用的UI element。最好的例子就是iPhone自带的一些应用，如电话，邮件，设置等。TED，Google+，Airbnb，微信等等都是很好例子。 创建一个项目 项目名称为SimpleTable，模板为”Single View application” 设计UI 选中Main.storyboard，从Object library中拖动Table View进入视图 改变Table View的大小至整个view，修改属性Prototype Cells为1 选中Table View Cell，修改Style为Basic，Identifier为Cell。table view cell的标准类型有 basic、right detail、left detail 和 subtitle，当然还有定制类型custom。 选中Table View，设置四个spacing约束，上下左右的距离都设置为0 为UITableView添加两个协议 Object library中的每一UI component都是对应一个class，如 Table View就是对应UITableView。可以通过点击并悬停在UI component上查看对应的class和介绍。 在ViewController.swift文件的UIViewController后，添加代码, UITableViewDataSource, UITableViewDelegate，表示ViewController类实现了UITableViewDataSource，UITableViewDelegate两个协议。出现红色感叹号，这是xcode的问题提示，点击参看问题描述： Type ‘ViewController’ does not conform to protocol‘UITableViewDataSource’ 问题描述为ViewController不符合协议UITableViewDataSource。通过command+点击 （最新的xcode9变成了command+option+点击）到UITableViewDataSource中看看你：1234567891011121314151617181920212223242526272829303132public protocol UITableViewDataSource : NSObjectProtocol &#123; @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int // Row display. Implementers should *always* try to reuse cells by setting each cell&apos;s reuseIdentifier and querying for available reusable cells with dequeueReusableCellWithIdentifier: // Cell gets various attributes set automatically based on table (separators) and data source (accessory views, editing controls) @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell @available(iOS 2.0, *) optional public func numberOfSections(in tableView: UITableView) -&gt; Int // Default is 1 if not implemented @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? // fixed font style. use custom view (UILabel) if you want something different @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? // Editing // Individual rows can opt out of having the -editing property set for them. If not implemented, all rows are assumed to be editable. @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool ... UITableViewDataSource协议中定义了很多方法，除了前两个方法没有optional其它都有，有的表示这个方法不一定要实现，没有的就一定要实现，把这个两个方法实现了，问题提示就会消失。这两个方法从名字和返回值类型也大概能知道做了什么： public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int 一个section有几行，也就是一个section有几个UITableViewCell， section就是一组UITableViewCell的意思，Table View可以定义多个section，默认是一个。 public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell 返回每一行的 UITableViewCell 在ViewController.swift中定义一个变量restaurantNames，类型是数组，表示一系列餐馆的名字。 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats AndDeli&quot;, &quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;,&quot;Barrafina&quot;, &quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 定义UITableViewDataSource的两个方法： 12345678910111213141516func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // 1 return restaurantNames.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 2 let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // 3 cell.textLabel?.text = restaurantNames[indexPath.row] return cell &#125; 1 餐馆的数目就是section的行数 2 “Cell”与之前定义的UITableViewCell的Identifier属性是对应的。dequeueReusableCell方法是产生一个UITableViewCell。 3 UITableViewCell中有可算属性textLabel，其实就是一个UILabel，由于是可选属性，调用时也用可选链式调用cell.textLabel?.text 连接 DataSource 和 Delegate运行app，没有数据显示。尽管上面已经在代码中让ViewController继承了UITableViewDataSource, UITableViewDelegate，但storyboard并不知道。 在document outline中选择Table View，使用control-drag到View Controller，在弹出框中选择dataSource。同样的方法选择delegate 确认连接是否成功。选中Table View，在connetion检查器中查看；或者直接在document outline中右击Table View 运行app 添加图片到Table View 从simpletable-image1.zip下载图片，解压后一起拖到asset catalog 在ViewController.swift的tableView(_:cellForRowAtIndexPath:)方法的return cell前添加代码cell.imageView?.image = UIImage(named: &quot;restaurant&quot;)。使每个UITableViewCell的image都是一样的。 隐藏状态栏顶部状态来和table view 数据重叠了，只要在ViewController加一段代码就可以：123override var prefersStatusBarHidden: Bool &#123; return true&#125; prefersStatusBarHidden是父类UIViewController中的属性，所以要加 override，表示重写了。 不同的Cell对应不同的图片 从simpletable-image2.zip下载图片，解压后一起拖到asset catalog 修改ViewController.swift的tableView(_:cellForRowAtIndexPath:)为： 12345678910111213141516171819func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // Configure the cell... let restaurantName = restaurantNames[indexPath.row] cell.textLabel?.text = restaurantName // 1 let imageName = restaurantName.lowercased().replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;) if let image = UIImage(named: imageName) &#123; cell.imageView?.image = image &#125; else &#123; cell.imageView?.image = UIImage(named: &quot;restaurant&quot;) &#125; return cell &#125; 1 把菜馆名字字符串先修改成小写，然后去空格 最终结果 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-18：错误处理(Error handling)]]></title>
    <url>%2F2017%2Fswift-18-error-handling.html</url>
    <content type="text"><![CDATA[错误处理(Error handling)是响应错误以及从错误中恢复的过程。 1 表示并抛出错误 Error空协议表明该类型可以用于错误处理 123456enum VendingMachineError: Error &#123; case InvalidSelection //选择无效 case InsufficientFunds(coinsNeeded: Int) //金额不足 case OutOfStock //缺货&#125;throw VendingMachineError.InsufficientFunds(coinsNeeded: 5) 2 处理错误 为了标识出代码中可能会抛出错误的地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上 try 关键字，或者 try? 或 try!这种变体。 四个处理错误的方式: 用throwing函数传递错误 throwing函数: 在函数声明的参数列表之后加上 throws 关键字，为了表示一个函数、方法或构造器可以抛出错误。12func canThrowErrors() throws -&gt; Stringfunc cannotThrowErrors() -&gt; String 一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。 只有 throwing 函数可以传递错误。任何在某个非throwing函数内部抛出的错误只能在函数内部处理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct Item &#123; var price: Int var count: Int&#125;class VendingMachine &#123; var inventory = [ "Candy Bar": Item(price: 12, count: 7), "Chips": Item(price: 10, count: 4), "Pretzels": Item(price: 7, count: 11) ] var coinsDeposited = 0 func dispenseSnack(snack: String) &#123; print("Dispensing \(snack)") &#125; func vend(itemNamed name: String) throws &#123; guard let item = inventory[name] else &#123; throw VendingMachineError.InvalidSelection &#125; guard item.count &gt; 0 else &#123; throw VendingMachineError.OutOfStock &#125; guard item.price &lt;= coinsDeposited else &#123; throw VendingMachineError.InsufficientFunds(coinsNeeded: item.price - coinsDeposited) &#125; coinsDeposited -= item.price var newItem = item newItem.count -= 1 inventory[name] = newItem dispenseSnack(snack: name) &#125;&#125;let favoriteSnacks = [ "Alice": "Chips", "Bob": "Licorice", "Eve": "Pretzels",]func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws &#123; let snackName = favoriteSnacks[person] ?? "Candy Bar" try vendingMachine.vend(itemNamed: snackName)&#125;// throwing构造器能像throwing函数一样传递错误。struct PurchasedSnack &#123; let name: String init(name: String, vendingMachine: VendingMachine) throws &#123; try vendingMachine.vend(itemNamed: name) self.name = name &#125;&#125; 用 Do-Catch 处理错误 123456789101112var vendingMachine = VendingMachine()vendingMachine.coinsDeposited = 8do &#123; try buyFavoriteSnack(person: "Alice", vendingMachine: vendingMachine)&#125; catch VendingMachineError.InvalidSelection &#123; print("Invalid Selection.")&#125; catch VendingMachineError.OutOfStock &#123; print("Out of Stock.")&#125; catch VendingMachineError.InsufficientFunds(let coinsNeeded) &#123; print("Insufficient funds. Please insert an additional \(coinsNeeded) coins.")&#125;// 打印 “Insufficient funds. Please insert an additional 2 coins.” 将错误转换成可选值 如果 someThrowingFunction() 抛出一个错误， x 和 y 的值是 nil，否则 x 和 y 的值就是该函数的返回值。无论 someThrowingFunction() 的返回值类型是什么类型， x 和 y 都是这个类型的可选类型。x，y的两种形式类似，try? 更简洁。 1234567891011func someThrowingFunction() throws -&gt; Int &#123; // ... return 0&#125;let x = try? someThrowingFunction()let y: Int?do &#123; y = try someThrowingFunction()&#125; catch &#123; y = nil&#125; 禁用错误传递 try! 禁止错误传递，如真有错误抛出，就出现运行错误。 let photo = try! loadImage(&quot;./Resources/John Appleseed.jpg&quot;) 3 指定清理操作 playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 4 用Stack View设计UI]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-4.html</url>
    <content type="text"><![CDATA[前一篇开始用Swift开发iOS 10 - 3 介绍Auto Layout中提到Auto Layout工具栏有个stack按钮，这是Stack View功能。为了解决复杂UI时布局约束定义困难，Apple从iOS 9开始引入Stack View。这篇文章将学习到： 用Stack View布局UI。 用image views展示图片。 用内建的asset catalog管理图片。 用Size Classes适配Stack View Stack View是什么Stack View为在纵向或横向布置一个视图的集合，提供了一个流线型界面。可以用stack view将很多UI对象合成一个。视图嵌入一个stack view里以后,就不再需要定义自动布局约束. Stack View管理它子视图的布局,然后自动提供布局约束。这意味着子视图已经准备好去适应不同的屏幕尺寸。此外，也可以嵌入一个stack view到另一个stack view来构建更复杂的用户界面。但是，这并不意味着不需要处理自动布局。仍然需要定义stack view的布局。这样不仅能够节约在创作每个UI元素的约束的时间，也可以轻松的从布局里来添加/移除视图。 Xcode提供两种方法使用Stack View： 直接从Object library中拖出stack view（纵向或横向），然后把其他视图拖动stack view 选中一些视图，然后点击Interface Builder editor右下角一组按钮中的stack按钮 一个小程序 新建项目 StackViewDemo 向Xcode中添加图片 从图片下载所需图片，加压后有3组9张图片，每组有3张不同类型的图片，针对不同类型的设备： user1.png （ non-Retina的一些老设备） user1@2x.png （iPhone 4/4s/5/5s/6） user1@3x.png （iPhone 6 Plus等高分辨的） 拖动图片竟然xcode的asset catalog中，xcode会自动组织这些有规律的图片，使用时直接用user1,不需要靠后面的@2或@3。 用Stack View布局title的label 选择Main.storyboard，从Object library中拖出Vertical Stack View到storyboard中 拖出一个label到stack view中。一旦label进入stack view中，它就自动调整大小以适应label 修改label的title为“Instant Developer”，字体大小为40 points，font style为medium，字体颜色为红色 另外拖出一个label到stack view中，修改label的title为“Get help from experts in 15 minutes” 选择stack view，在属性检查器中修改Alignment参数为center，这样使stack view中的label水平居中对齐。 多个视图在一起不方便选择时，可以用 shift + 右击：stack view的几个属性： axis stack view中对象是水平放置还是垂直放置，也就是Vertical Stack View和Horizontal Stack View之间的切换 alignment stack view中对象的对齐方式 distribution 用Stack按钮布局多个图片 拖动一个image view对象，并修改其image属性为user1 同样的方法再添加两个image view对象，image属性分别为user2，user3。粗略调整图片的带下，放在一个水平，大概如下： 选中三个image view，击Interface Builder editor右下角一组按钮中的stack按钮，则生成一个新的horizontal stack view。 修改新生成的horizontal stack view的属性，spacing为 10，表示图片之间的间距，Distribution为Fill Equally 同时选中两个stack view，点击stack 按钮，再生成一个新的大vertical stack view 为stack view添加布局约束 选中大的stack view，添加space constraints，上，左右，分别为70，0，0添加约束后，如果出现布局问题，可通过issue indicator解决，可参考上一篇文章。 看预览assistant editor，查看其它设备会发现两个问题： Instant Developer label文本在小屏幕设备被截断 图片的宽高比改变了 选择Instant Developer label，修改Autoshrink属性为Minimum Font Size，值为20，这样就设置了label的字体可以变化，最小值为20 ，小屏幕就不会被截断了。 横向control-drag图片的stack view，选择Aspect Ratio，使图片的宽高比不变化。 在图片stack view下添加一个label 拖动一个label到图片下，看到一个蓝色线后松开 改变label的文本：Need help with your coding problems? We’ll find you the right developer who can help you in 15 minutes. label的属性lines改为0，表示不限制行数 选择大stack view，修改间距sapcing为10，修改Alignment为居中 用stack view布局Buttons 添加两个Button：”Sign in” 和 “Sign up with Facebook” 修改白字体，红背景，宽度为200 选择两个Button生成vertical stack view，spacing为10 为vertical stack view添加两个约束，水平居中和底边距20 当把两个button聚合成stack view时，button的大小会自动调节到适宜大小，也就是”Sign up with Facebook”的宽度变为155 。需要再添加一个宽度约束，修改Constant值为200 。 用Size Classes来调节Stack view landscape orientation vs portrait orientation直译就是风景画方向和肖像画方向，其实就是指横屏和竖屏 上面设计的UI看上去以不错了，但一直没有考虑的横屏的情况。因为横屏上下高度变小，原本在竖屏下适宜的stack view上边距，就有点大了，需要小一点。这也导致了，从iOS 8开始引入了一个新的UI设计概念Adaptive Layout（自适应布局），为此，Apple引入了Size Classes。通过Size Classes 和 auto layout一起设计自适应UI。Size Classes仅仅是对屏幕进行了分类, 实际上的布局还是交给autolayout Size Classes有两种类型：regular 和 compact（可以理解为大[R] 和 小[C]）。而这两种类型应用在两个方向上：vertical (height) 和 horizontal (width) ，就对应不同类型的设备：Regular width-Regular Height, Regular width-Compact Height, Compact width-Regular Height and Compact width-Compact Height 最新版本的Xcode已经为我们提供了不同设备和方向的Size Classes查看： 选择上边距约束。在属性检查器中，点击Constant前面的+号，弹框中分别选择：Width：Any，Height：Compact，Gamunt：Any，后面的值为0，表示只有在Compact height下上边距为0 为了更加简洁也可以在有些屏幕状态下把”Need help with your …” label隐藏掉，就是height为0。也就是为label添加一个只有在Width：Any，Height：Compact，Gamunt：Any这个Size Classes下，的height约束。用control-drag方法添加height约束： 选择现价的height约束，修改Constant为0；去除选中Installed，点击Installed前的+，弹出框选择Width：Any，Height：Compact，Gamunt：Any，并选择新加的Installed（height约束颜色变浅了，说明这个约束不是在任何状态下都有效的）： 练习还有考虑特殊的一些设备的情况，添加一些特殊的约束： 在wR hR时，修改两个按钮的宽度为300 在iphone 6/7 和一些老的iphone等设备竖屏时，修改”Need help with …” label 字体为15 在wR hR时，修改图像stack view的上下空间为30 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-17：可选链式调用(Optional Chaining)]]></title>
    <url>%2F2017%2Fswift-17-optional-chaining.html</url>
    <content type="text"><![CDATA[一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法 1 使用可选链式调用代替强制展开可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。 123456789101112131415161718class Person &#123; var residence: Residence?&#125;class Residence &#123; var numberOfRooms = 1&#125;let john = Person()if let roomCount = john.residence?.numberOfRooms &#123; print("John's residence has \(roomCount) room(s).")&#125; else &#123; print("Unable to retrieve the number of rooms.")&#125;john.residence = Residence()if let roomCount = john.residence?.numberOfRooms &#123; print("John's residence has \(roomCount) room(s).")&#125; else &#123; print("Unable to retrieve the number of rooms.")&#125; 2 为可选链式调用定义模型类12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Person2 &#123; var residence: Residence2?&#125;class Residence2 &#123; var rooms = [Room]() var numberOfRooms: Int &#123; return rooms.count &#125; subscript(i: Int) -&gt; Room &#123; get &#123; return rooms[i] &#125; set &#123; rooms[i] = newValue &#125; &#125; func printNumberOfRooms() &#123; print("The number of rooms is \(numberOfRooms)") &#125; var address: Address?&#125;class Room &#123; let name: String init(name: String) &#123; self.name = name &#125;&#125;class Address &#123; var buildingName: String? var buildingNumber: String? var street: String? func buildingIdentifier() -&gt; String? &#123; if buildingName != nil &#123; return buildingName &#125; else if buildingNumber != nil &amp;&amp; street != nil &#123; return "\(buildingNumber) \(street)" &#125; else &#123; return nil &#125; &#125;&#125;func createAddress() -&gt; Address &#123; print("Function was called.") let someAddress = Address() someAddress.buildingNumber = "29" someAddress.street = "Acacia Road" return someAddress&#125; 3 通过可选链式调用访问属性12let andy = Person2()andy.residence?.address = createAddress() // andy.residence结果为nil，可选链式调用失败时，等号右侧的代码不会被执行。 4 通过可选链式调用调用方法1234567891011121314if let firstRoomName = andy.residence?[0].name &#123; print("The first room name is \(firstRoomName).")&#125; else &#123; print("Unable to retrieve the first room name.")&#125;let andyHouse = Residence2()andyHouse.rooms.append(Room(name: "Living Room"))andyHouse.rooms.append(Room(name: "Kitchen"))andy.residence = andyHouseif let firstRoomName = andy.residence?[0].name &#123; print("The first room name is \(firstRoomName).")&#125; else &#123; print("Unable to retrieve the first room name.")&#125; 5 访问可选类型的下标1234var testScores = ["Dave": [86, 82, 84], "Bev": [79, 94, 81]]testScores["Dave"]?[0] = 91testScores["Bev"]?[0] += 1testScores["Brian"]?[0] = 72 6 连接多层可选链式调用1234567891011121314if let andyStreet = andy.residence?.address?.street &#123; print("John's street name is \(andyStreet).")&#125; else &#123; print("Unable to retrieve the address.")&#125;let andyAddress = Address()andyAddress.buildingName = "东方明珠"andyAddress.street = "南京东路100号"andy.residence?.address = andyAddressif let andyStreet = andy.residence?.address?.street &#123; print("John's street name is \(andyStreet).")&#125; else &#123; print("Unable to retrieve the address.")&#125; 7 在方法的可选返回值上进行可选链式调用1234567891011if let buildingIdentifier = andy.residence?.address?.buildingIdentifier() &#123; print("John's building identifier is \(buildingIdentifier).")&#125;if let beginsWithThe = andy.residence?.address?.buildingIdentifier()?.hasPrefix("东") &#123; if beginsWithThe &#123; print("John's building identifier begins with \"东\".") &#125; else &#123; print("John's building identifier does not begin with \"东\".") &#125;&#125; playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-16：自动引用计数(Automatic Reference Counting, ARC)]]></title>
    <url>%2F2017%2Fswift-16-automatic-reference-counting.html</url>
    <content type="text"><![CDATA[引用计数仅仅应用于类的实例 1 自动引用计数的工作机制每次创建一个类的新的实例的时候，ARC会分配一块内存来储存该实例信息(包含实例的类型信息，以及这个实例所有相关的存储型属性的值)。 ARC会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。 引用数为0时，内存释放。 2 🌰12345678910111213141516171819class Person &#123; let name: String init(name: String) &#123; self.name = name print("\(name) is being initialized") &#125; deinit &#123; print("\(name) is being deinitialized") &#125;&#125;var reference1: Person?var reference2: Person?var reference3: Person?reference1 = Person(name: "John Appleseed")reference2 = reference1reference3 = reference1reference1 = nilreference2 = nilreference3 = nil 3 类实例之间的循环强引用123456789101112131415161718192021class Person2 &#123; let name: String init(name: String) &#123; self.name = name &#125; var apartment: Apartment2? deinit &#123; print("\(name) is being deinitialized") &#125;&#125;class Apartment2 &#123; let unit: String init(unit: String) &#123; self.unit = unit &#125; var tenant: Person2? deinit &#123; print("Apartment \(unit) is being deinitialized") &#125;&#125;var andy: Person2?var unit4A: Apartment2?andy = Person2(name: "Andy Ron")unit4A = Apartment2(unit: "4A")andy!.apartment = unit4Aunit4A!.tenant = andyandy = nilunit4A = nil// john和unit4A两个变量虽然已经被赋值为nil，但之前它们引用两个实例之间的强引用关系保留了下来并且不会被断开 4 解决实例之间的循环强引用弱引用(weak reference)和无主引用(unowned reference)允许循环引用中的一个实例引用另外一个实例而不保持强引用。 4.1 弱引用:弱引用必须被声明为变量，表明其值能在运行时被修改。weak 12345678910111213141516171819202122232425262728class Person3 &#123; let name: String init(name: String) &#123; self.name = name &#125; var apartment: Apartment3? deinit &#123; print("\(name) is being deinitialized") &#125;&#125;class Apartment3 &#123; let unit: String init(unit: String) &#123; self.unit = unit &#125; weak var tenant: Person3? deinit &#123; print("Apartment \(unit) is being deinitialized") &#125;&#125;var andy3: Person3?var unit5A: Apartment3?andy3 = Person3(name: "Andy Ron3")unit5A = Apartment3(unit: "5A")andy3!.apartment = unit5Aunit5A!.tenant = andy3andy3 = nil // Person3的实例被销毁，虽然tenant还引用它，但因为时弱引用在ARC计数范围内。unit5A = nil 4.2 无主引用 unowned 和弱引用不同的是，无主引用是永远有值的。Customer是客户，CreditCard是信用卡。客户可以有或五信用卡，但信用卡必须有对应的用户。 1234567891011121314151617181920212223class Customer &#123; let name: String var card: CreditCard? init(name: String) &#123; self.name = name &#125; deinit &#123; print("\(name) is being deinitialized") &#125;&#125;class CreditCard &#123; let number: UInt64 unowned let customer: Customer init(number: UInt64, customer: Customer) &#123; self.number = number self.customer = customer &#125; deinit &#123; print("Card #\(number) is being deinitialized") &#125;&#125;var john: Customer?john = Customer(name: "John Appleseed")john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)john = nil // 客户被销毁，对应的信用卡也要被销毁。// 打印 “John Appleseed is being deinitialized”// 打印 ”Card #1234567890123456 is being deinitialized” 4.3 无主引用以及隐式解析可选属性 123456789101112131415161718class Country &#123; let name: String var capitalCity: City! init(name: String, capitalName: String) &#123; self.name = name self.capitalCity = City(name: capitalName, country: self) &#125;&#125;class City &#123; let name: String unowned let country: Country init(name: String, country: Country) &#123; self.name = name self.country = country &#125;&#125;var country = Country(name: "Canada", capitalName: "Ottawa")print("\(country.name)'s capital city is called \(country.capitalCity.name)") 5 闭包引起的循环强引用6 解决闭包引起的循环强引用 playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>自动引用计数</tag>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-15：(类的)析构过程(Deinitialization)]]></title>
    <url>%2F2017%2Fswift-15-deinitialization.html</url>
    <content type="text"><![CDATA[1 析构过程原理每个类最多只能有一个析构器，而且析构器不带任何参数 析构器是在实例释放发生前被自动调用。不能主动调用析构器。 子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。 2 析构器实践 12345678910111213141516171819202122232425262728293031323334class Bank &#123; static var coinsInBank = 10_000 static func vendCoins(numberOfCoinsRequested: Int) -&gt; Int &#123; let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank) coinsInBank -= numberOfCoinsToVend return numberOfCoinsToVend &#125; static func receiveCoins(coins: Int) &#123; coinsInBank += coins &#125;&#125;class Player &#123; var coinsInPurse: Int init(coins: Int) &#123; coinsInPurse = Bank.vendCoins(numberOfCoinsRequested: coins) &#125; func winCoins(coins: Int) &#123; coinsInPurse += Bank.vendCoins(numberOfCoinsRequested: coins) &#125; deinit &#123; Bank.receiveCoins(coins: coinsInPurse) &#125;&#125;var playerOne: Player? = Player(coins: 100)print("A new player has joined the game with \(playerOne!.coinsInPurse) coins")print("There are now \(Bank.coinsInBank) coins left in the bank")playerOne!.winCoins(coins: 2_000)print("PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins")print("The bank now only has \(Bank.coinsInBank) coins left")playerOne = nilprint("PlayerOne has left the game")print("The bank now has \(Bank.coinsInBank) coins") playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>析构过程</tag>
        <tag>Deinitialization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-14：构造过程(Initialization)]]></title>
    <url>%2F2017%2Fswift-14-initialization.html</url>
    <content type="text"><![CDATA[构造过程是使用类、结构体或枚举类型的实例之前的准备过程通过定义构造器( Initializers )来实现构造过程 1 存储属性的初始赋值类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。 当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。 2 自定义构造过程 12345678910111213141516171819202122232425262728struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125;&#125;let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)// boilingPointOfWater.temperatureInCelsius 是 100.0let freezingPointOfWater = Celsius(fromKelvin: 273.15)// freezingPointOfWater.temperatureInCelsius 是 0.0struct Color &#123; let red, green, blue: Double init(red: Double, green: Double, blue: Double) &#123; self.red = red self.green = green self.blue = blue &#125; init(white: Double) &#123; red = white green = white blue = white &#125;&#125;let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)let halfGray = Color(white: 0.5) 不带外部名的构造器参数123456789101112struct Celsius2 &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125; init(_ celsius: Double)&#123; temperatureInCelsius = celsius &#125;&#125; 可选属性类型12345678910class SurveyQuestion &#123; var text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125; 对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改;不能在子类中修改。 12345678910class SurveyQuestion2 &#123; let text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125; 3 默认构造器如果结构体或类的所有属性都有默认值，相当于有一个自定义的构造器 123456class ShoppingListItem &#123; var name: String? var quantity = 1 var purchased = false&#125;var item = ShoppingListItem() 结构体的逐一成员构造器 1234struct Size &#123; var width = 0.0, height = 0.0&#125;let twoByTwo = Size(width: 2.0, height: 2.0) 4 值类型(结构体和枚举类型)的构造器代理(调用其它构造器来完成实例的部分构造过程)1234567891011121314151617struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() init() &#123;&#125; // 功能上与所有属性都有默认值的默认构造器类似 init(origin: Point, size: Size) &#123; // 功能上与结构体的逐一成员构造器类似 self.origin = origin self.size = size &#125; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 5 类的继承和构造过程 指定构造器(designated initializers)：主要，至少有一个。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。 123init(parameters) &#123; statements&#125; 便利构造器(convenience initializers)：次要，辅助。 123convenience init(parameters) &#123; statements&#125; 类的构造器代理规则 指定构造器必须调用其直接父类的的指定构造器。 便利构造器必须调用同一类中定义的其它构造器。 便利构造器必须最终导致一个指定构造器被调用。 两段式构造过程 第一阶段：每个存储型属性被引入它们的类指定一个初始值 第二阶段：给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性 4种有效的安全检查(确保两段式构造过程能不出错地完成) 指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。(一个对象的内存只有在其所有存储型属性确定之后才能完全初始化) 指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。 便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。 构造器的继承和重写 123456789101112131415class Vehicle &#123; var numberOfWheels = 0 var description: String &#123; return "\(numberOfWheels) wheel(s)" &#125;&#125;class Bicycle: Vehicle &#123; override init() &#123; super.init() // 确保`Bicycle`在修改`Vehicle`的属性之前，它所继承的属性`numberOfWheels`能被`Vehicle`初始化 numberOfWheels = 2 &#125;&#125;let bicycle = Bicycle()bicycle.numberOfWheels// 注：子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。 构造器的自动继承 规则1：如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。 规则2：如果子类提供了所有父类指定构造器的实现——无论是通过规则1继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。 指定构造器和便利构造器实践 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Food &#123; var name: String init(name: String) &#123; self.name = name &#125; convenience init() &#123; self.init(name: "[Unnamed]") &#125;&#125;let namedMeat = Food(name: "Bacon")let mysteryMeat = Food()class RecipeIngredient: Food &#123; // 食谱中的一项原料 var quantity: Int init(name: String, quantity: Int) &#123; self.quantity = quantity super.init(name: name) &#125; override convenience init(name: String) &#123; self.init(name: name, quantity: 1) &#125;&#125;let oneMysteryItem = RecipeIngredient()oneMysteryItem.quantity// `RecipeIngredient()`使用从`Food`自动继承的便利构造器`convenience init()`，并在这个便利构造器调用自身的`override convenience init(name: String)`let oneBacon = RecipeIngredient(name: "Bacon")let sixEggs = RecipeIngredient(name: "Eggs", quantity: 6)class ShoppingListItem2: RecipeIngredient &#123; // 购物单中出现的某一种食谱原料 var purchased = false var description: String &#123; var output = "\(quantity) x \(name)" output += purchased ? " 有" : " 无" return output &#125;&#125;var breakfastList = [ ShoppingListItem2(), ShoppingListItem2(name: "Bacon"), ShoppingListItem2(name: "Eggs", quantity: 6),]breakfastList[0].name = "Orange juice"breakfastList[0].purchased = truefor item in breakfastList &#123; print(item.description)&#125; 6 可失败构造器 init?1234567891011121314151617181920212223242526struct Animal &#123; let species: String init?(species: String) &#123; if species.isEmpty &#123; return nil &#125; self.species = species &#125;&#125;let someCreature = Animal(species: "Giraffe") // someCreature的类型是可选类型Animal?，而不是Animalif let giraffe = someCreature &#123; print("An animal was initialized with a species of \(giraffe.species)")&#125;enum TemperatureUnit &#123; case Kelvin, Celsius, Fahrenheit init?(symbol: Character) &#123; switch symbol &#123; case "K": self = .Kelvin case "C": self = .Celsius case "F": self = .Fahrenheit default: return nil &#125; &#125;&#125; 带原始值的枚举类型的可失败构造器带原始值的枚举类型会自带一个可失败构造器 init?(rawValue:)1234enum TemperatureUnit2: Character &#123; case Kelvin = "K", Celsius = "C", Fahrenheit = "F"&#125;let fahrenheitUnit = TemperatureUnit2(rawValue: "X") 构造失败的传递 类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。 传递过程中，一个可失败构造器触发构造失败，整个构造过程将立即终止。12345678910111213141516171819202122232425class Product &#123; let name: String init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125;class CartItem: Product &#123; let quantity: Int init?(name: String, quantity: Int) &#123; if quantity &lt; 1 &#123; return nil &#125; self.quantity = quantity super.init(name: name) &#125;&#125;if let zeroShirts = CartItem(name: "shirt", quantity: 0) &#123; print("Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)")&#125; else &#123; print("Unable to initialize zero shirts")&#125;if let oneUnnamed = CartItem(name: "", quantity: 1) &#123; print("Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)")&#125; else &#123; print("Unable to initialize one unnamed product")&#125; 可以用非可失败构造器重写可失败构造器，但不可反过来。init!类型的可失败构造器构造失败，会触发断言。 7 必要构造器在类的构造器前添加required修饰符表明所有该类的子类都必须实现该构造器在重写父类中必要的指定构造器时，不需要添加 override 修饰符 8 通过闭包或函数设置属性的默认值在闭包执行时，实例的其它部分都还没有初始化。也就说不能在闭包里访问其它属性，即使这些属性有默认值。同样，也不能使用隐式的self属性，或者调用任何实例方法。 1234567891011121314151617struct Checkerboard &#123; // 西洋跳棋棋盘，boardColors是棋盘颜色数组(8*8) let boardColors: [Bool] = &#123; var temporaryBoard = [Bool]() var isBlack = false for i in 1...8 &#123; for j in 1...8 &#123; temporaryBoard.append(isBlack) isBlack = !isBlack &#125; isBlack = !isBlack &#125; return temporaryBoard &#125;() func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool &#123; return boardColors[(row * 8) + column] &#125;&#125; playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>构造过程</tag>
        <tag>Initialization</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-13：继承(Inheritance)]]></title>
    <url>%2F2017%2Fswift-13-inheritance.html</url>
    <content type="text"><![CDATA[一个类可以继承(inherit)另一个类的方法(methods)，属性(properties)和其它特性类可以调用和访问超类的方法，属性和下标(subscripts)，并且可以重写(override)这些方法，属性和下标来优化或修改它们的行为。可以为类中继承来的属性添加属性观察器(property observers) 1 基类(base class)12345678910class Vehicle &#123; var currentSpeed = 0.0 var description: String &#123; return "traveling at \(currentSpeed) miles per hour" &#125; func makeNoise() &#123; // 什么也不做-因为车辆不一定会有噪音 &#125;&#125;let someVehicle = Vehicle() 2 子类生成(Subclassing) 1234567891011class Bicycle: Vehicle &#123; var hasBasket = false&#125;let bicycle = Bicycle()bicycle.hasBasket = truebicycle.currentSpeed = 15.0print("Bicycle: \(bicycle.description)")class Tandem: Bicycle &#123; var currentNumberOfPassengers = 0&#125; 3 重写(Overriding)任何缺少override关键字的重写都会在编译时被诊断为错误。 访问超类的方法，属性及下标。 super 1234567891011121314151617181920class Train: Vehicle &#123; override func makeNoise() &#123; print("Choo Choo") &#125;&#125;let train = Train()train.makeNoise()class Car: Vehicle &#123; var gear = 1 override var description: String &#123; return super.description + " in gear \(gear)" &#125;&#125;class AutomaticCar: Car &#123; override var currentSpeed: Double &#123; didSet &#123; gear = Int(currentSpeed / 10.0) + 1 &#125; &#125;&#125; 4 防止重写final var final func final class func final subscript playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>继承</tag>
        <tag>Inheritance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-12：下标(Subscripts)]]></title>
    <url>%2F2017%2Fswift-12-subscripts.html</url>
    <content type="text"><![CDATA[下标 (subscripts)可以定义在类(class)、结构体(structure)和枚举(enumeration)中，是访问集合(collection)，列表(list)或序列(sequence)中元素的快捷方式。一个类型可以定义多个下标，通过不同索引类型进行重载。 1 下标语法12345678struct TimesTable &#123; let multiplier: Int subscript(index: Int) -&gt; Int &#123; return multiplier * index &#125;&#125;let threeTimesTable = TimesTable(multiplier: 3)print("six times three is \(threeTimesTable[6])") 2 下标用法字典通过下标返回是可选类型 12var numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]numberOfLegs["bird"] = 2 3 下标选项下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。 12345678910111213141516171819202122232425// 一个 Double 类型的二维矩阵struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(repeating: 0.0, count: rows * columns) &#125; func indexIsValidForRow(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValidForRow(row: row, column: column), "Index out of range") return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValidForRow(row: row, column: column), "Index out of range") grid[(row * columns) + column] = newValue &#125; &#125;&#125;var matrix = Matrix(rows: 2, columns: 3)matrix[1, 2] = 2 playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>下标</tag>
        <tag>Subscripts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 3 介绍Auto Layout]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-3.html</url>
    <content type="text"><![CDATA[Auto layout是一种基于约束的，描述性的布局系统。 iPhone尺寸 为什么使用Auto Layout前面的一部分的项目HelloWorld默认是运行的iPhone 7(iPhone 6)的竖屏下的，button是在屏幕中间的，但是如果其他屏幕大小或不同方位就不一定了。按照在默认iPhone 7的条件下，button的左上角的坐标是(147,318)，其他尺寸的设备和不同方位显示时也会按照这种坐标显示，就不会在中间了，这也就是为什么需要使用Auto Layout。 Auto Layout就是关于所有约束关于“Hello World”按钮的位置信息的描述可能比较好的是： 无论屏幕的分辨率和方位，这个按钮在水平和垂直方向都应该是居中的 这实际就定义了两个约束： 水平居中 垂直居中 在Auto Layout中约束都被描述成数学表示，例如上述两个限制就会被表示成： Hello World.centerX = centerX ， Hello World.centerY = centerY。当然我们不需要直接处理这种数学公式，Xcode会帮我们处理。 使用Auto Layout使Button到中央Xcode提供了两种方法定义Auto Layout的约束： Auto Layout工具栏 Control-drag Auto Layout工具栏提供了四个按钮： Stack - 组合views变成一个stack view Align - 构建对齐约束 Pin - 构建空间约束，例如UI的宽度，高度，边距等 Issues - 解决布局问题 使用Align来定义两个约束：水平居中 和 垂直居中。弹窗中”Horizontal in container”后的数字表示button中心点的x坐标与父视图中心点的x坐标的相差数， “Vertically in container”后的数字表示button中心点的y坐标与父视图中心点的y坐标的相差数。如果都为零就表示button的中心和父视图的中心是相同的，也就是说button水平和垂直方向都居中。 点击 “Add 2 Constraints” 后，会出现如下情况。在document outline中出现两个约束选项，在视图中出现垂直两条蓝色的实线，在size检查器中也能看到约束。 如果点击每个约束，在size检查器中还能看到每个约束的具体信息，也能在此修改约束。 解决布局约束问题Xcode可以非常智能的检测的布局约束方面的问题。当创建了模棱两可或冲突的约束时就会出现布局问题。试着将button拖动左下角，视图中原本的蓝色实线变成了黄色实线，并且线上还有数字，这些数字表示button现在的位置偏离约束的距离，document outline右上角出现一个黄色箭头(disclosure arrow)。 点击disclosure arrow，出现布局问题列表，红色框中的Expected表示现在约束所期望的位置也就是居中位置，Actual表示现在实际位置。每个问题右侧有个indicator icon，点击它出现一个弹框，选择Update Frame然后点击Fix Misplacement，按钮回到原来中央位置；选择Update constraints表示button的位置不变，更新到最新位置的约束。 实际上，点击Auto Layout工具栏最右侧的issue，也会出现类似的功能： 不同设备同时预览Xcode提供了一个同时预览不同设备下视图的界面。按住option，然后按menu &gt; Preview(1) &gt; Main.storyboard (Preview)，就能打开用于预览的assistant editor。 这个预览窗口可以预览目前所有iOS设备。 添加一个Label 添加一个”Welcome to Auto Layout”的标签在右下角，并打开预览窗口查看，发现出来除了默认的iPhone 7，其他设备要不偏离了，要不不见了。 用control+drag方法来添加spacing constraint。按住control，从label上向右拖动，拖出label到视图后松开，出现弹框，选择 “Trailing space to container margin” ，表示设置右边距的约束。 类似2的方法，向下拖动松开，选择弹框中的”Vertical Spacing to Bottom Layout Guide”，表示设置了下边距约束。所有约束线变成了蓝色实线，蓝色实线表示约束正常。 document outline上又出现两个约束： 此时如果用预览窗口查看，发现label在不同的设备上都在右下角了： 编辑约束前面也提到约束本身可以手动修改的，选择约束，然后在size检查器中修改。默认label的”trailingMargin”约束的constant值是0，可以试着修改。 练习 添加新的label，修改文本为Learn Swift 把字体大小改为30 point，调整label为适宜大小 添加两个约束 label的上边距为40point label水平居中 代码HelloWorldAutoLayoutHelloWorldAutoLayoutExercise 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 2 Hello World！第一个Swift APP]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-2.html</url>
    <content type="text"><![CDATA[“Hello,World”已经成为编程世界里开始的惯例。 开始：先动起来，忘记代码 打开Xcode，选择”Create a new Xcode project” 选择 iOS &gt; Single View Application and click Next 填写项目的一些选项: Product Name: HelloWorld - app的名字 Team - Apple ID Organization Name: andyron - 这一般是组织的名字，或个人用户的名字；尽量保持不与别人重复 Organization Identifier: cn.andyron Bundle Identifier: com.andyron.HelloWorld - 根据Organization Identifier和Product Name自动组合而成 Language: Swift Devices: iPhone Use Core Data: [unchecked] Include Unit Tests: [unchecked] Include UI Tests: [unchecked] 选择一个项目保持位置，然后生成项目 熟悉Xcode界面Xcode Help中详细介绍了Xcode，主界面如下： 主要分六个区域： Toolbar(工具栏) Tab bar(便签页栏)：类似浏览器的标签页，快捷键也和大部分软件的相同(⌘+T新建，⌘+W关闭)，单个标签页时是隐藏的 Navigator area(导航区域)这个区域最上面有八个图标（快捷键分别对应⌘+1 ~ ⌘+8）： project navigator(源代码文件、图片文件、数据模型、属性列表等) symbol navigator(编译器能识别的：OC类、枚举类型、结构体、全局变量) find navigator issues navigator test navigator debug navigator breakpoint navigator log navigator Editor area（编辑区）这个区域最上面是jump bar(跳转栏) Debug area Utilities area（实用工具面板）分上下两块： Inspector pane(检查器)：选择不同文件会有不同个数的检查器，最多六个(快捷键分别对应⌘+option+1 ~ ⌘+option+6)。 Library pane(库面版, 快捷键分别对应⌘+option+control+1 ~ ⌘+option+control+4) 文件库模板(File Template Library) : 管理文件模板, 可以快速创建指定类型文件, 可以直接拖入项目中; 代码片段库(Code Snippet Library) : 管理各种代码片段, 可以直接拖入源代码中; 对象库(Object Library) : 界面组件, 可以直接拖入 故事板中; 媒体库(Media Library) : 管理各种 图片, 音频 等多媒体资源; 第一次运行AppRun和Stop分别对应 ⌘+R和⌘+.，Simulator用于选择模拟器或真实设备 快速了解Interface Builder（IB）在project navigator中选择main.storyboardThe Interface Builder editor为创造和设计app的UI提高了一个可视化的方法。在这里既可以设计单个页面，也可以设计多个页面。可以直接从右下角Object library拖动可用对象到IB中。当开始新建项目，选择了Single View Application模板时，Xcode默认在storyboard中生成一个view controller scene，对应一个view controller。通常app的每一个screen代表一个view controller。The Document Outline view在选择storyboard特定对象时特别有用。 设计UI 拖动一个Button到IB中 双击Button或在属性检查器中修改name为”Hello World** 根据蓝色虚线辅助线可以把Button拖到中心位置 写代码 选择main.storyboard，点击工具栏右侧的Assistant editor(option+⌘+return)，编辑区出现两部分，Ctrl拖动按钮到右侧ViewController类中： 然后写下如下代码：1234567@IBAction func showMessage() &#123; let alertController = UIAlertController(title: &quot;Welcome to My First App&quot;,message: &quot;Hello World&quot;, preferredStyle: UIAlertControllerStyle.alert) alertController.addAction(UIAlertAction(title: &quot;OK&quot;, style:UIAlertActionStyle.default, handler: nil)) present(alertController, animated: true, completion: nil)&#125; 上面的方法是先连接关系，然后写代码；也可以先写好代码，然后建立关系：@IBAction表示一个Action的标识符，没有特殊意义，当建立好关系后，@IBAction右侧会出现一个实心的点，点击会出现会出现以个弹框表示连接的地方： 修改按钮的颜色。选中按钮，在属性检查器中修改对应属性 测试应用选择特定的模拟器或设备，⌘+R Hello world 应用中事件流 更近一步 同上的方法添加几个按钮，并修改button的name为一些emoji表情（control+⌘+space） 添加@IBAction方法代码 通过先写好代码然后建立关系的方法，把几个button都与同一个@IBAction方法建立关系 代码HelloWorldHelloWordExercise 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-11：方法(Methods)]]></title>
    <url>%2F2017%2Fswift-11-methods.html</url>
    <content type="text"><![CDATA[方法是与某些特定类型相关联的函数实例方法为给定类型的实例封装了具体的任务与功能类、结构体、枚举都可以定义实例方法，也都可以定义类型方法在OC中，类是唯一能定义方法的类型 1 实例方法 (Instance Methods) 实例方法只能被它所属的类的某个特定实例调用 123456789101112class Counter &#123; var count = 0 func increment() &#123; count += 1 &#125; func incrementBy(amount: Int) &#123; count += amount &#125; func reset() &#123; count = 0 &#125;&#125; 方法的局部参数名称和外部参数名称 (Local and External Parameter Names for Methods) 12345678class Counter2 &#123; var count: Int = 0 func incrementBy(amount: Int, numberOfTimes: Int) &#123; count += amount * numberOfTimes &#125;&#125;let counter = Counter2()counter.incrementBy(amount: 5, numberOfTimes: 3) self 属性(The self Property)：self完全等同于该实例本身。 消除方法参数 x 和实例属性 x 之间的歧义: 123456struct Point &#123; var x = 0.0, y = 0.0 func isToTheRightOfX(x: Double) -&gt; Bool &#123; return self.x &gt; x &#125;&#125; 在实例方法中修改值类型(Modifying Value Types from Within Instance Methods)结构体和枚举的属性不能在它的实例方法中被修改(因为结构体和枚举是值类型)，但可通过mutating（可变方法）修改。 123456789struct Point2 &#123; var x = 0.0, y = 0.0 mutating func moveByX(_ deltaX: Double, y deltaY: Double) &#123; x += deltaX y += deltaY &#125;&#125;var somePoint = Point2(x: 1.0, y: 1.0)somePoint.moveByX(2.0, y: 3.0) 在可变方法中给 self 赋值(Assigning to self Within a Mutating Method) 12345678910111213141516171819struct Point3 &#123; var x = 0.0, y = 0.0 mutating func moveByX(_ deltaX: Double, y deltaY: Double) &#123; self = Point3(x: x + deltaX, y: y + deltaY) &#125;&#125;enum TriStateSwitch &#123; case Off, Low, High mutating func next() &#123; switch self &#123; case .Off: self = .Low case .Low: self = .High case .High: self = .Off &#125; &#125;&#125; 2 类型方法 (Type Methods)static class在类型方法的方法体(body)中，self指向这个类型本身，而不是类型的某个实例。 1234567891011121314151617181920212223242526272829struct LevelTracker &#123; static var highestUnlockedLevel = 1 static func unlockLevel(level: Int) &#123; if level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125; &#125; static func levelIsUnlocked(level: Int) -&gt; Bool &#123; return level &lt;= highestUnlockedLevel &#125; var currentLevel = 1 mutating func advanceToLevel(level: Int) -&gt; Bool &#123; if LevelTracker.levelIsUnlocked(level: level) &#123; currentLevel = level return true &#125; else &#123; return false &#125; &#125;&#125;class Player &#123; var tracker = LevelTracker() let playerName: String func completedLevel(level: Int) &#123; LevelTracker.unlockLevel(level: level + 1) tracker.advanceToLevel(level: level + 1) &#125; init(name: String) &#123; playerName = name &#125;&#125; playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>方法</tag>
        <tag>Methods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-10：属性(Properties)]]></title>
    <url>%2F2017%2Fswift-10-properties.html</url>
    <content type="text"><![CDATA[1 存储属性 Stored Properties （只能用于类和结构体）12345678910111213// 描述整数的范围，且这个范围值在被创建后不能被修改.struct FixedLengthRange &#123; var firstValue: Int let length: Int&#125;// 该区间表示整数0，1，2var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)// 该区间现在表示整数6，7，8rangeOfThreeItems.firstValue = 6// 常量结构的属性不能修改let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)// 尽管 firstValue 是个变量属性，这里还是会报错//rangeOfFourItems.firstValue = 6 延迟存储属性: 第一次被调用的时候才会计算其初始值。 lazy var (常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性)12345678910111213141516class DataImporter &#123; /* DataImporter 是一个负责将外部文件中的数据导入的类。 这个类的初始化会消耗不少时间。 */ var fileName = "data.txt" // 这里会提供数据导入功能&#125;class DataManager &#123; lazy var importer = DataImporter() var data = [String]() // 这里会提供数据管理功能&#125;let manager = DataManager() // DataImporter 实例的 importer 属性还没有被创建manager.data.append("Some data")manager.data.append("Some more data")manager.importer.fileName 2 计算属性Computed Properties (可用于类，结构体和枚举)不直接存储值，而是提供一个getter和一个可选的setter,来间接获取和设置其他属性或变量的值。 12345678910111213141516171819202122232425262728293031323334struct Point &#123; var x = 0.0, y = 0.0&#125;struct Size &#123; var width = 0.0, height = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set(newCenter) &#123; origin.x = newCenter.x - (size.width / 2) origin.y = newCenter.y - (size.height / 2) &#125; &#125;&#125;var square = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 10.0, height: 10.0))let initialSquareCenter = square.centersquare.center = Point(x: 15.0, y: 15.0)print("square.origin is now at (\(square.origin.x), \(square.origin.y))")// 输出 "square.origin is now at (10.0, 10.0)”// 只读计算属性struct Cuboid &#123; var width = 0.0, height = 0.0, depth = 0.0 var volume: Double &#123; // 只用get时可简写 return width*height*depth &#125;&#125; 3 属性观察器(Property Observers)设置属性时（就算值不变），就会调用willSet， didSet 123456789101112131415161718192021class StepCounter &#123; var totalSteps: Int = 0 &#123; willSet &#123; print("设置成\(newValue)") &#125;// willSet(newTotalSteps) &#123;// print("About to set totalSteps to \(newTotalSteps)")// &#125; didSet &#123; if totalSteps &gt; oldValue &#123; print("Added \(totalSteps - oldValue) steps") &#125; &#125;// didSet(old) &#123;// print(old)// &#125; &#125;&#125;let stepCounter = StepCounter()stepCounter.totalSteps = 1stepCounter.totalSteps = 20 4 全局变量和局部变量(Global and Local Variables)计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量 5 类型属性(Type Properties)：用于某个类型所有实例共享的数据。(类似于其他语言的静态属性)存储型类型属性是延迟初始化的。 标识符static可用在类、结构体、枚举、协议，class只用在类中。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647struct SomeStructure &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 1 &#125;&#125;enum SomeEnumeration &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 6 &#125;&#125;class SomeClass &#123; static var storedTypeProperty = "Some value." static var computedTypeProperty: Int &#123; return 27 &#125; class var overrideableComputedTypeProperty: Int &#123; return 107 &#125;&#125;SomeStructure.storedTypePropertyprotocol MyProtocol &#123; static func foo() -&gt; String&#125;// 声道模型struct AudioChannel &#123; static let thresholdLevel = 10 // 音量的最大 上限阈值 static var maxInputLevelForAllChannels = 0 // 实例的最大 音量 var currentLevel: Int = 0 &#123; didSet &#123; if currentLevel &gt; AudioChannel.thresholdLevel &#123; // 将当前音量限制在阀值之内 currentLevel = AudioChannel.thresholdLevel &#125; if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels &#123; // 存储当前音量作为新的最大输入音量 AudioChannel.maxInputLevelForAllChannels = currentLevel &#125; &#125; &#125;&#125;var leftChannel = AudioChannel()var rightChannel = AudioChannel()leftChannel.currentLevel = 7print(leftChannel.currentLevel)print(AudioChannel.maxInputLevelForAllChannels) playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>属性</tag>
        <tag>Properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-9：类和结构体(Classes and Structures)]]></title>
    <url>%2F2017%2Fswift-9-structures-classes.html</url>
    <content type="text"><![CDATA[一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。 类和结构体的异同 类和结构体的共同点： 定义属性用于存储值 定义方法用于提供功能 定义下标操作使得可以通过下标语法来访问实例所包含的值 定义构造器用于生成初始化值 通过扩展以增加默认实现的功能 实现协议以提供某种标准功能 类还有如下的附加功能： 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 析构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 结构体总是通过被复制的方式在代码中传递，不使用引用计数。 新类或结构体命名用UpperCamelCase（Swift类型的命名规范） 属性和方法命名用lowerCamelCase 12345678910struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125; 类和结构体实例 结构体和类都使用构造器语法来生成新的实例， ()是最简单的构造器语法。 12let someResolution = Resolution()let someVideoMode = VideoMode() 结构体的成员逐一构造器 1let hd = Resolution(width: 1920, height: 1080) 结构体和枚举是值类型。所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary)，都是 值类型，并且在底层都是以结构体的形式所实现。 123var cinema = hdcinema.width = 2048print("hd is still \(hd.width) pixels wide") 类是引用类型 12345678910let tenEighty = VideoMode()tenEighty.resolution = hdtenEighty.interlaced = truetenEighty.name = "1080i"tenEighty.frameRate = 25.0let alsoTenEighty = tenEightyalsoTenEighty.frameRate = 30.0tenEighty.frameRate// 恒等运算符:判定两个常量或者变量是否引用同一个类实例tenEighty === alsoTenEighty 建议选择结构体的情况： 该数据结构的主要目的是用来封装少量相关简单数据值。 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 该数据结构不需要去继承另一个既有类型的属性或者行为。 12345678910111213struct Shape &#123; var width: Double = 1.0 var height: Double = 1.0&#125;struct Path &#123; var start: Int var length: Int&#125;struct Point &#123; var x: Double var y: Double var z: Double&#125; Swift中的String，Array和Dictionary是值类型，OC中的NSString， NSArray和NSDictionary是引用类型 playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>类</tag>
        <tag>结构体</tag>
        <tag>Classes</tag>
        <tag>Structures</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-8：枚举(Enumerations)]]></title>
    <url>%2F2017%2Fswift-8-enumerations.html</url>
    <content type="text"><![CDATA[一等(first-class)类型每个枚举定义了一个全新的类型。以大写字母开头成员值(或成员) 原始值 关联值不会被赋予一个默认的整型值 1 枚举语法1234567891011enum CompassPoint &#123; case North case South case East case West&#125;enum Planet &#123; case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125;var directionToHead = CompassPoint.WestdirectionToHead = .East 2 Switch 语句匹配枚举值 12345678910switch directionToHead &#123; case .North: print("Lots of planets have a north") case .South: print("Watch out for penguins") case .East: print("Where the sun rises") case .West: print("Where the skies are blue")&#125; 3 关联值(Associated Values) 任意类型，可以各不相同“定义一个名为 Barcode 的枚举类型，它的一个成员值是具有 (Int，Int，Int，Int) 类型关联值的 UPCA ，另一个成员值是具有 String 类型关联值的 QRCode 。” 123456789101112enum Barcode &#123; case UPCA(Int, Int, Int, Int) case QRCode(String)&#125;var productBarcode = Barcode.UPCA(8, 85909, 51226, 3)productBarcode = .QRCode("ABCDEFGHIJKLMNOP")switch productBarcode &#123;case .UPCA(let numberSystem, let manufacturer, let product, let check): print("UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).")case .QRCode(let productCode): print("QR code: \(productCode).")&#125; 4 原始值(Raw Values)5 递归枚举(Recursive Enumerations) playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>枚举</tag>
        <tag>Enumerations</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-7：闭包(Closure)]]></title>
    <url>%2F2017%2Fswift-7-closure.html</url>
    <content type="text"><![CDATA[闭包是自包含的函数代码块，可以在代码中被传递和使用。Swift 中的闭包与 C 和 Objective-C 中的代码块(blocks)以及其他一些编程语言中的匿名函数比较相似。闭包可以捕获和存储其所在上下文中任意常量和变量的引用。 1 闭包表达式(Closure Expressions)1234567// sorted 方法(The Sorted Method)// 原数组不会被 sorted(by:) 方法修改。let names = ["Chris", "Alex", "Ewa", "Barry", "Daniella", "Andy", "Amni"]func backward(_ s1: String, _ s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversedNames = names.sorted(by: backward) 闭包表达式语法:1234&#123; (parameters) -&gt; returnType instatements&#125;关键字`in`表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。 1var reversedNames2 = names.sorted(by: &#123;(s1:String, s2:String) -&gt; Bool in return s1&gt;s2&#125;) 根据上下文推断类型(Inferring Type From Context) 1var reversedNames3 = names.sorted(by: &#123;(s1, s2)-&gt;Bool in return s1&gt;s2&#125;) 根据上下文推断类型(Inferring Type From Context) 省略 return 和 返回值 1var reversedNames4 = names.sorted(by: &#123;(s1, s2) in s1&gt;s2&#125;) 参数名称缩写(Shorthand Argument Names)：直接通过 $0 ， $1 ， $2 来顺序调用闭包的参数 1var reversedNames5 = names.sorted(by: &#123;$0&gt;$1&#125;) 运算符方法(Operator Methods) 1var reversedNames6 = names.sorted(by: &gt;) 2 尾随闭包(Trailing Closures):将一个很长的闭包表达式作为最后一个参数传递给函数不使用尾随闭包进行函数调用： 123func someFunctionThatTakesAClosure(closure: &#123;// 闭包主体部分 &#125;) 使用尾随闭包进行函数调用： 123func someFunctionThatTakesAClosure() &#123;// 闭包主体部分 &#125; 1234567891011121314151617var reversedNames7 = names.sorted()&#123;$0&gt;$1&#125;var reversedNames8 = names.sorted&#123;$0&gt;$1&#125; // 当闭包表达式是唯一参数时， ()可省略let digitNames = [ 0: "Zero", 1: "One", 2: "Two", 3: "Three", 4: "Four", 5: "Five", 6: "Six", 7: "Seven", 8: "Eight", 9: "Nine"]let numbers = [16, 58, 510]let strings = numbers.map &#123; (number) -&gt; String in var number = number var output = "" repeat &#123; output = digitNames[number%10]! + output // 字典下标返回一个可选值(optional value) number /= 10 &#125; while number &gt; 0 return output&#125; 3 值捕获(Capturing Values)闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。 嵌套函数 是 捕获值的闭包的最简单形式 1234567891011121314func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer&#125;var funcby10 = makeIncrementer(forIncrement: 10)var funcby50 = makeIncrementer(forIncrement: 50)// 新生成的incrementer函数，都会各自获得类似全局变量的 amount和runingTotalfuncby50()funcby50()funcby10() 4 闭包是引用类型(Closures Are Reference Types)// 函数和闭包都是引用类型// 无论将函数或闭包赋值给一个常量还是变量，实际上都是将常量或变量的值设置为对应函数或闭包的引用。 12let funcbyTen = funcby10funcbyTen() 逃逸闭包(Escaping Closures) 自动闭包(Autoclosures) playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>闭包</tag>
        <tag>Closure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-6：函数(Functions)]]></title>
    <url>%2F2017%2Fswift-6-functions.html</url>
    <content type="text"><![CDATA[1 函数的定义与调用 (Defining and Calling Functions)参数，parameters返回类型，return type实参，arguments 123func greet(person: String) -&gt; String &#123; return "Hello, " + person + "!"&#125; 2 函数参数与返回值 (Function Parameters and Return Values)无参数函数 (Functions Without Parameters) 123func sayHelloWorld() -&gt; String &#123; return "hello, world"&#125; 多参数函数 (Functions With Multiple Parameters) 1234567func greet(person: String, alreadyGreeted: Bool) -&gt; String &#123; if alreadyGreeted &#123; return "Hello, " + person + " again!" &#125; else &#123; return "Hello, " + person + "!" &#125;&#125; 无返回值函数 (Functions Without Return Values)：没有定义返回类型的函数会 返回一个特殊的Void值。它其实是一个空的元组(tuple)，没有任何元素，可以写成()。 123func greet(person: String) &#123; print("Hello, \(person)!")&#125; 多个返回值函数 (Functions with Multiple Return Values) 1234567891011121314func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print("min is \(bounds.min) and max is \(bounds.max)") 可选元组返回类型 (Optional Tuple Return Types) 12345678910111213141516func minMax2(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;if let bounds = minMax2(array: [8, -6, 2, 109, 3, 71]) &#123; print("min is \(bounds.min) and max is \(bounds.max)")&#125; 3 函数参数标签和参数名称 (Function Argument Labels and Parameter Names)每个函数参数都有一个参数标签( argument label )以及一个参数名称( parameter name )。参数标签在调用函数的时候使用;调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用。 12func someFunction(argumentLabel parameterName: Int) &#123;&#125; 忽略参数标签(Omitting Argument Labels)默认参数值 (Default Parameter Values) 可变参数 (Variadic Parameters) 一个函数最多只能拥有一个可变参数 123456789func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;print(arithmeticMean(1,2,3))print(arithmeticMean(1.2,3.45,5,6,3.12)) 输入输出参数(In-Out Parameters)函数参数默认是常量。输入输出参数可以在函数中修改参数，并且在函数调用结束后仍然存在。只能传递变量给输入输出参数输入输出参数不能有默认值，而且可变参数不能用inout标记。 123456789func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print("someInt is now \(someInt), and anotherInt is now \(anotherInt)") 4 函数类型 (Function Types)123456func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; // `(Int, Int) -&gt; Int` return a + b&#125;func printHelloWorld() &#123; // `() -&gt; Void` print("hello, world")&#125; 使用函数类型 (Using Function Types) 12var mathFunction: (Int, Int) -&gt; Int = addTwoIntsprint("Result: \(mathFunction(2, 3))") 函数类型作为参数类型 (Function Types as Parameter Types) 1234func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print("Result: \(mathFunction(a, b))")&#125;printMathResult(addTwoInts, 3, 5) 函数类型作为返回类型 (Function Types as Return Types)123456789func stepForward(_ input: Int) -&gt; Int &#123; return input + 1&#125;func stepBackward(_ input: Int) -&gt; Int &#123; return input - 1&#125;func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; return backward ? stepBackward : stepForward&#125; 5 嵌套函数 (Nested Functions)12345func chooseStepFunction2(backward: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125; playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>函数</tag>
        <tag>Functions</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-5：控制流(Control Flow)]]></title>
    <url>%2F2017%2Fswift-5-control-flow.html</url>
    <content type="text"><![CDATA[1 for infor in 可用来遍历 Array Dictionary Set Range String 1234567891011121314for index in 1...5 &#123;&#125;for _ in 1...5 &#123;&#125;for v in [1,2,3] &#123;&#125;let numberOfLegs = ["spider": 8, "ant": 6, "cat": 4]for (animalName, legCount) in numberOfLegs &#123;&#125;let countrys:Set = ["China", "USA", "Japan"]for country in countrys &#123;&#125;for s in "andyron" &#123;&#125; 2 while 12345678910var i = 1while i &gt; 10 &#123; // ... i += 1&#125;// repeat-while 类似其他语言的 do-while repeat &#123; // ... i += 1&#125; while i &gt; 10 3 if12345678var temperatureInFahrenheit = 30if temperatureInFahrenheit &lt;= 32 &#123; print("It's very cold. Consider wearing a scarf.")&#125; else if temperatureInFahrenheit &gt;= 86 &#123; print("It's really warm. Don't forget to wear sunscreen.")&#125; else &#123; print("It's not that cold. Wear a t-shirt.")&#125; 4 switch不存在隐式的贯穿(No Implicit Fallthrough)，不需要break 1234567let anotherCharacter: Character = "a"switch anotherCharacter &#123;case "a", "A": print("The letter A")default: print("Not the letter A")&#125; 区间匹配1234567891011121314151617let approximateCount = 62let countedThings = "moons orbiting Saturn"var naturalCount: Stringswitch approximateCount &#123;case 0: naturalCount = "no"case 1..&lt;5: naturalCount = "a few"case 5..&lt;12: naturalCount = "several"case 12..&lt;100: naturalCount = "dozens of"case 100..&lt;1000: naturalCount = "hundreds of"default: naturalCount = "many"&#125; 元组匹配12345678910111213let somePoint = (1, 1)switch somePoint &#123;case (0, 0): print("(0, 0) is at the origin")case (_, 0): print("(\(somePoint.0), 0) is on the x-axis")case (0, _): print("(0, \(somePoint.1)) is on the y-axis")case (-2...2, -2...2): print("(\(somePoint.0), \(somePoint.1)) is inside the box")default: print("(\(somePoint.0), \(somePoint.1)) is outside of the box")&#125; 值绑定(Value Bindings)123456789let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print("on the x-axis with an x value of \(x)")case (0, let y): print("on the y-axis with a y value of \(y)")case let (x, y): print("somewhere else at (\(x), \(y))")&#125; case分句中使用where123456789let yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print("(\(x), \(y)) is on the line x == y")case let (x, y) where x == -y: print("(\(x), \(y)) is on the line x == -y")case let (x, y): print("(\(x), \(y)) is just some arbitrary point")&#125; 复合匹配当多个条件可以使用同一种方式来处理时，可以将这几种可能放在同一个case后面，并且用逗号隔开。 1234567let stillAnotherPoint = (9, 0)switch stillAnotherPoint &#123;case (let distance, 0), (0, let distance): print("On an axis, \(distance) from the origin")default: print("Not on an axis")&#125; 5 控制转移语句(Control Transfer Statements): continue break fallthrough return throw贯穿(Fallthrough) 执行完一个case后，继续向下执行 123456789let integerToDescribe = 5var description = "The number \(integerToDescribe) is"switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += " a prime number, and also" fallthroughdefault: description += " an integer."&#125; 6 guard 与 if功能类似。区别：1 guard减少嵌套，会简洁 2 解包时，guard的结果作用域不限于本身。 12345678910111213141516171819202122232425262728// greet(person: ["name": "Jane", "location": "Cupertino"])func greet(person: [String: String]) &#123; if let name = person["name"] &#123; print("Hello \(name)!") if let location = person["location"] &#123; print("I hope the weather is nice in \(location).") &#125; else &#123; print("I hope the weather is nice near you.") &#125; &#125; else &#123; print("Hello stranger!") &#125;// print(name) //name的作用于只限于if中&#125;func greet2(person: [String: String]) &#123; guard let name = person["name"] else &#123; print("Hello stranger!") return &#125; print("Hello \(name)!") guard let location = person["location"] else &#123; print("I hope the weather is nice near you.") return &#125; print("I hope the weather is nice in \(location).")&#125; 7 检测 API 可用性12345if #available(iOS 10, macOS 10.12, *) &#123; // 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API&#125; else &#123; // 使用先前版本的 iOS 和 macOS 的 API&#125; playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
      <tags>
        <tag>控制流</tag>
        <tag>Control Flow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-4：集合类型(Collection Type)]]></title>
    <url>%2F2017%2Fswift-4-cellection-types.html</url>
    <content type="text"><![CDATA[Collection 分为 Arrays, Sets, Dictionaries(Collection，Sets有时都翻译成集合) 1 数组(Arrays)是有序数据的集。一个数组中只能有一种数据类型 123456789101112131415161718192021222324252627282930313233343536373839404142var someInts = [Int]() // 创建一个由特定数据类型构成的空数组someInts = [] // someInts 现在是空数组，但是仍然是 [Int] 类型的。let unmutableArray = [2, 3, 5] // 定义为let，数组内容和数量就不能变化var threeDoubles = [Double](repeating:0.0, count: 3) // `Array`创建特定大小并且所有数据都有相同默认值的构造方法var anotherThreeDoubles = [Double](repeating: 2.5, count: 3)var sixDoubles = threeDoubles + anotherThreeDoubles // 数组相加sixDoubles.countsixDoubles.isEmptysixDoubles.append(2.6)sixDoubles += [3.2, 3.3]sixDoubles[0]sixDoubles[4...6] // 通过区间获取多个数组项组成的新数组，注意区间大小不能超过数组的下标sixDoubles.insert(4.4, at: 2)sixDoubles.remove(at: 0)sixDoubles.removeLast()sixDoubles.removeAll()// 数组遍历var shoppingList = ["Eggs", "Milk"]for item in shoppingList &#123; print("\(item)")&#125;for (index, value) in shoppingList.enumerated() &#123; // enumerated()把数组的索引和值生成sequence用于遍历 print("\(index): \(value)")&#125;// 数组特殊操作 //var a = (1...10)var arr = [1,3,7,11]var arr2 = arr.map&#123;$0 * 2&#125;var sum = arr.reduce(0,+)// 验证tweet中是否包含选定的若干关键字中的一个let words = ["Swift","iOS","cocoa","OSX","tvOS"]let tweet = "This is an example tweet larking about Swift"//words.contains(tweet.containsString)//words.filter(&#123;tweet.containsString($0)&#125;)tweet.split(separator: " ") .lazy .map(String.init) .contains(where: Set(words).contains)let name = "andyron"(1...4).forEach&#123;print("Happy Birthday " + (($0 == 3) ? "dear \(name)":"to You"))&#125;// 创建重复固定长度数组let arr3 = [Int?](repeating: nil, count: 20) 2 集合(Sets)是无序无重复数据的集。存在集合的中数据类型必须是 可哈希化（必须提供一个方法来计算它的哈希值， 相等的对象哈希值必须相同， a.hashValue == b.hashValue）Swift的所有基本类型(比如String , Int , Double 和 Bool)默认都是可哈希化的在Swift内部可哈希化的类型都接触了Hashable协议，它提高了一个属性hashValue 123456789101112131415161718192021222324252627282930313233var letters = Set&lt;Character&gt;() // 创建和构造一个空的类型为`Set&lt;Character&gt;`的集合letters.insert("a")letters = []var favoriteGenres: Set&lt;String&gt; = ["Rock", "Classical", "Hip hop"]var favoriteGenres2: Set = ["Rock", "Classical", "Hip hop"]favoriteGenres.insert("Jazz")favoriteGenres.countfavoriteGenres.remove("Classical") // 有成员就返回此成员，否则返回`nil`//favoriteGenres.removeAll()favoriteGenres.contains("Rock")// 遍历集合for genre in favoriteGenres &#123; print(genre)&#125;for genre in favoriteGenres.sorted() &#123; print(genre)&#125;// 集合操作favoriteGenres = ["Rock", "Classical", "Hip hop"]favoriteGenres2 = ["Hip hop", "R&amp;B", "rap"]favoriteGenres.intersection(favoriteGenres2) // 交集favoriteGenres.symmetricDifference(favoriteGenres2) // 对称差集favoriteGenres.union(favoriteGenres2) // 并集favoriteGenres.subtracting(favoriteGenres2) // 差集favoriteGenres2.subtracting(favoriteGenres) // 差集favoriteGenres.subtract(favoriteGenres2) // 区别于subtracting，没有返回值直接修改favoriteGenresvar fg3: Set = ["rap"]favoriteGenres == favoriteGenres2favoriteGenres2.isSubset(of: fg3) // favoriteGenres2中所有元素是否在fg3中favoriteGenres2.isSuperset(of: fg3) // favoriteGenres2是否包括fg3中所有元素favoriteGenres2.isStrictSubset(of: fg3) // favoriteGenres2中所有元素是否在fg3中，并且两者不相同favoriteGenres2.isStrictSuperset(of: fg3) // favoriteGenres2是否包括fg3中所有元素，并且两者不相同favoriteGenres.isDisjoint(with: fg3) // favoriteGenres与fg3是否没有交集 3 字典(Dictionaries)是无序的键值对的集。12345678910111213141516171819var namesOfIntegers = [Int: String]()namesOfIntegers[16] = "sixteen"namesOfIntegers = [:]var airports: [String: String] = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]var airports2 = ["YYZ": "Toronto Pearson", "DUB": "Dublin"]airports.countairports.isEmptyairports["hongqiao"] = "shanghai"airports.updateValue("nanjing", forKey: "jichang")airports["jichang"] = nil; //airports.remove(at: "jichang")//airports.keys//airports.values// 遍历for (code, name) in airports &#123; print("\(code): \(name)")&#125;for code in airports.keys &#123; print("\(code)")&#125; playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-3：字符串和字符(Strings and Characters)]]></title>
    <url>%2F2017%2Fswift-3-strings-characters.html</url>
    <content type="text"><![CDATA[1 字符串字面量(String Literals)“Some string literal value” 2 初始化空字符串 (Initializing an Empty String)12345var emptyString = ""var anotherEmptyString = String()if emptyString.isEmpty &#123; print("Nothing to see here")&#125; 3 字符串可变性(String Mutability)1234var variableString = "Horse"variableString += " and carriage"//let constantString = "Highlander"//constantString += " and another Highlander" 4 字符串是值类型(Strings Are Value Types)在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。 5 使用字符(Working with Characters)123456for character in "Dog!?🐶" &#123; print(character)&#125;let exclamationMark: Character = "!" // `Character`是字符（注意也是双引号，不是单引号）let catCharacters: [Character] = ["C", "a", "t", "!", "?"]let catString = String(catCharacters) // 字符数组生成字符串 6 连接字符串和字符 (Concatenating Strings and Characters)12345let string1 = "Hello"let string2 = " there"var welcome0 = string1 + string2welcome0 += string1welcome0.append(exclamationMark) 7 字符串插值 (String Interpolation)插值字符串中写在括号中的表达式不能包含非转义双引号 (“) 和反斜杠 ()，并且不能包含回车或换行符。 12let multiplier = 3let message = "\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)" // message is "3 times 2.5 is 7.5" 8 Unicode12345// Swift的String和Character类型是完全兼容Unicode标准的。let dollarSign = "\u&#123;24&#125;" // Unicode 标量 U+0024let blackHeart = "\u&#123;2665&#125;" // Unicode 标量 U+2665let sparklingHeart = "\u&#123;1F496&#125;" // Unicode 标量 U+1F496// 可扩展的字形群集(Extended Grapheme Clusters) 9 计算字符数量 (Counting Characters)welcome0.count 10 访问和修改字符串 (Accessing and Modifying a String)12345678910111213141516let greeting = "Guten Tag!"greeting[greeting.startIndex] // Ggreeting[greeting.index(before: greeting.endIndex)] // !greeting[greeting.index(after: greeting.startIndex)] // ulet index = greeting.index(greeting.startIndex, offsetBy: 6) // 从某个索引开始向后offsetBy的索引greeting[index]for index in greeting.indices &#123; print("\(greeting[index]) ", terminator: "")&#125;// Inserting and Removingvar welcome = "hello"welcome.insert("!", at: welcome.endIndex) // welcome now equals "hello!"welcome.insert(contentsOf:" there", at: welcome.index(before: welcome.endIndex)) // welcome now equals "hello there!welcome.remove(at: welcome.index(before: welcome.endIndex)) // welcome now equals "hello there"let range = welcome.index(welcome.endIndex, offsetBy: -6) ..&lt; welcome.endIndexwelcome.removeSubrange(range) // welcome now equals "hello" 11 比较字符串 (Comparing Strings)12 字符串的 Unicode 表示形式(Unicode Representations of Strings)13 String的常见方法和属性1234567891011//welcome.characters // `String`没有继承`Sequence`，不能直接遍历，用 `String.characters`welcome.countfor c in welcome &#123;&#125;welcome.isEmptywelcome.startIndexwelcome.hashValuewelcome.hasPrefix("he") // 是否有前缀welcome.hasSuffix("!") // 是否有后缀welcome.lowercased() // 变成小写welcome.uppercased() // 变成大写 playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-2：基础运算符(Basic Operators)]]></title>
    <url>%2F2017%2Fswift-2-basic-operators.html</url>
    <content type="text"><![CDATA[1 赋值运算符(Assignment Operator) 赋值操作并不返回任何值123let b = 10var c = 5let (x, y) = (2, 5) 2 算术运算符(Arithmetic Operators)1234567891011121 + 25 - 32 * 310.0 / 2.5"hello, " + "world"// 溢出运算(如 a &amp;+ b )// 求余运算符(Remainder Operator)// a % b a = (b × 倍数) + 余数 倍数是整数，可以是负数9 % 4 // 1 9 = 4*2 + 1-9 % 4 // -1 -9 = 4*-2 + (-1)// 自增和自减运算 (最新版的swift已经去掉)// 一元负号运算符/一元正号运算符 3 复合赋值(Compound Assignment Operators)复合赋值运算没有返回值 12var a = 1a += 2 4 比较运算符(Comparsion Operators)123456789101112131 == 11 &lt;= 22 &gt;= 11 &lt; 11 &gt; 2class A &#123; &#125;var obja = A()var objb = A()var objc = objaobja === objb // false 恒等 === 和不恒等 !== 只用来两个对象是否引用同一个对象实例obja !== objc // false 5 三目运算符(Ternary Conditional Operator)1true ? "true" : "false" 6 空合运算符(Nil Coalescing Operator)123var e: String?var f = "我是fuck"e ?? f // `e != nil ? e! : f` ， 可选类型`e`不是`nil`时，就`e!`,否则为`f`。（注意`??`前后要空格） 7 区间运算符(Range Operators)123456for index in 1...5 &#123; print("\(index) * 5 = \(index * 5)")&#125;for index in 1..&lt;5 &#123; print("\(index) * 5 = \(index * 5)")&#125; 8 逻辑运算(Logical Operators) 操作对象是逻辑布尔值12345var mybool = falsevar youbool = true!myboolmybool &amp;&amp; youboolmybool || youbool playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-1：基础(The Basics)]]></title>
    <url>%2F2017%2Fswift-1-the-basics.html</url>
    <content type="text"><![CDATA[1 常量和变量(Constants and Variables)12345678910111213141516171819// 声明：常量 let 变量 varlet constants = 10var variables = 0// 多个声明var x = 0.0, y = 0.0, z = 0.0// 类型标注(type annotation)var welcomeMessage: String// 常量和变量的命名// 常量与变量名不能包含数学符号，箭头，保留的(或者非法的)Unicode 码位，连线与制表符。也不能以数字开头。// 常量与变量不能修改类型也不能互换// 使用反引号（`）来使用保留关键字let π = 3.14159let 你好 = "你好世界"let `let` = "hihi"// 输出常量和变量 `func print(_ items: Any..., separator: String = default, terminator: String = default)` 三种参数：输出项、分隔符、结束符print(1,`let`, separator: ",", terminator: "&lt;br/&gt;")print(x, y, z, `let`)// 字符串插值(string interpolation)print("The current value of constants is \(constants)") 2 注释(Comment)123456// 单行注释/* /* 多行注释可以嵌套在其它的多行注释之中 */ */ 3 分号(Semicolons)单行单条语句不一定需要，单行多条语句必须 let cat = &quot;?&quot;; print(cat) 4 整数(Integers)U代表无符号Int类型与当前系统的位数相同 12345678UInt8.maxUInt8.minInt8.maxInt32.maxUInt32.maxInt64.maxUInt64.maxInt.max 5 浮点数(Floating-Point Numbers)12Double(11.1) // 64位Float(11.1) // 32位 6 类型安全(type safe)和类型推断(type inference)12let meaningOfLife = 42 // meaningOfLife 会被推测为 Int 类型let pi = 3.14159 // pi 会被推测为 Double 类型(优先选择 Double 而不是 Float ) 7 数值型字面量(Numeric Literals)123456789101112// 整数字面量150b1111 // 二进制150o17 // 八进制150xf // 十六进制15// 浮点字面量1.025e2 // 1.025*10^21.025e-2 // 1.025*10^-20xbp3 // 11*2^30xbp-3 // 11*2^-30xC.3p0 // (12+3/16)*2^0100_000 // _增强可读性 8 数值型类型转换(Numeric Type Conversion)12345678910// 整数转换let twoThousand: UInt16 = 2_000let one: UInt8 = 1let twoThousandAndOne = twoThousand + UInt16(one) // `UInt16`有一个构造器，接受`UInt8`类型的参数生成`UInt16`// 整数和浮点数转换let three = 3let pointOneFourOneFiveNine = 0.14159let pi2 = Double(three) + pointOneFourOneFiveNinelet integerPi = Int(pi2)let pi3 = 3 + 0.14159 // 字面量没有特定的类型，所以可以直接相加 9 类型别名(type aliases)12typealias AudioSample = UInt16AudioSample.max 10 布尔值12truefalse 11 元组(tuples)把多个值组合成一个复合值 1234567// 元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。let http404Error = (404, "Not Found") // 一个类型为 (Int, String) 的元组， 用于描述 HTTP 状态码let (statusCode, statusMessage) = http404Error // 元组的内容分解(decompose)let (justTheStatusCode, _) = http404Errorhttp404Error.0 // 下标访问let http200Status = (statusCode: 200, description: "OK") // 给元组元素命名http200Status.description 12 可选类型(optionals)1234567891011121314151617181920212223242526272829// 声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nilvar optionalString: String? // optionalString的类型要么是String，要么是nillet possibleNumber = "123"let convertedNumber = Int(possibleNumber) // convertedNumber 被推测为可选的`Int`// if 语句以及强制解析// 使用 if 语句和 nil 比较来判断一个可选值是否包含值if convertedNumber != nil &#123; print("convertedNumber has an integer value of \(convertedNumber!).") // `!`称为可选值的强制解析(forced unwrapping)&#125;// optionalString! 报错， 使用!来强制解析值之前，一定要确定可选包含一个非nil 的值。// 可选绑定(optional binding)if let actualNumber = Int(possibleNumber) &#123; // 如果`Int(possibleNumber)`强制解析的值不是nil，就赋值给actualNumber，并且语句为ture print("\'\(possibleNumber)\' has an integer value of \(actualNumber)")&#125; else &#123; print("\'\(possibleNumber)\' could not be converted to an integer")&#125;var someOptional: String? = "some"var someOtherOptional: String?if let constantName = someOptional, let anotherConstantName = someOtherOptional&#123; print("多个可选绑定可以用逗号分隔, 需要每一个语句都为true")&#125;// 隐式解析可选类型(implicitly unwrapped optionals): 一个可以自动解析的可选类型let possibleString: String? = "An optional string."let forcedString: String = possibleString! // 需要惊叹号来获取值let assumedString: String! = "An implicitly unwrapped optional string."let implicitString: String = assumedString // 不需要感叹号if assumedString != nil &#123; print(assumedString)&#125; 13 错误处理1234567891011121314151617181920212223func canThrowAnErrow() throws &#123; // 这个函数有可能抛出错误&#125;do &#123; try canThrowAnErrow() // 没有错误消息抛出&#125; catch &#123; // 有一个错误消息抛出&#125;enum myError: Error &#123; case OutOfCleanDishes case MissingIngredients&#125;func makeASandwich() throws &#123; // ... throw myError.OutOfCleanDishes&#125;do &#123; try makeASandwich()&#125; catch myError.OutOfCleanDishes &#123; // washDishes()&#125; catch myError.MissingIngredients&#123; // buyGroceries&#125; 14 断言(assertion)12let age = -3//assert(age &gt;= 0, "A person's age cannot be less than zero") playground文件在andyRon/LearnSwift]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
</search>
