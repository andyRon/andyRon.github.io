<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[iOS-tutorial-7：解析XML(swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-7%EF%BC%9A%E8%A7%A3%E6%9E%90XML(swift)%2F</url>
    <content type="text"><![CDATA[参考：Parsing XML Tutorial 使用XMLParser解析XML文件，然后用table展示数据。 以Single View Application模板新建项目XMLParserTutorial。 删除SB中的View Controller，拖进一个Navigation Controller。选择新的View Controller为 “Is Initial View Controller”。设置Navigation Bar的title为Books。 新建一个继承至UITableViewController，名为TableViewController的控制器文件，并与SB的控制器关联。 新建一个xml文件Books.xml，用于之后解析，文件内容为: 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot;?&gt;&lt;catalog&gt; &lt;book id=&quot;1&quot;&gt; &lt;title&gt;To Kill a Mockingbird&lt;/title&gt; &lt;author&gt;Harper Lee&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;2&quot;&gt; &lt;title&gt;1984&lt;/title&gt; &lt;author&gt;George Orwell&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;3&quot;&gt; &lt;title&gt;The Lord of the Rings&lt;/title&gt; &lt;author&gt;J.R.R Tolkien&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;4&quot;&gt; &lt;title&gt;The Catcher in the Rye&lt;/title&gt; &lt;author&gt;J.D. Salinger&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;5&quot;&gt; &lt;title&gt;The Great Gatsby&lt;/title&gt; &lt;author&gt;F. Scott Fitzgerald&lt;/author&gt; &lt;/book&gt;&lt;/catalog&gt; 新建一个文件 Book.swift： 123456import Foundationclass Book &#123; var bookTitle: String = &quot;&quot; var bookAuthor: String = &quot;&quot;&#125; 在TableViewController中添加几个变量： 1234var books: [Book] = []var eName: String = &quot;&quot;var bookTitle = &quot;&quot;var bookAuthor = &quot;&quot; 在viewDidLoad方法中，添加读取XMl文件代码： 123456789override func viewDidLoad() &#123; super.viewDidLoad() if let path = Bundle.main.url(forResource: &quot;Books&quot;, withExtension: &quot;xml&quot;) &#123; if let parser = XMLParser(contentsOf: path) &#123; parser.delegate = self parser.parse() &#125; &#125; 添加Table View的数据源代理方法： 1234567891011121314151617override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return books.count&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) let book = books[indexPath.row] cell.textLabel?.text = book.bookTitle cell.detailTextLabel?.text = book.bookAuthor return cell&#125; 让TableViewController采纳XMLParserDelegate协议： class TableViewController: UITableViewController, XMLParserDelegate 实现XMLParserDelegate中的三个方法： 12345678910111213141516171819202122232425262728293031323334// 解析XMl元素开始时func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String] = [:]) &#123; print(&quot;开始 \(elementName)&quot;) eName = elementName if elementName == &quot;book&quot; &#123; bookTitle = &quot;&quot; bookAuthor = &quot;&quot; &#125;&#125;// 正在解析XMl元素func parser(_ parser: XMLParser, foundCharacters string: String) &#123; print(&quot;ing \(eName)&quot;) let data = string.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines) if (!data.isEmpty) &#123; if eName == &quot;title&quot; &#123; bookTitle += data &#125; else if eName == &quot;author&quot; &#123; bookAuthor += data &#125; &#125;&#125;// 结束解析XMl元素func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) &#123; print(&quot;结束 \(elementName)&quot;) if elementName == &quot;book&quot; &#123; let book = Book() book.bookTitle = bookTitle book.bookAuthor = bookAuthor books.append(book) &#125;&#125; 三个方法分别在XMl元素开始解析、正在解析、结束解析时调用，也就是说有很多元素时就不停在调用这三个方法。 代码XMLParserTutorial]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习6：Fondation-Kit介绍]]></title>
    <url>%2F2017%2FObjective-C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A06%EF%BC%9AFondation-Kit%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[12macOS -&gt; Cocoa -&gt; Foundation, AppKitiOS -&gt; Cocoa Touch -&gt; Foundation, UIKit(UIView, UIController) Foundation框架的基础是CoreFoundation（C语言），如果函数或变量是以CF开头，就是CoreFoundation框架中的。 Foundation中一些有用的数据类型范围： NSRange1234typedef struct _NSRange &#123; NSUInteger location; NSUInteger length;&#125; NSRange; 表示相关事务的范围。有三种方式初始化： 直接给字段赋值： 123NSRange range;range.location = 12;range.length = 5; 应用C语言的聚合结构赋值：NSRange range = {17, 4} 函数NSMakeRange()：NSRange range3 = NSMakeRange(12, 5);这个方法的好处是可以在任何能够使用函数的地方直接使用：[anObject flarbulateWithRange: NSMakeRange(13, 15)]; 几何数据类型CG前缀，表示Core Graphics框架（C语言），用来进行2D渲染。 CGPoint表示坐标 12345struct CGPoint&#123; float x; float y;&#125; CGSize表示大小，用来存储长度和宽度 12345struct CGSize&#123; float width; float height;&#125; CGRect 表示矩形，由坐标和大小复合而成 12345struct CGRect&#123; CGPoint origin; CGSize size;&#125; 对应创建函数： CGPointMake(), CGSizeMake(), CGRectMake() 集合数据类型是C语言结构体而不是类，是考虑性能的原因。 字符串字符串类： NSString。 通过格式字符串和参数创建NSString： 12NSString *height;height = [NSString stringWithFormat:@&quot;%d, %d&quot;, 4, 3]; 类方法： 以+为起始符的。 字符长度，实例方法length： - (NSUInteger) length; 字符串比较 (BOOL)isEqualToString:(NSString *)aString;，表示字符串内容是否相同，返回BooL；==判断字符串的指针是否相同，也就是是否是同一个事务。 12345678910NSString *thing1 = @&quot;hello 5&quot;;NSString *thing2 = [NSString stringWithFormat:@&quot;hello %d&quot;, 5]; if ([thing1 isEqualToString:thing2]) &#123; NSLog(@&quot;两个字符串内容相同&quot;);&#125;if (thing1 == thing2) &#123; NSLog(@&quot;两个字符串是同一个对象&quot;);&#125; - (NSComparisonResult)compare:(NSNumber *)decimalNumber;，逐个比较字符串的每个字符，判断大小。返回一个枚举类型NSComparisonResult，三个枚举值分别表示左小于右，左等于右，左大于右。 - (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;，根据options的不同值有不同的功能。 字符串内是否还包含别的字符串检测字符串是否以另一个字符开头或结尾： 12- (BOOL)hasPrefix:(NSString *)str;- (BOOL)hasSuffix:(NSString *)str; 一个字符串在另一个字符串内的返回：- (NSRange)rangeOfString:(NSString *)searchString; 可变性NSString是不可变的。也就是一旦被创建，就不能以删除字符或添加字符的方式改变它。NSMutableString是NSString的子类，可以改变。 可通过类方法stringWithCapacity:来创建，表示分配一块内存用于存储字符串，+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;。NSMutableString *string = [NSMutableString stringWithCapacity:1]; appendString:和appendFormat: 添加字符串： 123NSMutableString *string = [NSMutableString stringWithCapacity:50];[string appendString:@&quot;Hello there &quot;];[string appendFormat:@&quot;human %d!&quot;, 39]; // Hello there human 39! deleteCharactersInRange: 删除字符串，经常和rangeOfString:一起使用。 12345NSMutableString *friends = [NSMutableString stringWithCapacity:50]; [friends appendString:@&quot;James BethLynn Jack Evan&quot;]; NSRange jackRange = [friends rangeOfString:@&quot;Jack&quot;]; jackRange.length++; [friends deleteCharactersInRange:jackRange]; // James BethLynn Evan 集合 NSArray两个限制：只能存储OC对象；不能存储nil。 创建类方法arrayWithObjects:(nil表示结束)：NSArray *array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;, nil];直接字面量：NSArray *array2 = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; 数组对象个数： [array count]; 按索引获取对象： 12[array objectAtIndex:1];array[1]; 字符串切分成数组，数组合并成字符串。 123NSMutableString *string2 = @&quot;oop:ack:bork:greeble:ponies&quot;; NSArray *chunks = [string2 componentsSeparatedByString:@&quot;:&quot;]; string2 = [chunks componentsJoinedByString:@&quot;:-)&quot;]; // oop:-)ack:-)bork:-)greeble:-)ponies NSMutableArrayNSArray包含的对象个数是不能变化的（包含的对象是可以变化的）。NSMutableArray是可以变化数目。 创建: + (instancetype)arrayWithCapacity:(NSUInteger)numItems; 末尾添加 - (void) addObject: (id) anObject; 删除特定索引的对象 - (void)removeObjectAtIndex:(NSIndexSet *)index; 枚举：对数组进行遍历。NSEnumerator 1234NSEnumerator *emumerator = [array objectEnumerator];while (id thingie = [emumerator nextObject]) &#123; &#125; 快速枚举 123for (NSString *string in array) &#123; NSLog()&#125; NSDictionary同样也有对应的NSMutableDictionary。 123456789101112131415161718 // 创建 NSDictionary Tire *t1 = [Tire new]; Tire *t2 = [Tire new]; Tire *t3 = [Tire new]; Tire *t4 = [Tire new]; NSDictionary *tires = [NSDictionary dictionaryWithObjectsAndKeys:t1, @&quot;front-left&quot;, t2, @&quot;front-right&quot;, t3, @&quot;back-left&quot;, t4, @&quot;back-right&quot;, nil];// NSDictionary *tires = @&#123;@&quot;front-left&quot;: t1, @&quot;front-right&quot;: t2, @&quot;back-left&quot;: t3,@&quot;back-right&quot;: t4,&#125;; // 访问特定key的对象 Tire *tire = [tires objectForKey:@&quot;back-right&quot;];// Tire *tire = tires[@&quot;back-right&quot;]; // 创建NSMutableDictionary NSMutableDictionary *tires_m = [NSMutableDictionary dictionaryWithCapacity:10];// NSMutableDictionary *tires_m = [NSMutableDictionary dictionary]; // 为NSMutableDictionary添加元素 [tires_m setObject:t1 forKey:@&quot;front-left&quot;]; // 从NSMutableDictionary中删除元素 [tires_m removeObjectForKey:@&quot;front-left&quot;]; 其他数据类型NSArray和NSDictionary只能存储对象，不能直接存储任何基本类型的数据，如int、float、和struct。 NSNumber NSValue NSNull]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习5：源文件组织]]></title>
    <url>%2F2017%2FObjective-C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A05%EF%BC%9A%E6%BA%90%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%2F</url>
    <content type="text"><![CDATA[将程序拆分为多个小文件有助于更快地找到重要的代码，而且其他人在查看项目时也能有个大致的了解。 拆分接口和实现根据@interface和@implementation，OC的代码通常放在两种文件里： 接口部分(.h)：类的@interface指令、公共struct定义、enum常量、#defines和extern全局变量等。 实现部分(.m): 类的@implementation指令、全局变量的定义、私有struct等。 另外，复杂的项目可以拥有多个目标，它们源文件的配置各不相同，构建规则也不同。群组关系仅仅是有Xcode负责管理的一项奇妙的功能。 拆分Car程序 #import 带尖号的是导入系统头文件(只读)，如#import &lt;Foundation/Foundation.h&gt;；双引号是项目本地的代码文件，如#import &quot;Engine.h&quot;。 拆分上一篇中的Car程序首先拆分继承自NSObject的类：Tire和Engine。 1234567// Tire.h#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end 1234567891011// Tire.m#import &quot;Tire.h&quot;@implementation Tire//#pragma mark -- (NSString *)description &#123; return (@&quot;I am a Tire.&quot;);&#125; //description@end 1234567// Engine.h#import &lt;Foundation/Foundation.h&gt;@interface Engine : NSObject@end 12345678// Engine.m#import &quot;Engine.h&quot;@implementation Engine- (NSString *)description &#123; return (@&quot;I am a Engine.&quot;);&#125; //description@end 使用跨文件依赖关系 @class 是告诉编译器：“这是一个类，只会通过指针来引用它，不需要关注此类的更多信息”。可减少必须导入的头文件的数量，从而缩短编译时间。拆分Car类： 1234567891011121314// Car.h#import &lt;Foundation/Foundation.h&gt;@class Engine;@class Tire;@interface Car : NSObject- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Car.m#import &quot;Car.h&quot;#import &quot;Tire.h&quot;#import &quot;Engine.h&quot;@implementation Car&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@&quot;%@&quot;, engine); NSLog(@&quot;%@&quot;, tires[0]); NSLog(@&quot;%@&quot;, tires[1]); NSLog(@&quot;%@&quot;, tires[2]); NSLog(@&quot;%@&quot;, tires[3]);&#125;@end //Car 编译器需要先知道所有关于超类的信息才能成功地为其子类编译@interface部分。拆分Slant6和AllWeatherRadial： 1234567// Slant6.h#import &quot;Engine.h&quot;@interface Slant6 : Engine@end 123456789// Slant6.m#import &quot;Slant6.h&quot;@implementation Slant6- (NSString *)description &#123; return (@&quot;I am a slant-6.VROOM!&quot;);&#125;@end 1234567// AllWeatherRadial.h#import &quot;Tire.h&quot;@interface AllWeatherRadial : Tire@end 12345678910// AllWeatherRadial.m#import &quot;AllWeatherRadial.h&quot;@implementation AllWeatherRadial-(NSString *)description&#123; return (@&quot;I am a tire for rain or shine.&quot;);&#125;@end 最后是main.m文件：123456789101112131415161718192021222324// main.m#import &lt;Foundation/Foundation.h&gt;#import &quot;Car.h&quot;#import &quot;Tire.h&quot;#import &quot;Engine.h&quot;#import &quot;Slant6.h&quot;#import &quot;AllWeatherRadial.h&quot;int main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习2：面向对象编程的基础知识]]></title>
    <url>%2F2017%2FObjective-C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[间接(indirection) “只要再多添加一层间接，计算机科学中就没有解决不了的问题。” 例子 电话薄 让他人代替你自己去完成工作 编写一段代码来查询其他代码，并通过它继续访问另一层代码。 推诿 变量与间接 使用文件名的间接 在面向对象编程中使用间接 使用间接来调用代码，不是直接调用某个函数，而是间接调用。 过程式编程(Procedual Programming) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kCircle, kRectangle, kEgg,&#125; ShapeType;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//图形结构typedef struct &#123; ShapeType type; ShapeColor fillColor; ShapeRect bounds;&#125; Shape;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @&quot;red&quot;; break; case kGreenColor: return @&quot;green&quot;; break; case kBlueColor: return @&quot;blue&quot;; break; &#125; return @&quot;no clue&quot;;&#125;//绘制图形void drawCircle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawRectangle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Rectangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawEgg(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Egg at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawShapes(Shape shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; switch (shapes[i].type) &#123; case kCircle: drawCircle(shapes[i].bounds, shapes[i].fillColor); break; case kRectangle: drawRectangle(shapes[i].bounds, shapes[i].fillColor); break; case kEgg: drawEgg(shapes[i].bounds, shapes[i].fillColor); break; default: break; &#125; &#125;&#125;int main(int argc, const char * argv[]) &#123; Shape shapes[3]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0].type = kCircle; shapes[0].fillColor = kRedColor; shapes[0].bounds = rect0; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1].type = kRectangle; shapes[1].fillColor = kGreenColor; shapes[1].bounds = rect1; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2].type = kEgg; shapes[2].fillColor = kBlueColor; shapes[2].bounds = rect2; drawShapes(shapes, 3); return 0;&#125; 修改过去正常工作的代码很可能会引入新的错误。建立在函数之上，数据为函数服务。代码例子 3.2.1 Shapes-Procedural 面向对象编程 以数据为中心，函数为数据服务 代码例子 3.2.2 Shapes-Object id是一种泛型，可以用来引用任何类型的对象(id实际上是一个指向结构体的指针)。 方括号在OC中其他意义：用于通知某个对象该去做什么。[shape draw];表示通知shape对象执行draw操作 发送消息（调用方法）：通知对象执行某种操作。 类是一种能够实例化成对象的结构体。 如果在运行时改变某个类，则该类的所有对象自动继承这些变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @&quot;red&quot;; break; case kGreenColor: return @&quot;green&quot;; break; case kBlueColor: return @&quot;blue&quot;; break; &#125; return @&quot;no clue&quot;;&#125;@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Rectangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Rectangle@implementation Rectangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Rectangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Egg : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Egg@implementation Egg- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Egg at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end// 补充一个三角形@interface Triangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Triangle@implementation Triangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Triangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@endvoid drawShapes(id shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; id shape = shapes[i]; [shape draw]; &#125;&#125;int main(int argc, const char * argv[]) &#123; id shapes[4]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0] = [Circle new]; [shapes[0] setBounds:rect0]; [shapes[0] setFillColor:kRedColor]; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1] = [Rectangle new]; [shapes[1] setBounds:rect1]; [shapes[1] setFillColor:kGreenColor]; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2] = [Egg new]; [shapes[2] setBounds:rect2]; [shapes[2] setFillColor:kBlueColor]; ShapeRect rect3 = &#123;3, 4, 5, 0&#125;; shapes[3] = [Triangle new]; [shapes[3] setBounds:rect3]; [shapes[3] setFillColor:kBlueColor]; drawShapes(shapes, 4); return 0;&#125; 有关术语 class object instance message method method dispatcher interface implementation OC中的OOP12345678910111213141516171819202122232425262728293031@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end``` 1. `@interface` OC编译器需要一些有关类的信息 + `@` 可以看成是对C语言的扩展 + **instance variable**(实例变量) ： `@interface`下的花括号的内容： { @private ShapeColor fillColor; ShapeRect bounds;} 1+ **method declaration**(方法声明)。有点像C语言中的函数原型。`-`表示对象方法，`+`表示类方法。`(void)`表示返回类型。 - (void) setFillColor: (ShapeColor) fillColor; - (void) setBounds: (ShapeRect) bounds; - (void) draw; ``` + **infix notation**(中缀符) ： *方法的名称及其参数都是合在一起的* `[circle setFillColor: kRedColor]` 表示调用带一个参数的方法 + 如果方法使用参数，则需要冒号，否则不需要冒号 + 提倡@end语言后添加注释来注明类的名称 @implementation @implementation中可以定义在@interface中声明过和没有声明过的方法 OC中不存在真正的私有方法 实例化对象 instantiation（实例化） [Circle new] 发送new消息 软件实体应该对扩展开放，而对修改关闭。 —- 开放/关闭原则(Bertrand Meyer)]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习4：复合（composition）]]></title>
    <url>%2F2017%2FObjective-C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%A4%8D%E5%90%88%EF%BC%88composition%EF%BC%89%2F</url>
    <content type="text"><![CDATA[复合: 对象间的组合（类中中包括类）composition在音乐中翻译为作曲：将多个组件组合在一起，配合使用，从而得到完整的作品。在OC中，复合是通过包含作为实例变量的对象指针实现的。1234567@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;* (void)print;@end //Car 自定义NSLog()NSLog()使用%@格式说明符表示输出对象，也就是NSLog()会给这个对象发送了description消息，然后对象的description方法生成一个NSString并将其返回。**在类中提供description方法就可以自定义NSLog()如何输出对象。123456789101112131415@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@&quot;I am a tire.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; Tire *tire = [Tire new]; NSLog(@&quot;%@&quot;, tire); // 输出 &quot;I am a tire.&quot; return 0;&#125; 存取方法 存取(accessor) 方法是用来读取或改变某个对象属性的方法。分为 getter方法 和 setter方法。 应该尽量使用对象提供的存取方法，不要直接改变对象里面的值。存取方法总是成对出现的。命名方式：setter方法在要更改属性的加上前缀set；getter方法直接是属性名称。 1234567891011@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 在OC中所有对象间的交互都是通过指针实现的。 复合还是继承继承的关系：“Is a”（是一个）。如三角形是一个形状，Slant6是一个发动机……复合的关系：“has a”（有一个）。如形状有个填充颜色，汽车有个发动机和四个轮胎…… 详细代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@&quot;I am a tire.&quot;);&#125;@end@interface Engine : NSObject@end //Engine@implementation Engine- (NSString *)description &#123; return (@&quot;I am a Engine.&quot;);&#125; //description@end@interface Slant6 : Engine@end //slant-6型号的发动机@implementation Slant6- (NSString *)description &#123; return (@&quot;I am a slant-6型号的发动机.VROOM!&quot;);&#125;@end@interface AllWeatherRadial : Tire@end // 新型轮胎@implementation AllWeatherRadial-(NSString *)description&#123; return (@&quot;I am a tire for rain or shine.&quot;);&#125;@end@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car@implementation Car- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@&quot;%@&quot;, engine); NSLog(@&quot;%@&quot;, tires[0]); NSLog(@&quot;%@&quot;, tires[1]); NSLog(@&quot;%@&quot;, tires[2]); NSLog(@&quot;%@&quot;, tires[3]);&#125;@endint main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习3：继承(inheritance)]]></title>
    <url>%2F2017%2FObjective-C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03%EF%BC%9A%E7%BB%A7%E6%89%BF(inheritance)%2F</url>
    <content type="text"><![CDATA[为何使用继承 UML(Unified Modeling Language, 统一建模语言) 是一种用图表来表示类、类的内容以及它们之间关系。 将重复的代码合并到一处。 继承的语法格式 只能继承一个 只有代码精简，bug才无处藏身 没有声明实例变量时可以省略花括号 相关术语 refactoring (重构) superclass parent class subclass child class override 继承的工作机制OOP一个强大之处：可以对一个程序做一些重大改变，程序仍然可以正常运行。 方法调度：当代码发送信息时，将在当前的类中搜索相应方法，如果无法在接收消息的对象的类文件中找到相应的文件，就会在该对象的超类中进行查找。 实例变量 在创建一个新类时，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。 polymorphism(多态性) self：指向接收消息的对象的指针 重写方法 super 调用继承的方法可以确保获得方法实现的所有特性]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习1：对C的扩展]]></title>
    <url>%2F2017%2FObjective-C-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%AF%B9C%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[分析最简单的Hello Objective-C程序1234567#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;Hello, World!&quot;); return 0;&#125; // main OC本质上就是C语言，它用来声明main()和返回数值的语法和C语言是一样的。 扩展名.m代表message 与C类似，OC使用头文件来包含结构体、符号常量和函数原型等元素的声明。 #import类似于C的#include，但#import可保证头文件只被包含一次。 #import &lt;Foundation/Foundation.h&gt;语句告诉编译器查找Foundation框架中的Foundation.h头文件。 int argc, const char * argv[]中 argc是指命令行参数个数，argv[0]是指可执行文件的路径，argv[1]是指命令行第一个参数，argv[2]是指命令行第二个参数，以此类推。 框架 ：一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。 如Cocoa,Carbon,QuickTime,OpenGL Cocoa包括Foundation和Application Kit(AppKit) 每一个框架都有一个主头文件，它包含了框架内所有的头文件。 Foundation的头文件 1MB 14000行 100多文件 。通过#import &lt;Foundation/Foundation.h&gt; 就获得了整个集合 Xcode使用预编译头文件（一种经过压缩的，摘要形式的头文件）来加快读取速度。 NSLog()和@”字符串” NS前缀是NextSTEP（很早之前苹果公司收购的公司） NSLog()类似于C的printf() @符号是Objective-C在标准C语言基础上添加的特性，意味着引号内的字符串应作为Cocoa的NSString元素来处理 @符号可以看成之后是对C语言的扩展 布尔类型OC中的布尔值YES是1， NO是0，是与C语言中不同的。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 6：使用Quick Look框架预览文件(Swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-6%EF%BC%9A%E4%BD%BF%E7%94%A8Quick-Look%E6%A1%86%E6%9E%B6%E9%A2%84%E8%A7%88%E6%96%87%E4%BB%B6-Swift%2F</url>
    <content type="text"><![CDATA[参考 Using Quick Look Framework for Previewing Documents iOS SDK中有很多不常见，却非常好用的库，Quick Look框架就是一个非常好的例子。Quick Look框架提供了预览很多不同类型文件的功能，而不需要打开不同的APP查看，有点像Mac中的空格键功能。 Quick Look框架可以预览的文件类型： iWork documents (Pages, Numbers and Keynote) Microsoft Office documents (as long as they’ve been created with Office 97 or any other newer version) PDF files Images Text files Rich-Text Format documents Comma-Separated Value files (csv) 开始项目到开始项目处下载开始项目，这是原文提供了一个开始项目，代码是老版本的，需要转换一下。这个开始项目中包括了六种不同的类型的文件，一个navigation controller，一个table view controller（FileListViewController），另外还做了一些初始化工作。之后代码就在FileListViewController中完成。 文件和文件的URLS 在FileListViewController中定义一个文件名字的数组变量：let fileNames = [&quot;AppCoda-PDF.pdf&quot;, &quot;AppCoda-Pages.pages&quot;, &quot;AppCoda-Word.docx&quot;, &quot;AppCoda-Keynote.key&quot;, &quot;AppCoda-Text.txt&quot;, &quot;AppCoda-Image.jpeg&quot;] 继续定义一个数组变量，用户存储不同的文件的URL：var fileURLs = [NSURL]() 创建一个方法prepareFileURLs()，用于为fileURLs添加值： 123456789101112func prepareFileURLs() &#123; for file in fileNames &#123; // 1 let fileParts = file.components(separatedBy: &quot;.&quot;) if let fileURL = Bundle.main.url(forResource: fileParts[0], withExtension: fileParts[1]) &#123; // 2 if FileManager.default.fileExists(atPath: fileURL.path) &#123; fileURLs.append(fileURL as NSURL) &#125; &#125; &#125;&#125; 1 components(separatedBy:)方法用于把String按照给定的分隔符，分解成[String]。 2 判断文件地址是否真实存在。 在 viewDidLoad()中实现上面的函数： 12345override func viewDidLoad() &#123; ... prepareFileURLs()&#125; 展示文件用table view展示不同的文件： 根据文件的URL，获得文件名和文件后缀（文件类型），添加函数extractAndBreakFilenameInComponents(:)。 12345678910func extractAndBreakFilenameInComponents(fileURL: NSURL) -&gt; (fileName: String, fileExtension: String) &#123; let fileURLParts = fileURL.path!.components(separatedBy: &quot;/&quot;) let fileName = fileURLParts.last let filenameParts = fileName?.components(separatedBy: &quot;.&quot;) return (filenameParts![0], filenameParts![1])&#125; 修改 tableView(tableView:cellForRowAtIndexPath)： 123456789func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCellWithIdentifier(&quot;idCellFile&quot;, forIndexPath: indexPath) let currentFileParts = extractAndBreakFilenameInComponents(fileURLs[indexPath.row]) cell.textLabel?.text = currentFileParts.fileName return cell&#125; 根据不同的后缀名，定义不同的文件类型名称，添加函数getFileTypeFromFileExtension(:)： 12345678910111213141516171819202122232425func getFileTypeFromFileExtension(fileExtension: String) -&gt; String &#123; var fileType = &quot;&quot; switch fileExtension &#123; case &quot;docx&quot;: fileType = &quot;Microsoft Word document&quot; case &quot;pages&quot;: fileType = &quot;Pages document&quot; case &quot;jpeg&quot;: fileType = &quot;Image document&quot; case &quot;key&quot;: fileType = &quot;Keynote document&quot; case &quot;pdf&quot;: fileType = &quot;PDF document&quot; default: fileType = &quot;Text document&quot; &#125; return fileType&#125; 回到tableView(tableView:cellForRowAtIndexPath)，添加一段cell配置： cell.detailTextLabel?.text = getFileTypeFromFileExtension(fileExtension: currentFileParts.fileExtension) 修改每个section中row的数目为文件数目： 123func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return fileNames.count&#125; QLPreviewControllerDataSource 引入框架Quick Look import QuickLook 定义QLPreviewController let quickLookController = QLPreviewController() 让FileListViewController实现QLPreviewControllerDataSource协议 实现QLPreviewControllerDataSource协议的必须要实现的方法。第一方法表示有多少个文件需要预览： 123func numberOfPreviewItems(in controller: QLPreviewController) -&gt; Int &#123; return fileURLs.count&#125; 第二个方法：123func previewController(_ controller: QLPreviewController, previewItemAt index: Int) -&gt; QLPreviewItem &#123; return fileURLs[index]&#125; 在viewDidLoad()中添加：quickLookController.dataSource = self 预览文件在table view中选中文件，就要跳转的预览页面。实现方法tableView(_:didSelectRowAt:)：123456func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; if QLPreviewController.canPreview(fileURLs[indexPath.row]) &#123; quickLookController.currentPreviewItemIndex = indexPath.row navigationController?.pushViewController(quickLookController, animated: true) &#125; &#125; navigationController?.pushViewController(quickLookController, animated: true)可用presentViewController(quickLookController, animated: true, completion: nil)代替。 运行可预览文件： 观察上图，可发现 Quick Look Preview Controller自带了toolbar，左边一个是分享按钮(通过UIActivityViewController实现的)，右边一个是类似目录功能，当有很多预览文件时，来跳转到不同预览文件。 代码QuickLookDemo 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 6：使用Quick Look框架预览文件(Swift)//)]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 4：CALayer介绍(swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-4%EF%BC%9ACALayer%E4%BB%8B%E7%BB%8D-swift%2F</url>
    <content type="text"><![CDATA[参考 A Beginner’s Guide to CALayer Layers是Core Animation Framework的一部分。Core Animation Framework在iOS架构的位置： 访问CALayer凡是继承至UIView的都将有一个属性layer来表示CALayer。myView.layer 初始化项目 新建CALayerDemo，single View Application模板 新建一个UIView和一个UILabel 圆角CALayer的cornerRadius属性大小表示UIView圆角处圆的半径大小。类似于box.layer.cornerRadius = 20，就形成了圆角，数字越大圆角效果越大，当cornerRadius等于box半径时，box就会变成一个园。 阴影效果1234box.layer.shadowOffset = CGSize(width: 5, height: 5)box.layer.shadowOpacity = 0.7box.layer.shadowRadius = 10box.layer.shadowColor = UIColor.blue.cgColor shadowOffset表示阴影偏移大小，也就是阴影向box的下放偏移5和向右方偏移5距离。 shadowOpacity是阴影透明度 shadowRadius是阴影涉及的半径，并且这个半径越大，阴影的颜色深浅就会越来越小。shadowRadius与shadowOffset是共同作用的 设置边的宽度和颜色12box.layer.borderColor = UIColor.black.cgColorbox.layer.borderWidth = 3 展示图片123box.layer.contents = UIImage(named: &quot;tree.jpg&quot;)?.cgImagebox.layer.contentsGravity = kCAGravityResizebox.layer.masksToBounds = true CALayer的contents属性是open var contents: Any?，可以设置为图片 contentsGravity设置成kCAGravityResize，表示contents的内容会调整大小以适应layer。如果设置成其他值可能出现大小不适的形象，比如kCAGravityBottomRight，将是： masksToBounds为true表示按照layer的边框范围显示内容；如果是false，将会是如下结果 背景颜色和透明度12box.layer.backgroundColor = UIColor.green.cgColorbox.layer.opacity = 0.5 代码CALayerDemo 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 4：CALayer介绍(swift)/]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 5：关于地理定位和特定区域(Swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-5%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%E5%92%8C%E7%89%B9%E5%AE%9A%E5%8C%BA%E5%9F%9F-Swift%2F</url>
    <content type="text"><![CDATA[参考 Building a Geo Targeting iOS App in Swift 用户带着iPhone进入某个区域，并在某些区域待多久在开发肯能会有很大用处。 初始化项目 创建新的项目GeoTargeting，使用Single View Appliction模板 添加一个Map View，大小为整个页面 添加相关outlet 实现两个协议 123class ViewController: UIViewController, MKMapViewDelegate, CLLocationManagerDelegate &#123; @IBOutlet weak var mapView: MKMapView! 设置CLLocationManager和MKMapView。 1234567891011121314151617// 1let locationManager = CLLocationManager()override func viewDidLoad() &#123; super.viewDidLoad() // 2 locationManager.delegate = self locationManager.distanceFilter = kCLLocationAccuracyNearestTenMeters locationManager.desiredAccuracy = kCLLocationAccuracyBest // 3 mapView.delegate = self mapView.showsUserLocation = true mapView.userTrackingMode = .follow setupData() &#125; 1 创建一个CLLocationManager的实例，用于检测用户的位置变化 2 设置locationManager一些参数，确定精确性 在viewDidAppear中核查用户授权状态1234567891011121314151617override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) let authorizationStatus = CLLocationManager.authorizationStatus() // 1 if authorizationStatus == .notDetermined &#123; locationManager.requestAlwaysAuthorization() &#125; // 2 else if authorizationStatus == .denied &#123; showAlert(&quot;Location services &quot;) &#125; // 3 else if authorizationStatus == .authorizedAlways &#123; locationManager.startUpdatingLocation() &#125;&#125; 1 如果用户授权状态是不确定，就检查是否是一直的状态。 2 如果用户授权状态是拒绝，就用弹框显示信息给用户看。showAlert(title:)是弹框函数： 1234567891011func showAlert(_ title: String) &#123; print(title) let alertController = UIAlertController(title: title, message: nil, preferredStyle: .alert) let action = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler: nil) alertController.addAction(action) present(alertController, animated: true, completion: nil) &#125; 3 如果用户授权状态是一直，就开始更新地理位置。 另外，还需要在.plist文件中添加key为NSLocationAlwaysUsageDescription的提示信息 需要一直能获取你的位置 才可以。在调用requestAlwaysAuthorization()时这个key是必须的。允许获取当前位置。 添加函数setupData()1234567891011121314151617181920212223242526272829303132333435func setupData() &#123; // 1 if CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) &#123; // 2 let title = &quot;全季酒店&quot; let coordinate = CLLocationCoordinate2DMake(31.1849700000,121.6303200000) let regionRadius = 300.0 // 3 let region = CLCircularRegion(center: CLLocationCoordinate2D(latitude: coordinate.latitude, longitude: coordinate.longitude), radius: regionRadius, identifier: title) locationManager.startMonitoring(for: region) // 4 let restaurantAnnotation = MKPointAnnotation() restaurantAnnotation.coordinate = coordinate restaurantAnnotation.title = title mapView.addAnnotation(restaurantAnnotation) // 5 let circle = MKCircle(center: coordinate, radius: regionRadius) mapView.add(circle) &#125; else &#123; print(&quot;不能追踪区域&quot;) &#125;&#125;// 6func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123; let circleRenderer = MKCircleRenderer(overlay: overlay) circleRenderer.strokeColor = UIColor.red circleRenderer.lineWidth = 1.0 return circleRenderer&#125; 1 判断是否监控区域功能是否可用。当用户拒绝状态，或用户不让app背景下刷新，或飞行模式时这个功能不可用 2 随意构建一个位置（如全季酒店），经纬度可通过经纬度查询查询，并设置区域半径regionRadius，单位是米。 3 初始化CLCircularRegion。 4 添加一个注解，类似大头针形状。 5 添加区域圆圈标志。 6 这是MKMapViewDelegate的方法，用户画圆 CLRegionCLRegion就是上面标定的圆形区域。下面添加两个CLLocationManagerDelegate的回调方法，分别在是设备的定位位置进和出标定的区域时调用。12345678// MARK:- CLLocationManagerDelegatefunc locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;)&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;)&#125; Xcode中的位置调试上面设备的位置，不可能拿着手机到处跑，Xcode提高了方便的调式方式。可以建立位置文件.GPX: xcode也提供世界上一些常用的位置文件：点击上图调试栏最后的位置标志就可以调式了。 复杂逻辑下的位置处理如果位置不停变化，在监控区域停留时间比较短，或者监控区域比较多是，处理位置问题就比较复杂了。更新部分代码：123456789101112131415161718// 1var monitoredRegions: Dictionary&lt;String, NSDate&gt; = [:] func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;) // 2 monitoredRegions[region.identifier] = NSDate()&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;) // 3 monitoredRegions.removeValue(forKey: region.identifier)&#125;// 4func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; updateRegions()&#125; 1 定义以字典用于存储用户进入监控区的时间。 2 记录进入时间。 3 删除进入时间。 4 用户位置变化后调用 加入函数updateRegions()代码：1234567891011121314151617181920func updateRegions() &#123; // 1 let regionMaxVisiting = 10.0 var regionsToDelete: [String] = [] // 2 for regionIdentifier in monitoredRegions.keys &#123; // 3 if NSDate().timeIntervalSince(monitoredRegions[regionIdentifier]! as Date) &gt; regionMaxVisiting &#123; showAlert(&quot;谢谢访问&quot;) regionsToDelete.append(regionIdentifier) &#125; &#125; // 4 for regionIdentifier in regionsToDelete &#123; monitoredRegions.removeValue(forKey: regionIdentifier) &#125;&#125; 1 加的用户到某个区域10s，就确定用户已经到访问过这个区域。regionsToDelete用来存储即将删除的区域的identifier，也就用户待过超过10s的区域。 2 遍历所有监控区域 3 timeIntervalSince用来计算某个时间到当前时间的差值，单位为秒。 4 删除用户待过超过regionMaxVisiting的区域。 代码GeoTargeting 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 5：关于地理定位和特定区域(Swift)]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 3：Speech Framework的简单使用]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-3%EF%BC%9ASpeech-Framework%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考： Building a Speech-to-Text App Using Speech Framework in iOS 10 在WWDC 2016时，Apple介绍了Speech framework，这是一个很有用的声音识别框架。实际上这是利用Siri进行声音识别。 初始化项目 新建SpeechToTextDemo，模板是Single View Application。 添加简单的UI 分别定义UITextView和UIButton的两个outlet，为textView和microphoneButton。 再为UIButton添加一个action：123@IBAction func microphoneTapped(_ sender: AnyObject) &#123;&#125; 使用Speech Framework import Speech 实现SFSpeechRecognizerDelegate协议 用户授权获取声音数据是要获得用户的授权的。 在ViewController类中定义一个变量，作为语音识别器。参数identifier是识别的语种，可参考这个列表，中文是“ zh_Hans_CN”。private let speechRecognizer = SFSpeechRecognizer(locale: Locale.init(identifier: &quot;zh_Hans_CN&quot;)) 在viewDidLoad()中： 1234567891011121314151617181920212223242526272829override func viewDidLoad() &#123; super.viewDidLoad() // 1 microphoneButton.isEnabled = false speechRecognizer?.delegate = self // 2 SFSpeechRecognizer.requestAuthorization&#123; (authStatus) in var isButtionEnabled = false switch authStatus &#123; case .authorized: isButtionEnabled = true case .denied: isButtionEnabled = false print(&quot;用户拒绝接受语音识别&quot;) case .notDetermined: isButtionEnabled = false print(&quot;语音识别功能没有经过认可&quot;) case .restricted: isButtionEnabled = false print(&quot;当前设备不能语音识别&quot;) &#125; self.microphoneButton.isEnabled = isButtionEnabled &#125; startRecording()&#125; 1 默认按钮设成不可用 2 授权结果回调 Apple需要每个app如要用户授权时，都应该定制一个反馈信息（info.plist）。在info.plist中添加两个key，分别是麦克风和语音识别的授权，Privacy - Microphone Usage Description和Privacy - Speech Recognition Usage Description。 处理语音识别 在ViewController类中添加三个变量 123private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest? //识别请求private var recognitionTask: SFSpeechRecognitionTask? // 提供识别请求的结果private let audioEngine = AVAudioEngine() // SFSpeechAudioBufferRecognitionRequest对象处理语音识别的请求，代表语音进入语音识别器。 SFSpeechRecognitionTask 识别任务，用于操作识别器的停止和开始 AVAudioEngine 语音引擎，提供语音输出 创建新函数startRecording()，这个函数在点击button后调用，也就是microphoneTapped(:)中最后调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162func startRecording() &#123; // 1 if recognitionTask != nil &#123; recognitionTask?.cancel() recognitionTask = nil &#125; // 2 let audioSession = AVAudioSession.sharedInstance() do &#123; try audioSession.setCategory(AVAudioSessionCategoryRecord) try audioSession.setMode(AVAudioSessionModeMeasurement) try audioSession.setActive(true, with: .notifyOthersOnDeactivation) &#125; catch &#123; print(&quot;audioSession的属性设置失败&quot;) &#125; // 3 recognitionRequest = SFSpeechAudioBufferRecognitionRequest() // 4 guard let inputNode = audioEngine.inputNode else &#123; fatalError(&quot;Audio engine has no input node&quot;) &#125; // 5 guard let recognitionRequest = recognitionRequest else &#123; fatalError(&quot;Unable to create an SFSpeechAudioBufferRecognitionRequest object&quot;) &#125; // 6 recognitionRequest.shouldReportPartialResults = true // 7 recognitionTask = speechRecognizer?.recognitionTask(with: recognitionRequest, resultHandler: &#123; (result, error) in var isFinal = false if result != nil &#123; self.textView.text = result?.bestTranscription.formattedString isFinal = (result?.isFinal)! &#125; if error != nil || isFinal &#123; self.audioEngine.stop() inputNode.removeTap(onBus: 0) self.recognitionRequest = nil self.recognitionTask = nil self.microphoneButton.isEnabled = true &#125; &#125;) let recordingFormat = inputNode.outputFormat(forBus: 0) inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) &#123; (buffer, when) in self.recognitionRequest?.append(buffer) &#125; audioEngine.prepare() do &#123; try audioEngine.start() &#125; catch &#123; print(&quot;audioEngine couldn&apos;t start beacause of an error.&quot;) &#125; textView.text = &quot;Say something, I&apos;m listening!&quot;&#125; 1 开始录音时的初始化 2 AVAudioSession提供语音录音，设置一些参数 3 初始化SFSpeechAudioBufferRecognitionRequest 4 核查audioEngine是否可用 5 核查recognitionRequest 7 检测的音频后的回调方法，也就是开始录音后，有音频进入后都调用 语音识别的开关 实现代理方法speechRecognizer(_:availabilityDidChange:)。这个方法在语音识别器可用性发生变化时被调用。 1234567func speechRecognizer(_ speechRecognizer: SFSpeechRecognizer, availabilityDidChange available: Bool) &#123; if available &#123; microphoneButton.isEnabled = true &#125; else &#123; microphoneButton.isEnabled = false &#125;&#125; 点击button时的操作： 1234567891011@IBAction func microphoneTapped(_ sender: AnyObject) &#123; if audioEngine.isRunning &#123; audioEngine.stop() recognitionRequest?.endAudio() microphoneButton.isEnabled = false microphoneButton.setTitle(&quot;Start Recording&quot;, for: .normal) &#125; else &#123; startRecording() microphoneButton.setTitle(&quot;Stop Recording&quot;, for: .normal) &#125; &#125; 总结语音识别在iPhone的自带键盘中有这个功能，中文识别率很高，如果不高兴或不方便打字，很方便使用。 代码SpeechToTextDemo 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 3：Speech Framework的简单使用/]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 2：用Core Image进行面部识别(Swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-2%EF%BC%9A%E7%94%A8Core-Image%E8%BF%9B%E8%A1%8C%E9%9D%A2%E9%83%A8%E8%AF%86%E5%88%AB-Swift%2F</url>
    <content type="text"><![CDATA[参考：Face Detection in iOS Using Core Image 面部识别API不仅可以是识别面部，也可识别面部的特殊细节，例如微笑甚至眨眼睛。 建立初始项目原文建好了初始项目，我自己新建了初始项目 新建项目Detector 删除IB中原本View Controller Scene。 拖动UITabBarController到IB中，得到三个Scene。选择UITabBarController的Is Initial View Controller，使其作为初始控制器。 修改Item 1的title和其Bar Item都为Photo，修改其Class为ViewController。 向Assets中添加几张人物图片 想Photo Scene中添加一个Image View，Content Mode改为Aspect Fit，选择一个图片。在ViewController添加图片对应@IBOutlet：@IBOutlet var personPic: UIImageView! 选中Item 2，点击菜单栏EDitor &gt; Embed In &gt; Navigation Controller，新生成一个与之关联的Scene。 新建CameraViewController类，继承至UIViewController。修改上面生成的Scene的Class属性为CameraViewController。 拖动一个UIBarButtonItem到Camera View Controller Scene的UINavigationItem的右边，并选择System Item为Camera 在CameraViewController中建立outlet和Action 识别照片的面部 在 ViewController.swift中引入CoreImage:import CoreImage 在 ViewController.swift中添加函数detect(): 12345678910111213141516171819202122232425262728293031func detect() &#123; // 1 guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; // 2 let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // 3 for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) let faceBox = UIView(frame: face.bounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) // 4 if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 1 根据UIImage获取CoreImage中图片对象。guard与if功能类似，区别可查看以撸代码的形式学习Swift-5：Control Flow的6 guard 与 if。 2 初始化检测器CIDetector， accuray是检查器配置选项，表示精确度；因为CIDetector可以进行几种类型的检测，所以CIDetectorTypeFace用来表示面部检测；features方法返回具体的检测结果 3 给每个检测到的脸添加红色框 4 检测是否有左眼位置 在viewDidLoad中添加 detect()，运行结果类似： 打印结果，显示检测到的面部位置是不对的：Found bounds are (177.0, 416.0, 380.0, 380.0)这是因为UIKit的坐标系统与Core Image的坐标系统是不同的： 把Core Image的坐标系统转换为UIKit的坐标系统，修改detect()为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func detect() &#123; guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // let ciImageSize = personciImage.extent.size var transform = CGAffineTransform(scaleX: 1, y: -1) transform = transform.translatedBy(x: 0, y: -ciImageSize.height) for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) // Apply the transform to convert the coordinates var faceViewBounds = face.bounds.applying(transform) // Calculate the actual position and size of the rectangle in the image view let viewSize = personPic.bounds.size let scale = min(viewSize.width / ciImageSize.width, viewSize.height / ciImageSize.height) let offsetX = (viewSize.width - ciImageSize.width * scale) / 2 let offsetY = (viewSize.height - ciImageSize.height * scale) / 2 faceViewBounds = faceViewBounds.applying(CGAffineTransform(scaleX: scale, y: scale)) faceViewBounds.origin.x += offsetX faceViewBounds.origin.y += offsetY let faceBox = UIView(frame: faceViewBounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 运行可看到正确识别位置： 相机拍照后的脸部识别之前是项目中照片识别，现在是拍完照再识别，原理是相同的，就是多一个拍完照，取照片的过程。 更新CameraViewController类的代码 1234567891011121314151617181920212223242526272829303132333435363738// 1class CameraViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate &#123; @IBOutlet var imageView: UIImageView! // 2 let imagePicker = UIImagePickerController() override func viewDidLoad() &#123; super.viewDidLoad() imagePicker.delegate = self &#125; @IBAction func takePhoto(_ sender: AnyObject) &#123; // 3 if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; imagePicker.allowsEditing = false imagePicker.sourceType = .camera present(imagePicker, animated: true, completion: nil) &#125; // 4 //MARK: -UIImagePickerControllerDelegate func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage &#123; imageView.contentMode = .scaleAspectFit imageView.image = pickedImage &#125; dismiss(animated: true, completion: nil) self.detect() &#125; // 5 func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil) &#125;&#125; 1 实现UIImagePickerControllerDelegate协议，用于拍照相关代理。 2 初始化UIImagePickerController。UIImagePickerController是照相或摄影界面和功能管理的类。 3 判断设备照相机是否可用。 4 实现一个UIImagePickerControllerDelegate中的代理方法，当拍摄完备确实使用照片时调用。 5 也是UIImagePickerControllerDelegate中的代理方法，取消拍摄时调用。 添加detect()代码，与ViewController中不同的是，不用红色框框处识别出的面部，而是识别出面部的细节，并用UIAlertController弹出显示。 1234567891011121314151617181920212223242526272829303132333435363738394041func detect() &#123; let imageOptions = NSDictionary(object: NSNumber(value: 5) as NSNumber, forKey: CIDetectorImageOrientation as NSString) let personciImage = CIImage(cgImage: imageView.image!.cgImage!) let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage, options: imageOptions as? [String : AnyObject]) if let face = faces?.first as? CIFaceFeature &#123; print(&quot;found bounds are \(face.bounds)&quot;) var message = &quot;有个脸&quot; if face.hasSmile &#123; print(&quot;脸是笑的&quot;) message += &quot;,脸是笑的&quot; &#125; if face.hasMouthPosition &#123; print(&quot;有嘴唇&quot;) message += &quot;,有嘴唇&quot; &#125; if face.hasLeftEyePosition &#123; print(&quot;左眼镜的位置是 \(face.leftEyePosition)&quot;) message += &quot;,左眼镜的位置是 \(face.leftEyePosition)&quot; &#125; if face.hasRightEyePosition &#123; print(&quot;右眼镜的位置是 \(face.rightEyePosition)&quot;) message += &quot;,右眼镜的位置是 \(face.rightEyePosition)&quot; &#125; let alert = UIAlertController(title: &quot;嘿嘿&quot;, message: message, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; else &#123; let alert = UIAlertController(title: &quot;没脸了&quot;, message: &quot;没有检测到脸&quot;, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; &#125; 运行就可以识别照片的面部具体细节CIFaceFeature还提供了其他很多面部细节：1234567891011121314151617181920212223242526272829open var hasLeftEyePosition: Bool &#123; get &#125;open var leftEyePosition: CGPoint &#123; get &#125;open var hasRightEyePosition: Bool &#123; get &#125;open var rightEyePosition: CGPoint &#123; get &#125;open var hasMouthPosition: Bool &#123; get &#125;open var mouthPosition: CGPoint &#123; get &#125;open var hasTrackingID: Bool &#123; get &#125;open var trackingID: Int32 &#123; get &#125;open var hasTrackingFrameCount: Bool &#123; get &#125;open var trackingFrameCount: Int32 &#123; get &#125;open var hasFaceAngle: Bool &#123; get &#125;open var faceAngle: Float &#123; get &#125;open var hasSmile: Bool &#123; get &#125;open var leftEyeClosed: Bool &#123; get &#125;open var rightEyeClosed: Bool &#123; get &#125; 代码Detector 本文作者：AndyRon本文链接：http://andyron.com/2017/]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[swift的文档注释]]></title>
    <url>%2F2017%2Fswift%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[在Xcode中Quick Help 为开发者提供方便快捷的简洁文档查看方式。option+点击查看弹框，option+command+2在检查器中查看。swift的中有两种注释方式，让Xcode在Quick Help中显示。这种注释可以认为是将文档以某种规范的格式嵌入在实际代码的上方，这样就可以通过某些工具自动生成漂亮的文档文件。这种内嵌式的文档在现代编程中是很普遍的。在swift中，这两种注释方式是： /** */ ///这些注释中还可以有其他一些规范 可以支持markdown 关键词 三个关键词：parameter， returns， throws。这三个关键词会在最左边显示。 还有一些关键词会被提取到description中作为一些特殊字段显示，其他都会在description正常显示：author, authors, copyright, date；since, version；attention, important, note, remark, warning；bug, TODO, experiment； complexity； precondition, postcondition, requires, invariant see* 参考http://swifter.tips/documentation/http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/ 本文作者：AndyRon本文链接：http://andyron.com/2017/swift的文档注释/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 1： 识别二维码（swift3）]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-1-%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%EF%BC%88swift3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这是一篇使用AVFoundation框架识别二维码的文章，原文提供了初始化项目QRCodeReaderStarter，我重新建立项目，图片是从原文提供的初始化项目中copy的。 初始化项目 新建一个名为QRCodeReader的单页项目 删除ViewController.swift文件，在项目目录处右击新建文件，新建一个QRCodeViewController类继承自UIViewController。 点击Main.storyboard，选中View Controller，修改其属性Class为QRCodeViewController，使两者关联。 向Main.storyboard中拖动一个View Controller对象，以1的方法新建一个继承自UIViewController的类QRScannerController，然后与Main.storyboard中新建的View Controller关联。 下载图片。从原文的初始化项目QRCodeReaderStarter复制。 修改Code View Controller Scene的view背景颜色做修改；添加一个label，名称改为Quick Scan，字体，和字体大小也做修改；添加button，删除文本，大小为150150，Type为System，image为focus*，Tint为黄色；添加一些约束。 Scanner Controller Scene： 在顶部添加一个View，在这个View中添加以label和button，button的image为cross；在顶部添加一个label；添加一些约束。 构建 segue 用control-drag从Code View Controller Scene中的button到Scanner Controller Scene，选择Present Modally 在QRCodeViewController中添加代码： 1234@IBAction func unwindToHomeScreen(segue: UIStoryboardSegue) &#123; //去除模态视图 dismiss(animated: true, completion: nil) &#125; 在Scanner Controller Scene 中，用control-drag从button到Exit，选择unwindToHomeScreenWithSegue: 6和7中样式和约束，合适即可。 加载 AVFoundation 框架 在QRScannerController.swift文件中引入AVFoundation Framework：import AVFoundation QRScannerController实现AVCaptureMetadataOutputObjectsDelegate协议：class QRScannerController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {表示当捕获的元数据产生时，需要一些回调方法。 QRScannerController中添加三个变量：123var captureSession: AVCaptureSession?var videoPreviewLayer: AVCaptureVideoPreviewLayer?var qrCodeFrameView: UIView? 实现视频捕获 在QRScannerController的viewDidLoad中添加代码： 123456789101112131415161718192021222324252627// 1let captureDevice = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)do &#123; // 2 let input = try AVCaptureDeviceInput(device: captureDevice) // 3 captureSession = AVCaptureSession() // 4 captureSession?.addInput(input) // 5 let captureMetadataOutput = AVCaptureMetadataOutput() captureSession?.addOutput(captureMetadataOutput) // 6 captureMetadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main) captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode] videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession) videoPreviewLayer?.videoGravity = AVLayerVideoGravityResizeAspectFill videoPreviewLayer?.frame = view.layer.bounds view.layer.addSublayer(videoPreviewLayer!) captureSession?.startRunning()&#125; catch &#123; print(error) return&#125; 1 初始化AVCaptureDevice，它表示物理捕获设备；AVMediaTypeVideo是Media types，表示视频类型，还有AVMediaTypeAudio，AVMediaTypeText等其他类型 2 根据AVCaptureDevice初始化捕获设备的输入数据对象AVCaptureDeviceInput。这边的try是swift中错误处理的标识，对应public init(device: AVCaptureDevice!) throws。 3 AVCaptureSession 用于协调输入与输出之间的数据流。 4 为AVCaptureSession 添加输入数据 5 定义输出数据对象AVCaptureMetaDataOutput，并把它添加给AVCaptureSession 6 设置self为输出数据对象的代理，这就对应了QRScannerController类实现AVCaptureMetadataOutputObjectsDelegate协议。metadataObjectTypes是识别的元数据类型，AVMetadataObjectTypeQRCode表示二维码类型。 在Info.plist中添加key为NSCameraUsageDescription或”Privacy – Camera Usage Description”，值为 为了扫描二维码，需要使用你的相机。 运行应用时，点击scan button后，使用了相机，但messageLabel和tapbar没有了，因为被AVCaptureVideoPreviewLayer覆盖了，加入两行代码就可以显示了：12view.bringSubview(toFront: messageLabel)view.bringSubview(toFront: topbar) 实现二维码读取当检测到二维码时，用绿色框高亮；然后二维码被解码成文本信息展示在messagelabel中。 初始化绿色框。继续在上述代码后添加:12345678qrCodeFrameView = UIView() if let qrCodeFrameView = qrCodeFrameView &#123; qrCodeFrameView.layer.borderColor = UIColor.green.cgColor qrCodeFrameView.layer.borderWidth = 2 view.addSubview(qrCodeFrameView) view.bringSubview(toFront: qrCodeFrameView)&#125; 由于qrCodeFrameView没有设置大小，默认是0，所以不会显示，当之后发现二维码时再让它显示。 解码二维码当AVCaptureMetadataOutput识别出二维码时，AVCaptureMetadataOutputObjectsDelegate中的代理方法将被调用：optional public func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) 回调方法定义：123456789101112131415161718192021222324252627282930313233 func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) &#123; if metadataObjects == nil || metadataObjects.count == 0 &#123; qrCodeFrameView?.frame = CGRect.zero messageLabel.text = &quot;没有二维码/条形码&quot; return &#125; let metadataObj = metadataObjects[0] as! AVMetadataMachineReadableCodeObject if metadataObj.type == AVMetadataObjectTypeQRCode &#123; // 1 let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil &#123; // 2 messageLabel.text = metadataObj.stringValue &#125; &#125; &#125;``` + 第二个参数`metadataObjects`是个数组，就是所有被识别出来的元数据对象。如果这个参数为nil或数组为空数组，就表示没有识别出对象。 + 1 通过`transformedMetadataObject `方法获得`AVMetadataObject`对象，更加这个对象可以获得二维码的位置，然后显示绿框。 + 2 把二维码信息显示在messagelabel上。![](http://upload-images.jianshu.io/upload_images/1678135-815e15ae07a32822.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)### 识别条形码除了识别二维码以外，还可以识别条形码。只要在`captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode]`添加更多的元数据类型。，然后回调方法中修改检测类型就可以。 let supportedCodeTypes = [AVMetadataObjectTypeUPCECode, AVMetadataObjectTypeCode39Code, AVMetadataObjectTypeCode39Mod43Code, AVMetadataObjectTypeCode93Code, AVMetadataObjectTypeCode128Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeAztecCode, AVMetadataObjectTypePDF417Code, AVMetadataObjectTypeQRCode ] captureMetadataOutput.metadataObjectTypes = supportedCodeTypes // …. if supportedCodeTypes.contains(metadataObj.type) { let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil { messageLabel.text = metadataObj.stringValue } } ``` 代码QRCodeReader 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS tutorial 1: 识别二维码（swift3）/]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode中Scene里的名称]]></title>
    <url>%2F2017%2FXcode%E4%B8%ADScene%E9%87%8C%E7%9A%84%E5%90%8D%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[默认的Scene名称 Xcode中新建一个控制器对象后会产生一个Scene，而Scene的名称就与其关联的控制器名称相关，比如默认的View Controller的对象的Scene的名称就是View Controller Scene。 如果把控制器改成SFSafariViewController，那么Scene的名字就会变成Safari View Scene。 如果把控制器改成自建的，Scene名字也会随着变化，比如ASAndyViewController对应的Scene名字是 Andy View Scene 总的来说，apple在程序中代码命名规范，一般是前面连续大写的是框架名称，然后后面使用驼峰命名法。要显示时就把框架前缀去掉，然后根据驼峰命名规则分隔显示。 自定义Scene的名称Scene的名称也是可以自定义的，在其属性检查器中，修改title即可，当然这种修改只是停留在IB中，为了开发时便于查看，不影响代码中的名称。 本文作者：AndyRon本文链接：http://andyron.com/2017/Xcode中Scene里的名称/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS应用程序的状态]]></title>
    <url>%2F2017%2FiOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[iOS应用程序一共有五种状态： Not Running 程序还没运行 Inactive 程序运行在foreground但没有接收事件 Active 程序运行在foreground接收事件 Background 程序运行在background正在执行代码 Suspended 程序运行在background没有执行代码 iOS应用程序状态变化会回调APPDelegate中的方法，但不是每一种状态变化都会有对应的方法(上图的红框的两个变化就没有对应的方法) application:didFinishLaunchingWithOptions: Not Running -&gt; Inactive applicationDidBecomeActive: Inactive -&gt; Active applicationWillResignActive: Active -&gt; Inactive applicationDidEnterBackground: Background -&gt; Suspended applicationWillEnterForeground: Background -&gt; Inactive applicationWillTerminate: Suspended -&gt; Not Running 常见的应用状态变化场景 程序第一次启动（或者被杀掉以后启动）： Not Running -&gt; Inactive -&gt; Active 点击Home键（没有在Inof.plist中设置Application does not run in background）： Active -&gt; Inactive -&gt; Background -&gt; Suspended 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 挂起重新运行 Suspended -&gt; Background -&gt; Inactive -&gt; Active 内存清除（杀掉应用或删除应用） Suspended -&gt; Not Running 应用之间的切换 Active -&gt; Inactive Inactive -&gt; Active 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 可通过在APPDelegate的回调方法中打印数据，来查看应用状态变化 123456789101112131415161718192021222324252627282930func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; print(&quot;`application:didFinishLaunchingWithOptions:` Not Running -&gt; Inactive&quot;) return true&#125;func applicationWillResignActive(_ application: UIApplication) &#123; print(&quot;`applicationWillResignActive:` Active -&gt; Inactive&quot;)&#125;func applicationDidEnterBackground(_ application: UIApplication) &#123; print(&quot;`applicationDidEnterBackground:` Background -&gt; Suspended&quot;)&#125;func applicationWillEnterForeground(_ application: UIApplication) &#123; print(&quot;`applicationWillEnterForeground:` Background -&gt; Inactive&quot;)&#125;func applicationDidBecomeActive(_ application: UIApplication) &#123; print(&quot;`applicationDidBecomeActive:` Inactive -&gt; Active&quot;)&#125;func applicationWillTerminate(_ application: UIApplication) &#123; print(&quot;`applicationWillTerminate:` Suspended -&gt; Not Running&quot;)&#125; 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS应用程序的状态/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
</search>