<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于字符编码]]></title>
    <url>%2F2018%2Fascii-unicode-utf8.html</url>
    <content type="text"><![CDATA[作为一名程序员，对编码问题有必要了解一下。计算机是以二进制形式存储数据的，至于为什么选择二进制，这可能就需要从计算机的诞生历史说起了，这不是现在关注的点。 计算机文件一般可以分为（暂且这样分吧）：文本文件和二进制文件。通俗的说，文本文件就是平常通过某个软件（记事本，EditPlus，UltraEdit，sublime等各种编辑器，各种IDE等等）打开看到是‘字符’，二进制文件就是打开是图片或视频等，当然是通过某些能够解释二进制的程序来完成。这里需要强调的是，文件的后缀名不能用来区分文件的类型，后缀名只是系统（特别是Windows）用来对文件进行预先分类，并给予对应的图标和相应双击后打开的程序，至于预先给定的程序能不能打开就不得而知。如，在Windows下，把一个txt文件的后缀名改成jpg后：变成 双击打不开，用记事本依然能打开，就是内部编码没变，其实文件的类型在编码成二进制形式已经确定（一般是在头部）。 php读取图片文件：12$a = file_get_contents(&apos;bg.png&apos;);echo $a; 浏览器以UTF8形式打开图片的二进制形式，虽然大部分是乱码，但头部还是可以看到解码为PNG的： 字符编码字符编码就是每个在电脑里出现的字符都会对应一个二进制数，这个二进制可以成为码点(code point)。不同的编码形式，包含的字符数不同，字符和二进制数对应关系也不同。 ASCII码ASCII(American Standard Code for Information Interchange)码是 比较早的编码形式，总共定义128个字符，用了一个字节的7位，也就是从 0000 0000 到 0111 1111 。 0-32, 127：（共34个）不能直接显示字符的（控制或者通信使用的），32是空格也算在其中，127是删除符； 33-64,91-96,123-126：（共21*2=42个）键盘上除了英文字母和不直接显示字符的键有21个，每一个键上有两个字符； 65-90,97-122：（26*2=56个）英文字母； 对于英语系的人来说这128个字符已经够了，他们在电脑上接触的的字符也就这么多够了，说来也是奇特，英文字符26个就能通过组合用来表示英语所有意思，这种组合形式很适合计算机。而我们汉语就不同了，我想是不能通过笔画的组合组成所有汉字了。据说汉语是最难学的语言之一😅，辛亏我已经会汉语了😀😝。 Unicode128个字符对于其他语言是远远不够的，单汉字就有将近10万个（常用应该几千个），每个汉字都需要一个码点，其他语言中的字符也需要对其字符编码成码点，原本有很多编码方式，这些编码没有进行统一规定，就会有冲突，一个二进制数在不同编码方式中就有可能解释为不同的字符，这样使不同地区的人交流不便。 Unicode就是在这样条件下诞生，简单的说，Unicode就是大的映射表，把全世界所有语言符号都包含其中，每个符号的映射的码点的都不相同。 汉字大部分可以用4个16进制数表示，参看汉字Unicode。如：U+620E表示戎(这是我的姓，读róng，不是 戒，在这里普及一下，我已经被叫成 戒某 无数次了🤦‍♀️🤦‍♀️🤦‍♀️)。 Unicode是一个庞大的字符集，一个很多字符与二进制数的唯一的一一对应集合。Unicode没有规定怎么存储，620E（0110 0010 0000 1110）至少需要2个字节，而其他字符可能需要更多字节。像U+0041表示英文字母A，如果也需要用2个字节或者更多，则前面的有一些字节都是0，那么太浪费资源了，为了减少空间的浪费就出现了UTF8。 UTF8UTF8是Unicode存储一种实现方式。它采用变字节数（1-4个）来节约资源。 UTF-8的编码规则很简单，只有二条： 对于单字节的符号，字节的第一位设为0，后面7位为这个符号的Unicode码。因此对于英语字母，此时UTF-8编码和ASCII码是相同的。 对于n字节的符号（n&gt;1），第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的Unicode码。 下表总结了编码规则，字母x表示可用编码的位。 Unicode符号范围(十六进制) UTF-8编码方式 (二进制） 0000 0000 - 0000 007F 0xxxxxxx 0000 0080 - 0000 07FF 110xxxxx 10xxxxxx 0000 0800 - 0000 FFFF 1110xxxx 10xxxxxx 10xxxxxx 0001 0000 - 0010 FFFF 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 这样解读UTF8编码就容易区分几个字节表示一个字符了。如果一个字节的第一位是0，那么这个字节单独表示一个字符；如果一个字节的第一位是1，那么这个字节下面连续几个1，就表示当前字符占用几个字节。 以汉字戎为例，看看UTF8编码实现过程： 已知戎的Unicode是620E（0110 0010 0000 1110）。 620E 在第三行范围内（0000 0800 - 0000 FFFF），因此需要三个字节编码戎，即 1110xxxx 10xxxxxx 10xxxxxx 从戎的最后一个二进制位开始，依次从后向前填入格式中的x，多出的位补0。得戎的UTF8编码的十六进制是E6888E。 参考：字符编码笔记：ASCII，Unicode和UTF-8]]></content>
      <categories>
        <category>暂且没想到怎么分类</category>
      </categories>
      <tags>
        <tag>ASCII</tag>
        <tag>Unicode</tag>
        <tag>UTF8</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《畅销的原理》——作为消费者，我不想被商家牵着鼻子走]]></title>
    <url>%2F2018%2F%E3%80%8A%E7%95%85%E9%94%80%E7%9A%84%E5%8E%9F%E7%90%86%E3%80%8B.html</url>
    <content type="text"><![CDATA[作者和本书概要马修·威尔科克斯（Matthew Willcox），博达大桥广告公司（FCB）决策制定研究所的创立者和执行常委。博达大桥广告公司（FCB）是世界最早的广告公司之一，也是全球最早上市的广告公司之一。马修在品牌战略领域已经有25年的从业经历，足迹遍布欧洲、亚洲和北美洲。他服务过李维斯、美国艺电、希尔顿酒店集团、联合利华、雀巢、壳牌和葛兰素史克等大企业。 《畅销的原理》，作者在书里总结了自己25年的广告和营销从业经验，以及半个世纪以来人类行为和神经科学的研究成果，揭秘营销的本质以及如何刺激大脑做出决策。 内容一、营销的本质 营销的本质是：影响选择，使事情变得直观，让别人轻易就能选择你的商品和服务 品牌方针：想尽办法找到用户喜欢啥，再看看自己的商品有啥好的地方能够迎合他们的喜好。 大脑方针：从大脑做决策的过程出发，去研究怎么影响消费者的每一次选择，每一次营销行为都是一次影响选择的过程。 品牌的重要性也在逐渐降低，品牌对消费者的吸引力在下降。传统营销中的品牌方针逐渐变得不适用，应转为以大脑决策为出发点的大脑方针。 二、刺激大脑做出选择的方法1)成为用户心里的“老熟人”先让商品成为消费者生活中反复出现的“老熟人”，产生熟悉度，在此基础上，再通过制造 小惊喜和小新奇 让消费者持续关注。 🌰：在一个各种声音混杂的鸡尾酒会上，无论多么吵闹，只要有人喊我们的名字，我们总能听得到，这就是认知神经科学中一个著名的现象，叫做“鸡尾酒会效应”，说的就是熟悉和相关的事物会受到人们的重点关注。 🌰：登机或者入住酒店时，升舱或者换更好的房间会让我们获得意外惊喜。这份高兴不仅仅是因为感觉受到了优待，还因为我们的大脑感受到因为自己的好决策带来了好回报，所以，在第二次面临选择时，大脑会做出同样的决策。 2)制造稀缺展望理论(prospect theory，也作前景理论)：通过考虑损失和保存所得的决策行为。前景理论的一个表现就是人们特别讨厌损失，不愿放弃已经得到的东西。 利用大脑害怕失去的本能，可以制造稀缺感，从而驱动消费者的各种行为。 🌰：打客服电话的时候，我们经常会听到“坐席正忙”，同样都是让用户等待，为什么不把语音录制成“马上就有人接听电话”呢？马上就有人接听难道不是对用户更友善吗？其实，这是营销人员的一种营销手段。研究表明，当人们听到“坐席正忙”时，会产生这种服务很稀有的感觉，这种稀缺感让人们害怕失去的感觉更强烈，人们就更愿意继续等待。 禀赋效应(Endowment effect)：人们会高估已经拥有的东西。 🌰：人们不愿意交换自己购买到的彩票，因为人们都认为自己买的彩票中奖概率高。 3)用轻松打动客户人类永远偏好最容易的那条路，大脑喜欢简单。 行动上的便利 和 精神上的放松。 🌰：要想人们吃得健康，可以把健康食品放在餐厅最显眼的地方，用灯光突出陈列，让人们一眼就能看到，伸手就能拿到。总之，就是让健康食品的选项成为最省力的选项。 4)利用时间的力量系列位置效应(serial-position effect)：人们倾向于对首先见到的事物和最后见到的事物有更好的印象。 🌰：背单词的时候，如果能把一本单词书从头背到尾，往往是 A、Z 开头的单词容易记住，中间部分的单词记得就没那么好了。 强势结尾理论， 最后一步一定要做好，给消费者留下一个好的结尾。销售人员如何与消费者道别，要比如何欢迎他们更重要。🌰：一位司机在高速公路上开车时，看到了同样多的红色汽车和蓝色汽车，但如果在下高速的时候他看到的是一辆红色汽车，那么他会认为自己一路上看到的红色汽车更多。 参考：得到-每天听本书]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>心理学</tag>
        <tag>营销</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-5-iP协议相关技术]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-5.html</url>
    <content type="text"><![CDATA[仅凭IP无法完成通信 1 DNS 2 ARPARP(Address Resolution Protocol)，以目标IP地址为线索，用来定位下一个应该接收数据分包的网络设备对应的MAC地址。 ARP的工作机制ARP借助ARP请求与ARP响应两种类型的包确定MAC地址。 RARPRARP(Reverse Address Resolution Protocol)，从MAC地址定位IP地址的协议 代理ARP3 ICMPICMP的主要功能：确认IP包是否成功送达目标地址，通知在发送过程当中IP包被废弃的具体原因，改善网路设置等。 4 DHCPDHCP(Dynamic Host Configuration Protocol)，实现自动设置IP地址、统一管理IP地址分配。 DHCP工作机制 5 NATNAT(Network Address Translator)，用于本地网络中使用私有地址，在连接互联网时转而使用全局IP地址的技术。 6 IP隧道]]></content>
      <categories>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[读《设计心理学1》——好的设计是有章可循的]]></title>
    <url>%2F2018%2F%E8%AE%BE%E8%AE%A1%E5%BF%83%E7%90%86%E5%AD%A61.html</url>
    <content type="text"><![CDATA[作者和本书概要唐纳德·诺曼(Donald Arthur Norman)，曾被美国《商业周刊》评为全球影响力设计师之一。美国认知心理学家、计算机工程师、工业设计家，认知科学学会的发起人之一。现为美国西北大学计算机科学系和心理学教授，是尼而森-诺曼集团(Nielsen Norman Group)咨询公司的创办人之一，苹果计算机公司先进技术部副总裁。1999年，Upside杂志提名诺曼博士为世界100精英之一。2002年，诺曼获得了由人机交互专家协会(SIGCHI)授予的终身成就奖。作为一个以人为中心的设计的倡导者，诺曼最著名的书就是《设计心理学》。 《设计心理学》最早出版于1988年，是设计学的经典入门书籍。2013左右，作者对这套书大幅度增加和完善，现在《设计心理学》 有四本书： 《设计心理学1：日常的设计》 《设计心理学2：与复杂共处》 《设计心理学3：情感化设计》 《设计心理学4：未来设计》 本文是对《设计心理学1：日常的设计》的读书笔记。 内容一、什么是好设计 可视性，就是让用户知道这个产品怎么用，怎么操作才是合理的。 🌰，门的把手让用户知道门是拉的或推的，或是左右移动的。 易通性，就是要让用户明白你的设计意图，明确的告诉用户，你设计的这个东西是干什么用的。 🌰，电视遥控器太多的键，让用户不知所谓 为什么有那么多的糟糕设计？ 因为很多产品都是工程师做的，工程师都是受过严格逻辑训练的人，他们天然地以为，所有人都应该按照逻辑思考，所以他们设计出来的产品往往都“不近人情”。 🔥作为工程师的我，要时刻注意这一点，不要任何时候都太注重逻辑。 二、交互设计的五个基本原则 示能（显示能力）： 指某些物体本身就有的、特定的交互方式，不需要解释，它直接就可以被感知到。 🌰：一把椅子，不管它怎么设计，一定会有一个平面，咱们还是能认出它是一把椅子，可以坐人。这里面的“平面”，就是一种示能。一出现平面，人们就会天然地认为，这个地方是可以坐的。 意符： 是一种提示，告诉用户可以采取什么行为。 🌰：有些商场的大门上，会写上“推”或者是“拉”的提示，这个推和拉就是一种意符。 意符不仅可以用视觉的方式来展现，声音也可以起到意符的作用。🌰：门锁锁好的时候，会发出“咔嚓”一声。面包片烤好之后从面包机里跳出来的声音。这些声音都是一种意符，能传达给人某种信息。 🌰：汽车发动机的声音会给人一种安全警告⚠️，现在电动车没有那种声音，有时就电动机就需要模仿汽车发动机的声音来给人警告。 约束 很多东西咱们以前都没用过，但为什么总是能很快上手呢？这就是约束在设计里起到的作用。 🌰：比如一辆乐高的玩具摩托车，即便你以前没玩儿过，也能很快就把它组装起来。因为它的轮子只能装在前叉上，手臂只能装在小人的躯干上，每个部件的接口都不一样，可以执行的操作就那么几种，多尝试几次，我们就能把这个玩具摩托车组装好。 映射 最好的映射，就是控制开关直接安装在被控制的对象上。 🌰：触屏手机比按键手机好 如果做不到这么直接的映射，那就尽量把开关装到被控制对象的附近。 🌰：有两个灶眼的煤气灶，开关就会分别装到两个灶眼的旁边。 如果这也做不到，那就要让开关和被控制对象的空间分布保持一致。 🌰：墙面上的开关和屋顶的吊灯，要有明确的映射关系。 反馈一个好的设计，一定要有及时的反馈。当然，反馈也不能太频繁，这会打扰到用户。 🌰：很多遥控器按一下就会发出“滴”的一声，完成一个操作要按好几下遥控器，这时候连续的滴滴声就会搞得人心烦意乱。 三、人为差错往往来源于糟糕的设计人不是机器，不能要求人做出违反自然规律的事情,比如要求人好几个小时保持高度警惕的状态，或者同一时间处理好几个任务，这几乎是不可能的，肯定会有人会出错。 面对问题的时候，多问几个为什么，能促进人们更多思考，也能到最根本的原因，发现设计问题。 五个为什么：12345678战斗机失事，查找原因：为什么飞机失事？ 因为它当时失控了不断向下俯冲。飞机员为什么没有把俯冲状态下的飞机恢复到正常状态？ 因为飞行员没有及时启动恢复装置。为什么他没有启动恢复装置呢？ 可能是因为他当时缺氧了或者是恢复装置按钮太小了。... 四、怎么设计，才能避免人们操作失误 约束 🌰：比如在银行办理业务，填写完信息之后，人们很可能顺手就把营业窗口的笔装到自己兜里了，为了避免这种失误，银行就把笔拴在窗口上，这个小约束就能减少人们的失误。 🌰：ATM机，如果约束先拔卡后取钱 就可以避免忘记取卡 强制 🌰：在没有断电的情况下打开微波炉是非常危险的，为了防止这个错误，微波炉就可以被设计成在开门的一瞬间，也同时断开电源。 🌰：割草机，弹簧开关，按着才能使用 故意制造困难 🌰：很难打开的药瓶，就可以防止小孩吃错药，但还不影响大人平时正常使用。 二次确认、撤销 🌰：很多电脑软件，在你点击关闭之后，都会弹窗提醒你，是否确认关闭。还可以加上撤销功能，比如电脑的“回收站”功能。 五、“以人为本”的设计思维“以人为本”，不仅是价值观，还是方法论。它可以指导我们的行动。学会定义问题，工程师解决问题强 观察 设计师不会一开始就聚焦于解决方案，而是会先分析隐藏在问题之下的本质原因，找到问题的本质，才开始下一步的行动。设计师还会去找潜在用户，观察他们的行为，理解他们的兴趣爱好、动机以及真实需求。通过这些信息，来定义设计要解决的真正问题。 当然要在用户自然状态下观察。 创意 在创意的初期，要发散思维，让人们尽量多提出新点子，这个阶段千万不要急着批判，不管人们说出什么点子，都要记下来。等有了一堆点子的时候，再进行筛选整合，挑出最好的点子进行下一步。 打样 要想知道一个创意是不是合理，唯一的方法就是测试。所谓的打样，就是用草图，或者是模型，快速做出一个可以展示的样品出来。 测试 先找一小部分目标用户，让他们使用样品，这个过程一定要自然，尽量还原到真实的使用场景里。得到反馈之后。 再次重复上面四个步骤：观察、创意、打样、测试。直到设计出能真正解决用户需求，并且有良好用户体验的产品为止。 参考：得到-每天听本书]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>设计</tag>
        <tag>心理学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《赤裸裸的统计学》——面对爆炸的数据，了解统计学是很有必要的]]></title>
    <url>%2F2018%2F%E8%B5%A4%E8%A3%B8%E8%A3%B8%E7%9A%84%E7%BB%9F%E8%AE%A1%E5%AD%A6.html</url>
    <content type="text"><![CDATA[作者和本书概要查尔斯•惠伦（Charles Wheelan），于1997～2002年间担任《经济学人》杂志驻美国中西部地区的记者，还为《芝加哥部报》、《纽约时报》和《华尔街日报》撰稿，所著《赤裸裸的经济学》是畅销多年的经济学普及读物。 《赤裸裸的统计学》是一本关于统计学常识的科普书。 内容作为大数据时代炙手可热的学问，统计学可以解决很多实际问题。可如果运用不当，统计学也会制造假象、造成误导。 了解统计学，了解在大数据时代生存的游戏法则。 运用好统计学知识，能让我们在面对陌生问题的时候，得出有说服力的结论，做出合理的决策。统计学家的工作：通过分析数据来推断事物的本质，预测它未来的发展。 一、大数定律大数定律 的数学表达：当试验次数足够多时，实验结果的平均值会无限地接近一个数值，这个数值一般叫做“期望值”。 彩票：发行机构只要保证彩票的销售额大于奖金期望值，就肯定赚钱。 赌场：只要能吸引到足够数量的赌客，不管幸运儿赢走多少钱，赌场永远是最后的赢家。 投资风险承受能力越强，意味着允许试验的次数越多，也就越有可能赚到期望的投资回报。 保险行业 二、中心极限定理中心极限定理： 任意一个群体样本的平均值，都会围绕在这个群体的整体平均值周围。 任意群体样本的平均值≈整体平均值 例子🌰： 假如你烧了一锅汤，想知道味道怎么样，没必要把汤都喝光，只要尝一小勺就可以了，任意一勺汤的味道绝不会相差很远。 三、随机抽样选取代表性样本的过程就是随机抽样。 注意偏见。 选择性偏见 幸存者偏见 健康用户偏见 四、回归分析回归分析 ：通过一个已知的现象，来找到未知的原因。多元线性回归方程模型。研究复杂统计学问题的必备工具。保持理性的态度。 五、常犯的错误 “黑天鹅事件”：一般用来指那些影响很大，但难以预测的小概率事件。 美国次贷危机，致命问题是它的概率学模型参照的是过去20年的市场行为，不能对未知的意外情况做出预测。 统计误差： 只要数据分析建立在抽样调查之上，样本的统计结果和真实情况之间就会存在误差。 六、总结精确有时候并不意味着准确。 概率学本身不会犯错，犯错的是使用它的人。 随着大数据时代的到来，转变自己对周围世界的认知方式非常重要。 参考：得到-每天听本书]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>统计学</tag>
        <tag>大数据</tag>
        <tag>大数定律</tag>
        <tag>期望值</tag>
        <tag>随机抽样</tag>
        <tag>中心极限定理</tag>
        <tag>回归分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-4-IP协议]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-4.html</url>
    <content type="text"><![CDATA[TCP/IP的心脏是互联网层，包括IP(Internet Protocol)和ICMP(Internet Control Message Protocol)两个协议。 1IP即网际协议 主机：配置IP地址，但不进行路由控制的设备。路由器：配置IP地址又有路由控制的设备。节点：主机和路由器的统称。 2IP基础知识IP地址属于网络层地址路由控制IP路由也叫多路路由 为了将数据包发给目标主机，所有主机都维护这一张路由控制表（Routing Table） 数据链路的抽象化不同数据链路最大区别是最大传输单位（MTU，Maximum Transmission Unit）。 IP属于面向无连接型面向无连接是指在发包之前，不需要建立与对端目标地址之间的连接。 这样做的原因： 简化 提速 为了提高可靠性，上一层的TCP采用面向有连接型 3IP地址的基础知识IP地址组成IP地址组成： 网路标识（网络地址）， 主机标识（主机地址） IP地址的分类 广播地址IP多播 子网掩码 CIDR与VLSM0、10、27等开头的A类地址都是具有特殊意义的保留地址。 全局地址与私有地址4路由控制IP地址与路由控制 路由控制表中记录着网络地址与下一步应该发送至路由器的地址。 在Windows和Unix上表示路由器的方法分别为netstat-r， netstat-rn。 环回地址：同一台计算机上的程序之间进行网络通信时所使用的一个默认地址。 127.0.0.1 路由控制器的聚合 5IP分割处理与再构成处理 IP报文的分片与重组经过分片之后的IP数据报在背重组的时候，只能由目标主机进行。路由器虽然做分片但不会进行重组。 路径MTU发现 6 IPv67 IPv4首部8 IPv6 首部格式]]></content>
      <categories>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-3-数据链路]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-3.html</url>
    <content type="text"><![CDATA[1数据链路的作用二进制0、1表示信息，在通信媒介中国对应是 电压的高低、光的闪灭以及电波的强弱等信号。 数据链路被视为网络传输中的最小单位。 不同的数据链路网路：以太网FDDI（Fiber Distributed Data Interface，光纤分布式数据接口）ATM（Asynchronous Transfer Mode，异步传输方式）无线LAN蓝牙 网络拓扑（Topology） 2数据链路相关技术2.1MAC地址MAC地址长48比特，一般被烧入到ROM中。任意一个网卡的MAC地址是全世界唯一的（虚拟网卡除外）。 厂商识别码（OUI, Organizationally Unique Ideifier），可通过网络分析器分析得到。 2.2共享介质网路：多个设备共享一个通信介质 争用方式（Contention），也叫 CSMA（载波监听多路访问） CSMA/CD (Carrier Sense Multiple Acess with Collision Detection) 令牌传递方式只有获得令牌的站才能发送数据 2.3非共享介质网络 半双工与全双工通信 2.4 根据MAC地址转发交换集线器 也叫 以太网交换机 2.5 环路检测技术2.6 VLAN3以太网以太网（Ethernet）源于Ether（以太），意为介质。 以太网的分类BASE前的10、100、10G等代表传输速度，BASE后的2、5、T、F等字符代表传输介质。 以太网传输速度与计算机内部的表现值不同，以太网中是1000（1K=1000，1M=1000K等），而计算机内部是1024。 4无线通信 5PPPPPP(Point-to-Point Protocol) 点对点]]></content>
      <categories>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-2-TCP/IP基础知识]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-2.html</url>
    <content type="text"><![CDATA[1TCP/IP出现的背景及其历史军用技术ARPANET UNIX系统的普及与互联网的扩张 商用互联网服务的启蒙 ISP 2TCP/IP的标准化 TCP/IP协议群 TCP/IP规范 —- RFCRFC(Request For Comment，征求意见表) TCP/IP的标准化流程 互联网草案阶段 -&gt; 记入RFC进入提议标准阶段 -&gt; 草案标准阶段 -&gt; 真正的标准阶段 3互联网基础知识 互联网结构 4TCP/IP协议分层模型 硬件（物理层） 网络接口层（数据链路层） 互联网层（网络层）连接互联网的所有主机跟路由器必须实现IP的功能，其它连接互联网的网络设备（如网桥、中继器或集线器）就没有必要一定实现IP或TCP的功能（有时为了监控和管理这些设备就要了）。 ARP：从分组数据包的IP地址中解析出物理地址（MAC地址）的协议 传输层 ： 让应用程序之间实现通信 应用层 5TCP/IP分层模型与通信示例 每个分层的包首部中还包含一个识别位。]]></content>
      <categories>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[图解TCP/IP-1-网络基础知识]]></title>
    <url>%2F2018%2Ftujie-TCP-IP-1.html</url>
    <content type="text"><![CDATA[现在TCP/IP不局限于链接计算机，还可以链接汽车、数码相机、家电等，另外还应用在计算机系统虚拟化和云计算。 1计算机网络出现的背景 从独立模式到网络互连模式WAN（Wide Area Network， 广域网），LAN（Local Area Network，局域网） 从计算机通信到信息通信 2计算机与网络发展的7个阶段 批处理（batch processing）： 事先先将用户程序和数据装入卡带或磁带，并由计算机按照一定的顺序读取 分时系统（time sharing system ，TSS）(1960s)：多个终端与同一个计算机连接，允许多个用户同时使用一台计算机的系统。 独占性、多路性、交互性、及时性 BASIC 计算机之间的通信 (1970s) 多台计算机分布式处理 通信线路 计算机网络的产生 (1980s)分组交换技术 窗口系统 互联网的普及 (1990s) 以互联网技术为中心 (2000s)电话网 -&gt; IP网 从“单纯建立连接”到“安全建立连接” TCP/IP 3协议 协议就信是计算机之间通过网络实现通时事先达成都的一种“约定”。协议如同人与人的对话：将汉语和英语当作“协议”将聊天当作“通信”将说话的内容当作“数据” cpu通常同一时间只能运行一个程序。乱转机制 多任务调度 人与人之间交流的容错率很高，而计算机不一样，计算机之间交流要注意“应对异常”。 分组交换协议 是将大数据分割成包（Packet）的较小单位进行传输的方法。 4协议由谁规定 ISO（International Organization for Standards, 国际标准化组织）制定了国际标准OSI（Open System Interconnection, 开放式通信系统互联参考模型） 5协议分层分层 类似模块化开发。“接口” 上下层之间交互所遵循的约定“协议” 同一层之间交互所遵循的约定 分层的优势：独立使用（扩展灵活），细分通信功能。 分层的劣势：过分模块化，使处理变得更加沉重以及每个模块都不得不实现相似的处理逻辑 OSI参考模型各个分层的作用 6OSI参考模型通信处理举例假设用户A使用主机A要给使用主机B的用户B 在应用层 在表示层表示层将数据从主机特有的格式转换为网络标准传输格式。不同计算机对数据在内存中相异的分配方式（如：大实体和小实体） 在会话层会话层决定采用哪个链接发送（何时连接，何时发送，但没有实际传输数据的功能） 在传输层：实际传输数据 网络层 网络层与传输层相互协作以确保数据包能够传送的世界各地，实现可靠传输。 数据链路层、物理层 数据链路层通过传输介质互连的设备之间进行数据处理 物理层将数据的0、1转换为电压和脉冲传输给物理的传输介质，而相互直连的设备之间使用地址（MAC地址）实现传输 7传输方式的分类 面向有连接型与面向无连接型 电路交换（历史久，主要用于电话网）和 分组交换（蓄积交换） 根据接收端数量分类 单播（unicast） 广播（broadcast) 电视播放 多播（multicast） 电视会议 任播（anycast） DNS根域名解析服务器 8地址1.地址的唯一性 在同一个通信网络中不允许有两个相同地址的通信主体存在。2.地址的层次性 为了高效地从越来越多的地址中找出通信的目标地址。 ip地址具有层次性 MAC寻址 参考 地址转发表(记录实际的MAC地址)IP地址 参考 路由控制表(记录之后的网络号和子网掩码) 9网络的构成要素 9.1通信媒介与数据链路 传输速率，单位bps(Bits Per Second, 每秒比特数)， 又称为 带宽(Bandwidth) 吞吐量：主机之间实际的传输速率。吞吐量不仅衡量带宽，也衡量主机的CPU处理能力、网络的拥堵程度、报文中数据字段的占有份额等信息。 9.2网卡网卡，全程网络接口卡（NIC, Network Information Center），也称网络适配器、LAN卡。 9.3中继器(Repeater)波形调整和放大中继器无法改变传输速率有多个端口服务的中继器被称为 集线器 9.4网桥/2层交换机 自学式网桥会记住曾经通过自己转发的所有数据帧的MAC地址，并保存到自己里的内存表中。 交换集线器 是网桥的一种 9.5路由器/3曾交换机 网络是根据物理地址（MAC地址）进行处理，而路由器/3层交换机则是根据IP地址进行处理的。 9.6 4~7层交换机 9.7网关 典型例子是互联网邮件与手机邮件之间的转换服务。 代理服务器也是网关的一种，成为应用网关 防火墙]]></content>
      <categories>
        <category>图解TCP/IP</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《我所理解的生活》记录]]></title>
    <url>%2F2018%2F%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E7%94%9F%E6%B4%BB.html</url>
    <content type="text"><![CDATA[注： 本文是我几年前写的文章，整理时发现还可以再看看。 序我所理解的生活就是除了造谣以外，去造其他一切东西。 这世道让那些不说粗话但最缺德的人能做道德评判家，这世道让那些话不脏但心眼脏、手段脏的人当道。 我所理解的生活就是做着自己喜欢的事件，养活自己，养活家人。 你在台面上看见我成功一次，我在台面下就干砸十次，那又如何，我又没死，不停地干就行了，人们只会记住你成功的那一次。 我只负责制造作品，不负责用户体验，也没有售后服务，更不会根据大家的口味来改进。 充满挫败甚至后悔，但遗憾并不多。 得之我幸，不得我也没什么不幸。 国事我走得“肤浅”， 几乎所有人都和气。 除了利益和人与人之间的斗争，我们几乎对一切都冷漠。 我们所炫耀的，他们的纳税人不会答应；我们所失去的，他们都留下了；我们所缺少的，才是最能让人感到自豪的。 在这个一点就着、一煽就旺的社会里，每个人的私有财产都是不安全的。 看见好的捧个场，遇见坏的冷个场，碰见傻的笑个场，等他们自己给自己砸个场。 很多人恨特权没有在自己手中。 没有人能控制自己不会凌驾在他人和法律之上，哪怕他再好再温厚。体制赋予特殊个体的特权是无法靠自我修行来美化和消解的。 地表上的光鲜，地底下的不堪。城市让生活更美好，也能让生活更槽糕。 现在的人心其实相信的是情绪。大家的注意力转移得太快了。 中国人有时候不认可自己人。 总是习惯于认可当下，追溯过往。不是每件事都能给人生带来什么，人生的时光，总需要去度过。我选择这样度过。在做事件的时候，我希望看得远一些；但在过日子的时候，我希望看得近一些。 只是我的欲望可能未必那么直接。我始终不能接受和很多不解风情的人在一起。有些人的努力是为了摆脱自己原来的出身和环境，有些人的努力是为了证明无论出身和环境自己都可以，这都无可厚非。 天下势革命不保证就能带来民主。不能用完美的民主、完美的自由、完美的人权字面上的解释来逃避中国的现实。一切能用钱解决的社会矛盾都不算什么矛盾。自由在中国最没有感染力。我不会用他人的前途来美化我自己的履历。 消费政治 消费情绪 消费公共事件现实社会中的可行性操作 成功之道有很多未必能展开的东西，而且你也不能将自己的狗屎运赠送给受众。 家世荒诞的欺骗你说你一生没做坏事，为何这样。我想我可以试着告诉你为何。因为，你一生没做过坏事，所以，就是这样。 命里有时终须有，命里无时须强求。因为命里本来什么都没有，只有诞生和死亡，而中间的都是你要强求的部分。两个想在一起的人，便是最大，便是最正，他人皆是第三者。 牢骚也是推动社会进步的一种方式。愿怀着善意，相信他是无心的吹水。没有人永远和过去的自己一致，除非你不再成长。 我选择走得道路太不一样，充满未知，所以我很希望日常生活里没有变故，不再有陌生的事物。 为在乎我的人创造各种东西，绝不向厌恶我的人解释是个什么东西。 人生的许多问题需要阅历来回答，而不能像数学问题一样，通过不停论证而得到。 过去式如果文明不够文明，那就让野蛮足够野蛮。 《这个男人来自地球》 为热爱的人或事物洒下热血和热泪，最坏的结果无非就是对方一句“你想怎样”。 有的时候死死的坚持可能会在一个合适的时候重拾，无论对理想还是对感情都是这样。 我是一个虚荣的人，有时候甚至还虚伪，由于我得到的越来越多，所以也可以假装越来越不虚荣，因为有了一些真容。但我的内心还是虚荣的。不出席所有颁奖典礼，不去各种上流场合其实是另一种虚荣，并不是淡泊。 成名算屁，多少屡秀下限的傻逼也能粉丝绕膝。 我是你当时都没有做好、没有做到，你有什么资格豁免被他人嘲笑？自己没有展露光芒，就不应该怪别人没有眼光。 历史只会记得你的作品和荣誉，而不会留下一事无成者的闲言碎语。 青春就是一场离自己的童年、自己的少年越来越远的远行。 因为我们不能回去了，不能简单了，所以才会对过往那些纯粹发出偶然的叹息。 往往没怎么经历过的人会有一堆感悟，经历越多反而要说的越少。 神不保佑你，因为神就是你所理解的你自己。 开始了并会有结果，过程各不同。走过的路我会记得，但不会重新走过。正在走的和未来的路我会走过，方式不得而知，让别人有路可走吧！但我知道有很多人会给我指路的。我会非常感谢他们，我爱他们，他们怕我迷路或者误入歧途。不管最终我怎么选择，都对到达终点。路开始了就一定会结束，方式和路线属于每个人自己。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[《黑客与画家》记录]]></title>
    <url>%2F2018%2F%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6.html</url>
    <content type="text"><![CDATA[注： 本文是我几年前写的文章，整理时发现还可以再看看。 保罗-格雷厄姆其人其事“运营创业公司，每天都像在战斗；而为大公司工作，就像在窒息中挣扎。” “我生活的中得一切，都正在成为计算机。所以，如果你想理解我们目前的世界以及它的未知动向，那么多了解一些黑客的想法会对你有帮助。” Y Combinator创始人本身比他的创意更重要内耗 译者序表面上这是一个机器的时代，但是实际上机器的设计者决定了我们的时代。stallman：“出于兴趣而解决某个难题，不管它有没用，这就是黑客。” 好玩，高智商，探索精神真正的黑客致力于改变世界，让世界运转得更好。 前言计算机世界就像是智力世界的大西部，在那里没有你不敢想得事件，只要你愿意承担冒险后果。 为什么书呆子不受欢迎他们真的不想让自己受欢迎 “任何一种艺术，不管是否重要，如果你想要再该领域出类拔萃，就必须全身投入” —- 阿尔伯蒂 对于那些高度困难的领域，只有身处其中的人，才能意识到成功需要不间断（虽然未必是自觉的）付出。在一个人产生良知之前，折磨就是一种娱乐。 那些对自己没自信的人就会通过虐待他们眼中的下等人来突显自己的身份。 没有什么比一个共同的敌人更能使得人们团结起来了 难怪聪明的小孩读中学时往往是不快乐的。 那些在学校的想法在社会中得到了实现也成为了他们个人魅力所在。 当所做的事件能产生真实的效果，那么发现正确的答案就开始变得重要了。 书呆子已经在思考的东西，正是真实世界看重的东西。 学校的真正目的是把儿童都关在同一个地方，以便大人们白天可以腾出手来把事件做完。 你告诉一个人，他的脚天生就是坏的，并不能阻止他去怀疑他可能穿错了鞋子。 逃离这种空虚生活的唯一方法，就是向它屈服。 2 黑客与画家创作者 computer science1 计算机科学家/数学家2 计算机博物学家/计算机的实验室科学3 黑客 没有什么比一个错误的前提更容易产生大量待解决的问题了。 创造优美事物的方式往往不是从头做起，而是在现有成果的基础上做一些小小的调整，或者将已有的观点用比较新的方式组合起来。 创造性从不同方面限制了优美软件的诞生 更大的危险是你自己也会误解自己的工作。 黑客搞懂“计算理论”的必要性，与画家搞懂颜料化学成分的必要性差不多大。 （黑客的想法）来自于其他创作领域。 太过专业化所带来的弊端。 允许动态扩展(malleable)。编程语言是用来帮助思考程序的，而不是用来表达你已经想好的程序。 作家和画家没有“对数学家的妒忌”，他们认为自己在从事与数学完全不相关的事件。大学和实验室强迫黑客成为科学家，企业强迫黑客成为工程师。当你排斥差异的时候，你不仅将失败的可能性排除在外，也将获得高利润的可能性排除在外。好玩的软件的需求量，比不上解决客户麻烦问题的软件的需求量。day job应该定期地从头开始，而不要长年累月地在一个项目上不断工作，并且试图把所有的最新想法以修订版的形式包括进去。 初始的原创和站在巨人的肩上 从他人的角度思考问题正是成功的奥秘所在。 了解别人对于事件的看法，并不代表你为他的利益服务。 怎样向没有技术背景的人解释技术问题。 程序写出来是给人看的，附带能在机器上运行。 —- 《计算机程序的结构与解释》 一种新的媒介刚刚诞生的时候，人们热情高涨、兴奋不已，短短几代人就探索清楚了这种媒介的大部分可能性，把它的能量发挥到极致。 编程目前好像就处在这个阶段。 不能说的话习俗的力量不足以束缚他们 “要根据社会要求，改造自己的思想” 历史的倒退 未来的人们可能会发现，他们觉得很平常的话，在我们今天这个时代都是不能说的。 回顾过去。我们可以去找那些过去被认为理所当然，如今却被认为不可思议的事情 hard sicence soft science 我们喜欢孩子们看上去天真无邪。 流行的时尚 流行的道德观念 如果一个团队强大到无比自信，它更本不会在乎别人的抨击。 道德禁忌的最大制造者是权力斗争中占上风的，但同时有软弱到需要禁忌保护自己的利益。 抱负心 恐惧心 第二批的接受者只有跟随者了我要亲眼看一下，然后自己做决定。 优秀作品往往来自于其他人忽视的想法，而最被忽视的想法就是那些被禁止的思想观点。 只要你能看到别人看不到或不敢看的东西，你就有很大的优势。 训练自己去想那些不能想的事情，你获得的好处会超过所得到的想法本身。自由思考比畅所欲言更重要。在心里无所不想，但是不一定要说出来。“守口如瓶，笑脸相迎”“不能说的话”太多了，如果口无遮拦，你就没时间做正事了。只要不是错误的观点，就不应该被压制讨论。 良好的坏习惯hacker, hack prose, hack the problem只有深入了解当前的技术，黑客才能构想下一代技术。黑客永远是自负的。黑客的所作所为完全出于兴趣，想到哪里就做到哪里，没有明确的计划，只求开心。很自负的人必须培养出敏锐的感觉，及时发现周围情势的变化，知道怎样才能脱身。一个人们拥有言论自由和行动自由的社会，往往最有可能采纳最优方案，而不是采纳最有权势的人提出的方案。Laffer curve 另一条路桌面软件 互联网软件 用户密集互动的软件 坐下来写东西的时候，一半的构思是写作时产生的。 实现某个构思，会带来更多的构思。 提高软件可靠性的关键在于开发时全神贯注，而不是降低开发速度。如果你亲眼见到某人第一次使用你的软件，你就会知道软件的哪个地方最打动他。 一定数量的盗版对软件公司是有好处的。 价格歧视 公司内部所有不直接感受到竞争压力的部门都应该外包出去，让它们暴露在竞争压力之下。 如果新事物真的有重大改进，那么它总是可以找到生存空间的。 管理企业：做出用户喜欢的产品，保证开支小于收入。 只有懂得设计的黑客，才能设计软件，不能交给对软件一知半解的设计师。如果你不算自己动手设计和开发，那就不要创业。 他们害怕你胜过你害怕他们 开发互联网软件不需要得到任何人的许可，没有人能够阻止你。你不需要去申请许可证，不需要在零售店的货架上谋得一席之地，也不需要卑躬屈膝地求人家，将你的软件与操作系统捆绑在一起。你能狗购过浏览器发布软件，没有人能在你和浏览网站的用户之间插上一脚。 如何创造财富平均主义泛滥 使用“挣钱”这个词会不利于理解如何才能挣钱。(make money-财富，money-金钱) 金钱是专业化的副产品。 公司的存在目的就是满足人们的某种需要。 苦恼：无法准确测量每个员工的贡献。 团队越大，每个人的贡献就越接近于整体的平均值。 技术就是某种手段，就是我们做事的方式。经济价值取决于有多少人使用这种新方式。我们很乐于迫使那些又大又慢的竞争对手跟着我们一起走进沼泽地。不是让买家看到有获利的可能，而是让他们感到失去机会的恐惧。 无论你的技术水平有多高，用户数量都比你自己的判断更能准确反映哪些问题应该优先解决。 创造人们需要的东西，也就是创造财富。创造财富的人能够心安理得地享用自己的财富。 没有财富的激励，就不会有人愿意去做技术革新。 关注贫富分化不管是战争还是政治斗争，本质上都属于偷窃。技术的发展使得通过创造而积累的速度第一次有可能超过通过偷窃而积累财富的速度。 每一笔巨大财富的背后，都隐藏着罪行。 —- 巴尔扎克技术无法使其变得更便宜的唯一东西，就是品牌。无所事事使人感到孤独和消沉技术在加大收入差距的同时，缩小了大部分的其他差距。生活在一个整体上非常富裕但是我个人相对贫穷的社会，还是生活在一个我个人相对非常富裕但是整体上非常贫穷的社会呢？ 防止垃圾邮件的一种方法设计者的品味喜欢一件东西，却不知道为什么自己喜欢它。 人类的思想就是没有经过整理的无数杂念的混合。 如果你是一个设计师，并且你不承认有一种人们共同认可的东西叫做“美”，那么你就没有办法做好工作。 优秀设计的原则是许多学科的共同原则 装饰品本身并不是坏事，只有当它被用来掩盖结构的苍白时，才变成了一件坏事。 好设计师永远不过时的设计 对称的危险在于它可以用来取代思考，在大量使用重复的时候这种危险性更大。 大自然在长期的演化中已经解决了很多设计问题。 遗传算法可能会创造出正常条件下难以设计的复杂事物。 你应该培养对自己的不满。 编程语言解析一个操作所需的代码越多，就越难避免bug，也越难发现它们。 只要你懂得驾驭开源软件社区，就会有很多人在短期内为你提供大量的代码。 一百年后的编程语言一种编程语言的两大组成部分：1.基本运算符的集合（扮演公理的角色）。2.除运算符以外的其他部分（原则上，这个部分可以用基本运算符表达出来） 数学家总是觉得公理越少越好。 一种语言的内核设计得越小、越干净，它的生命力就越顽强。 对速度的追求是人类内心深处根深蒂固的欲望。效率低下的软件并不等于很烂的软件。浪费程序员的时间而不是浪费机器的时间才是真正的无效率。 拒绝平庸选择使用哪一种技术的时候，你不能考虑别人的做法，只能考虑什么样的技术能最好地完成工作。在竞争中，你的对手无法理解你的技术优势，这可是再宝贵不过了。他们都满足于自己碰巧用熟了的那种语言。Lisp人类天性变化的速度大大慢于计算机硬件变化的速度。 书呆子的复仇条件越苛刻的项目，强大的编程语言就越能发挥作用。把软件运行在服务器端就可以没有顾忌地使用最先进的技术。 他们眼中不正常的事件恰恰就是使得这一切发生的原因所在。在基础语言之上先构建一种你自己的语言，然后再用后者开发应用程序。程序员使用某种语言能做到的事件是有极限的。经理真正关心的是不承担决策失败的责任。 梦寐以求的编程语言只有流行才会让它保持优秀。 无法以一种语言本身的优缺点评判这种语言。 只有当一种语言本身的优缺点评判这种语言。只要计算机可以自己推断出来的事情，都应该让计算机自己去推断。敞开胸怀：对于制造工具的人来说，总是会有用户以违背你本意的方式使用你的工具。 让字节码成为语言的正式组成部分，允许程序员在瓶颈处内嵌字节码。 硬件和软件现在捆绑在一起供应。 人们有时候会想要自己并不真正需要的东西。 大多数热门新商品事后被证明都是浪费时间的噱头，没多久就消失得无影无踪。 人们真正注意到你的时候，不是第一眼看到你站在那里，而是发现过了这么久你居然还在那里。 “最好的文字来自不停的修改。” 对解决难题的可能性保持乐观，同时对当前解法的合理性保持怀疑。 做出优秀成果的人，在做的过程中常常觉得自己做得不够好。 如果你能平衡好希望和担忧，它们就会推动项目前进，就像自行车在保持平衡中前进一样。 如果用户数量庞大，修改语言带来的痛苦就将持续很长时间。 设计与研究设计与研究，好与新。 只有应用“新”的创意和理论，才会诞生超越前人的最佳设计；只有解决那些值得解决的难题（也就是“好”的难题），只是前进的路线不同罢了。除非设定目标用户，否则一种设计的好坏根本无从谈起。如果目标用户群体涵盖了设计师本人，那么最有可能诞生优秀设计。 “弱即是强”(Worse is Better) 尽快拿出原型，听取用户的意见。先做出原型，再逐步加工做出成品。 任何时候，代码必须能够运行。 “画作永远没有完工的一天，你只是不再画下去而已。”]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[为博客添加Disqus评论系统]]></title>
    <url>%2F2018%2Fcomment-disqus.html</url>
    <content type="text"><![CDATA[给博客添加一个评论系统，考虑了好几个，但最终还是选择了Disqus，考虑一下几点： 之前非常受欢迎的多说，某原因关闭了，现在国内也有非常多好的评论系统，但就是担心又出现某原因关闭，那就麻烦了 Disqus唯一的问题就是在墙外，我考虑一下，访问我博客十有八九都是做技术的，梯子肯定是多的是，😀 Disqus添加也非常方便。 注册Disqus到Disqus，注册一个账号 I want to install Disqus on my site就是现在Disqus做个站点的标记。 这边的Shortname比较重要，之后再hexo-next中配置就是用这个Shortname，需要不重复。 下面的信息就按照规则填就是了。 填写配置文件在next/_config.yml中添加或修改，如下：12345# Disqusdisqus: enable: true shortname: http-andyron-com count: true 更新一下系统123hexo cleanhexo ghexo d 现在在文章底部就出现评论系统了。 Disqus刚刚推出了 Reactions，可以在后台配置。]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>Disqus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用LeanClound给hexo+next博客添加文章阅读数]]></title>
    <url>%2F2018%2Fleanclound-hexo-next.html</url>
    <content type="text"><![CDATA[个人博客之前用的NexT 框架介绍 不蒜子统计 来统计文章阅读数、网站访问人数和网站访问总数。但是总是发现文章阅读数老是出现问题，因此把文章阅读数换成用LeanCloud来统计，看起来也方便。LeanCloud的免费的开发版完全满足了我博客这种小网站的需求了。配置起来也很方便，下面做个记录： 注册LeanClound账号这个很方便，微博，GitHub都可以直接关联注册，或者直接用邮箱注册。 创建应用比如我创建一个名为andyron.com.counter的应用。 获取APP ID，APP Key，之后再配置文件中配置。 创建Class 在应用的数据配置界面，左侧下划线开头的都是系统预定义好的表，为了便于区分我们新建一张表来保存我们的数据。新建Class用来专门保存我们博客的文章访问量等数据，理论上来说名字可以随意取名，只要你交互代码做相应的更改即可，但是为了保证对NexT主题的修改兼容，此处的新建Class名字必须为Counter: 添加安全域名添加安全域名后，只有这些安全域名才有权访问后台的数据了，可以进一步提升安全性。 修改一下主题配置文件修改配置文件next/_config.yml12345678910111213141516171819202122leancloud_visitors: enable: true app_id: #你的app_id app_key: #你的的app_key# Show PV/UV of the website/page with busuanzi. 不蒜子统计# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: # count values only if the other configs are false enable: true # custom uv span for the whole site site_uv: true site_uv_header: &lt;i class=&quot;fa fa-user&quot;&gt;&lt;/i&gt; 访问人数 site_uv_footer: 人次 # # custom pv span for the whole site site_pv: true site_pv_header: &lt;i class=&quot;fa fa-eye&quot;&gt;&lt;/i&gt; 总访问量 site_pv_footer: 次 # custom pv span for one page only page_pv: false page_pv_header: &lt;i class=&quot;fa fa-file-o&quot;&gt;&lt;/i&gt; 阅读 page_pv_footer: 次 更新一下系统123hexo cleanhexo ghexo d 最新的NexT框架已经不需要再配置样式，可以看到 在LeanCloud中也可以查看数据了： 注：objetcId这个主键是由日期和博文标题组合成的，因此标题变化，阅读会重新计数 参考： 为NexT主题添加文章阅读量统计功能使用leancloud给博客添加阅读次数]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>LeanClound</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于iOS多线程，这边勉强可以看看(OC&Swift)]]></title>
    <url>%2F2018%2Fios-multithreading.html</url>
    <content type="text"><![CDATA[iOS开发多线程总是绕不过的坎，看了很多前辈们优秀的文章，如：关于iOS多线程，我说，你听，没准你就懂了！、谈iOS多线程(NSThread、NSOperation、GCD)编程、iOS多线程：『GCD』详尽总结、iOS多线程：『pthread、NSThread』详尽总结、iOS多线程：『NSOperation、NSOperationQueue』详尽总结、关于iOS多线程，你看我就够了等，但不自己整理一下，敲一下代码总是感觉不深刻 ，于是就有这篇文章，断断续续整理了好久。 示例我尽量把不同知识点代码独立开，看着简单一些，容易理解。示例代码我都用OC和Swift分别写了，不过文中都是以OC说明的，英文如果用两种语言一起，看起来可能比较乱，文章也会更加长（已经非常长了😂😂）。Swift写法可能有比较大区别，也有些功能取消，但看一下代码应该能明白了。文中的所有示例代码：andyRon/iOS-Multithreading 先看个大概： 1 简介1.1 一些概念 系统中正在运行的每一个应用程序都是一个 进程(Process) ，每个进程系统都会分配给它独立的内存运行。也就是说，在iOS系统中中，每一个应用都是一个进程。 一个进程的所有任务都在 线程(Thread) 中进行，因此每个进程至少要有一个线程，也就是主线程。那多线程其实就是一个进程开启多条线程，让所有任务并发执行。 iOS App一旦运行，默认就会开启一条线程。这条线程，通常称作为“主线程”。在iOS应用中主线程的作用一般是：刷新UI；处理UI事件，例如点击、滚动、拖拽。 如果主线程的操作太多、太耗时，就会造成App卡顿现象严重。所以，通常我们都会把耗时的操作放在子线程中进行，获取到结果之后，回到主线程去刷新UI。 多线程在一定意义上实现了进程内的资源共享，以及效率的提升。同时，在一定程度上相对独立，它是程序执行流的最小单元，是进程中的一个实体，是执行程序最基本的单元，有自己栈和寄存器。 同步： 只能在当前线程按先后顺序依次执行，不开启新线程。 异步： 可以在当前线程开启多个新线程执行，可不按顺序执行。 队列： 装载线程任务的队形结构。 并发： 线程执行可以同时一起进行执行。 串行： 线程执行只能依次逐一先后有序的执行。 通过确保主线程自由响应用户事件，并发可以很好地提高应用的响应性。通过将工作分配到多核，还能提高应用处理的性能。但是并发也带来一定的额外开销(调度)，并且使代码更加复杂，更难编写和调试。 1.2 多线程概念补充 多线程的原理： 同一时间，CPU只能处理一条线程，也就是只有一条线程在工作。所谓多线程并发(同时)执行，其实是CPU快速的在多线程之间调度(切换)。如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象。 在实际项目开发中并不是线程越多越好，如果开了大量的线程，会消耗大量的CPU资源，CPU会被累死，所以一般手机只开1~3个线程为宜，不超过5个。 多线程的优点： 能适当提高程序的执行效率能适当提高资源的利用率，这个利用率表现在(CPU，内存的利用率) 多线程的缺点： 开启线程需要占用一定的内存空间(默认情况下，主线程占用1M，子线程占用512KB，如果开启大量的线程，会占用大量的内存空间，降低程序的性能) 线程越多，CPU在调度线程上的开销就越大 线程越多，程序设计就越复杂，比如线程之间的通信，多线程的数据共享，这些都需要程序的处理，增加了程序的复杂度。 在iOS开发中使用线程的注意事项： 别将比较耗时的操作放在主线程中 耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验 2 四种解决方案对比 目前iOS多线程有四种方法：pthread，NSThread，GCD， NSOperation，四种方案的简单对比一下。 由于pthread平常几乎用不到，我暂时就不学了。 每个NSThread对象对应一个线程，真正最原始的线程，相对简单，但是需要手动管理所有的线程活动，如生命周期、线程同步、睡眠等。 怎么选择？简单而安全的选择NSOperation实现多线程即可。处理大量并发数据，又追求性能效率的选择GCD。 3 NSTread生命周期还是需要程序员手动管理，所以这套方案也是偶尔用用。 3.1 NSThread三种线程开启方式 动态开启 12NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(doSomething1:) object:(@&quot;NSThread1&quot;)];[thread1 start]; 静态开启 12// 创建好之后直接启动[NSThread detachNewThreadSelector:@selector(doSomething2:) toTarget:self withObject:(@&quot;NSTread2&quot;)]; 隐式开启 12// 创建好之后也是直接启动[self performSelectorInBackground:@selector(doSomething3:) withObject:(@&quot;NSTread3&quot;)]; 3.2 NSThread拓展 获取当前线程 1NSThread *current = [NSThread currentThread]; 获取主线程 1NSThread *main = [NSThread mainThread]; 暂停当前线程一段时间 1[NSThread sleepForTimeInterval:2]; 暂停当前线程到某个时间 1[NSThread sleepUntilDate: date]; 线程之间通信 123456//在指定线程上执行操作[self performSelector:@selector(run) onThread:thread withObject:nil waitUntilDone:YES]; //在主线程上执行操作[self performSelectorOnMainThread:@selector(run) withObject:nil waitUntilDone:YES]; //在当前线程执行操作[self performSelector:@selector(run) withObject:nil]; 4. GCD GCD为Grand Central Dispatch的缩写。Grand Central Dispatch (GCD)是Apple开发的一个多核编程的较新的解决方法。它主要用于优化应用程序以支持多核处理器以及其他对称多处理系统。 4.1 GCD的优点 GCD 可用于多核的并行运算 GCD 会自动利用更多的 CPU 内核（比如双核、四核） GCD 会自动管理线程的生命周期（创建线程、调度任务、销毁线程） 程序员只需要告诉 GCD 想要执行什么任务，不需要编写任何线程管理代码 4.2 任务和队列 任务： 表现上就是一段代码，OC就对应一个Block。任务 有两种执行方式，是否会创建新的线程，会不会阻塞当前线程 同步执行（sync）：在当前线程执行任务，不会开辟新的线程。必须等到Block函数执行完毕后，dispatch函数才会返回。 异步执行（async）：可以在新的线程中执行任务，但不一定会开辟新的线程。dispatch函数会立即返回, 然后Block在后台异步执行。 队列：任务管理方式。分为 串行 和 并行两种方式，都是按照 FIFO（先进先出）原则依次触发任务。 串行队列 ： 所有任务会在一条线程中执行（有可能是当前线程也有可能是新开辟的线程），并且一个任务执行完毕后，才开始执行下一个任务。（等待完成） 并行队列： 可以开启多条线程并行执行任务（但不一定会开启新的线程），并且当一个任务放到指定线程开始执行时，下一个任务就可以开始执行了。（等待发生） 两者的区别：执行顺序不同，以及开启线程数不同。 两个特殊队列： 主队列： 系统创建好的一个 串行队列，它管理必须在主线程中执行的任务。 全局队列：系统为我们创建好的一个并行队列，使用起来与我们自己创建的并行队列无本质差别。 不同队列创建获取方式： 123456789101112- (void)create &#123; // dispatch_queue_create 第一个参数是队列名字，一般用app的Bundle Identifier命名方式命名；第二个参数为NULL时表是串行队列 //串行队列 dispatch_queue_t serialQueue = dispatch_queue_create(&quot;q1.andyron.com&quot;, NULL); dispatch_queue_t serialQueue2 = dispatch_queue_create(&quot;q2.andyron.com&quot;, DISPATCH_QUEUE_SERIAL); //并行队列 dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;q3.andyron.com&quot;, DISPATCH_QUEUE_CONCURRENT); //全局并行队列 DISPATCH_QUEUE_PRIORITY_DEFAULT表示优先级 dispatch_queue_t globalQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //主队列获取 dispatch_queue_t mainQueue = dispatch_get_main_queue();&#125; 同步执行 异步执行 串行队列 当前线程，一个一个执行 其他线程，一个一个执行 并行队列 当前线程，一个一个执行 开很多线程，一起执行 4.3 下面👇以一个一个🌰来学习GCD，帮助搞清上面的概念 例子一:线程死锁（主队列 + 同步执行）1234567- (void)case1 &#123; NSLog(@&quot;A=====%@&quot;, [NSThread currentThread]); dispatch_sync(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;B=====%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;C=====%@&quot;, [NSThread currentThread]);&#125; 运行结果崩溃： 打印结果：1GCD(OC)[51511:6351422] A=====&lt;NSThread: 0x600000064340&gt;&#123;number = 1, name = main&#125; 解释：默认就一个主队列和一个主线程，因此case1函数这段任务就在主队列中同步执行，dispatch_sync...这段代码表示把B处任务加入主队列中，并且同步执行，这就出问题，B处任务要等主队列中同步执行之前的case1这段任务结束后执行，但B处任务在case1这段任务中，case1又要等B处任务执行完才能继续执行。case1任务要等B处完成才能继续，但case1又排在B处前面，这就尴尬了，￣□￣｜｜，因此崩溃了😖 例子二：主队列 + 异步执行1234567- (void)case2 &#123; NSLog(@&quot;A=====%@&quot;, [NSThread currentThread]); dispatch_async(dispatch_get_main_queue(), ^&#123; NSLog(@&quot;B=====%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;C=====%@&quot;, [NSThread currentThread]);&#125; 结果：123GCD(OC)[52567:6465354] A=====&lt;NSThread: 0x600000068d40&gt;&#123;number = 1, name = main&#125;GCD(OC)[52567:6465354] C=====&lt;NSThread: 0x600000068d40&gt;&#123;number = 1, name = main&#125;GCD(OC)[52567:6465354] B=====&lt;NSThread: 0x600000068d40&gt;&#123;number = 1, name = main&#125; 解释：任务都在主队列（串行），而且只要一个主线程（name都是main），B处任务由于是异步执行，等case2任务完成后执行。 例子三：串行队列 + 同步执行1234567891011121314// 串行队列 + 同步执行- (void)case3 &#123; dispatch_queue_t serialQueue = dispatch_queue_create(&quot;q2.andyron.com&quot;, DISPATCH_QUEUE_SERIAL); dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;1======%@&quot;, [NSThread currentThread]); &#125;); dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;2======%@&quot;, [NSThread currentThread]); &#125;); dispatch_sync(serialQueue, ^&#123; NSLog(@&quot;3======%@&quot;, [NSThread currentThread]); &#125;); NSLog(@&quot;4======%@&quot;, [NSThread currentThread]);&#125; 结果：1234GCD(OC)[53734:6582112] 1======&lt;NSThread: 0x604000261700&gt;&#123;number = 1, name = main&#125;GCD(OC)[53734:6582112] 2======&lt;NSThread: 0x604000261700&gt;&#123;number = 1, name = main&#125;GCD(OC)[53734:6582112] 3======&lt;NSThread: 0x604000261700&gt;&#123;number = 1, name = main&#125;GCD(OC)[53734:6582112] 4======&lt;NSThread: 0x604000261700&gt;&#123;number = 1, name = main&#125; 解释：🌰1中的主队列也是串行队列，但和这边不同，这边是新建了另一个串行队列，不会出现冲突，并且都在主线程中运行，这也说明了同步执行不具备创建新线程的能力。 列子四：串行队列 + 异步执行1234567891011121314// 串行队列 + 异步执行- (void)case4 &#123; dispatch_queue_t serialQueue = dispatch_queue_create(&quot;q2.andyron.com&quot;, DISPATCH_QUEUE_SERIAL); dispatch_async(serialQueue, ^&#123; NSLog(@&quot;1========%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(serialQueue, ^&#123; NSLog(@&quot;2========%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(serialQueue, ^&#123; NSLog(@&quot;3========%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;4========%@&quot;,[NSThread currentThread]);&#125; 打印结果：1234GCD(OC)[53970:6604711] 4========&lt;NSThread: 0x60000007c880&gt;&#123;number = 1, name = main&#125;GCD(OC)[53970:6604933] 1========&lt;NSThread: 0x600000460280&gt;&#123;number = 3, name = (null)&#125;GCD(OC)[53970:6604933] 2========&lt;NSThread: 0x600000460280&gt;&#123;number = 3, name = (null)&#125;GCD(OC)[53970:6604933] 3========&lt;NSThread: 0x600000460280&gt;&#123;number = 3, name = (null)&#125; 解释：现在打印了4，后打印了1，2，3，这是一部执行的结果，并且4在主线程，其它在子线程打印，这也说明了异步执行可以创建新线程。 列子五：并行队列 + 同步执行1234567891011121314151617/// 并行队列 + 同步执行- (void)case5 &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;q3.andyron.com&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_sync(concurrentQueue, ^&#123; NSLog(@&quot;1========%@&quot;,[NSThread currentThread]); //[self nslogCount:10000 number:1]; &#125;); dispatch_sync(concurrentQueue, ^&#123; NSLog(@&quot;2========%@&quot;,[NSThread currentThread]); //[self nslogCount:10000 number:2]; &#125;); dispatch_sync(concurrentQueue, ^&#123; NSLog(@&quot;3========%@&quot;,[NSThread currentThread]); //[self nslogCount:10000 number:3]; &#125;); NSLog(@&quot;4========%@&quot;,[NSThread currentThread]);&#125; 打印结果：1234GCD(OC)[54401:6646454] 1========&lt;NSThread: 0x600000260e80&gt;&#123;number = 1, name = main&#125;GCD(OC)[54401:6646454] 2========&lt;NSThread: 0x600000260e80&gt;&#123;number = 1, name = main&#125;GCD(OC)[54401:6646454] 3========&lt;NSThread: 0x600000260e80&gt;&#123;number = 1, name = main&#125;GCD(OC)[54401:6646454] 4========&lt;NSThread: 0x600000260e80&gt;&#123;number = 1, name = main&#125; 解释：都在主线程执行，由于只有一个线程，结果看上去是顺序执行。 列子六： 并行队列 + 异步执行1234567891011121314// 并行队列 + 异步执行- (void)case6 &#123; dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;q3.andyron.com&quot;, DISPATCH_QUEUE_CONCURRENT); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;1========%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;2========%@&quot;,[NSThread currentThread]); &#125;); dispatch_async(concurrentQueue, ^&#123; NSLog(@&quot;3========%@&quot;,[NSThread currentThread]); &#125;); NSLog(@&quot;4========%@&quot;,[NSThread currentThread]);&#125; 打印结果：1234GCD(OC)[54687:6675227] 2========&lt;NSThread: 0x600000466600&gt;&#123;number = 5, name = (null)&#125;GCD(OC)[54687:6675036] 4========&lt;NSThread: 0x604000078d00&gt;&#123;number = 1, name = main&#125;GCD(OC)[54687:6675226] 1========&lt;NSThread: 0x600000463fc0&gt;&#123;number = 4, name = (null)&#125;GCD(OC)[54687:6675229] 3========&lt;NSThread: 0x60400067d400&gt;&#123;number = 6, name = (null)&#125; 解释：除了打印4的是主线，其他又开启了三个线程来执行三个任务，当天开启几个线程是有CPU自己决定的，任务的执行是随机的。 4.4 GCD 重点 只要是串行队列，肯定要等上一个任务执行完成，才能开始下一个任务。但是并行队列当上一个任务开始执行后，下一个任务就可以开始执行。 同步+串行：未开辟新线程，串行执行任务；同步+并行：未开辟新线程，串行执行任务；异步+串行：新开辟一条线程，串行执行任务；异步+并行：开辟多条新线程，并行执行任务；在主线程中同步使用主队列执行任务，会造成死锁。 4.5 GCD其他相关方法 延迟执行方法： void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);指定时间后执行某个任务，dispatch_after函数指定的时间是指多长后将任务加到某个队列中，而不是具体执行时间，具体时间要看CPU执行时间了，可以看做是个大约延迟时间。 123456- (void)after &#123; dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(2.0 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^&#123; // 2.0秒后异步追加任务代码到主队列，并开始执行 NSLog(@&quot;after---%@&quot;,[NSThread currentThread]); // 打印当前线程 &#125;);&#125; dispatch_once：在生命周期内只执行一次。 123456- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSLog(@&quot;就一次%@&quot;,[NSThread currentThread]); &#125;);&#125; 不管点击多少次只有一次输出。 GCD的内容很丰富，还有很多函数，2016和2017的WWDC都有专门讲到GCD，想更近一步可以参考：Modernizing Grand Central Dispatch Usage，Concurrent Programming With GCD in Swift 3。 5 NSOperation 和 NSOperationQueue5.1 概念 NSOperation(操作) 和 NSOperationQueue（操作队列） 是苹果对GCD的封装 NSOperation 和 NSOperationQueue 分别相当于 GCD 的 任务 和 队列 NSOperation 只是一个抽象类，不能直接使用，使用其 2 个子类：NSInvocationOperation 和 NSBlockOperation 。 NSOperation的使用除了其现有的子类，还可以自定义子类。 操作队列通过设置最大并发操作数（maxConcurrentOperationCount）来控制并发、串行。 NSOperationQueue 为我们提供了两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。 NSOperation 需要配合 NSOperationQueue 来使用。否则，NSOperation 单独使用时系统默认同步执行操作，配合 NSOperationQueue 我们能更好的实现异步执行。 5. 2 NSOperation 实现多线程的步骤 创建操作：先将需要执行的操作封装到一个 NSOperation 对象中。 创建队列：创建 NSOperationQueue 对象。 将操作加入到队列中：将 NSOperation 对象添加到NSOperationQueue 对象中。 之后，系统就会自动将 NSOperationQueue 中的 NSOperation 取出来，在新线程中执行操作。 5.3 使用NSOperation的子类NSInvocationOperation12NSInvocationOperation *operation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(run) object:nil];[operation start]; 在没有使用NSOperationQueue时，NSInvocationOperation会在当前线程（主线程或其他线程）内运行。 5.4 使用NSOperation的子类NSBlockOperation1234NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;%@&quot;, [NSThread currentThread]); &#125;];[operation start]; 结果： 12NSOperation(OC)[97406:5880178] 1---&lt;NSThread: 0x60400006e700&gt;&#123;number = 1, name = main&#125;NSOperation(OC)[97406:5880178] 1---&lt;NSThread: 0x60400006e700&gt;&#123;number = 1, name = main&#125; 在没有使用NSOperationQueue时，NSBlockOperation也会在当前线程（主线程或其他线程）内运行。 另外，NSBlockOperation还提供了一个方法 addExecutionBlock:，用来添加额外的操作： 1234567891011121314151617181920212223242526272829// 1.创建 NSBlockOperation 对象NSBlockOperation *op = [NSBlockOperation blockOperationWithBlock:^&#123; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程&#125;];// 2.添加额外的操作[op addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;];[op addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;];[op addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;];[op addExecutionBlock:^&#123; [NSThread sleepForTimeInterval:1]; // 模拟耗时操作 NSLog(@&quot;5---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125;];// 3.调用 start 方法开始执行操作[op start]; 某一次的运行结果： 12345NSOperation(OC)[97709:5888750] 1---&lt;NSThread: 0x600000469740&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[97709:5888750] 5---&lt;NSThread: 0x600000469740&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[97709:5888748] 3---&lt;NSThread: 0x600000469e40&gt;&#123;number = 4, name = (null)&#125;NSOperation(OC)[97709:5888498] 4---&lt;NSThread: 0x60400007a600&gt;&#123;number = 1, name = main&#125;NSOperation(OC)[97709:5888758] 2---&lt;NSThread: 0x604000463480&gt;&#123;number = 5, name = (null)&#125; addExecutionBlock:添加的操作和之前blockOperationWithBlock添加的操作是否在主线程或者是否开多线程，是由系统决定，它们的地位是相同的，所以每一次执行的结果可能不同。 5.5 NSOperation的自定义子类除了上面两个子类外，还可以通过重写main方法来自定义子类。12345678910111213#import &quot;AROperation.h&quot;@implementation AROperation- (void)main &#123; if (!self.isCancelled) &#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; NSLog(@&quot;自定义Operation---%@&quot;, [NSThread currentThread]); &#125; &#125;&#125;@end 使用：12AROperation *op = [[AROperation alloc] init];[op start]; 5.6 NSOperationQueue上面几种情况都是没有操作队列，一般只在主线程运行。而使用操作队列就可以实现多线程了。操作队列分两种： 主队列 : 凡是添加到主队列中的操作，都会放到主线程中执行 自定义队列: 操作自动放到子线程中执行，同时包含了：串行、并发功能。 5.6.1 创建队列12345// 主队列获取方法NSOperationQueue *queue = [NSOperationQueue mainQueue];// 自定义队列创建方法NSOperationQueue *queue = [[NSOperationQueue alloc] init]; 5.6.2 添加操作到队列中两种不同的添加方法： - (void)addOperation:(NSOperation *)op;1234567891011121314151617181920212223242526272829303132333435- (void)addOperationToQueue &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 // 使用 NSInvocationOperation 创建操作1 NSInvocationOperation *op1 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task1) object:nil]; // 使用 NSInvocationOperation 创建操作2 NSInvocationOperation *op2 = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task2) object:nil]; // 使用 NSBlockOperation 创建操作3 NSBlockOperation *op3 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [op3 addExecutionBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.使用 addOperation: 添加所有操作到队列中 [queue addOperation:op1]; // [op1 start] [queue addOperation:op2]; // [op2 start] [queue addOperation:op3]; // [op3 start]&#125;- (void) task1 &#123; NSLog(@&quot;1---%@&quot;, [NSThread currentThread]);&#125;- (void) task2 &#123; NSLog(@&quot;2---%@&quot;, [NSThread currentThread]);&#125; 某一次的运行结果：123456NSOperation(OC)[7557:6218702] 2---&lt;NSThread: 0x60400027f900&gt;&#123;number = 4, name = (null)&#125;NSOperation(OC)[7557:6218699] 1---&lt;NSThread: 0x600000461a00&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[7557:6218701] 4---&lt;NSThread: 0x6040004606c0&gt;&#123;number = 5, name = (null)&#125;NSOperation(OC)[7557:6218700] 3---&lt;NSThread: 0x604000460d40&gt;&#123;number = 6, name = (null)&#125;NSOperation(OC)[7557:6218700] 3---&lt;NSThread: 0x604000460d40&gt;&#123;number = 6, name = (null)&#125;NSOperation(OC)[7557:6218701] 4---&lt;NSThread: 0x6040004606c0&gt;&#123;number = 5, name = (null)&#125; 并发运行，执行次序不确定。 - (void)addOperationWithBlock:(void (^)(void))block; 不需要先创建操作，直接添加block123456789101112131415161718192021222324- (void)addOperationWithBlockToQueue &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.使用 addOperationWithBlock: 添加操作到队列中 [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;];&#125; 某一次的运行结果：123456NSOperation(OC)[7772:6229770] 2---&lt;NSThread: 0x600000277640&gt;&#123;number = 5, name = (null)&#125;NSOperation(OC)[7772:6229772] 1---&lt;NSThread: 0x60400026bfc0&gt;&#123;number = 4, name = (null)&#125;NSOperation(OC)[7772:6229780] 3---&lt;NSThread: 0x6040002686c0&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[7772:6229770] 2---&lt;NSThread: 0x600000277640&gt;&#123;number = 5, name = (null)&#125;NSOperation(OC)[7772:6229780] 3---&lt;NSThread: 0x6040002686c0&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[7772:6229772] 1---&lt;NSThread: 0x60400026bfc0&gt;&#123;number = 4, name = (null)&#125; 5.6.3 maxConcurrentOperationCountNSOperationQueue 提供一个maxConcurrentOperationCount（最大并发操作数）属性来控制串行还是并发。maxConcurrentOperationCount 控制的不是并发线程的数量，而是一个队列中同时能并发执行的最大操作数。而且一个操作也并非只能在一个线程中运行。maxConcurrentOperationCount默认情况下为-1，表示不进行限制。 1234567891011121314151617181920212223242526272829303132333435- (void)setMaxConcurrentOperationCount &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.设置最大并发操作数 queue.maxConcurrentOperationCount = 1; // 串行队列 // queue.maxConcurrentOperationCount = 2; // 并发队列 // queue.maxConcurrentOperationCount = 8; // 并发队列 // 3.添加操作 [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;3---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; [queue addOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;4---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;];&#125; 当最大并发操作数为1时，也就是串行执行时，控制台中返回的结果顺序是固定的。而大于1时，也就是并发执行，每一次执行的顺序就可能不同（控制台中返回的额结果顺序可能不同）。当然开启的线程数量是有系统决定的。 5.7 NSOperation之间的依赖并行时，各个的操作的执行顺序是有系统决定，程序员不能直接控制。但是NSOperation提高了依赖，来解决这个问题。相关方法和属性： - (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 - (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 1234567891011121314151617181920212223- (void)addDependency &#123; // 1.创建队列 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; // 2.创建操作 NSBlockOperation *op1 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;1---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; NSBlockOperation *op2 = [NSBlockOperation blockOperationWithBlock:^&#123; for (int i = 0; i &lt; 2; i++) &#123; [NSThread sleepForTimeInterval:2]; // 模拟耗时操作 NSLog(@&quot;2---%@&quot;, [NSThread currentThread]); // 打印当前线程 &#125; &#125;]; // 3.添加依赖 [op2 addDependency:op1]; // 让op2 依赖于 op1，则先执行op1，再执行op2 // 4.添加操作到队列中 [queue addOperation:op1]; [queue addOperation:op2];&#125; 运行结果是固定的：1234NSOperation(OC)[8977:6302811] 1---&lt;NSThread: 0x604000277f80&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[8977:6302811] 1---&lt;NSThread: 0x604000277f80&gt;&#123;number = 3, name = (null)&#125;NSOperation(OC)[8977:6302810] 2---&lt;NSThread: 0x604000274240&gt;&#123;number = 4, name = (null)&#125;NSOperation(OC)[8977:6302810] 2---&lt;NSThread: 0x604000274240&gt;&#123;number = 4, name = (null)&#125; 注意：不能添加相互依赖，会死锁，比如 A依赖B，B依赖A。可以使用 removeDependency 来解除依赖关系。可以在不同的队列之间依赖，反正就是这个依赖是添加到任务身上的，和队列没关系。 5.8 NSOperation 常用属性和方法 取消操作方法- (void)cancel; 实质是标记 isCancelled 状态。 判断操作状态方法 - (BOOL)isFinished; 判断操作是否已经结束。 - (BOOL)isCancelled; 判断操作是否已经标记为取消。 - (BOOL)isExecuting; 判断操作是否正在在运行。 - (BOOL)isReady; 判断操作是否处于准备就绪状态，这个值和操作的依赖关系相关。 操作同步 - (void)waitUntilFinished; 阻塞当前线程，直到该操作结束。可用于线程执行顺序的同步。 - (void)setCompletionBlock:(void (^)(void))block; completionBlock 会在当前操作执行完毕时执行 completionBlock。 - (void)addDependency:(NSOperation *)op; 添加依赖，使当前操作依赖于操作 op 的完成。 - (void)removeDependency:(NSOperation *)op; 移除依赖，取消当前操作对操作 op 的依赖。 @property (readonly, copy) NSArray&lt;NSOperation *&gt; *dependencies; 在当前操作开始执行之前完成执行的所有操作对象数组。 5.9 NSOperationQueue 常用属性和方法 取消/暂停/恢复操作 - (void)cancelAllOperations; 可以取消队列的所有操作。 - (BOOL)isSuspended; 判断队列是否处于暂停状态。 YES 为暂停状态，NO 为恢复状态。 - (void)setSuspended:(BOOL)b; 可设置操作的暂停和恢复，YES 代表暂停队列，NO 代表恢复队列。 操作同步 - (void)waitUntilAllOperationsAreFinished; 阻塞当前线程，直到队列中的操作全部执行完毕。 添加/获取操作 - (void)addOperationWithBlock:(void (^)(void))block; 向队列中添加一个 NSBlockOperation 类型操作对象。 - (void)addOperations:(NSArray *)ops waitUntilFinished:(BOOL)wait; 向队列中添加操作数组，wait 标志是否阻塞当前线程直到所有操作结束 - (NSArray *)operations; 当前在队列中的操作数组（某个操作执行结束后会自动从这个数组清除）。 - (NSUInteger)operationCount; 当前队列中的操作数。 获取队列 + (id)currentQueue; 获取当前队列，如果当前线程不是在 NSOperationQueue 上运行则返回 nil。 + (id)mainQueue; 获取主队列。 6 后记虽然总结了很多，但还有很多内容没有涉及和深入。由于个人能力有限，时间紧凑（实际我已经花了很多时间😒🤦‍♀️🤦‍♀️），文中难免有错误，希望小伙伴批评指正。 示例代码：andyRon/iOS-Multithreading 参考：关于iOS多线程，我说，你听，没准你就懂了！谈iOS多线程(NSThread、NSOperation、GCD)编程iOS多线程：『GCD』详尽总结iOS多线程：『pthread、NSThread』详尽总结iOS多线程：『NSOperation、NSOperationQueue』详尽总结关于iOS多线程，你看我就够了Grand Central Dispatch (GCD) and Dispatch Queues in Swift 3WWDC-2017-Modernizing Grand Central Dispatch Usage]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Multithreading</tag>
        <tag>GCD</tag>
        <tag>NSThread</tag>
        <tag>NSOperation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC中的键/值编码(KVC)]]></title>
    <url>%2F2018%2Fios-oc-kvc-begin.html</url>
    <content type="text"><![CDATA[1. KVC 的定义键/值编码(Key-value coding，KVC) 可以允许开发者通过Key名访问对象的属性或给对象的属性赋值, 而不需要调用明确的存取方法，并有一组api供开发者使用，像操作字典一样操作对象属性/成员变量/关联对象。这样就可以在 运行时动态地访问和修改 对象的属性。而不是在编译时确定。这种机制不属于Objective-C语言的特性，而是Cocoa提供的一种特性。 通过定义一个NSObject的类别NSKeyValueCoding来实现KVC功能。因此所有继承了NSObject的类都支持KVC。NSKeyValueCoding的四个重要方法：1234- (nullable id)valueForKey:(NSString *)key; //直接通过Key来取值- (void)setValue:(nullable id)value forKey:(NSString *)key; //通过Key来设值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来取值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; //通过KeyPath来设值 NSKeyValueCoding还有其它许多方法，我列举一些，详细可查看官方文档 NSKeyValueCoding：1234567891011121314151617181920+ (BOOL)accessInstanceVariablesDirectly;//默认返回YES，表示如果没有找到set&lt;Key&gt;方法的话，会按照_&lt;key&gt;，_isKey，key，isKey的顺序搜索成员，设置成NO就不这样搜索- (BOOL)validateValue:(inout id __nullable * __nonnull)ioValue forKey:(NSString *)inKey error:(out NSError **)outError;//KVC提供属性值正确性验证的API，它可以用来检查set的值是否正确、为不正确的值做一个替换值或者拒绝设置新值并返回错误原因。- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;//这是集合操作的API，里面还有一系列这样的API，如果属性是一个NSMutableArray，那么可以用这个方法来返回。- (nullable id)valueForUndefinedKey:(NSString *)key;//在取值时，如果Key不存在，且KVC无法搜索到任何和Key有关的字段或者属性(或者+ (BOOL)accessInstanceVariablesDirectly;方法返回NO时)，则会调用这个方法，默认是抛出 NSUndefinedKeyException异常。- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;//和上一个方法相对应，这个方法是用来设值。- (void)setNilValueForKey:(NSString *)key;//如果你在SetValue方法时面给Value传nil，则会调用这个方法- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;//输入一组key,返回该组key对应的Value，再转成字典返回，用于将Model转到字典。 2 KVC是如何寻找Key2.1 设置值当调用setValue:forKey:方法来设置属性值时，执行机制如下： 先调用setter方法set&lt;Key&gt;：属性值 如果没有找到setter方法，KVC就会检测+ (BOOL)accessInstanceVariablesDirectly的返回值，是默认值YES,就按照_&lt;key&gt;，_isKey，key，isKey的顺序一一查找。只要存在_&lt;key&gt;，无论该变量是在类接口处定义，还是在类实现处定义，也不管是什么访问修饰符，KVC都可以对其访问。 如果没有setter方法，也没找到_&lt;key&gt;，_isKey，key，isKey中的任何一个，KVC就会执行方法- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key;，默认是抛出异常。 代码示例（andyRon/KVCDemo1）：1234567891011121314151617181920212223242526272829303132@interface Dog : NSObject@end@implementation Dog&#123; NSString* toSetName; NSString* isName; NSString* name; NSString* _name; NSString* _isName;&#125;+(BOOL)accessInstanceVariablesDirectly&#123; return NO;&#125;-(id)valueForUndefinedKey:(NSString *)key&#123; NSLog(@&quot;取值出现异常，key为：%@的变量不存在&quot;,key); return nil;&#125;-(void)setValue:(id)value forUndefinedKey:(NSString *)key&#123; NSLog(@&quot;设置值出现异常，key为：%@的变量不存在&quot;,key);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; // insert code here... Dog* dog = [Dog new]; [dog setValue:@&quot;newNameValue&quot; forKey:@&quot;name&quot;]; NSString* toSetName = [dog valueForKey:@&quot;toSetName&quot;]; NSLog(@&quot;%@&quot;,toSetName); &#125; return 0;&#125; 打印结果：123KVCDemo1[5107:12399654] 设置值出现异常，key为：name的变量不存在KVCDemo1[5107:12399654] 取值出现异常，key为：toSetName的变量不存在KVCDemo1[5107:12399654] (null) 重写+(BOOL)accessInstanceVariablesDirectly方法让其返回NO后,KVC机制就不会实现，就直接调用- (nullable id)valueForUndefinedKey:(NSString *)key;或- (void)setValue:(nullable id)value forUndefinedKey:(NSString *)key; 稍微修改以下代码，看示例（andyRon/KVCDemo2）：123456789101112131415161718192021222324252627282930313233343536@interface Dog : NSObject@end@implementation Dog&#123; NSString* toSetName; NSString* isName; NSString* _name; NSString* _isName;&#125; -(void)setName:(NSString*)name&#123; toSetName = name; &#125;-(NSString*)getName&#123; return toSetName;&#125;+(BOOL)accessInstanceVariablesDirectly&#123; return NO;&#125;-(id)valueForUndefinedKey:(NSString *)key&#123; NSLog(@&quot;取值出现异常，key为：%@的变量不存在&quot;,key); return nil;&#125;-(void)setValue:(id)value forUndefinedKey:(NSString *)key&#123; NSLog(@&quot;设置值出现异常，key为：%@的变量不存在&quot;,key);&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Dog* dog = [Dog new]; [dog setValue:@&quot;newNameValue&quot; forKey:@&quot;name&quot;]; NSString* name = [dog valueForKey:@&quot;name&quot;]; NSLog(@&quot;%@&quot;,name); &#125; return 0;&#125; 打印结果：1KVCDemo2[5323:12426199] newNameValue 虽然+(BOOL)accessInstanceVariablesDirectly方法结果还是NO，但因为有了setter和getter方法就不会出现异常了。当+(BOOL)accessInstanceVariablesDirectly结果为YES，的🌰代码我就不列出了，可查看andyRon/KVCDemo3。 2.2 KVC取值对于取值方法valueForKey:, KVC对key的查询方式不同于setValue:forKey:,如下： 首先按get&lt;Key&gt;,&lt;key&gt;,is&lt;Key&gt;的顺序方法查找getter方法，找到的话会直接调用。如果是BOOL或者Int等值类型， 会将其包装成一个NSNumber对象。 如果getter没有找到，KVC则会查找countOf&lt;Key&gt;,objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes格式的方法。如果有一个被找到，那么就会返回一个可以响应NSArray所有方法的代理集合(它是NSKeyValueArray，是NSArray的子类)，调用这个代理集合的方法，或者说给这个代理集合发送属于NSArray的方法，就会以countOf&lt;Key&gt;,objectIn&lt;Key&gt;AtIndex或&lt;Key&gt;AtIndexes这几个方法组合的形式调用。还有一个可选的get&lt;Key&gt;:range:方法。所以你想重新定义KVC的一些功能，你可以添加这些方法，需要注意的是你的方法名要符合KVC的标准命名方法，包括方法签名。 如果上面的方法没有找到，那么会同时查找countOf&lt;Key&gt;，enumeratorOf&lt;Key&gt;,memberOf&lt;Key&gt;格式的方法。如果这三个方法都找到，那么就返回一个可以响应NSSet所的方法的代理集合，和上面一样，给这个代理集合发NSSet的消息，就会以countOf&lt;Key&gt;，enumeratorOf&lt;Key&gt;,memberOf&lt;Key&gt;组合的形式调用。 在类自定义了KVC的实现，并且实现了上面的方法，就可以将返回的对象当数组(NSArray)用了 如果还没有找到，再检查类方法+ (BOOL)accessInstanceVariablesDirectly,如果返回YES(默认行为)，那么和先前的设值一样，会按_,_is,,is的顺序搜索成员变量名，这里不推荐这么做，因为这样直接访问实例变量破坏了封装性，使代码更脆弱。如果重写了类方法+ (BOOL)accessInstanceVariablesDirectly返回NO的话，那么会直接调用valueForUndefinedKey: 示例代码（andyRon/KVCDemo4）：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@interface TwoTimesArray : NSObject-(void)incrementCount;-(NSUInteger)countOfNumbers;-(id)objectInNumbersAtIndex:(NSUInteger)index;@end@interface TwoTimesArray()@property (nonatomic,readwrite,assign) NSUInteger count;@property (nonatomic,copy) NSString* arrName;@end@implementation TwoTimesArray-(void)incrementCount&#123; self.count ++;&#125;-(NSUInteger)countOfNumbers&#123; return self.count;&#125;-(id)objectInNumbersAtIndex:(NSUInteger)index&#123; //当key使用numbers时，KVC会找到这两个方法。 return @(index * 2);&#125;-(NSInteger)getNum&#123; //第一个,自己一个一个注释试 return 10;&#125;-(NSInteger)num&#123; //第二个 return 11;&#125;-(NSInteger)isNum&#123; //第三个 return 12;&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; TwoTimesArray* arr = [TwoTimesArray new]; NSNumber* num = [arr valueForKey:@&quot;num&quot;]; NSLog(@&quot;%@&quot;,num); id ar = [arr valueForKey:@&quot;numbers&quot;]; NSLog(@&quot;%@&quot;,NSStringFromClass([ar class])); NSLog(@&quot;0:%@ 1:%@ 2:%@ 3:%@&quot;,ar[0],ar[1],ar[2],ar[3]); [arr incrementCount]; //count加1 NSLog(@&quot;%lu&quot;,(unsigned long)[ar count]); //打印出1 [arr incrementCount]; //count再加1 NSLog(@&quot;%lu&quot;,(unsigned long)[ar count]); //打印出2 [arr setValue:@&quot;newName&quot; forKey:@&quot;arrName&quot;]; NSString* name = [arr valueForKey:@&quot;arrName&quot;]; NSLog(@&quot;%@&quot;,name); &#125; return 0;&#125; 结果：123456KVCDemo4[25723:3947658] 10KVCDemo4[25723:3947658] NSKeyValueArrayKVCDemo4[25723:3947658] 0:0 1:2 2:4 3:6KVCDemo4[25723:3947658] 1KVCDemo4[25723:3947658] 2KVCDemo4[25723:3947658] newName 3 KVC中使用keyPath一个类的属性可能是另外一个类，可以通过keyPath方式获取或设置这种多层中属性，这种解决方式也是通过NSKeyValueCoding中的方法来实现的。1234//通过KeyPath来取值- (nullable id)valueForKeyPath:(NSString *)keyPath; //通过KeyPath来设值- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath; 来看看具体代码例子（KVCKeyPathDemo）：123456789101112131415161718192021222324252627282930313233343536373839404142434445@interface Address : NSObject@end@interface Address()@property (nonatomic,copy)NSString* country;@end@implementation Address- (id)valueForUndefinedKey:(NSString *)key &#123; return key;&#125;@end@interface People : NSObject@end@interface People()@property (nonatomic,copy) NSString* name;@property (nonatomic,strong) Address* address;@property (nonatomic,assign) NSInteger age;@end@implementation People@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; People* people1 = [People new]; Address* add = [Address new]; add.country = @&quot;China&quot;; people1.address = add; NSString* country1 = people1.address.country; NSString * country2 = [people1 valueForKeyPath:@&quot;address.country&quot;]; NSLog(@&quot;country1:%@ country2:%@&quot;,country1,country2); [people1 setValue:@&quot;USA&quot; forKeyPath:@&quot;address.country&quot;]; country1 = people1.address.country; country2 = [people1 valueForKeyPath:@&quot;address.country&quot;]; NSString* city = [people1 valueForKeyPath:@&quot;address.city&quot;]; NSLog(@&quot;country1:%@ country2:%@ city:%@&quot;,country1, country2, city); &#125; return 0;&#125; 打印结果：12KVCKeyPathDemo[6330:12568821] country1:China country2:ChinaKVCKeyPathDemo[6330:12568821] country1:USA country2:USA city:city keyPath中，key之间用.分隔，当keyPath出现错误时，就会调用valueForUndefinedKey:key方法。 4 KVC的异常处理两种情况，一种是key或keyPath错误，上面也都提到过，就是调用valueForUndefinedKey:key方法。 另一种情况是在使用setValue:forKey:方法时值设置为nil了，这是不被允许的，会调用setNilValueForKey:方法。1234567@implementation People-(void)setNilValueForKey:(NSString *)key&#123; NSLog(@&quot;不能将%@设成nil&quot;,key);&#125;@end 1[people setValue:nil forKey:@&quot;age&quot;]; 5 KVC处理非对象和自定义对象valueForKey:总是返回一个id对象，如果原本的变量类型是值类型或者结构体，返回值会封装成NSNumber或者NSValue对象。这两个类会处理从数字，布尔值到指针和结构体任何类型。然后开以者需要手动转换成原来的类型。尽管valueForKey：会自动将值类型封装成对象，但是setValue:forKey:却不行。你必须手动将值类型转换成NSNumber或者NSValue类型，才能传递过去。 对于自定义对象，KVC也会正确地设值和取值。因为传递进去和取出来的都是id类型，所以需要开发者自己担保类型的正确性，运行时Objective-C在发送消息的会检查类型，如果错误会直接抛出异常。 6 KVC和容器类对象的属性可以是一对一的，也可以是一对多的。一对多的属性要么是有序的(数组)，要么是无序的(集合)。 不可变的有序容器属性(NSArray)和无序容器属性(NSSet)一般可以使用valueForKey:来获取。但也可以利用更灵活的方法来管理，比如：- (NSMutableArray *)mutableArrayValueForKey:(NSString *)key;实例代码（KVCDemo6）:12345678910111213141516171819202122232425262728293031323334353637383940@interface Demo : NSObject@property (nonatomic,strong) NSMutableArray* arr;@end@implementation Demo-(id)init&#123; if (self == [super init])&#123; _arr = [NSMutableArray new]; [self addObserver:self forKeyPath:@&quot;arr&quot; options:NSKeyValueObservingOptionNew|NSKeyValueObservingOptionOld context:nil]; &#125; return self;&#125;// Informs the observing object when the value at the specified key path relative to the observed object has changed.-(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSString *,id&gt; *)change context:(void *)context&#123; NSLog(@&quot;%@&quot;, self.arr);&#125;-(void)dealloc&#123; [self removeObserver:self forKeyPath:@&quot;arr&quot;]; //一定要在dealloc里面移除观察&#125;-(void)addItem&#123; [_arr addObject:@&quot;addItem&quot;];&#125;-(void)addItemObserver&#123; [[self mutableArrayValueForKey:@&quot;arr&quot;] addObject:@&quot;addItemObserver&quot;];&#125;-(void)removeItemObserver&#123; [[self mutableArrayValueForKey:@&quot;arr&quot;] removeLastObject];&#125;@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Demo* d = [Demo new]; [d addItem]; [d addItemObserver]; [d removeItemObserver]; &#125; return 0;&#125; 结果：1234567KVCDemo6[11393:3534594] ( addItem, addItemObserver)KVCDemo6[11393:3534594] ( addItem) 当只是普通地调用[_arr addObject:@&quot;addItem&quot;];时，Observer并不会回调，只有[[self mutableArrayValueForKey:@&quot;arr&quot;] addObject:@&quot;addItemObserver&quot;];这样写时才能正确地触发KVO。 对于无序容器属性(NSSet)有对应的方法：- (NSMutableSet *)mutableSetValueForKey:(NSString *)key; 另外还有对应的keyPath方法：12- (NSMutableArray *)mutableArrayValueForKeyPath:(NSString *)keyPath;- (NSMutableSet *)mutableSetValueForKeyPath:(NSString *)keyPath; 7 KVC和字典KVC与字典相关的方法：12- (NSDictionary&lt;NSString *, id&gt; *)dictionaryWithValuesForKeys:(NSArray&lt;NSString *&gt; *)keys;- (void)setValuesForKeysWithDictionary:(NSDictionary&lt;NSString *, id&gt; *)keyedValues; 示例代码（KVCDemo7）：123456789101112131415161718192021222324252627282930313233343536@interface Address : NSObject@end@interface Address()@property (nonatomic,copy)NSString* country;@property (nonatomic,copy)NSString* province;@property (nonatomic,copy)NSString* city;@property (nonatomic,copy)NSString* district;@end@implementation Address@endint main(int argc, const char * argv[]) &#123; @autoreleasepool &#123; Address *address = [Address new]; address.country = @&quot;中国&quot;; address.province = @&quot;上海&quot;; address.city = @&quot;上海&quot;; address.district = @&quot;浦东&quot;; NSArray* arr = @[@&quot;country&quot;,@&quot;province&quot;,@&quot;district&quot;]; NSDictionary* dict = [address dictionaryWithValuesForKeys:arr]; //把对应key所有的属性全部取出来 NSLog(@&quot;%@&quot;,dict); NSDictionary* modifyDict = @&#123;@&quot;country&quot;:@&quot;美国&quot;,@&quot;province&quot;:@&quot;加州&quot;,@&quot;city&quot;:@&quot;旧金山&quot;&#125;; [address setValuesForKeysWithDictionary:modifyDict]; //修改的属性 NSLog(@&quot;country:%@ province:%@ city:%@&quot;,address.country, address.province, address.city); &#125; return 0;&#125; 结果：1234567KVCDemo7[14135:3606256] &#123; country = &quot;\U4e2d\U56fd&quot;; district = &quot;\U6d66\U4e1c&quot;; province = &quot;\U4e0a\U6d77&quot;;&#125;KVCDemo7[14135:3606256] country:美国 province:加州 city:旧金山Program ended with exit code: 0 8 KVC的应用场景 动态取值和设值 用KVC来访问和修改私有变量 Model和字典转换 修改一些控件的内部属性有的时候可以通过KVC修改一些苹果官方没有公开的属性，比如UITextField中的placeHolderText。这个时候用playground能很方便的演示（KVCDemo8）： 没有公开的属性可通过runtime的方式获取(KVCDemo9):12345678910import UIKitvar count: UInt32 = 0let ivars = class_copyIvarList(UITextField.self, &amp;count)for i in 0 ..&lt; count &#123; let ivar = ivars![Int(i)] let name = ivar_getName(ivar) print(String(cString: name!))&#125;free(ivars) 操作集合 用KVC实现高阶消息传递 用KVC中的函数操作集合 最后参照前辈的文章 iOS开发技巧系列—详解KVC(我告诉你KVC的一切)学习KVC，动手写了各种简单的示例加深理解，由于目前KVC实际项目中运用的还不是很多，有很多地方理解的还不够透彻。 示例代码： andyRon/KVCDemo 参考：iOS开发技巧系列—详解KVC(我告诉你KVC的一切)Key-Value Coding Programming Guide - Apple Developer]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>OC</tag>
        <tag>KVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OS数据持久化小结]]></title>
    <url>%2F2018%2Fios-persistdata.html</url>
    <content type="text"><![CDATA[持久化就是把数据保存在硬盘上而不是内存里，程序重启后数据不会消失。iOS中数据持久化方法有：plist文件（属性列表）、UserDefaults、NSKeyedArchiver（归档）、SQLite3、CoreData等，另外还有FMDB（用OC封装的SQLite库）、realm（代替SQLite3和CoreData新的数据库）。 plist某些特定的数据类型，可以通过XML形式存储成plist文件。这些数据类型都有write(ToFile:)方法，包括：12345678910NSArray;NSMutableArray;NSDictionary;NSMutableDictionary;NSData;NSMutableData;NSString;NSMutableString;NSNumber;NSDate; 示例代码：1234567891011121314// 获得路径let fileManager = FileManager.defaultlet path = fileManager.urls(for: .documentDirectory, in: .userDomainMask).firstlet fileName = path?.appendingPathComponent(&quot;test.plist&quot;)// 存储。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写true。let arr: NSArray = [123, 34]try? arr.write(toFile: (fileName?.path)!, atomically: true)// 读取let res = NSArray(contentsOfFile: (fileName?.path)!)print((fileName?.path)!)print(res) UserDefaults123456789101112131415// 获得UserDefaults文件let userDefaults = UserDefaults.standard// 向文件中写入内容userDefaults.set(&quot;Andy&quot;, forKey: &quot;name&quot;)userDefaults.set(&quot;male&quot;, forKey: &quot;sex&quot;)userDefaults.set(100, forKey: &quot;age&quot;)// 立即保存userDefaults.synchronize()// 读取文件let name = userDefaults.object(forKey: &quot;name&quot;)let sex = userDefaults.object(forKey: &quot;sex&quot;)let age = userDefaults.object(forKey: &quot;age&quot;)print(name, sex, age) 如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法. UserDefaults适合存储少量的本地数据，比如要保存一个登陆界面的数据，用户名、密码之类的。 相对于plist文件，UserDefaults保存数据方便，不需要创建文件，读取文件。 UserDefaults保存的数据也是plist类型文件，在目录Library/Preferences/里。 NSKeyedArchiver（归档）遵循了NSCoding协议的对象都可以通过NSKeyedArchiver实现序列化 实现NSCoding协议的两个方法 1234567891011121314151617//解档- (id)initWithCoder:(NSCoder *)aDecoder &#123; if ([super init]) &#123; self.name = [aDecoder decodeObjectForKey:@&quot;name&quot;]; self.sex = [aDecoder decodeObjectForKey:@&quot;sex&quot;]; self.age = [aDecoder decodeIntegerForKey:@&quot;age&quot;]; &#125; return self;&#125;//归档- (void)encodeWithCoder:(NSCoder *)aCoder &#123; [aCoder encodeObject:self.name forKey:@&quot;name&quot;]; [aCoder encodeObject:self.sex forKey:@&quot;sex&quot;]; [aCoder encodeInteger:self.age forKey:@&quot;age&quot;];&#125; 归档后的对象存储和读取 1234567891011121314151617181920- (void)save &#123; NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;]; Person *person = [[Person alloc] init]; person.sex = @&quot;male&quot;; person.name = @&quot;Andy&quot;; person.age = 100; [NSKeyedArchiver archiveRootObject:person toFile:file];&#125;- (void)get &#123; NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.data&quot;]; Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file]; if (person) &#123; NSLog(@&quot;name: %@, sex: %@, age: %ld&quot;, person.name, person.sex, (long)person.age); &#125;&#125; SQLite3 打开数据库并创建一个表 123456789101112131415161718192021222324252627/** * 打开数据库并创建一个表 */- (void)openDatabase &#123; //1.设置文件名 NSString *filename = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@&quot;person.db&quot;]; //2.打开数据库文件，如果没有会自动创建一个文件 NSInteger result = sqlite3_open(filename.UTF8String, &amp;_sqlite3); if (result == SQLITE_OK) &#123; NSLog(@&quot;打开数据库成功！&quot;); //3.创建一个数据库表 char *errmsg = NULL; sqlite3_exec(_sqlite3, &quot;CREATE TABLE IF NOT EXISTS t_person(id integer primary key autoincrement, name text, age integer)&quot;, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;错误：%s&quot;, errmsg); &#125; else &#123; NSLog(@&quot;创表成功！&quot;); &#125; &#125; else &#123; NSLog(@&quot;打开数据库失败！&quot;); &#125;&#125; 插入数据 12345678910111213141516171819202122/** * 往表中插入1000条数据 */- (void)insertData &#123; NSString *nameStr; NSInteger age; for (NSInteger i = 0; i &lt; 1000; i++) &#123; nameStr = [NSString stringWithFormat:@&quot;andy-%d&quot;, arc4random_uniform(10000)]; age = arc4random_uniform(80) + 20; NSString *sql = [NSString stringWithFormat:@&quot;INSERT INTO t_person (name, age) VALUES(&apos;%@&apos;, &apos;%ld&apos;)&quot;, nameStr, age]; char *errmsg = NULL; sqlite3_exec(_sqlite3, sql.UTF8String, NULL, NULL, &amp;errmsg); if (errmsg) &#123; NSLog(@&quot;错误：%s&quot;, errmsg); &#125; &#125; NSLog(@&quot;插入完毕！&quot;);&#125; 读取数据 123456789101112131415161718192021/** * 从表中读取数据 */- (void)readData &#123; NSMutableArray *mArray = [NSMutableArray arrayWithCapacity:1000]; char *sql = &quot;select name, age from t_person;&quot;; sqlite3_stmt *stmt; NSInteger result = sqlite3_prepare_v2(_sqlite3, sql, -1, &amp;stmt, NULL); if (result == SQLITE_OK) &#123; while (sqlite3_step(stmt) == SQLITE_ROW) &#123; char *name = (char *)sqlite3_column_text(stmt, 0); NSInteger age = sqlite3_column_int(stmt, 1); NSLog(@&quot;name: %s, age: %d&quot;, name, age); &#125; &#125; sqlite3_finalize(stmt);&#125; CoreData之前的笔记：开始用Swift开发iOS 10 - 17 使用Core Data 代码：LearniOSByProject/115-PersistData 参考： 我要永远地记住你！（iOS中几种数据持久化方案）]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识iOS事情处理机制]]></title>
    <url>%2F2018%2Fios-event-begin.html</url>
    <content type="text"><![CDATA[事件的生命周期： 事件的产生和传递（事件如何从父控件传递到子控件并寻找到最合适的view、寻找最合适的view的底层实现、拦截事件的处理）-&gt;找到最合适的view后事件的处理（touches方法的重写，也就是事件的响应） iOS中的事件可以分为3大类型：触摸事件加速计事件远程控制事件这里只讨论iOS中的触摸事件。 1 响应者对象(UIResponder)在iOS中不是任何对象都能处理事件，只有继承了UIResponder的对象才能接受并处理事件，我们称之为“响应者对象”。UIApplicationUIViewController,UIView都继承了UIResponder，所以都能接收并处理事件。 UIResponder中处理事件的相关方法1234567891011121314151617// 触摸事件open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)open func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)// 加速计事件@available(iOS 3.0, *)open func motionBegan(_ motion: UIEventSubtype, with event: UIEvent?)@available(iOS 3.0, *)open func motionEnded(_ motion: UIEventSubtype, with event: UIEvent?)@available(iOS 3.0, *)open func motionCancelled(_ motion: UIEventSubtype, with event: UIEvent?)// 远程控制事件@available(iOS 4.0, *)open func remoteControlReceived(with event: UIEvent?) 2 触摸事件的处理以UIView为例说明触摸事件的处理12345678// 一根或者多根手指开始触摸view，系统会自动调用open func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)// 一根或者多根手指在view上移动，系统会自动调用（随着手指的移动，会持续调用该方法）open func touchesMoved(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)// 一根或者多根手指离开view，系统会自动调用open func touchesEnded(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?)// 触摸结束前，某个系统事件(例如电话呼入)会打断触摸过程，系统会自动调用open func touchesCancelled(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) touches中存放的都是UITouch对象 如果两根手指同时触摸一个view，那么view只会调用一次touchesBegan(_:with:)方法，touches参数中装着2个UITouch对象 如果这两根手指一前一后分开触摸同一个view，那么view会分别调用2次touchesBegan(_:with:)方法，并且每次调用时的touches参数中只包含一个UITouch对象 想处理UIView的触摸事件，必须自定义UIView子类继承自UIView 3 UITouch对象3.1 UITouch的属性和方法12345678910111213141516// 触摸产生时所处的窗口open var window: UIWindow? &#123; get &#125;// 触摸产生时所处的视图open var view: UIView? &#123; get &#125;// 记录了触摸事件产生或变化时的时间，单位是秒open var timestamp: TimeInterval &#123; get &#125;// 当前触摸事件所处的状态open var phase: UITouchPhase &#123; get &#125;// 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击open var tapCount: Int &#123; get &#125;// 返回值表示触摸在view上的位置// 这里返回的位置是针对view的坐标系的（以view的左上角为原点(0, 0)）open func location(in view: UIView?) -&gt; CGPoint// 前一个触摸点的位置open func previousLocation(in view: UIView?) -&gt; CGPoint 3.2 UITouch的作用 保存着跟手指相关的信息，比如触摸的位置、时间、阶段 当手指移动时，系统会更新同一个UITouch对象，使之能够一直保存该手指在的触摸位置 当手指离开屏幕时，系统会销毁相应的UITouch对象 4 iOS事件的产生 发生触摸事件后，系统会将该事件加入到一个由UIApplication管理的事件队列中,即先进先出，先产生的事件先处理才符合常理。 UIApplication会从事件队列中取出最前面的事件，并将事件分发下去以便处理，通常，先发送事件给应用程序的主窗口（keyWindow）。 主窗口会在视图层次结构中找到一个最合适的视图来处理触摸事件，这也是整个事件处理过程的第一步。找到合适的视图控件后，就会调用视图控件的touches方法来作具体的事件处理。 5 iOS事件的传递 触摸事件的传递是从父控件传递到子控件，也就是UIApplication-&gt;window-&gt;寻找处理事件最合适的view 如果父控件不能接受触摸事件，那么子控件就不可能接收到触摸事件 点击一个UIView或产生一个触摸事件A，这个触摸事件A会被添加到由UIApplication管理的事件队列中（即，首先接收到事件的是UIApplication）。 UIApplication会从事件对列中取出最前面的事件（此处假设为触摸事件A），把事件A传递给应用程序的主窗口（keyWindow）。 5.1 应用如何找到最合适的控件来处理事件？ 首先判断主窗口（keyWindow）自己是否能接受触摸事件 判断触摸点是否在自己身上 子控件数组中从后往前遍历子控件，重复前面的两个步骤（所谓从后往前遍历子控件，就是首先查找子控件数组中最后一个元素，然后执行1、2步骤） view，比如叫做fitView，那么会把这个事件交给这个fitView，再遍历这个fitView的子控件，直至没有更合适的view为止。 如果没有符合条件的子控件，那么就认为自己最合适处理这个事件，也就是自己是最合适的view。 5.2 UIView不能接收触摸事件的三种情况： 不允许交互：userInteractionEnabled = false 隐藏：如果把父控件隐藏，那么子控件也会隐藏，隐藏的控件不能接受事件 透明度：如果设置一个控件的透明度&lt;0.01，会直接影响子控件的透明度。alpha：0.0~0.01为透明。 默认UIImageView不能接受触摸事件，因为不允许交互，即userInteractionEnabled = NO。所以如果希望UIImageView可以交互，需要设置UIImageView的userInteractionEnabled = YES。 5.3 事件传递示例 不管视图能不能处理事件，只要点击了视图就都会产生事件，关键在于该事件最终是由谁来处理！也就是说，如果蓝色视图不能处理事件，点击蓝色视图产生的触摸事件不会由被点击的视图（蓝色视图）处理！ 如果设置父控件的透明度或者hidden，会直接影响到子控件的透明度和hidden。如果父控件的透明度为0或者hidden = YES，那么子控件也是不可见的！ 6 如何寻找最合适的view 主窗口接收到应用程序传递过来的事件后，首先判断自己能否接手触摸事件。如果能，那么在判断触摸点在不在窗口自己身上 如果触摸点也在窗口身上，那么窗口会从后往前遍历自己的子控件（遍历自己的子控件只是为了寻找出来最合适的view） 遍历到每一个子控件后，又会重复上面的两个步骤（传递事件给子控件，1.判断子控件能否接受事件，2.点在不在子控件上） 如此循环遍历子控件，直到找到最合适的view，如果没有更合适的子控件，那么自己就成为最合适的view。 6.1 寻找的方法 6.1.1 hitTest(_:with:)方法什么时候调用？只要事件一传递给一个控件,这个控件就会调用它自己的hitTest(_:with:)方法（不管这个控件能不能处理事件） 作用寻找并返回最合适的view(能够响应事件的那个最合适的view) 拦截事件的处理 通过重写hitTest(_:with:)方法，返回指定的view作为最合适的view。 不管点击哪里，最合适的view都是hitTest(_:with:)方法中返回的那个view。 通过重写hitTest(_:with:)，就可以拦截事件的传递过程，想让谁处理事件谁就处理事件。 事件的传递顺序 是：产生触摸事件 -&gt; UIApplication事件队列 -&gt; UIWindow.hitTest(_:with:) -&gt;返回更合适的view -&gt; 子控件.hitTest(_:with:) -&gt; 返回最合适的view 6.1.2 point(inside:with:) 方法次方法判断点在不在当前view上（方法调用者的坐标系上）如果返回true，代表点在方法调用者的坐标系上;返回false代表点不在方法调用者的坐标系上，那么方法调用者也就不能处理事件。 7 事件的响应事件的传递和响应的区别： 事件的传递是从上到下（父控件到子控件），事件的响应是从下到上（顺着响应者链条向上传递：子控件到父控件。 参考：史上最详细的iOS之事件的传递和响应机制-原理篇iOS触摸事件全家桶史上最详细的iOS之事件的传递和响应机制-实践篇]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>事件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 15：实现计算器界面布局--Masonry和SnapKit的学习]]></title>
    <url>%2F2018%2Fios-tutorial-15.html</url>
    <content type="text"><![CDATA[Masonry和SnapKit分别是OC、Swift的界面布局框架，而且开发者相同。分别用这两个框架实现一个简单计算器界面： 完全代码：LearniOSByProject/101-MasonryDemo 和 LearniOSByProject/114-SnapKitDemo 显示区域和键盘区域： 12345678910111213141516171819202122232425262728293031323334//申明区域，displayView是显示区域，keyboardView是键盘区域 UIView *displayView = [UIView new]; [displayView setBackgroundColor:[UIColor blackColor]]; [self.view addSubview:displayView]; UIView *keyboardView = [UIView new]; [self.view addSubview:keyboardView]; //displView（显示结果区域）和 keyboardView（键盘区域） [displayView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.view.mas_top); make.left.and.right.equalTo(self.view); // displView是keyboardView的0.3倍，也就是前者是3份，后者是10份。整个屏幕的占比是前者3/13,后者10/13 make.height.equalTo(keyboardView).multipliedBy(0.3f); &#125;]; [keyboardView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(displayView.mas_bottom); make.bottom.equalTo(self.view.mas_bottom); make.left.and.right.equalTo(self.view); &#125;]; //设置显示位置的数字为0 UILabel *displayNum = [[UILabel alloc]init]; [displayView addSubview:displayNum]; displayNum.text = @&quot;0&quot;; displayNum.font = [UIFont fontWithName:@&quot;HeiTi SC&quot; size:70]; displayNum.textColor = [UIColor whiteColor]; displayNum.textAlignment = NSTextAlignmentRight; [displayNum mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.and.right.equalTo(displayView).with.offset(-10); make.bottom.equalTo(displayView).with.offset(-10); &#125;]; 键盘区域和约束 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109//定义键盘键名称，？号代表合并的单元格 NSArray *keys = @[@&quot;AC&quot;,@&quot;+/-&quot;,@&quot;%&quot;,@&quot;÷&quot; ,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;x&quot; ,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;-&quot; ,@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;+&quot; ,@&quot;0&quot;,@&quot;?&quot;,@&quot;.&quot;,@&quot;=&quot;]; int indexOfKeys = 0; for (NSString *key in keys)&#123; //循环所有键 indexOfKeys++; int rowNum = (indexOfKeys % 4 == 0) ? indexOfKeys/4 : (indexOfKeys/4 + 1); int colNum = (indexOfKeys % 4 == 0) ? 4 : indexOfKeys % 4; NSLog(@&quot;index is:%d and row:%d,col:%d&quot;,indexOfKeys,rowNum,colNum); //键样式 UIButton *keyView = [UIButton buttonWithType:UIButtonTypeCustom]; [keyboardView addSubview:keyView]; [keyView setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [keyView setTitle:key forState:UIControlStateNormal]; [keyView.layer setBorderWidth:1]; [keyView.layer setBorderColor:[[UIColor blackColor]CGColor]]; [keyView.titleLabel setFont:[UIFont fontWithName:@&quot;Arial-BoldItalicMT&quot; size:30]]; //键约束 [keyView mas_makeConstraints:^(MASConstraintMaker *make) &#123; //处理 0 合并单元格 if([key isEqualToString:@&quot;0&quot;] || [key isEqualToString:@&quot;?&quot;] )&#123; if([key isEqualToString:@&quot;0&quot;])&#123; [keyView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(keyboardView.mas_height).with.multipliedBy(.2f); make.width.equalTo(keyboardView.mas_width).multipliedBy(.5); make.left.equalTo(keyboardView.mas_left); make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.92f); &#125;]; &#125;if([key isEqualToString:@&quot;?&quot;])&#123; [keyView removeFromSuperview]; &#125; &#125; //正常的单元格 else&#123; make.width.equalTo(keyboardView.mas_width).with.multipliedBy(.25f); make.height.equalTo(keyboardView.mas_height).with.multipliedBy(.2f); //按照行和列添加约束，这里添加行约束 switch (rowNum) &#123; case 1: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.12f); &#125; break; case 2: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.32f); &#125; break; case 3: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.52f); &#125; break; case 4: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.72f); &#125; break; case 5: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.92f); &#125; break; default: break; &#125; //按照行和列添加约束，这里添加列约束 switch (colNum) &#123; case 1: &#123; make.left.equalTo(keyboardView.mas_left); &#125; break; case 2: &#123; make.right.equalTo(keyboardView.mas_centerX); &#125; break; case 3: &#123; make.left.equalTo(keyboardView.mas_centerX); &#125; break; case 4: &#123; make.right.equalTo(keyboardView.mas_right); &#125; break; default: break; &#125; &#125; &#125;]; &#125; 参考：忘记记录了😝]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 14：简单的下拉菜单 -- dropDownMenu]]></title>
    <url>%2F2018%2Fios-tutorial-14.html</url>
    <content type="text"><![CDATA[详细代码： dropDownMenu 按钮dropDownBtn: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687class dropDownBtn: UIButton, dropDownProtocol &#123; func dropDownPressed(string: String) &#123; self.setTitle(string, for: .normal) self.dismissDropDown() &#125; var dropView = dropDownView() var height = NSLayoutConstraint() override init(frame: CGRect) &#123; super.init(frame: frame) self.backgroundColor = UIColor.darkGray dropView = dropDownView.init(frame: CGRect.init(x: 0, y: 0, width: 0, height: 0)) dropView.translatesAutoresizingMaskIntoConstraints = false dropView.delegate = self &#125; // 本视图被添加到父视图上时调用 override func didMoveToSuperview() &#123; self.superview?.addSubview(dropView) self.superview?.bringSubview(toFront: dropView) dropView.topAnchor.constraint(equalTo: self.bottomAnchor).isActive = true dropView.centerXAnchor.constraint(equalTo: self.centerXAnchor).isActive = true dropView.widthAnchor.constraint(equalTo: self.widthAnchor).isActive = true height = dropView.heightAnchor.constraint(equalToConstant: 0) &#125; var isOpen = false // 刚触摸时调用 override func touchesBegan(_ touches: Set&lt;UITouch&gt;, with event: UIEvent?) &#123; if isOpen == false &#123; isOpen = true NSLayoutConstraint.deactivate([self.height]) if self.dropView.tableView.contentSize.height &gt; 150 &#123; self.height.constant = 150 &#125; else &#123; self.height.constant = self.dropView.tableView.contentSize.height &#125; NSLayoutConstraint.activate([self.height]) UIView.animate(withDuration: 0.5, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: .curveEaseInOut, animations: &#123; self.dropView.layoutIfNeeded() print(self.center, self.dropView.center, self.dropView.frame.height, self.dropView.frame.width) self.dropView.center.y += self.dropView.frame.height / 2 &#125;, completion: nil) &#125; else &#123; isOpen = false NSLayoutConstraint.deactivate([self.height]) self.height.constant = 0 NSLayoutConstraint.activate([self.height]) UIView.animate(withDuration: 0.5, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: .curveEaseInOut, animations: &#123; self.dropView.center.y -= self.dropView.frame.height / 2 self.dropView.layoutIfNeeded() &#125;, completion: nil) &#125; &#125; func dismissDropDown() &#123; isOpen = false NSLayoutConstraint.deactivate([self.height]) self.height.constant = 0 NSLayoutConstraint.activate([self.height]) UIView.animate(withDuration: 0.5, delay: 0, usingSpringWithDamping: 0.5, initialSpringVelocity: 0.5, options: .curveEaseInOut, animations: &#123; self.dropView.center.y -= self.dropView.frame.height / 2 self.dropView.layoutIfNeeded() &#125;, completion: nil) &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125;&#125; 下拉视图dropDownView 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class dropDownView: UIView, UITableViewDelegate, UITableViewDataSource &#123; var dropDownOptions = [String]() var tableView = UITableView() var delegate: dropDownProtocol! override init(frame: CGRect) &#123; super.init(frame: frame) tableView.backgroundColor = UIColor.darkGray self.backgroundColor = UIColor.darkGray tableView.delegate = self tableView.dataSource = self tableView.translatesAutoresizingMaskIntoConstraints = false self.addSubview(tableView) tableView.leftAnchor.constraint(equalTo: self.leftAnchor).isActive = true tableView.rightAnchor.constraint(equalTo: self.rightAnchor).isActive = true tableView.topAnchor.constraint(equalTo: self.topAnchor).isActive = true tableView.bottomAnchor.constraint(equalTo: self.bottomAnchor).isActive = true &#125; required init?(coder aDecoder: NSCoder) &#123; fatalError(&quot;init(coder:) has not been implemented&quot;) &#125; func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return dropDownOptions.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = UITableViewCell() cell.textLabel?.text = dropDownOptions[indexPath.row] cell.backgroundColor = UIColor.darkGray return cell &#125; func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; self.delegate.dropDownPressed(string: dropDownOptions[indexPath.row]) self.tableView.deselectRow(at: indexPath, animated: true) &#125; &#125; 参考：https://www.youtube.com/watch?v=22zu-OTS-3M]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[整理之前学的iOS小项目合集——LearniOSByProject]]></title>
    <url>%2F2018%2Flearniosbyproject.html</url>
    <content type="text"><![CDATA[介绍LearniOSByProject本来是自己学习iOS时的一些非常简单小例子，小项目，或者我个人博客AndyRon’s Blog文章的代码集合。没有按照什么路线学习，就是学到什么就是什么了，看上去特别乱，我自己有时候也非常懵逼，然后看到道长前辈的项目Swift-30-Projects，就整理、筛选一下，这样看着清晰一点，找起来也方便。 语言方面大部分是Swift，个别项目是OC。 以数字为目录只是为了记录项目数和排序，没有特殊意义。 下载单个项目可以参考 DownGit：怎么下载github中某个文件夹？ 总览图 一些项目的预览图]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发关于沙盒]]></title>
    <url>%2F2018%2Fios-sandbox.html</url>
    <content type="text"><![CDATA[每个iOS程序都有一个独立的文件系统（存储空间），而且只能在对应的文件系统中进行操作，此区域被称为沙盒。应用必须待在自己的沙盒里，其他应用不能访问该沙盒。所有的非代码文件都要保存在此，例如属性文件plist、文本文件、图像、图标、媒体资源等。 沙盒中相关路径 AppName.app 应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以不能在运行时对这个目录中的内容进行修改，否则会导致应用程序无法启动。 Documents/ 保存应用程序的重要数据文件和用户数据文件等。用户数据基本上都放在这个位置(例如从网上下载的图片或音乐文件)，该文件夹在应用程序更新时会自动备份，在连接iTunes时也可以自动同步备份其中的数据。 Library：这个目录下有两个子目录,可创建子文件夹。可以用来放置您希望被备份但不希望被用户看到的数据。该路径下的文件夹，除Caches以外，都会被iTunes备份. Library/Caches: 保存应用程序使用时产生的支持文件和缓存文件(保存应用程序再次启动过程中需要的信息)，还有日志文件最好也放在这个目录。iTunes 同步时不会备份该目录并且可能被其他工具清理掉其中的数据。 Library/Preferences: 保存应用程序的偏好设置文件。NSUserDefaults类创建的数据和plist文件都放在这里。会被iTunes备份。 tmp/: 保存应用运行时所需要的临时数据。不会被iTunes备份。iPhone重启时，会被清空。 12345678910111213141516171819// 获取沙盒根目录路径 NSString *homeDir = NSHomeDirectory(); // 获取Documents目录路径 NSString *docDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask,YES) firstObject]; //获取Library的目录路径 NSString *libDir = [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory,NSUserDomainMask,YES) lastObject]; // 获取cache目录路径 NSString *cachesDir = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory,NSUserDomainMask,YES) firstObject]; // 获取tmp目录路径 NSString *tmpDir =NSTemporaryDirectory(); // 获取应用程序程序包中资源文件路径的方法： NSString *bundle = [[NSBundle mainBundle] bundlePath]; NSLog(@&quot;homeDir=%@ \n docDir=%@ \n libDir=%@ \n cachesDir=%@ \n tmpDir=%@ \n bundle=%@&quot;, homeDir,docDir, libDir, cachesDir, tmpDir, bundle); 结果为：123456homeDir=/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917 docDir=/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917/Documents libDir=/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917/Library cachesDir=/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917/Library/Caches tmpDir=/private/var/mobile/Containers/Data/Application/FBE41071-F5DD-4F02-9DFC-E9E473D3C917/tmp/ bundle=/var/containers/Bundle/Application/4A42EF08-30BA-4C19-B0C9-62903300C2BC/SandboxDemo.app 关于NSSearchPathForDirectoriesInDomains函数FOUNDATION_EXPORT NSArray&lt;NSString *&gt; *NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde); 用于查找目录，返回指定范围内的指定名称的目录的路径集合。有三个参数： NSSearchPathDirectory directory 想要查找的目录，是个枚举值，有很多值，有关于iOS的，有关于macOS，也有关于watchOS的。 123456789101112131415161718192021222324252627282930typedef NS_ENUM(NSUInteger, NSSearchPathDirectory) &#123; NSApplicationDirectory = 1, // supported applications (Applications) NSDemoApplicationDirectory, // unsupported applications, demonstration versions (Demos) NSDeveloperApplicationDirectory, // developer applications (Developer/Applications). DEPRECATED - there is no one single Developer directory. NSAdminApplicationDirectory, // system and network administration applications (Administration) NSLibraryDirectory, // various documentation, support, and configuration files, resources (Library) NSDeveloperDirectory, // developer resources (Developer) DEPRECATED - there is no one single Developer directory. NSUserDirectory, // user home directories (Users) NSDocumentationDirectory, // documentation (Documentation) NSDocumentDirectory, // documents (Documents) NSCoreServiceDirectory, // location of CoreServices directory (System/Library/CoreServices) NSAutosavedInformationDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 11, // location of autosaved documents (Documents/Autosaved) NSDesktopDirectory = 12, // location of user&apos;s desktop NSCachesDirectory = 13, // location of discardable cache files (Library/Caches) NSApplicationSupportDirectory = 14, // location of application support files (plug-ins, etc) (Library/Application Support) NSDownloadsDirectory API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)) = 15, // location of the user&apos;s &quot;Downloads&quot; directory NSInputMethodsDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 16, // input methods (Library/Input Methods) NSMoviesDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 17, // location of user&apos;s Movies directory (~/Movies) NSMusicDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 18, // location of user&apos;s Music directory (~/Music) NSPicturesDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 19, // location of user&apos;s Pictures directory (~/Pictures) NSPrinterDescriptionDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 20, // location of system&apos;s PPDs directory (Library/Printers/PPDs) NSSharedPublicDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 21, // location of user&apos;s Public sharing directory (~/Public) NSPreferencePanesDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 22, // location of the PreferencePanes directory for use with System Preferences (Library/PreferencePanes) NSApplicationScriptsDirectory NS_ENUM_AVAILABLE(10_8, NA) = 23, // location of the user scripts folder for the calling application (~/Library/Application Scripts/code-signing-id) NSItemReplacementDirectory API_AVAILABLE(macos(10.6), ios(4.0), watchos(2.0), tvos(9.0)) = 99, // For use with NSFileManager&apos;s URLForDirectory:inDomain:appropriateForURL:create:error: NSAllApplicationsDirectory = 100, // all directories where applications can occur NSAllLibrariesDirectory = 101, // all directories where resources can occur NSTrashDirectory API_AVAILABLE(macos(10.8), ios(11.0)) API_UNAVAILABLE(watchos, tvos) = 102 // location of Trash directory&#125;; NSSearchPathDomainMask domainMask 表示“想要从哪个路径区域保护区查找”。 1234567typedef NS_OPTIONS(NSUInteger, NSSearchPathDomainMask) &#123; NSUserDomainMask =1, // 用户的主目录 NSLocalDomainMask =2, // 当前机器的本地目录 NSNetworkDomainMask =4, //在网络中公开可用的位置 NSSystemDomainMask =8, // 被苹果系统提供的，不可更改的位置 (/System) NSAllDomainsMask = 0x0ffff // 上述所有及未来的位置&#125;; BOOL expandTilde 表示是否用波浪线显示部分目录路径。~在*nix系统表示当前用户的Home目录。列如上面获取cache目录路径如果使用NO，那么结果就是cachesDir=~/Library/Caches 参考：沙盒和NSBundleNSSearchPathForDirectoriesInDomains方法使用沙盒和NSBundle文件系统官方手册]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS开发：学习Runtime]]></title>
    <url>%2F2018%2Fios-runtime-begin.html</url>
    <content type="text"><![CDATA[学习iOS开发，runtime这个知识点是绕不过去的，但对于我这种学习OC不是太久，写OC的量不够多的人来说，抽象理解runtime的概念或者是看源代码有点枯燥，效果也不好，以例子的方法学习可能会更好，随着代码量的上升，对runtime的理解会越来越深入。详细代码ARRuntimeDemo,开发环境Xcode9.4 Person.h为：123456789101112131415#import &lt;Foundation/Foundation.h&gt;@interface Person : NSObject&#123; NSString * firstName;&#125;@property (nonatomic, assign) int age;+(void)run;+(void)study;-(void)f1;-(void)f2;@end Person.m为：12345678910111213141516171819202122232425262728293031323334#import &quot;Person.h&quot;@implementation Person&#123; NSString *lastname; float weight;&#125;-(instancetype)init &#123; self = [super init]; if (self) &#123; firstName = @&quot;Andy&quot;; &#125; return self;&#125;-(void)f1 &#123; NSLog(@&quot;执行f1&quot;);&#125;-(void)f2 &#123; NSLog(@&quot;执行f2&quot;);&#125;+ (void)run &#123; NSLog(@&quot;跑&quot;);&#125;+ (void)study &#123; NSLog(@&quot;学习&quot;);&#125;@end 1 获取类的所有变量(包括成员变量和属性变量)12345678910111213// 1. 获取所有变量，包括成员变量和属性变量- (IBAction)getAllVar:(UIButton *)sender &#123; unsigned int count = 0; Ivar *allVariables = class_copyIvarList([Person class], &amp;count); for (int i=0; i&lt;count; i++) &#123; Ivar ivar = allVariables[i]; const char *Variablename = ivar_getName(ivar); const char *VariableType = ivar_getTypeEncoding(ivar); NSLog(@&quot;Name: %s Type: %s&quot;, Variablename, VariableType); &#125;&#125; 结果输出(其中firstName、lastname、weight为成员变量，_age为属性变量)：12342018-06-01 17:04:56.275194+0800 ARRuntimeDemo[60670:5448260] Name: firstName Type: @&quot;NSString&quot;2018-06-01 17:04:56.276120+0800 ARRuntimeDemo[60670:5448260] Name: lastname Type: @&quot;NSString&quot;2018-06-01 17:04:56.276503+0800 ARRuntimeDemo[60670:5448260] Name: weight Type: f2018-06-01 17:04:56.276614+0800 ARRuntimeDemo[60670:5448260] Name: _age Type: i 解释： Iva，一个指向objc_ivar结构体指针,包含了变量名、变量类型等信息 像lastname、weight这种定义在@implementation所谓的私有变量也可获取 对应class_copyIvarList还有一个class_copyPropertyList只能获得属性变量的方法 2 获取所有方法（不包括类方法）12345678910111213141516// 2. 获取所有方法，不包括类方法- (IBAction)getAllMethod:(UIButton *)sender &#123; unsigned int count; //获取方法列表，所有在.m文件显式实现的方法都会被找到，包括setter+getter方法； Method *allMethods = class_copyMethodList([Person class], &amp;count); for(int i =0;i&lt;count;i++) &#123; //Method，为runtime声明的一个宏，表示对一个方法的描述 Method md = allMethods[i]; //获取SEL：SEL类型,即获取方法选择器@selector() SEL sel = method_getName(md); //得到sel的方法名：以字符串格式获取sel的name，也即@selector()中的方法名称 const char *methodname = sel_getName(sel); NSLog(@&quot;(Method:%s)&quot;,methodname); &#125;&#125; 结果输出:123456782018-06-01 16:54:50.433232+0800 ARRuntimeDemo[60482:5418318] (Method:f1)2018-06-01 16:54:50.433465+0800 ARRuntimeDemo[60482:5418318] (Method:f2)2018-06-01 16:54:50.433930+0800 ARRuntimeDemo[60482:5418318] (Method:.cxx_destruct)2018-06-01 16:54:50.434335+0800 ARRuntimeDemo[60482:5418318] (Method:init)2018-06-01 16:54:50.435163+0800 ARRuntimeDemo[60482:5418318] (Method:height)2018-06-01 16:54:50.435788+0800 ARRuntimeDemo[60482:5418318] (Method:setHeight:)2018-06-01 16:54:50.435990+0800 ARRuntimeDemo[60482:5418318] (Method:setAge:)2018-06-01 16:54:50.436482+0800 ARRuntimeDemo[60482:5418318] (Method:age) 解释： 获得了像height,setHeight这种隐藏的setter、getter方法 Method是一个指向objc_method结构体指针，表示对类中的某个方法的描述。 .cxx_destruct是关于系统自动内存释放的隐藏方法 3 为类添加新属性category只能为类添加新方法，不能添加新属性，但通过runtime配合category就可以达到添加属性效果。首先新建一个类Person的category：.h文件123456789// Person+Category.h#import &quot;Person.h&quot;@interface Person (Category)@property (nonatomic, assign)float height;@end .m文件1234567891011121314151617181920212223242526// Person+Category.m#import &quot;Person+Category.h&quot;#import &lt;objc/runtime.h&gt;const char *key = &quot;myKey&quot;;@implementation Person (Category)-(void)setHeight:(float)height &#123; NSNumber *num = [NSNumber numberWithFloat:height]; /* objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy); 第一个参数是需要添加属性的对象； 第二个参数是属性的key，是C字符串就可以; 第三个参数是属性的值,类型必须为id，所以此处height先转为NSNumber类型； 第四个参数是使用策略，是一个枚举值，类似@property属性创建时设置属性修饰符，可从命名看出各枚举的意义； */ objc_setAssociatedObject(self, key, num, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;-(float)height &#123; NSNumber *number = objc_getAssociatedObject(self, key); return [number floatValue];&#125;@end 然后就能访问新属性height了：123456- (IBAction)addVar:(UIButton *)sender &#123; per = [[Person alloc] init]; per.height = 123; NSLog(@&quot;%f&quot;, [per height]);&#125; 此时虽然通过上面的获取所有变量方法不能获取height,但通过上面的额获取所有方法可以获取height和setHeight方法了:123456789101112132018-06-01 17:14:36.945742+0800 ARRuntimeDemo[60892:5482950] Name: firstName Type: @&quot;NSString&quot;2018-06-01 17:14:36.948330+0800 ARRuntimeDemo[60892:5482950] Name: lastname Type: @&quot;NSString&quot;2018-06-01 17:14:36.948771+0800 ARRuntimeDemo[60892:5482950] Name: weight Type: f2018-06-01 17:14:36.949166+0800 ARRuntimeDemo[60892:5482950] Name: _age Type: i2018-06-01 17:15:02.198444+0800 ARRuntimeDemo[60892:5482950] (Method:f1)2018-06-01 17:15:02.198620+0800 ARRuntimeDemo[60892:5482950] (Method:f2)2018-06-01 17:15:02.198800+0800 ARRuntimeDemo[60892:5482950] (Method:.cxx_destruct)2018-06-01 17:15:02.198917+0800 ARRuntimeDemo[60892:5482950] (Method:init)2018-06-01 17:15:02.199048+0800 ARRuntimeDemo[60892:5482950] (Method:height)2018-06-01 17:15:02.199150+0800 ARRuntimeDemo[60892:5482950] (Method:setHeight:)2018-06-01 17:15:02.199239+0800 ARRuntimeDemo[60892:5482950] (Method:setAge:)2018-06-01 17:15:02.199356+0800 ARRuntimeDemo[60892:5482950] (Method:age) 4 添加新方法1234567891011121314151617// 4. 添加新方法- (IBAction)addMethod:(UIButton *)sender &#123; /* 动态添加方法： 第一个参数表示Class cls 类型； 第二个参数表示待调用的方法名称； 第三个参数(IMP)myAddingFunction，IMP一个函数指针，这里表示指定具体实现方法myAddingFunction； 第四个参数表方法的参数，0代表没有参数； */ class_addMethod([per class], @selector(NewMethod), (IMP)myAddingFunction, 0); //调用方法 【如果使用[per NewMethod]调用方法，在ARC下会报“no visible @interface&quot;错误】 [per performSelector:@selector(NewMethod)];&#125;//具体的实现（方法的内部都默认包含两个参数Class类和SEL方法，被称为隐式参数。）int myAddingFunction(id self, SEL _cmd)&#123; NSLog(@&quot;已新增方法:NewMethod&quot;); return 1;&#125; 输出：12018-06-01 17:31:56.113168+0800 ARRuntimeDemo[61295:5543319] 已新增方法:NewMethod 5 交换两个方法12345678910111213// 5. 交换两个方法- (IBAction)swapMethod:(UIButton *)sender &#123; [Person run]; [Person study]; Method m1 = class_getClassMethod([Person class], @selector(run)); Method m2 = class_getClassMethod([Person class], @selector(study)); method_exchangeImplementations(m1, m2); [Person run]; [Person study];&#125; 输出：12342018-06-01 17:39:00.497375+0800 ARRuntimeDemo[61448:5566239] 跑2018-06-01 17:39:00.497841+0800 ARRuntimeDemo[61448:5566239] 学习2018-06-01 17:39:00.499255+0800 ARRuntimeDemo[61448:5566239] 学习2018-06-01 17:39:00.499449+0800 ARRuntimeDemo[61448:5566239] 跑 这篇文章我只是做了runtime一些简单使用，并没有相关的使用场景，算是入门了，文末参考提到的文章都是不错，值得以后深入。 参考：iOS开发 – Runtime 的几个小例子OC最实用的runtime总结，面试、工作你看我就足够了！iOS-RunTime，不再只是听说Runtime全方位装逼指南 Objective-C Runtime]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>runtime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS核心动画小结(swift)]]></title>
    <url>%2F2018%2Fios-coreanimation-swift.html</url>
    <content type="text"><![CDATA[本文所有示例代码都是Swift4，参看文末链接 Core Animation是IOS和OS X平台上负责图形渲染与动画的基础框架。Core Animation可以作用与动画视图或者其他可视元素，为你完成了动画所需的大部分绘画工作。你只需要配置少量的动画参数（如开始点的位置和结束点的位置）即可使用Core Animation的动画效果。Core Animation将大部分实际的绘图任务交给了图形硬件来处理，图形硬件会加速图形渲染的速度。这种自动化的图形加速技术让动画拥有更高的帧率并且显示效果更加平滑，不会加重CPU的负担而影响程序的运行速度。 上图少了iOS9才引入的CASpringAnimation, 它继承至CABasicAnimation 一、常用属性这些属性一般是在基类CAAnimation和协议CAMediaTiming中，是几种动画类共用的属性。 duration : 动画的持续时间 beginTime : 动画的开始时间 repeatCount : 动画的重复次数 autoreverses :动画结束时是否执行逆动画 timingFunction : 控制动画的显示节奏系统提供五种值选择，分别是： kCAMediaTimingFunctionLinear 线性动画 kCAMediaTimingFunctionEaseIn 先慢后快（慢进快出） kCAMediaTimingFunctionEaseOut 先块后慢（快进慢出） kCAMediaTimingFunctionEaseInEaseOut 先慢后快再慢 kCAMediaTimingFunctionDefault 默认，也属于中间比较快 delegate ： 动画代理。能够检测动画的执行和结束，在动画执行和结束做一些处理。 1234567public protocol CAAnimationDelegate : NSObjectProtocol &#123; @available(iOS 2.0, *) optional public func animationDidStart(_ anim: CAAnimation) @available(iOS 2.0, *) optional public func animationDidStop(_ anim: CAAnimation, finished flag: Bool)&#125; fillMode 动画在开始和结束时的动作。 kCAFillModeRemoved 这个是默认值，也就是说当动画开始前和动画结束后，动画对layer都没有影响，动画结束后，layer会恢复到之前的状态 kCAFillModeForwards 当动画结束后，layer会一直保持着动画最后的状态 kCAFillModeBackwards 在动画开始前，只需要将动画加入了一个layer，layer便立即进入动画的初始状态并等待动画开始。 kCAFillModeBoth 这个其实就是上面两个的合成.动画加入后开始之前，layer便处于动画初始状态，动画结束后layer保持动画最后的状态 二、基础动画（CABasicAnimation）基础动画就是从一个状态值（fromValue）变换成另一个状态值（toValue），特有的属性： fromValue 所改变属性的起始值 toValue 所改变属性的结束时的值 byValue 所改变属性相同起始值的改变量下面的代码是一个简单位置移动动画：12345678910111213let moveView = UIView(frame: CGRect(x: 20, y: 240, width: 70, height: 70))moveView.center = CGPoint(x: 40, y: 200)moveView.backgroundColor = UIColor.redview.addSubview(moveView)let moveAnim = CABasicAnimation(keyPath: &quot;position&quot;)moveAnim.fromValue = NSValue(cgPoint: CGPoint(x: 40, y: 240))moveAnim.toValue = NSValue(cgPoint: CGPoint(x: 300, y: 240))moveAnim.duration = 2moveAnim.repeatCount = Float.infinitymoveAnim.autoreverses = truemoveView.layer.add(moveAnim, forKey: &quot;moveAnim&quot;) 另外CABasicAnimation还可以做旋转、比例缩放、背景颜色变化、内容（图片）变化、透明度变化、圆角变化、指定大小变化等动画。（这些我都写了一些示例代码，链接在文末）这些动画的代码形式基本都差不多，先建立视图，然后创建CABasicAnimation类型动画对象，并指定不同的fromValue、toValue等属性，最后把动画对象加入到视图的CALayer层。 三、关键帧动画（CAKeyframeAnimation）按照指定的一串值进行动画,好像拍电影一样的一帧一帧的效果。 values： 动画对象会在指定的时间(duration)内，依次显示values数组中的每一个关键帧 path ： 可以设置一个CGPathRef\CGMutablePathRef,让层跟着路径移动。path只对CALayer的anchorPoint和position起作用。设置了path，那么values将被忽略。 keyTimes ： 可以为对应的关键帧指定对应的时间点,其取值范围为0到1.0,keyTimes中的每一个时间值都对应values中的每一帧。当keyTimes没有设置的时候,各个关键帧的时间是平分的。 rotationMode : 旋转样式 CABasicAnimation可看做是最多只有2个关键帧（开始和结束）的CAKeyframeAnimation 下面的代码通过values做成抖动的动画：1234let anima = CAKeyframeAnimation(keyPath: &quot;transform.rotation&quot;)anima.values = [-Double.pi/180*4,Double.pi/180*4, -Double.pi/180*4]anima.repeatCount = Float.infinityanimView.layer.add(anima, forKey: &quot;shake&quot;) 使用path配合贝塞尔曲线就可以做成如下效果： 代码12345678910111213141516171819let tempView = UIView(frame: CGRect(x: 50, y: 100, width: 250, height: 500))let bezierPath = UIBezierPath(ovalIn: tempView.frame)let orbitAnim = CAKeyframeAnimation(keyPath: &quot;position&quot;)orbitAnim.duration = 5orbitAnim.path = bezierPath.cgPathorbitAnim.calculationMode = kCAAnimationPacedorbitAnim.fillMode = kCAFillModeForwardsorbitAnim.repeatCount = Float.infinityorbitAnim.rotationMode = kCAAnimationRotateAutoReverseanimView.layer.add(orbitAnim, forKey: &quot;orbitAnim&quot;)let shapeLayer = CAShapeLayer()shapeLayer.strokeColor = UIColor.purple.cgColorshapeLayer.fillColor = UIColor.clear.cgColorshapeLayer.lineWidth = 0.5shapeLayer.lineJoin = kCALineJoinRoundshapeLayer.lineCap = kCALineCapRoundshapeLayer.path = bezierPath.cgPathview.layer.addSublayer(shapeLayer) 四、组动画（CAAnimationGroup）组动画顾名思义就是把不同的动画组合起来，比如下面的代码：1234567891011121314151617// 位移let anima1 = CABasicAnimation(keyPath: &quot;position&quot;)anima1.fromValue = NSValue(cgPoint: CGPoint(x: 40, y: 240))anima1.toValue = NSValue(cgPoint: CGPoint(x: 300, y: 240))// 缩放let anima2 = CABasicAnimation(keyPath: &quot;transform.scale&quot;)anima2.fromValue = NSNumber.init(value: 0.8)anima2.toValue = NSNumber.init(value: 2.0)// 旋转let anima3 = CABasicAnimation(keyPath: &quot;transform.rotation&quot;)anima3.toValue = Double.pi*4// 组合let groupAnimation = CAAnimationGroup()groupAnimation.animations = [anima1, anima2, anima3]groupAnimation.duration = 3.0animView.layer.add(groupAnimation, forKey: nil) 组合后的动画效果就是在移动的同时，也在缩放和旋转。 五、过渡动画（CATransition）CATransition用于做过渡动画或者转场动画，能够为层提供移出屏幕和移入屏幕的动画效果。 type：动画过渡类型四个系统公开的 系统公开API 效果说明 是否支持方向 kCATransitionFade 淡出效果 是 kCATransitionMoveIn 新视图移动到旧视图上 是 kCATransitionPush 新视图推出旧视图 是 kCATransitionReveal 移开旧视图显示新视图 是 其他还有一些非系统公开的过渡类型：1[&quot;cube&quot;, &quot;suckEffect&quot;, &quot;rippleEffect&quot;, &quot;pageCurl&quot;, &quot;pageUnCurl&quot;, &quot;oglFlip&quot;] subtype : 过渡动画的动画方向 1234kCATransitionFromRight 从右侧进入kCATransitionFromLeft 从左侧进入kCATransitionFromTop 从顶部进入kCATransitionFromBottom 从底部进入 startProgress：动画起点(在整体动画的百分比) endProgress：动画终点(在整体动画的百分比) 六、弹簧动画 CASpringAnimation常用属性 mass： 模拟的是质量，影响图层运动时的弹簧惯性，质量越大，弹簧拉伸和压缩的幅度越大 默认值：1 ; stiffness：刚度系数(劲度系数/弹性系数)，刚度系数越大，形变产生的力就越大，运动越快。默认值： 100 ； damping：阻尼系数，阻止弹簧伸缩的系数，阻尼系数越大，停止越快。默认值：10； initialVelocity：初始速率，动画视图的初始速度大小。默认值：0 ；速率为正数时，速度方向与运动方向一致，速率为负数时，速度方向与运动方向相反； settlingDuration：估算时间 返回弹簧动画到停止时的估算时间，根据当前的动画参数估算；实例：1234567891011121314151617181920212223242526272829// 不同的keypath，不同的效果let springAnimation = CASpringAnimation(keyPath: &quot;position.y&quot;)if springAnimation.keyPath == &quot;position&quot; &#123; springAnimation.fromValue = NSValue.init(cgPoint: self.jellyView.layer.position) springAnimation.toValue = NSValue.init(cgPoint: point)&#125; else if springAnimation.keyPath == &quot;position.x&quot; &#123; springAnimation.fromValue = self.jellyView.layer.position.x springAnimation.toValue = point.x&#125; else if springAnimation.keyPath == &quot;position.y&quot; &#123; springAnimation.fromValue = self.jellyView.layer.position.y springAnimation.toValue = point.y&#125; else if springAnimation.keyPath == &quot;bounds&quot; &#123; springAnimation.fromValue = NSValue.init(cgRect: CGRect(x: point.x, y: point.y, width: 60, height: 60)) springAnimation.toValue = NSValue.init(cgRect: self.jellyView.frame)&#125;springAnimation.mass = 5springAnimation.stiffness = 100springAnimation.damping = 10springAnimation.initialVelocity = 10springAnimation.duration = springAnimation.settlingDurationspringAnimation.isRemovedOnCompletion = falseself.jellyView.layer.add(springAnimation, forKey: &quot;springAnimation&quot;) keyPath不同时效果不同： 代码：本文所有的示例代码都在https://github.com/andyRon/iOS-Animation 参考：IOSAnimationDemoiOS动画详解(学习动画看这一篇就够了)一篇文章搞定 CASpringAnimation 弹簧动画Core Animation 官方手册]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Masonry学习]]></title>
    <url>%2F2018%2Fmasonry-begin.html</url>
    <content type="text"><![CDATA[Masonry是一个轻量级的OC布局框架， 拥有自己的描述语法，采用更优雅的链式语法封装自动布局，简洁明了，并具有高可读性，而且同时支持 iOS 和 Max OS X。 Masonry支持的属性与NSLayoutAttrubute的对照： MASConstraint (Masonry) NSAutoLayout 说明 left NSLayoutAttributeLeft 左侧 top NSLayoutAttributeTop 上侧 right NSLayoutAttributeRight 右侧 bottom NSLayoutAttributeBottom 下侧 leading NSLayoutAttributeLeading 首部 trailing NSLayoutAttributeTrailing 尾部 width NSLayoutAttributeWidth 宽 height NSLayoutAttributeHeight 高 centerX NSLayoutAttributeCenterX 横向中点 centerY NSLayoutAttributeCenterY 纵向中点 baseline NSLayoutAttributeBaseline 文本基线 其中leading与left, trailing与right 在正常情况下是等价的。但是当一些布局是从右至左时(比如阿拉伯文) 则会对调， 换句话说就是基本可以 用left和right就好了。 在Masonry中能够添加AutoLayout约束有三个函数: 12345678/*mas_makeConstraints 只负责新增约束 Autolayout不能同时存在两条针对于同一对象的约束 否则会报错 mas_updateConstraints 针对上面的情况 会更新在block中出现的约束 不会导致出现两个相同约束的情况mas_remakeConstraints 则会清除之前的所有约束 仅保留最新的约束*/- (NSArray *)mas_makeConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_updateConstraints:(void(^)(MASConstraintMaker *make))block;- (NSArray *)mas_remakeConstraints:(void(^)(MASConstraintMaker *make))block; equalTo 和 mas_equalTo的区别? mas_equalTo是宏，在MASConstraint.h文件中定义： 1#define mas_equalTo(...) equalTo(MASBoxValue((__VA_ARGS__))) mas_equalTo 比equalTo多了类型转换操作, 大多数时候两个方法都是 通用的，但是对于数值元素使用mas_equalTo。对于对象或是多个属性的处理，使用equalTo。 以几个🌰学习Masonry： 1 中心点与self.view相同，宽度为300*30012345678910// exp1: 中心点与self.view相同，宽度为300*300-(void)exp1 &#123; UIView *view = [UIView new]; [view setBackgroundColor:[UIColor redColor]]; [self.view addSubview:view]; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.center.equalTo(self.view); make.size.mas_equalTo(CGSizeMake(300, 300)); &#125;];&#125; 2 上下左右边距都为1012345678910111213141516171819202122-(void)exp2 &#123; UIView *view = [UIView new]; [view setBackgroundColor:[UIColor redColor]]; [self.view addSubview:view]; [view mas_makeConstraints:^(MASConstraintMaker *make) &#123; // 写法1 make.edges.equalTo(self.view).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); /* // 写法2 make.top.equalTo(self.view).with.offset(10); make.left.equalTo(self.view).with.offset(10); make.bottom.equalTo(self.view).with.offset(-10); make.right.equalTo(self.view).with.offset(-10); */ /* // 写法3 make.top.left.bottom.and.right.equalTo(self.view).with.insets(UIEdgeInsetsMake(10, 10, 10, 10)); */ &#125;];&#125; edges 就是top,left,bottom,right简化写法 写法2中 bottom和right的offset是负数，因为计算的是绝对的数值，也就是view的bottom的y值减去self.view的bottom的y值是-10，view的right的x值减去self.view的right的x值是-10。 and和with什么事件都没做，只是从应用语法看上去很顺。 3 让两个高度为150的view垂直居中且等宽且等间隔排列 间隔为10(自动计算器高度)123456789101112131415161718192021222324252627282930-(void)exp3&#123; UIView *view1 = [UIView new]; [view1 setBackgroundColor:[UIColor redColor]]; [self.view addSubview:view1]; UIView *view2 = [UIView new]; [view2 setBackgroundColor:[UIColor redColor]]; [self.view addSubview:view2]; [view1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(self.view.mas_centerY); make.height.mas_equalTo(150); make.width.mas_equalTo(view2.mas_width); make.left.mas_equalTo(self.view.mas_left).with.offset(10); make.right.mas_equalTo(view2.mas_left).offset(-10); &#125;]; [view2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.centerY.mas_equalTo(self.view.mas_centerY); make.height.mas_equalTo(150); make.width.mas_equalTo(view1.mas_width); make.left.mas_equalTo(view1.mas_right).with.offset(10); make.right.equalTo(self.view.mas_right).offset(-10); &#125;]; &#125; 4 iOS自带计算器布局123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150-(void)exp4&#123; //申明区域，displayView是显示区域，keyboardView是键盘区域 UIView *displayView = [UIView new]; [displayView setBackgroundColor:[UIColor blackColor]]; [self.view addSubview:displayView]; UIView *keyboardView = [UIView new]; [self.view addSubview:keyboardView]; //先按1：3分割 displView（显示结果区域）和 keyboardView（键盘区域） [displayView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(self.view.mas_top); make.left.and.right.equalTo(self.view); make.height.equalTo(keyboardView).multipliedBy(0.3f); &#125;]; [keyboardView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.top.equalTo(displayView.mas_bottom); make.bottom.equalTo(self.view.mas_bottom); make.left.and.right.equalTo(self.view); &#125;]; //设置显示位置的数字为0 UILabel *displayNum = [[UILabel alloc]init]; [displayView addSubview:displayNum]; displayNum.text = @&quot;0&quot;; displayNum.font = [UIFont fontWithName:@&quot;HeiTi SC&quot; size:70]; displayNum.textColor = [UIColor whiteColor]; displayNum.textAlignment = NSTextAlignmentRight; [displayNum mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.left.and.right.equalTo(displayView).with.offset(-10); make.bottom.equalTo(displayView).with.offset(-10); &#125;]; //定义键盘键名称，？号代表合并的单元格 NSArray *keys = @[@&quot;AC&quot;,@&quot;+/-&quot;,@&quot;%&quot;,@&quot;÷&quot; ,@&quot;7&quot;,@&quot;8&quot;,@&quot;9&quot;,@&quot;x&quot; ,@&quot;4&quot;,@&quot;5&quot;,@&quot;6&quot;,@&quot;-&quot; ,@&quot;1&quot;,@&quot;2&quot;,@&quot;3&quot;,@&quot;+&quot; ,@&quot;0&quot;,@&quot;?&quot;,@&quot;.&quot;,@&quot;=&quot;]; int indexOfKeys = 0; for (NSString *key in keys)&#123; //循环所有键 indexOfKeys++; int rowNum = indexOfKeys %4 ==0? indexOfKeys/4:indexOfKeys/4 +1; int colNum = indexOfKeys %4 ==0? 4 :indexOfKeys %4; NSLog(@&quot;index is:%d and row:%d,col:%d&quot;,indexOfKeys,rowNum,colNum); //键样式 UIButton *keyView = [UIButton buttonWithType:UIButtonTypeCustom]; [keyboardView addSubview:keyView]; [keyView setTitleColor:[UIColor blackColor] forState:UIControlStateNormal]; [keyView setTitle:key forState:UIControlStateNormal]; [keyView.layer setBorderWidth:1]; [keyView.layer setBorderColor:[[UIColor blackColor]CGColor]]; [keyView.titleLabel setFont:[UIFont fontWithName:@&quot;Arial-BoldItalicMT&quot; size:30]]; //键约束 [keyView mas_makeConstraints:^(MASConstraintMaker *make) &#123; //处理 0 合并单元格 if([key isEqualToString:@&quot;0&quot;] || [key isEqualToString:@&quot;?&quot;] )&#123; if([key isEqualToString:@&quot;0&quot;])&#123; [keyView mas_makeConstraints:^(MASConstraintMaker *make) &#123; make.height.equalTo(keyboardView.mas_height).with.multipliedBy(.2f); make.width.equalTo(keyboardView.mas_width).multipliedBy(.5); make.left.equalTo(keyboardView.mas_left); make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.9f); &#125;]; &#125;if([key isEqualToString:@&quot;?&quot;])&#123; [keyView removeFromSuperview]; &#125; &#125; //正常的单元格 else&#123; make.width.equalTo(keyboardView.mas_width).with.multipliedBy(.25f); make.height.equalTo(keyboardView.mas_height).with.multipliedBy(.2f); //按照行和列添加约束，这里添加行约束 switch (rowNum) &#123; case 1: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.1f); keyView.backgroundColor = [UIColor colorWithRed:205 green:205 blue:205 alpha:1]; &#125; break; case 2: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.3f); &#125; break; case 3: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.5f); &#125; break; case 4: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.7f); &#125; break; case 5: &#123; make.baseline.equalTo(keyboardView.mas_baseline).with.multipliedBy(.9f); &#125; break; default: break; &#125; //按照行和列添加约束，这里添加列约束 switch (colNum) &#123; case 1: &#123; make.left.equalTo(keyboardView.mas_left); &#125; break; case 2: &#123; make.right.equalTo(keyboardView.mas_centerX); &#125; break; case 3: &#123; make.left.equalTo(keyboardView.mas_centerX); &#125; break; case 4: &#123; make.right.equalTo(keyboardView.mas_right); [keyView setBackgroundColor:[UIColor colorWithRed:243 green:127 blue:38 alpha:1]]; &#125; break; default: break; &#125; &#125; &#125;]; &#125; &#125; 代码: MasonryDemo 参考:Masonry介绍与使用实践(快速上手Autolayout)Masonry的使用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Masonry</tag>
        <tag>布局</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向CocoaPods发布代码]]></title>
    <url>%2F2017%2Fios-cocoapods-push.html</url>
    <content type="text"><![CDATA[Cocoapods是非常好用的一个iOS依赖管理工具，用它来管理和更新项目中的第三库使iOS开发更加方便。使用别人优秀的代码在程序员开发过程中是非常常见的事，为别人贡献代码也是很有必要的事。 这篇文章是我总结向Cocoapods贡献代码的过程。我以自己一个非常非常简单的项目ARFPSStatus来记录这个过程。ARFPSStatus非常简单，是Swift写的在状态栏显示屏幕的FPS，源码只有一个Swift文件。 来吧！🎉我试着为iOS开发贡献一点绵薄之力吧。🎉 一、安装cocoapods1sudo gem install cocoapods --pre 二、创建代码并上传代码到Github就是要发布的代码了，具体怎么上传代码到Github上我就不重复了。 三、在github上发布一个版本点击这边的release:发布一个版本，假设是0.1.0: 创建podspec文件常见一个&lt;项目名称&gt;.podspec文件，我这边就是ARFPSStatus.podspec文件，内容如下：1234567891011121314Pod::Spec.new do |s| s.name = &quot;ARFPSStatus&quot; s.version = &quot;0.1.0&quot; s.summary = &quot;ARFPSStatus - Show FPS Status on StatusBar in Swift&quot; s.homepage = &quot;https://github.com/andyRon/ARFPSStatus&quot; s.license = &quot;MIT&quot; s.authors = &#123; &quot;andyron&quot; =&gt; &quot;rongming.2008@163.com&quot; &#125; s.source = &#123; :git =&gt; &quot;https://github.com/andyRon/ARFPSStatus.git&quot;, :tag =&gt; &quot;0.1.0&quot; &#125; s.frameworks = &apos;Foundation&apos;, &apos;UIKit&apos; s.platform = :ios, &apos;9.0&apos; s.source_files = &apos;ARFPSStatus/*&apos; s.requires_arc = true end s.name – 项目名称，也就是别人使用Pod时使用的名字，需要唯一，可事先在Cocoapods上查询一下。 s.version – 这是你 Pod 的版本。务必注意，它得和 Github release 的版本号相同，就是刚才发布的版本0.1.0。如果两者不匹配，就会报错。 s.summary 和 s.description – 这两个变量最终会显示在 Cocoapods 页面上。请确保 description 比 summary 更长，否则将会报错。description不是必须的。 s.homepage – 这是 Pod 源代码的 URL。 s.author – 开发者信息，开发者名字和邮箱。 s.source_files – 这是最重要的参数。不是所有Github项目中所有文件都需要提交到CocoaPods里，项目中可能有一些Demo、图片啊等，提交到CocoaPods的只需要源码，就是别人使用时最少所需的代码。例如，我需要提交的是ARFPSStatus/ARFPSStatus.swift文件，s.source_files就是ARFPSStatus/ARFPSStatus.swift，或者之后如果再在ARFPSStatus/目录中添加其他文件，s.source_files就可以是ARFPSStatus/*。当然，还可以是其它一些形式。ARFPSStatus/*.swiftARFPSStatus/*.{swift,plist} Podspec文件的详细语法规则可查看官网的Podspec Syntax Reference 验证项目CocoaPods 需要验证项目有没有错误 pod lib lint12345678$ pod lib lint -&gt; ARFPSStatus (0.1.0) - WARN | [iOS] license: Unable to find a license file - WARN | xcodebuild: /Users/andyron/myfield/github/ARFPSStatus/ARFPSStatus/ARFPSStatus.swift:91:17: warning: variable &apos;label&apos; was never mutated; consider changing to &apos;let&apos; constant[!] ARFPSStatus did not pass validation, due to 2 warnings (but you can use `--allow-warnings` to ignore them).You can use the `--no-clean` option to inspect any issue. 如果想忽略警告，可使用--allow-warnings。 $ pod lib lint --allow-warnings 发布 创建 Trunk 账号关于Trunk可以查看为什么做 Trunk这篇文章创建 Trunk 账号很简单，只要一个邮箱。pod trunk register rongming.2008@163.com邮箱会收到一封确认邮件，确认成功： 推送代码到Podpod trunk push ARFPSStatus.podspec当然也可使用pod trunk push ARFPSStatus.podspec --allow-warnings来忽略一些不必要的警告。成功后：1234567891011$ pod trunk push ARFPSStatus.podspec Updating spec repo `master`-------------------------------------------------------------------------------- 🎉 Congrats 🚀 ARFPSStatus (0.1.0) successfully published 📅 September 28th, 11:33 🌎 https://cocoapods.org/pods/ARFPSStatus 👍 Tell your friends!-------------------------------------------------------------------------------- 使用新发布的代码发布成功和可能需要一段时间才能使用，可以到Cocoapods上查询。 项目的Podfile文件中添加ARFPSStatus,并安装。 123456target &apos;FPSDemo&apos; douse dynamic frameworks use_frameworks! pod &quot;ARFPSStatus&quot; end Pods项目会多出ARFPSStatus目录，里面的Support Files目录不是我添加的，是Cocoapods自动添加的一些相关文件。 参考：基于 Swift 创建 CocoaPods 完全指南Podspec Syntax Reference]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>CocoaPods</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于iOS开发中的pch文件]]></title>
    <url>%2F2017%2Fios-pch.html</url>
    <content type="text"><![CDATA[.pch文件也是一种头文件，它的内容能被项目中的其他所有源文件共享和访问。是一个预编译文件。 pch文件的作用：1.存放一些全局的宏(整个项目中都用得上的宏) 2.用来包含一些头文件(整个项目中都用得上的头文件) 3.能自动打开或者关闭日志输出功能 Xcode新建pch文件 Xcode配置pch文件 pch文件的简单例子一个小项目的pch文件： 1234567891011121314151617181920212223242526272829303132#ifndef PrefixHeader_pch#define PrefixHeader_pch// Include any system framework and library headers here that should be included in all compilation units.// You will also need to set the Prefix Header build setting of one or more of your targets to reference this file.#import &quot;ARSearchBar.h&quot;#import &lt;FMDB.h&gt;#import &quot;ARSqliteTool.h&quot;#import &lt;AFNetworking.h&gt;#import &lt;SSZipArchive.h&gt;#import &lt;MobileCoreServices/MobileCoreServices.h&gt;#import &lt;SystemConfiguration/SystemConfiguration.h&gt;#define ARUserDefaults [NSUserDefaults standardUserDefaults]#define ARScreenBounds [UIScreen mainScreen].bounds#define ARScreenWidth [UIScreen mainScreen].bounds.size.width#define ARScreenHeight [UIScreen mainScreen].bounds.size.height#define WeakSelf __weak typeof(self) weakSelf = self;/** * 1.返回一个RGBA格式的UIColor对象 */#define RGBA(r, g, b, a) [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]/** * 2.返回一个RGB格式的UIColor对象 */#define RGB(r, g, b) RGBA(r, g, b, 1.0f)#endif /* PrefixHeader_pch */ 参考：http://www.cnblogs.com/manmq/p/6377882.html]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>pch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS沙盒和文件管理]]></title>
    <url>%2F2017%2Fios-sandbox-file.html</url>
    <content type="text"><![CDATA[沙盒（sandbox）：iOS系统为每个应用程序创建自己的目录，每个应用程序只能访问自己的目录。所有的非代码文件都要保存在此，例如图像，图标，声音，映像，属性列表，文本文件等。 在Mac的Finder上打开一个目录由于有些目录比较长，不适合直接Finder里点击选取。有两种方法可以用： 在Finder的菜单中选择 前往 &gt; 前往文件夹 在命令行中使用open命令： open /Users/andyron/Library/Developer/CoreSimulator/Devices/F03C84B3-2A5E-44A7-AA51-2142A6397CA7/data/Containers/Data/Application/E83106A7-FCF3-45A6-888E-330BC52B279B/ 应用沙盒的完整目录 Xcode的模拟器的目录类似：1/Users/andyron/Library/Developer/CoreSimulator/Devices/F03C84B3-2A5E-44A7-AA51-2142A6397CA7/data/Containers/Data/Application/E83106A7-FCF3-45A6-888E-330BC52B279B/ Devices/F03C84B3-2A5E-44A7-AA51-2142A6397CA7是Xcode中不同模拟器的区别字符 真机中类似：1/var/mobile/Containers/Data/Application/9AC577C1-08B2-4BAE-9CE2-1211E4994F9E/ 类似Application/9AC577C1-08B2-4BAE-9CE2-1211E4994F9E/这个目录就是每个应用沙盒的根目录。 沙盒中目录结构类似如下：12345678910├── Documents├── Library│ ├── Caches│ │ └── Snapshots│ │ └── com.andyron.Sandbox│ │ ├── 9EEA412B-07C1-44EC-995B-0C12AD87BAF9@2x.ktx│ │ └── D3F89052-27FD-42A1-B246-B416E1772FBB@2x.ktx│ └── Preferences├── SystemData└── tmp 默认情况下，每个沙盒含有3个文件夹：Documents, Library 和 tmp。因为应用的沙盒机制，应用只能在几个目录下读写文件 Documents：苹果建议将程序中建立的或在程序中浏览到的文件数据保存在该目录下，iTunes备份和恢复的时候会包括此目录 Library：存储程序的默认设置或其它状态信息； Library/Caches：存放缓存文件，iTunes不会备份此目录，此目录下文件不会在应用退出删除 tmp：提供一个即时创建临时文件的地方。 iTunes在与iPhone同步时，备份所有的Documents和Library文件。 iPhone在重启时，会丢弃所有的tmp文件。 获取不同目录12345678910111213141516171819202122// 1、获取程序的Home目录 NSString *homeDirectory = NSHomeDirectory(); NSLog(@&quot;home path:%@&quot;, homeDirectory); // 2、获取document目录 NSArray *Documentspaths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *Documentspath = [Documentspaths objectAtIndex:0]; NSLog(@&quot;Documents path:%@&quot;, Documentspath); // 3、获取Cache目录 Library/Caches NSArray *Cachepaths = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES); NSString *Cachepath = [Cachepaths objectAtIndex:0]; NSLog(@&quot;Cache path:%@&quot;, Cachepath);// 4、获取Library目录 NSArray *Librarypaths = NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES); NSString *Librarypath = [Librarypaths objectAtIndex:0]; NSLog(@&quot;Library path:%@&quot;, Librarypath);// 5、获取Tmp目录 NSString *tmpDir = NSTemporaryDirectory(); NSLog(@&quot;tmpDir:%@&quot;, tmpDir); 文件的写入和读取1234567891011121314151617181920- (void)file_w &#123;// 6、写入文件 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *docDir = [paths objectAtIndex:0]; if (!docDir) &#123; NSLog(@&quot;Documents 目录未找到&quot;); &#125; NSArray *array = [[NSArray alloc] initWithObjects:@&quot;内容&quot;,@&quot;content&quot;,nil]; NSString *filePath = [docDir stringByAppendingPathComponent:@&quot;testFile.txt&quot;]; [array writeToFile:filePath atomically:YES];&#125;- (void)file_r &#123;// 7, 读取文件 NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *docDir = [paths objectAtIndex:0]; NSString *filePath = [docDir stringByAppendingPathComponent:@&quot;testFile.txt&quot;]; NSArray *array = [[NSArray alloc]initWithContentsOfFile:filePath]; NSLog(@&quot;%@&quot;, array);&#125; 文件管理文件管理器NSFileManager有判断文件是否存在、创建目录和文件、获取文件名、删除文件等功能。 判断文件是否存在 12345678910// 创建文件管理器NSFileManager * fileManager = [NSFileManager defaultManager];NSString * documents = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];NSString * filePath = [documents stringByAppendingPathComponent:@&quot;testFile.txt&quot;];// 判断一个文件是否存在,传入全路径if ([fileManager fileExistsAtPath:filePath]) &#123; NSLog(@&quot;it is exit&quot;);&#125; 创建目录和文件 123456789101112131415161718// 在Documents里创建目录NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];NSLog(@&quot;documentsDirectory: %@&quot;,documentsDirectory);NSFileManager *fileManager = [NSFileManager defaultManager];NSString *testDirectory = [documentsDirectory stringByAppendingPathComponent:@&quot;test&quot;];// 创建目录[fileManager createDirectoryAtPath:testDirectory withIntermediateDirectories:YES attributes:nil error:nil];// 在目录下创建文件NSString *testPath = [testDirectory stringByAppendingPathComponent:@&quot;test00.txt&quot;];NSString *testPath2 = [testDirectory stringByAppendingPathComponent:@&quot;test22.txt&quot;];NSString *testPath3 = [testDirectory stringByAppendingPathComponent:@&quot;test33.txt&quot;];NSString *string = @&quot;写入内容，write String&quot;;[fileManager createFileAtPath:testPath contents:[string dataUsingEncoding:NSUTF8StringEncoding] attributes:nil];[fileManager createFileAtPath:testPath2 contents:[string dataUsingEncoding:NSUTF8StringEncoding] attributes:nil];[fileManager createFileAtPath:testPath3 contents:[string dataUsingEncoding:NSUTF8StringEncoding] attributes:nil]; 获取目录列里所有文件名subpathsOfDirectoryAtPath 和 subpathsAtPath 两个方法都可以。 12345678910NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];NSLog(@&quot;documentsDirectory: %@&quot;,documentsDirectory);NSFileManager *fileManage = [NSFileManager defaultManager];NSString *myDirectory = [documentsDirectory stringByAppendingPathComponent:@&quot;test&quot;];NSArray *file = [fileManage subpathsOfDirectoryAtPath: myDirectory error:nil];NSLog(@&quot;%@&quot;,file);NSArray *file2 = [fileManage subpathsAtPath: myDirectory ];NSLog(@&quot;%@&quot;,file2); 更改到指定目录下操作changeCurrentDirectoryPath方法。 12345678910//创建文件管理器NSFileManager *fileManager = [NSFileManager defaultManager];NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES);NSString *documentsDirectory = [paths objectAtIndex:0];//更改到待操作的目录下[fileManager changeCurrentDirectoryPath:[documentsDirectory stringByExpandingTildeInPath]];//创建文件fileName文件名称，contents文件的内容，如果开始没有内容可以设置为nil，attributes文件的属性，初始为nilNSString * fileName = @&quot;testFileNSFileManager.txt&quot;;NSArray *array = [[NSArray alloc] initWithObjects:@&quot;hello world&quot;,@&quot;hello world1&quot;, @&quot;hello world2&quot;,nil];[fileManager createFileAtPath:fileName contents:[NSKeyedArchiver archivedDataWithRootObject:array] attributes:nil]; 删除文件 1[fileManager removeItemAtPath:fileName error:nil]; 代码： Sandbox 参考：沙盒机制与文件(一)沙盒机制与文件(二)沙盒机制与文件(三)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>sandbox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(六)：SDWebImage的简单使用]]></title>
    <url>%2F2017%2Fios-network-6.html</url>
    <content type="text"><![CDATA[SDWebImage一些知识： 对远程图片进行缓存管理（磁盘+内存） 异步加载 同一个URL图片不会重复下载 失效的URL不会被无限重试 图片加载一般使用 SDWebImage通过为UIImageView添加类别，扩展了一些类似的方法，只是参数的多少数目不同，最全的参数的方法是： 1-sd_setImageWithURL:placeholderImage:options:progress:completed: sd_setImageWithURL: URL的图片的URL placeholderImage: 远程图片没有加载完成的占位图片 options: 一个位移枚举(SDWebImageOptions)，可以通过按位或 | 来并列添加参数。SDWebImageOptions的所有选项如下 1234567891011121314151617181920212223242526272829303132//失败后重试SDWebImageRetryFailed = 1 &lt;&lt; 0, //UI交互期间开始下载，导致延迟下载比如UIScrollView减速。SDWebImageLowPriority = 1 &lt;&lt; 1, //只进行内存缓存SDWebImageCacheMemoryOnly = 1 &lt;&lt; 2, //这个标志可以渐进式下载,显示的图像是逐步在下载SDWebImageProgressiveDownload = 1 &lt;&lt; 3, //刷新缓存SDWebImageRefreshCached = 1 &lt;&lt; 4, //后台下载SDWebImageContinueInBackground = 1 &lt;&lt; 5, //NSMutableURLRequest.HTTPShouldHandleCookies = YES;SDWebImageHandleCookies = 1 &lt;&lt; 6, //允许使用无效的SSL证书//SDWebImageAllowInvalidSSLCertificates = 1 &lt;&lt; 7, //优先下载SDWebImageHighPriority = 1 &lt;&lt; 8, //延迟占位符SDWebImageDelayPlaceholder = 1 &lt;&lt; 9, //改变动画形象SDWebImageTransformAnimatedImage = 1 &lt;&lt; 10, progress: Block 获取当前图片数据的下载进度 receivedSize：已经下载完成的数据大小 expectedSize：该文件的数据总大小 completed: Block加载完 image:下载得到的图片数据 error:下载出现的错误信息 SDImageCacheType：图片的缓存策略 imageURL：下载的图片的url地址 引入UIImageView+WebCache类别就可以使用SDWebImage加载图片 1#import &quot;UIImageView+WebCache.h&quot; 不同参数方法使用🌰 12345678910111213141516171819[self.imageView sd_setImageWithURL: url];[self.imageView sd_setImageWithURL: url completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123; NSLog(@&quot;图片加载完&quot;);&#125;];[self.imageView sd_setImageWithURL:url placeholderImage:[UIImage imageNamed:@&quot;apple&quot;]];[self.imageView sd_setImageWithURL:url placeholderImage:[UIImage imageNamed:@&quot;apple&quot;] completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123; NSLog(@&quot;图片加载完&quot;);&#125;];[self.imageView sd_setImageWithURL:url placeholderImage:[UIImage imageNamed:@&quot;apple&quot;] options: SDWebImageCacheMemoryOnly];[self.imageView sd_setImageWithURL:url placeholderImage:nil options:0 progress:^(NSInteger receivedSize, NSInteger expectedSize, NSURL * _Nullable targetURL) &#123; //计算当前图片的下载进度 NSLog(@&quot;下载进度:%.2f&quot;,1.0 *receivedSize / expectedSize);&#125; completed:^(UIImage * _Nullable image, NSError * _Nullable error, SDImageCacheType cacheType, NSURL * _Nullable imageURL) &#123;&#125;]; 图片加载过程 缓存大小12NSInteger *cacheSize = [[SDImageCache sharedImageCache] getSize];NSLog(@&quot;缓存大小：%d&quot;, cacheSize); 清理缓存12345// 清理内存缓存[[SDImageCache sharedImageCache] clearMemory];// 清理磁盘缓存[[SDImageCache sharedImageCache] clearDisk]; 查看缓存完整目录1NSLog(@&quot;%s__%d__|%@&quot;,__FUNCTION__,__LINE__,[[SDImageCache sharedImageCache] defaultCachePathForKey:@&quot;http://img4.duitang.com/uploads/blog/201310/18/20131018213446_smUw4.thumb.600_0.jpeg&quot;]); 代码：SDWebImageDemo 参考：iOS图片加载框架－SDWebImage解读SDWebImage 的简单使用方法iOS开发SDWebImage的基本使用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>SDWebImage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(五)：Cookie的使用]]></title>
    <url>%2F2017%2Fios-network-5.html</url>
    <content type="text"><![CDATA[Cookie在Web开发时是非常常用的客户端（浏览器）保存少量信息一种方法。Cookie是网站为了便是终端身份，保存在终端本地的用户凭证信息。Cookie中的字段与意义由服务端进行定义。例如，当用户在某个网站进行了登录操作后，服务端会将Cookie信息返回给终端，终端会将这些信息进行保存，在下一次再次访问这个网站时，终端会将保存的Cookie信息一并发送到服务端，服务端根据Cookie信息是否有效来判断此用户是否可以自动登录。 在iOS同样也有Cookie，Cookie管理的有两个类：NSHTTPCookieStorage 和 NSHTTPCookie。 获取Cookie在请求后获取Cookie1234NSHTTPCookieStorage *cookieJar = [NSHTTPCookieStorage sharedHTTPCookieStorage];for (NSHTTPCookie *cookie in [cookieJar cookies]) &#123; NSLog(@&quot;%@&quot;, cookie);&#125; 例如请求百度后，就会返回几个如下Cookie对象(NSHTTPCookie):123456789101112&lt;NSHTTPCookie version:0 name:BD_NOT_HTTPS value:1 expiresDate:&apos;2017-09-23 14:14:22 +0000&apos; created:&apos;2017-09-23 14:09:22 +0000&apos; sessionOnly:FALSE domain:www.baidu.com partition:none path:/ isSecure:FALSE path:&quot;/&quot; isSecure:FALSE&gt; 设置Cookie在请求前设置一个如下Cookie：1234567891011 // 请求前 设置Cookie NSMutableDictionary *cookieProperties = [NSMutableDictionary dictionary]; [cookieProperties setObject:@&quot;andyron&quot; forKey:NSHTTPCookieName]; [cookieProperties setObject:@&quot;1587&quot; forKey:NSHTTPCookieValue]; [cookieProperties setObject:@&quot;andyron.com&quot; forKey:NSHTTPCookieDomain]; [cookieProperties setObject:@&quot;andyron.com&quot; forKey:NSHTTPCookieOriginURL]; [cookieProperties setObject:@&quot;/&quot; forKey:NSHTTPCookiePath]; [cookieProperties setObject:@&quot;0&quot; forKey:NSHTTPCookieVersion]; NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:cookieProperties]; [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];` 在请求后获取的几个Cookie对象（服务器本身设置的和服务器从客户端后去的）中就有如下一个：123456789101112&lt;NSHTTPCookie version:0 name:andyron value:1587 expiresDate:&apos;(null)&apos; created:&apos;2017-09-23 14:43:52 +0000&apos; sessionOnly:TRUE domain:andyron.com partition:none path:/ isSecure:FALSE path:&quot;/&quot; isSecure:FALSE&gt; NSHTTPCookieStorage方法和属性介绍12345678910111213141516171819202122232425262728293031323334//获取单例对象+ (NSHTTPCookieStorage *)sharedHTTPCookieStorage;//所有Cookie数据数组 其中存放NSHTTPCookie对象@property (nullable , readonly, copy) NSArray&lt;NSHTTPCookie *&gt; *cookies;//手动设置一条Cookie数据- (void)setCookie:(NSHTTPCookie *)cookie;//删除某条Cookie信息- (void)deleteCookie:(NSHTTPCookie *)cookie;//删除某个时间后的所有Cookie信息 iOS8后可用- (nullable NSArray&lt;NSHTTPCookie *&gt; *)cookiesForURL:(NSURL *)URL;//获取某个特定URL的所有Cookie数据- (void)removeCookiesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//为某个特定的URL设置Cookie- (void)setCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies forURL:(nullable NSURL *)URL mainDocumentURL:(nullable NSURL *)mainDocumentURL;//Cookie数据的接收协议/*枚举如下：typedef NS_ENUM(NSUInteger, NSHTTPCookieAcceptPolicy) &#123; NSHTTPCookieAcceptPolicyAlways,//接收所有Cookie信息 NSHTTPCookieAcceptPolicyNever,//不接收所有Cookie信息 NSHTTPCookieAcceptPolicyOnlyFromMainDocumentDomain//只接收主文档域的Cookie信息&#125;;*/@property NSHTTPCookieAcceptPolicy cookieAcceptPolicy; 与Cookie相关的通知：12345//Cookie数据的接收协议改变时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerAcceptPolicyChangedNotification;//管理的Cookie数据发生变化时发送的通知FOUNDATION_EXPORT NSString * const NSHTTPCookieManagerCookiesChangedNotification; NSHTTPCookie的方法和属性介绍NSHTTPCookie就是Cookie对象。12345678910111213141516171819202122232425262728293031323334353637383940414243444546//下面两个方法用于对象的创建和初始化 都是通过字典进行键值设置- (nullable instancetype)initWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;+ (nullable NSHTTPCookie *)cookieWithProperties:(NSDictionary&lt;NSString *, id&gt; *)properties;//返回Cookie数据中可用于添加HTTP头字段的字典+ (NSDictionary&lt;NSString *, NSString *&gt; *)requestHeaderFieldsWithCookies:(NSArray&lt;NSHTTPCookie *&gt; *)cookies;//从指定的响应头和URL地址中解析出Cookie数据+ (NSArray&lt;NSHTTPCookie *&gt; *)cookiesWithResponseHeaderFields:(NSDictionary&lt;NSString *, NSString *&gt; *)headerFields forURL:(NSURL *)URL;//Cookie数据中的属性字典@property (nullable, readonly, copy) NSDictionary&lt;NSString *, id&gt; *properties;//请求响应的版本@property (readonly) NSUInteger version;//请求相应的名称@property (readonly, copy) NSString *name;//请求相应的值@property (readonly, copy) NSString *value;//过期时间@property (nullable, readonly, copy) NSDate *expiresDate;//请求的域名@property (readonly, copy) NSString *domain;//请求的路径@property (readonly, copy) NSString *path;//是否是安全传输@property (readonly, getter=isSecure) BOOL secure;//是否只发送HTTP的服务@property (readonly, getter=isHTTPOnly) BOOL HTTPOnly;//响应的文档@property (nullable, readonly, copy) NSString *comment;//相应的文档URL@property (nullable, readonly, copy) NSURL *commentURL;//服务端口列表@property (nullable, readonly, copy) NSArray&lt;NSNumber *&gt; *portList;` 代码：Cookie 参考： IOS中http请求使用cookieiOS网络编程之七——本地用户凭证Cookie的应用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSHTTPCookieStorage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(四)：缓存类NSURLCache介绍]]></title>
    <url>%2F2017%2Fios-network-4.html</url>
    <content type="text"><![CDATA[网络请求中缓存类NSURLCache常用属性和方法：1234567891011121314151617181920212223242526272829303132333435363738394041//获取当前应用的缓存管理对象+ (NSURLCache *)sharedURLCache;//设置自定义的NSURLCache作为应用缓存管理对象+ (void)setSharedURLCache:(NSURLCache *)cache;//初始化一个应用缓存对象/*memoryCapacity 设置内存缓存容量diskCapacity 设置磁盘缓存容量path 磁盘缓存路径内容缓存会在应用程序退出后 清空 磁盘缓存不会*/- (instancetype)initWithMemoryCapacity:(NSUInteger)memoryCapacity diskCapacity:(NSUInteger)diskCapacity diskPath:(nullable NSString *)path;//获取某一请求的缓存- (nullable NSCachedURLResponse *)cachedResponseForRequest:(NSURLRequest *)request;//给请求设置指定的缓存- (void)storeCachedResponse:(NSCachedURLResponse *)cachedResponse forRequest:(NSURLRequest *)request;//移除某个请求的缓存- (void)removeCachedResponseForRequest:(NSURLRequest *)request;//移除所有缓存数据- (void)removeAllCachedResponses;//移除某个时间起的缓存设置- (void)removeCachedResponsesSinceDate:(NSDate *)date NS_AVAILABLE(10_10, 8_0);//内存缓存容量大小@property NSUInteger memoryCapacity;//磁盘缓存容量大小@property NSUInteger diskCapacity;//当前已用内存容量@property (readonly) NSUInteger currentMemoryUsage;//当前已用磁盘容量@property (readonly) NSUInteger currentDiskUsage; 参考：iOS网络编程之六——数据缓存类NSURLCache使用解析]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLCache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(三)：请求类NSURLRequest和请求响应类NSURLResponse介绍]]></title>
    <url>%2F2017%2Fios-network-3.html</url>
    <content type="text"><![CDATA[NSURLSession和NSURLConnection框架，网络请求都是通过NSURLRequest类发起的。 NSURLRequest请求类除了在初始化时可以设定一些属性，创建出来后则大部分属性都为只读的，无法设置与修改。NSMutableURLRequest相对而言可以更加灵活的设置请求的相关属性（属性修饰符变化），其他方面没有多少区别。 一、NSURLRequest类中常用方法和属性类方法：12345// 创建的请求对象 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s+ (instancetype)requestWithURL:(NSURL *)URL;// 创建的请求对象 创建时设置缓存逻辑和超时时限+ (instancetype)requestWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval; 实例方法：12345// init方法进行对象的创建 默认使用NSURLRequestUseProtocolCachePolicy缓存逻辑 默认请求超时时限为60s- (instancetype)initWithURL:(NSURL *)URL;// init方法进行对象的创建- (instancetype)initWithURL:(NSURL *)URL cachePolicy:(NSURLRequestCachePolicy)cachePolicy timeoutInterval:(NSTimeInterval)timeoutInterval; 属性：1234567891011121314151617181920// 判断是否支持安全编码@property (class, readonly) BOOL supportsSecureCoding;// 只读属性 获取请求对象的URL@property (nullable, readonly, copy) NSURL *URL;// 只读属性 缓存策略@property (readonly) NSURLRequestCachePolicy cachePolicy;//只读属性 获取请求的超时时限@property (readonly) NSTimeInterval timeoutInterval;//主文档地址 这个地址用来存放缓存@property (nullable, readonly, copy) NSURL *mainDocumentURL;// 获取网络请求的服务类型@property (readonly) NSURLRequestNetworkServiceType networkServiceType;//获取是否允许使用服务商蜂窝网络@property (readonly) BOOL allowsCellularAccess; 缓存策略NSURLRequestCachePolicy:12345678910111213141516171819202122232425262728293031typedef NS_ENUM(NSUInteger, NSURLRequestCachePolicy)&#123; //默认的缓存协议 NSURLRequestUseProtocolCachePolicy = 0, //无论有无本地缓存数据 都进行从新请求 NSURLRequestReloadIgnoringLocalCacheData = 1, //忽略本地和远程的缓存数据 未实现的策略 NSURLRequestReloadIgnoringLocalAndRemoteCacheData = 4, //无论有无缓存数据 都进行从新请求 NSURLRequestReloadIgnoringCacheData = NSURLRequestReloadIgnoringLocalCacheData, //先检查缓存 如果没有缓存再进行请求 NSURLRequestReturnCacheDataElseLoad = 2, //类似离线模式，只读缓存 无论有无缓存都不进行请求 NSURLRequestReturnCacheDataDontLoad = 3, //未实现的策略 NSURLRequestReloadRevalidatingCacheData = 5, // Unimplemented&#125;; 网络请求的服务类型枚举NSURLRequestNetworkServiceType:12345678910111213typedef NS_ENUM(NSUInteger, NSURLRequestNetworkServiceType)&#123; NSURLNetworkServiceTypeDefault = 0, // Standard internet traffic NSURLNetworkServiceTypeVoIP = 1, // Voice over IP control traffic NSURLNetworkServiceTypeVideo = 2, // Video traffic NSURLNetworkServiceTypeBackground = 3, // Background traffic NSURLNetworkServiceTypeVoice = 4 // Voice data&#125;; 二、与HTTP/HTTPS协议相关请求的属性和方法这些属性属于NSMutableURLRequest: 1234567891011121314151617181920212223// HPPT请求方式 默认为“GET”@property (copy) NSString *HTTPMethod;//通过字典设置HTTP请求头的键值数据@property (nullable, copy) NSDictionary&lt;NSString *, NSString *&gt; *allHTTPHeaderFields;//设置http请求头中的字段值- (void)setValue:(nullable NSString *)value forHTTPHeaderField:(NSString *)field;//向http请求头中添加一个字段- (void)addValue:(NSString *)value forHTTPHeaderField:(NSString *)field;//设置http请求体 用于POST请求@property (nullable, copy) NSData *HTTPBody;//设置http请求体的输入流@property (nullable, retain) NSInputStream *HTTPBodyStream;//设置发送请求时是否发送cookie数据@property BOOL HTTPShouldHandleCookies;//设置请求时是否按顺序收发 默认禁用 在某些服务器中设为YES可以提高网络性能@property BOOL HTTPShouldUsePipelining; 三、NSURLResponse网络请求成功后，服务器响应信息会存存放在NSURLResponse和其子类NSHTTPURLResponse中: 1234567891011121314151617181920//请求的URL地址@property (nullable, readonly, copy) NSURL *URL;//返回数据的数据类型@property (nullable, readonly, copy) NSString *MIMEType;//获取返回数据的内容长度@property (readonly) long long expectedContentLength;//获取返回数据的编码方式@property (nullable, readonly, copy) NSString *textEncodingName;//返回拼接的数据文件名 以url为名 数据没醒MIMEType为扩展名@property (nullable, readonly, copy) NSString *suggestedFilename;//请求的状态码@property (readonly) NSInteger statusCode;//请求头中所有的字段@property (readonly, copy) NSDictionary *allHeaderFields; 参考：iOS网络编程之四——请求类NSURLRequest使用详解iOS网络编程之五——请求回执类NSURLResponse属性简介]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLRequest</tag>
        <tag>NSURLResponse</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(二)：NSURLConnection介绍]]></title>
    <url>%2F2017%2Fios-network-2.html</url>
    <content type="text"><![CDATA[NSURLConnection在iOS7之后基本被NSURLSession，但为了兼容，有必要学习一下。 网络请求分为同步和异步两种： 同步是指在请求结果返回之前，程序代码会卡在请求处，之后的代码不会被执行，请求返回结果后，之后的代码再执行。 异步是指在发送请求之后，一边在子线程中接收返回数据，一边执行之后的代码，当返回数据接收完毕后，采用回调的方式通知主线程做处理。 一、NSURLConnection同步请求12345678// 同步- (void)tongbu &#123; NSURL * url = [NSURL URLWithString:@&quot;https://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; NSData * data = [NSURLConnection sendSynchronousRequest:request returningResponse:nil error:nil]; NSLog(@&quot;%@&quot;,data); NSLog(@&quot;继续执行&quot;);&#125; 而、NSURLConnection异步请求 block方式的异步请求 12345678910// block的异步- (void)yibu &#123; NSURL * url = [NSURL URLWithString:@&quot;https://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; //其中的queue参数决定block中的代码在哪个队列中执行 [NSURLConnection sendAsynchronousRequest:request queue:[NSOperationQueue mainQueue] completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) &#123; NSLog(@&quot;%@&quot;,data); &#125;]; NSLog(@&quot;继续执行&quot;);&#125; 代理回调方式的异步请求采用协议和声明一个用户接受数据的可变NSData： 1234@interface ViewController ()&lt;NSURLConnectionDataDelegate&gt;&#123; NSMutableData * _data;&#125; 请求代码：1234567// 代理回调的异步- (void)yibu_delegate &#123; _data = [[NSMutableData alloc]init]; NSURL * url = [NSURL URLWithString:@&quot;https://www.baidu.com&quot;]; NSURLRequest * request = [NSURLRequest requestWithURL:url]; [NSURLConnection connectionWithRequest:request delegate:self];&#125; 实现代理方法：123456789101112131415161718-(void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response&#123; //开始接收数据 [_data setLength:0]; NSLog(@&quot;%s&quot;,&quot;开始接收数据&quot;);&#125;-(void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data&#123; //正在接收数据 [_data appendData:data]; NSLog(@&quot;%s&quot;,&quot;正在接收数据&quot;);&#125;-(void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error&#123; //接收数据失败 NSLog(@&quot;%@&quot;,error);&#125;-(void)connectionDidFinishLoading:(NSURLConnection *)connection&#123; //接收数据完成 NSLog(@&quot;%@&quot;,_data);&#125; 代码：NSURLConnection 参考：iOS网络编程之三——NSURLConnection的简单使用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLConnection</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS网络编程(一)：NSURLSession介绍]]></title>
    <url>%2F2017%2Fios-network-1.html</url>
    <content type="text"><![CDATA[NSURLSession是iOS7之后被用来代替NSURLConnection的网络开发框架，前者相对于后者的优势是支持后台处理能力 NSURLSession的配置通过NSURLSessionConfiguration来配置Session的三种类型： Default：提供前台请求相关方法，支持配置缓存，身份凭证等。 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration]; Ephemeral类型：即时的请求类型，不使用缓存，身份凭证等。 NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration ephemeralSessionConfiguration]; Background：后台类型，支持在后台完成请求任务。 NSURLSessionConfiguration * backgroundConfiguration = [NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;com.andyron.NSURLSession-delegate-&quot;]; backgroundSessionConfigurationWithIdentifier只是标识符。 NSURLSessionConfiguration还可以配置如缓存，网络模式等参数。 NSURLSession的两种进行网络请求方式 通过block的方式获取网络数据 123456789101112//创建session配置对象NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];//创建请求对象NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]];//创建session对象NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration];//添加任务NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123; NSLog(@&quot;%@&quot;,response);&#125;];//开始任务[task resume]; 在block中进行数据处理 通过代理回调获取网络数据 首先采用协议 NSURLSessionDataDelegate123@interface ViewController ()&lt;NSURLSessionDataDelegate&gt;@end 配置 1234567NSURLSessionConfiguration * defaultConfiguration = [NSURLSessionConfiguration defaultSessionConfiguration];NSURLRequest * request = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]];NSURLSession * defaultSession = [NSURLSession sessionWithConfiguration:defaultConfiguration delegate:self delegateQueue:[NSOperationQueue mainQueue]];NSURLSessionTask * task= [defaultSession dataTaskWithRequest:request];[task resume]; 实现代理方法 12345678//开始接受数据-(void)URLSession:(NSURLSession *)session dataTask:(NSURLSessionDataTask *)dataTask didReceiveData:(NSData *)data&#123; NSLog(@&quot;=======%@&quot;,data);&#125;//接受数据结束-(void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error&#123; NSLog(@&quot;完成：error%@&quot;,error);&#125; 后台处理下载任务这是NSURLSession最大的优势。使用代理的方式进行后台处理下载任务。配置和代理方式相同，主要是实现一些代理方法。 下载进度监听的代理方法： 12345// 下载进度监听- (void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite&#123; NSLog(@&quot;######&quot;);&#125; 在下载过程中点击Home键使应用程序进入后台，下载任务依然在进行，当后台下载完成后会与AppDelegate进行交互，会调用AppDelegate中的代理方法 123-(void)application:(UIApplication *)application handleEventsForBackgroundURLSession:(NSString *)identifier completionHandler:(void (^)(void))completionHandler&#123; NSLog(@&quot;下载任务在后台完成&quot;);&#125; 下载完成后，可查看下载的文件所在位置 1234//此方法只有下载成功才会调用， 文件放在location位置-(void)URLSession:(NSURLSession *)session downloadTask:(NSURLSessionDownloadTask *)downloadTask didFinishDownloadingToURL:(NSURL *)location&#123; NSLog(@&quot;下载临时文件的位置%@&quot;, location);&#125; 在后台完成无人所有任务时调用 12345// 后台所有任务都完成-(void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session&#123; NSLog(@&quot;All tasks are finished&quot;);&#125; 代码：NSURLSession(delegate), NSURLSession(block)深入学习：URL Session Programming Guide 参考iOS网络编程之二——NSURLSession的简单使用]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>NSURLSession</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Charles抓取iOS的http/https请求数据]]></title>
    <url>%2F2017%2Fios-charles.html</url>
    <content type="text"><![CDATA[关于Charles不做多的介绍了，Charles官网一句话介绍简单明了： Web Debugging Proxy Application for Windows, Mac OS and Linux 一、安装Charleshttps://www.charlesproxy.com/download/ 二、安装Charles根证书打开Charles，在菜单栏的Help中操作： 在钥匙串访问中把Charles的根证书设置为信任： 三、在iOS设备上配置证书 首先在Charles点击 会弹出以一个提示框： 有的版本也会弹出不一样的，比如我的： 没关系，到系统网络查看iP 配置手机网络的HTTP代理为手动，然后更改服务器为电脑的IP，端口为8888. 注意：电脑和手机要在同一局域网内。 手机浏览器中输入 charlesproxy.com/getssl 安装证书 之前如果出现如下，选择允许即可： **此时已经可以抓取iOS的http请求数据了： Structure 按照域名分类显示。sequence按照时间选项分类显示。 域名前面的符合表示请求是否加密了 四、抓取HTTPS请求选择如下： 在弹框中添加，需要查看https请求的域名： 比如我添加了知乎的，查看 知乎首页动态对应的接口： 提醒：不抓包时，把手机的http代理改为自动 手机，电脑，Charles的环境不同可能有所不同，我的环境：Charles v4.0.1macOS Sierra 10.12.6iPhone 6s iOS 11.0 参考：十分钟学会Charles抓包(iOS的http/https请求)使用 Charles 获取 https 的数据]]></content>
      <tags>
        <tag>Charles</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习13：文件加载与保存]]></title>
    <url>%2F2017%2Foc-basic-13.html</url>
    <content type="text"><![CDATA[1 属性列表(property list, plist)属性列表可以保存的类型有NSArray,NSDictionary,NSString,NSNumber,NSDate,NSDate以及它们对应的Mutable类。 NSDate 1234NSDate *date = [NSDate date];NSLog(@&quot;today is %@&quot;, date);NSDate *yesterday = [NSDate dateWithTimeIntervalSinceNow: -(24*3600)];NSLog(@&quot;yesterday is %@&quot;, yesterday); NSDateFormatter用来处理时间格式 NSData 123456const *string = &quot;Hi there, this is a C string!&quot;;NSData *data = [NSData dataWithBytes: string length: strlen(string)+1];NSLog(@&quot;data is %@&quot;, data);// data is &lt;48692074 68657265 2c207468 69732069 73206120 43207374 72696e67 2100&gt;NSLog(@&quot;%lu byte string is &apos;%s&apos;&quot;, [data length], [data bytes]);// 30 byte string is &apos;Hi there, this is a C string!&apos; 写入和读取属性列表 写入123NSArray *phrase;phrase = [NSArray arrayWithObjects:@&quot;I&quot;, @&quot;seem&quot;, @&quot;to&quot;, @&quot;be&quot;, @&quot;a&quot;, @&quot;verb&quot;, nil];[phrase writeToFile:@&quot;/tmp/verbiage.txt&quot; atomically:YES]; verbiage.txt内容为：123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;&lt;plist version=&quot;1.0&quot;&gt;&lt;array&gt; &lt;string&gt;I&lt;/string&gt; &lt;string&gt;seem&lt;/string&gt; &lt;string&gt;to&lt;/string&gt; &lt;string&gt;be&lt;/string&gt; &lt;string&gt;a&lt;/string&gt; &lt;string&gt;verb&lt;/string&gt;&lt;/array&gt;&lt;/plist&gt; Mac电脑系统中 ~/Library/Preferences下的所有首选项文件和/System/Library/LaunchDaemons/下的系统配置文件都是plist 读取123NSArray *phrase2;phrase2 = [NSArray arrayWithContentsOfFile:@&quot;/tmp/verbiage.txt&quot;];NSLog(@&quot;%@&quot;, phrase2); -writeToFile:atomically:方法中的atomically表示是否首先将文件内容保存在临时文件中，再将临时文件和原始文件交换。 修改对象类型NSPropertyListSerialization 2 编码对象无法将对象信息表示为属性列表类。编码和解码(encoding and decoding) 和 序列化与反序列化(serialization and deserialization) 必须采用NSCoding协议在Interface Builder中的的对象就被序列化保存到磁盘中了。NSCoding定义两个方法，用于对象与NSDate之间的转换：123456@protocol NSCoding- (void)encodeWithCoder:(NSCoder *)aCoder;- (nullable instancetype)initWithCoder:(NSCoder *)aDecoder; // NS_DESIGNATED_INITIALIZER@end 一个列子123456789101112131415161718@interface Thingie : NSObject &lt;NSCoding&gt;&#123; NSString *name; int magicNumber; float shoeSize; NSMutableArray *subThingies;&#125;@property (copy) NSString *name;@property int magicNumber;@property float shoeSize;@property (retain) NSMutableArray *subThingies;- (id)initWithName: (NSString *) n magicNumber: (int) mn shoeSize: (float) ss;@end // Thingie Thingie采用了NSCoding协议，要实现编码和解码响应的方法。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162@implementation Thingie@synthesize name;@synthesize magicNumber;@synthesize shoeSize;@synthesize subThingies;- (id)initWithName: (NSString *) n magicNumber: (int) mn shoeSize: (float) ss&#123; if (self = [super init]) &#123; self.name = n; self.magicNumber = mn; self.shoeSize = ss; self.subThingies = [NSMutableArray array]; &#125; return (self);&#125;- (void) encodeWithCoder: (NSCoder *) coder&#123; [coder encodeObject: name forKey: @&quot;name&quot;]; [coder encodeInt: magicNumber forKey: @&quot;magicNumber&quot;]; [coder encodeFloat: shoeSize forKey: @&quot;shoeSize&quot;]; [coder encodeObject: subThingies forKey: @&quot;subThingies&quot;]; &#125; // encodeWithCoder- (id) initWithCoder: (NSCoder *) decoder&#123; if (self = [super init]) &#123; self.name = [decoder decodeObjectForKey: @&quot;name&quot;]; self.magicNumber = [decoder decodeIntForKey: @&quot;magicNumber&quot;]; self.shoeSize = [decoder decodeFloatForKey: @&quot;shoeSize&quot;]; self.subThingies = [decoder decodeObjectForKey: @&quot;subThingies&quot;]; &#125; return (self); &#125; // initWithCoder- (NSString *) description&#123; NSString *description = [NSString stringWithFormat: @&quot;%@: %d/%.1f %@&quot;, name, magicNumber, shoeSize, subThingies]; return (description); &#125; // description@end // Thingie]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习12：代码块（Block）]]></title>
    <url>%2F2017%2Foc-basic-12.html</url>
    <content type="text"><![CDATA[代码块(Block)/闭包(closure) 是对C语言中函数的扩展。代码块两种类的绑定：自动绑定(automatic binding) 栈内存托管绑定(managed binding) 堆内存 代码块和函数指针函数指针的声明：void (*my_func)(void);*变成^（幂符号）变成代码块定义：void (^my_block)(void); 代码块展示： 123int (^square_block)(int number) = ^(int number) &#123;return (number * number);&#125;;int result = square_block(5);printf(&quot;Result = %d\n&quot;, result); 等号前面是代码块的定义，而等号后面是实现内容。一般形式： 1&lt;returntype&gt; (^blockname)(list of arguments) = ^(arguments)&#123; body; &#125;; 没有参数时可以简写： 1void (^theBlock)(void) = ^&#123; printf(&quot;Hello Blocks!\n&quot;); &#125;; 使用代码块代码块可以访问与它相同的（本地）有效范围内声明的变量。 12345int value = 6;int (^multiply_block)(int number) = ^(int number) &#123; return (value * number);&#125;;value = 8;int result2 = multiply_block(7);printf(&quot;Result2 = %d\n&quot;, result2); // 是6*7，不是8*7 直接使用代码块 123456NSArray *array = [NSArray arrayWithObjects:@&quot;Amir&quot;, @&quot;Mishal&quot;, @&quot;Irrum&quot;, @&quot;Adam&quot;, nil];NSLog(@&quot;Unsorted Array %@&quot;, array);NSArray *sorteArray = [array sortedArrayUsingComparator:^(NSString *objet1, NSString *object2) &#123; return [objet1 compare:object2];&#125;];NSLog(@&quot;Sorted Array %@&quot;, sorteArray); 使用typedef关键字 12345typedef double (^MKSampleMultiply2BlockRef)(double c, double d);MKSampleMultiply2BlockRef multiply2 = ^(double c, double d) &#123; return c * d; &#125;;printf(&quot;%f, %f&quot;, multiply2(4, 5), multiply2(5,3));typedef void (^MKSampleVoidBlockRef)(void);typedef void (^MKSampleStringBlockRef)(NSString *); 代码块和变量代码块被声明后会捕捉创建点时的状态。代码块可以访问函数用到的标准类的变量： 全局变量，包括封闭范围内声明的本地静态变量。 全局函数 封闭范围内的参数 函数级别（即与代码块声明时相同的级别）的_block变量。 封闭范围内的非静态变量会被获取为常量。 Objective-C的实例变量 代码块内部的本地变量 本地变量 12345678typedef double (^MKSampleMultiplyBlockRef)(void);double a = 10, b = 20;MKSampleMultiplyBlockRef multiply = ^(void)&#123; return a * b; &#125;;NSLog(@&quot;%f&quot;, multiply()); // 200.0a = 20;b = 50;NSLog(@&quot;%f&quot;, multiply()); // 200.0 全局变量 1234567typedef double (^MKSampleMultiplyBlockRef)(void);static double a = 10, b = 20;MKSampleMultiplyBlockRef multiply = ^(void)&#123; return a * b; &#125;;NSLog(@&quot;%f&quot;, multiply()); // 200.0a = 20; b = 50;NSLog(@&quot;%f&quot;, multiply()); // 1000.0 参数变量代码块中的参数变量与函数中的参数变量具有同样的作用。 123typedef double (^MKSampleMultiply2BlockRef)(double c, double d);MKSampleMultiply2BlockRef multiply2 = ^(double c, double d) &#123; return c * d; &#125;;printf(&quot;%f, %f&quot;, multiply2(4, 5), multiply2(5,3)); __block变量本地变量会被代码块作为常量获取到。在代码块中修改会报错。 123double c = 3;MKSampleMultiplyBlockRef multiply = ^(void) &#123; c = 5; return c; &#125;;//报错： Variable is not assignable (missing __block type specifier) 将本地变量标记为__block，就可以修改了 12__block double c = 3;MKSampleMultiplyBlockRef multiply = ^(void) &#123; c = 5; return c; &#125;; 代码块内部的本地变量]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习11：协议]]></title>
    <url>%2F2017%2Foc-basic-11.html</url>
    <content type="text"><![CDATA[1 正式协议 声明协议 123@protocol NSCoding- (id) copyWithZone: (NSZone *) zone;@end 继承父协议：12@protocol MySuperDuberProtocol &lt;MyParentProtocol&gt;@end 采用协议 123456@interface Car ：NSObject &lt;NSCopying, NSCoding&gt;&#123;// instance variables&#125;// methods@end // Car 实现协议 2 复制浅层复制深层复制 3 @optional @required4 委托方法委托(delegation)是某个对象指定另一个对象处理某些特定任务的设计模式。委托经常与协议共用。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习10：类别（category）]]></title>
    <url>%2F2017%2Foc-basic-10.html</url>
    <content type="text"><![CDATA[类别（category）是一种为现有的类添加新方法的方式。 1 创建类别一般，只是习惯 把类别代码放在独立的文件中命名：”类名称+类别名称”，如 NSString+NumberConvenience 开始创建类别 生成两个文件，NSString+NumberConvenience.h:12345#import &lt;Foundation/Foundation.h&gt;@interface NSString (NumberConvenience)@end NSString+NumberConvenience.m:12345#import &quot;NSString+NumberConvenience.h&quot;@implementation NSString (NumberConvenience)@end 类别名在括号中。可以在@implementation部分实现自己的方法。任何NSString类的对象都将响应在类别中的方法。正是这种兼容性使类别成为了一种非常强大的概念。 类别的缺陷 文法向类中添加新的实例变量。 名称冲突。类别中的方法与现有的方法重名时，类别中的方法会替代现有的方法。（可在类别名称加前缀） 类别的优势 将类的实现分散到多个不同文件或多个不同框架中 创建对私有方法的前向引用 向对象添加非正式协议 类扩展（class extentsion）：特殊的类别 12345678@interface Things : NSObject@property (assign) NSInteger thing1;@property (readonly, assign) NSInteger thing2;- (void)resetAllValues;@end 12345678@interface Things()&#123; NSInteger thing4; &#125;@property (readwrite, assign) NSInteger thing2;@property (assign) NSInteger thing3;@end 2 利用类别分散实现代码不能将@implementation分散到多个不同的.m文件中。可以通过类别把大型的单个类分散到多个不同的.m文件中。以AppKit中的NSWindow为例，在NSWindow.h中搜索@interface大约能搜到5个类别声明：12345@interface NSWindow(NSEvent)@interface NSWindow(NSCursorRect)@interface NSWindow(NSDrag)@interface NSWindow(NSCarbonExtensions)@interface NSWindow(NSDeprecated) 类别可以访问其继承的类的实例变量。 3 通过类别创建前向引用没有真正的私有方法。不在头文件声明，也可以调用，不过编译器会提示警告，并且app store会拒绝上架。可通过在类别中声明方法避免这种警告。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习9：属性]]></title>
    <url>%2F2017%2Foc-basic-9.html</url>
    <content type="text"><![CDATA[1 使用属性 接口代码简化没有使用属性：12345678910111213#import &quot;Tire.h&quot;@interface AllWeatherRadial : Tire&#123; // 轮胎在潮湿和积雪的道路上的性能 float rainHandling; float snowHandling;&#125;- (void) setRainHandling:(float)rainHandling;- (float) rainHandling;- (void) setSnowHandling:(float)snowHandling;- (float) snowHandling;@end 使用属性：1234567891011@interface AllWeatherRadial : Tire&#123; // 轮胎在潮湿和积雪的道路上的性能 float rainHandling; float snowHandling;&#125;@property float rainHandling;@property float snowHandling;@end @ property预编译指令的作用是自动声明属性的setter和getter方法。 简化实现代码之前：123456789101112131415161718192021222324252627282930313233343536#import &quot;AllWeatherRadial.h&quot;@implementation AllWeatherRadial-(NSString *)description&#123;// return (@&quot;I am a tire for rain or shine.&quot;); NSString *desc; desc = [[NSString alloc] initWithFormat:@&quot;AllWeatherRadial: %.1f / %.1f / %.1f / %.1f.&quot;, self.pressure, self.treadDepth, self.rainHandling, self.snowHandling]; return desc;&#125;- (void)setRainHandling:(float)r&#123; rainHandling = r;&#125;- (float)rainHandling&#123; return rainHandling;&#125;- (void)setSnowHandling:(float)s&#123; snowHandling = s;&#125;- (float)snowHandling&#123; return snowHandling;&#125;- (id) initWithPressure:(float)p treadDepth:(float)td&#123; if (self = [super initWithPressure:p treadDepth:td]) &#123; rainHandling = 23.7; snowHandling = 58.1; &#125; return self;&#125;@end 使用属性后的实现代码：1234567891011121314151617181920212223#import &quot;AllWeatherRadial.h&quot;@implementation AllWeatherRadial@synthesize rainHandling;@synthesize snowHandling;-(NSString *)description&#123; NSString *desc; desc = [[NSString alloc] initWithFormat:@&quot;AllWeatherRadial: %.1f / %.1f / %.1f / %.1f.&quot;, self.pressure, self.treadDepth, self.rainHandling, self.snowHandling]; return desc;&#125;- (id) initWithPressure:(float)p treadDepth:(float)td&#123; if (self = [super initWithPressure:p treadDepth:td]) &#123; rainHandling = 23.7; snowHandling = 58.1; &#125; return self;&#125;@end @synthesize预编译指令表示通知编译器生成访问方法。当遇到@synthesize xxx；这行代码时，编译器将添加实现-setXxx：和-xxx方法的预编译代码。 该@synthesize预编译指令不同于代码生成。你永远看不到实现-setXxx：和-xxx的代码，但是这些方法确实存在并可以被调用。这种技术使苹果公司可以更加灵活地改变Objective-C中生成访问方法的方式，并获得更安全的实现和更高的的性能。在Xcode4.5以后的版本中，可以不必使用@synthesize了。 所有的属性都是基于变量的，在@synthesize时，编译器会自动创建与属性名称相同的实例变量。 实例变量声明位置： 头文件：有子类，想从子类直接通过属性访问变量。 实现文件：变量只属于当前类。 点表达式之前的[tire setPressure:23+i];可相应变为：tire.rainHandling = 23+i; 2 属性扩展 实例变量和属性不是同一个名称12345678@interface Car : NSObject&#123; NSMutableArray *tires; Engine *engine; NSString *appellation;&#125;@property (copy) NSString *name;@property (retain) Engine *engine; 修改@synthesize指令为： @synthesize name = appellation;编译器仍将创建-setName:和-name方法，但在其实现代码中用的确实appellation实例变量。 只读属性readwrite readonly属性为只读时，编译器只会生成一个getter方法。 属性不支持那些需要接收额外参数的方法。如car对象中tire对象的代码。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习8：对象初始化]]></title>
    <url>%2F2017%2Foc-basic-8.html</url>
    <content type="text"><![CDATA[1 分配(allocation)对象alloc方法干的事件： 1 从操作系统获得一块内存。2 指定为存储对象的实例变量的位置。3 对内存初始化：BOOL类型被初始化为：NO；int类型被初始化为：0；float类型被初始化为：0.0；所有指针被初始化为nil。 初始化对象init方法Car *car = [[Car alloc] init]; 初始化要做些什么 CarParts程序中初始car对象是，init方法中创建engine对象和全部4个tire对象 懒性求值(lazy evaluation)，只为engine对象和tire对象预留位置 2 便利初始化函数(convenience initializer)以init开头的方法只是遵循命名约定的普通方法。NSString类的初始化方法例子： - (id) init; NSString *emptyString = [[NSString alloc] init]; - (instancetype)initWithFormat:(NSString *)format, ... NS_FORMAT_FUNCTION(1,2); NSString *string = [[NSString alloc] initWithFormat:@&quot;%d or %d&quot;, 1, 2]; - (nullable instancetype)initWithContentsOfFile:(NSString *)path encoding:(NSStringEncoding)enc error:(NSError **)error; NSError *error = nil; NSString *string1 = [[NSString alloc] initWithContentsOfFile:@&quot;/tmp/words.txt&quot; encoding:NSUTF8StringEncoding error:&amp;error]; if (nil != error) { NSLog(@&quot;未能读取文件数据：%@&quot;, [error localizedDescription]); } 3 指定初始化函数(designated initializer) 类中的某个初始化方法被指派为指定初始化函数 该类的所有初始化方法都使用指定初始化函数执行初始化操作 子类使用期超类的指定初始化函数进行超类的初始化 通常，接受参数最多的初始化方法是最终的指定的初始化函数]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS与JS(二)：MessageHandler(OC&Swift)]]></title>
    <url>%2F2017%2Fios-js-2.html</url>
    <content type="text"><![CDATA[iOS与JS的相互调用除了URL拦截（iOS与JS(一)：使用URL拦截的方式进行JS与OC互相调用）外，还可以使用WKWebView的中的MessageHandler来实现。 MessageHandler是什么呢？以代码来说明，比较好理解。在OC中初始化WKWebView是，添加如下代码:[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Location&quot;];那么在JS中就可以使用：window.webkit.messageHandlers.Location.postMessage(null);JS中的Location就对应OC中的name，postMessage后的参数就是JS传给OC的参数，类型可以是 NSNumber, NSString, NSDate, NSArray, NSDictionary, and NSNull。JS回调OC时，就回调WKScriptMessageHandler的- (void)userContentController:([WKUserContentController](apple-reference-documentation://hcracoR5p2) *)userContentController didReceiveScriptMessage:([WKScriptMessage](apple-reference-documentation://hcD3KQdcJY) *)message;方法，这边的message是WKScriptMessage， message.name就是“Location”，message.body就是postMessage后的参数。 下面看完整的🌰： html的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf8&quot;&gt; &lt;script language=&quot;javascript&quot;&gt; var ctuapp_share_img=&quot;www.baidu.com&quot;; function locationClick() &#123; window.webkit.messageHandlers.Location.postMessage(null); &#125; function shake() &#123; window.webkit.messageHandlers.Shake.postMessage(null); &#125; function payClick()&#123; window.webkit.messageHandlers.Pay.postMessage(&#123;order_no:&apos;201511120981234&apos;,channel:&apos;wx&apos;,amount:1,subject:&apos;粉色外套&apos;&#125;); &#125; function setLocation(location) &#123; alert(location) document.getElementById(&quot;returnValue&quot;).value = location; &#125; function payResult(str) &#123; alert(str); document.getElementById(&quot;returnValue&quot;).value = str; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是按钮调用&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;获取定位&quot; onclick=&quot;locationClick()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;震动一下&quot; onclick=&quot;shake()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;支付&quot; onclick=&quot;payClick()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是文件上传&lt;/h1&gt; &lt;input type=&quot;file&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是回调结果展示区&lt;/h1&gt; &lt;textarea id =&quot;returnValue&quot; type=&quot;value&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; 初始化WKWebView12345678910111213141516171819- (void)initWKWebView&#123; WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init]; WKPreferences *preferences = [WKPreferences new]; preferences.javaScriptCanOpenWindowsAutomatically = YES; preferences.minimumFontSize = 40.0; configuration.preferences = preferences; self.webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration]; NSString *urlStr = [[NSBundle mainBundle] pathForResource:@&quot;index.html&quot; ofType:nil]; NSURL *fileURL = [NSURL fileURLWithPath:urlStr]; [self.webView loadFileURL:fileURL allowingReadAccessToURL:fileURL]; self.webView.UIDelegate = self; [self.view addSubview:self.webView];&#125; 添加 MessageHandler为了防止循环引用，结束时释放。123456789101112131415161718- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; // addScriptMessageHandler 很容易导致循环引用 // 控制器 强引用了WKWebView,WKWebView copy(强引用了）configuration， configuration copy （强引用了）userContentController [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Location&quot;]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Shake&quot;]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Pay&quot;];&#125;- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;Location&quot;]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;Shake&quot;]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;Pay&quot;];&#125; 实现WKUIDelegate和WKScriptMessageHandler协议方法12345678910111213141516171819202122232425#pragma mark - WKUIDelegate- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提醒&quot; message:message preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@&quot;知道了&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(); &#125;]]; [self presentViewController:alert animated:YES completion:nil];&#125;#pragma mark - WKScriptMessageHandler- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123; // message.body -- Allowed types are NSNumber, NSString, NSDate, NSArray,NSDictionary, and NSNull. NSLog(@&quot;body:%@&quot;,message.body); if ([message.name isEqualToString:@&quot;Location&quot;]) &#123; [self getLocation]; &#125; else if ([message.name isEqualToString:@&quot;Shake&quot;]) &#123; [self shakeAction]; &#125; else if ([message.name isEqualToString:@&quot;Pay&quot;]) &#123; [self payWithParams:message.body]; &#125;&#125; 效果： Swift的和OC类型，代码我也一起写了 代码： 90-iOSJS 中的 OCJSMessageHandler 和 SwiftJSMessageHandler 参考：iOS下JS与OC互相调用（三）–MessageHandler]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS与JS(一)：使用URL拦截的方式进行JS与OC互相调用]]></title>
    <url>%2F2017%2Fios-js-1.html</url>
    <content type="text"><![CDATA[关于WKWebView与UIWebView之间的区别，本文就不在说明，本文只使用WKWebView。效果图如下： html代码：12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf8&quot;&gt; &lt;script language=&quot;javascript&quot;&gt; function loadURL(url) &#123; window.location.href = url &#125; function locationClick() &#123; loadURL(&quot;scheme://getLocation&quot;); &#125; function shake() &#123; loadURL(&quot;scheme://shake&quot;); &#125; function setLocation(location) &#123; alert(location) document.getElementById(&quot;returnValue&quot;).value = location; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是按钮调用&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;获取定位&quot; onclick=&quot;locationClick()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;震动一下&quot; onclick=&quot;shake()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是文件上传&lt;/h1&gt; &lt;input type=&quot;file&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是回调结果展示区&lt;/h1&gt; &lt;textarea id =&quot;returnValue&quot; type=&quot;value&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; 以获取定位这个按钮为例说明OC和JS互相调用代码执行流程： 初始化WKWebView加载本地html文件。 点击web中的按钮，web发起URL请求。 URL请求被WKNavigationDelegate中的代理方法拦截。根据自定义的URL识别使用不同的处理方式。如：在- (void)getLocation方法中调用JS的setLocation函数。 JS的setLocation函数执行JS的alert()函数，被WKUIDelegate中的代理方法捕获，调用iOS原生的弹框。 详细代码说明 初始化WKWebView加载本地html文件 123456789101112131415161718192021- (void)initWKWebView&#123; // 1 WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init]; configuration.userContentController = [WKUserContentController new]; WKPreferences *preferences = [WKPreferences new]; preferences.javaScriptCanOpenWindowsAutomatically = YES; preferences.minimumFontSize = 40.0; configuration.preferences = preferences; self.webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration]; // 2 NSString *urlStr = [[NSBundle mainBundle] pathForResource:@&quot;index.html&quot; ofType:nil]; NSURL *fileURL = [NSURL fileURLWithPath:urlStr]; [self.webView loadFileURL:fileURL allowingReadAccessToURL:fileURL]; self.webView.navigationDelegate = self; self.webView.UIDelegate = self; [self.view addSubview:self.webView];&#125; 1 WKWebView的一些参数配置 2 加载本html URL请求被WKNavigationDelegate中的代理方法拦截。也就是JS调用了OC 1234567891011121314#pragma mark - WKNavigationDelegate- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; NSURL *URL = navigationAction.request.URL; NSString *scheme = [URL scheme]; if ([scheme isEqualToString:@&quot;scheme&quot;]) &#123; [self handleCustomAction:URL]; decisionHandler(WKNavigationActionPolicyCancel); return; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; OC 调用 JS 12345678- (void)getLocation&#123; // 将结果返回给js NSString *jsStr = [NSString stringWithFormat:@&quot;setLocation(&apos;%@&apos;)&quot;,@&quot;上海市浦东新区&quot;]; [self.webView evaluateJavaScript:jsStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@&quot;%@----%@&quot;,result, error); &#125;];&#125; JS代码被当成字符串调用 completionHandler是JS代码被调用后回调 JS中alert弹窗被WKUIDelegate中的代理方法捕获，调用iOS原生的弹框。 1234567891011#pragma mark - WKUIDelegate- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提醒&quot; message:message preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@&quot;知道了&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(); &#125;]]; [self presentViewController:alert animated:YES completion:nil];&#125; 最后，html中的文件input可以直接调用iOS的图片库，相机和文件。 代码： 90-iOSJS/OCJS1 参考： iOS下JS与OC互相调用（二）–WKWebView 拦截URL iOS下JS与原生OC互相调用(总结)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS动画(三)：核心动画中缩放和旋转(Swift)]]></title>
    <url>%2F2017%2Fios-animation-3.html</url>
    <content type="text"><![CDATA[原理和上一篇是相同的，不同之处是keyPath属性，缩放时是keyPath是 transform.scale，旋转时keyPath是transform.rotation。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113class ScaleRotationViewController: UIViewController &#123; // 用于缩放的layer lazy var redLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 150), backgroundColor: UIColor.red) &#125;() lazy var greenLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 250), backgroundColor: UIColor.green) &#125;() lazy var cyanLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 350), backgroundColor: UIColor.cyan) &#125;() lazy var blueLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 450), backgroundColor: UIColor.blue) &#125;() // 用于旋转的Layer lazy var redRotationLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 300, y: 150), backgroundColor: UIColor.red) &#125;() lazy var greenRotationLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 300, y: 250), backgroundColor: UIColor.green) &#125;() lazy var cyanRotationLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 300, y: 350), backgroundColor: UIColor.cyan) &#125;() override func viewDidLoad() &#123; super.viewDidLoad() // 添加缩放的动画 redLayer.add(createAnimation(keyPath: &quot;transform.scale.x&quot;, toValue: 0.5), forKey: nil) greenLayer.add(createAnimation(keyPath: &quot;transform.scale.y&quot;, toValue: 0.5), forKey: nil) cyanLayer.add(createAnimation(keyPath: &quot;transform.scale.z&quot;, toValue: 0.5), forKey: nil) blueLayer.add(createAnimation(keyPath: &quot;transform.scale&quot;, toValue: 0.5), forKey: nil) // 添加旋转的动画 redRotationLayer.add(createAnimation(keyPath: &quot;transform.rotation.x&quot;, toValue: CGFloat(Double.pi / 4)), forKey: nil) greenRotationLayer.add(createAnimation(keyPath: &quot;transform.rotation.y&quot;, toValue: CGFloat(Double.pi / 4)), forKey: nil) cyanRotationLayer.add(createAnimation(keyPath: &quot;transform.rotation.z&quot;, toValue: CGFloat(Double.pi / 4)), forKey: nil) self.creatLabel(title: &quot;缩放&quot;, frame: CGRect(x: 100, y: 80, width: 50, height: 20)) self.creatLabel(title: &quot;旋转&quot;, frame: CGRect(x: 250, y: 80, width: 50, height: 20)) self.creatLabel(title: &quot;X轴&quot;, frame: CGRect(x: 20, y: 125, width: 50, height: 20)) self.creatLabel(title: &quot;Y轴&quot;, frame: CGRect(x: 20, y: 225, width: 50, height: 20)) self.creatLabel(title: &quot;Z轴&quot;, frame: CGRect(x: 20, y: 325, width: 50, height: 20)) self.creatLabel(title: &quot;XYZ轴&quot;, frame: CGRect(x: 20, y: 425, width: 50, height: 20)) &#125; // 创建calayer func createLayer (position: CGPoint, backgroundColor: UIColor) -&gt; CALayer &#123; //创建calayer let layer = CALayer() //设置位置和大小 layer.position = position layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100) //设置背景颜色 layer.backgroundColor = backgroundColor.cgColor //把layer添加到UIView的layer上 self.view.layer.addSublayer(layer) return layer &#125; // 创建基础Animation func createAnimation (keyPath: String, toValue: CGFloat) -&gt; CABasicAnimation &#123; //创建动画对象 let scaleAni = CABasicAnimation() //设置动画属性 scaleAni.keyPath = keyPath //设置动画的起始位置。也就是动画从哪里到哪里。不指定起点，默认就从positoin开始 scaleAni.toValue = toValue //动画持续时间 scaleAni.duration = 2; //动画重复次数 scaleAni.repeatCount = Float(CGFloat.greatestFiniteMagnitude) return scaleAni; &#125; //创建Label fileprivate func creatLabel (title: String, frame: CGRect) -&gt; ()&#123; let label = UILabel() label.text = title label.frame = frame label.textColor = UIColor.darkGray label.font = UIFont.systemFont(ofSize: 12) self.view.addSubview(label) &#125;&#125; 代码： 89-Animation/CABasic Animation 参考：第五篇：CABasic Animation。iOS动画系列之五：基础动画之缩放篇&amp;旋转篇]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画(二)：核心动画中的基础移动(Swift)]]></title>
    <url>%2F2017%2Fios-animation-2.html</url>
    <content type="text"><![CDATA[简单的移动 新建一个CALayer。 12345678910lazy var redLayer: CALayer = &#123; return self.createLayer()&#125;()func createLayer() -&gt; CALayer &#123; let redLayer = CALayer() redLayer.position = CGPoint(x: 200, y: 200) redLayer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100) redLayer.backgroundColor = UIColor.red.cgColor return redLayer&#125; 把新建的CALayer添加的view的layer中。 1view.layer.addSublayer(redLayer) 遵守协议CAAnimationDelegate class BasicPostionViewController: UIViewController, CAAnimationDelegate { 创建动画CABasicAnimation,并添加的CALayer中。 12345678910111213141516171819func createCABasicAnimation() -&gt; CABasicAnimation &#123; let basicAni = CABasicAnimation() // 设置动画属性 basicAni.keyPath = &quot;position&quot; basicAni.fromValue = NSValue.init(cgPoint: CGPoint(x: 0, y: 0)) basicAni.toValue = NSValue.init(cgPoint: CGPoint(x: 300, y: 300)) basicAni.duration = 2 basicAni.fillMode = kCAFillModeForwards basicAni.isRemovedOnCompletion = false basicAni.delegate = self return basicAni&#125; 12let basicAni = createCABasicAnimation()self.redLayer.add(basicAni, forKey: &quot;basicPosition&quot;) forKey 是动画对象的名字，只是用来标识，没有特殊意义。 稍微复杂的移动 原理和上面相同，都是先创建CALayer，然后添加CABasicAnimation。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class BasicPostion2ViewController: UIViewController, CAAnimationDelegate&#123; lazy var redLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 150), backgroundColor: UIColor.red) &#125;() lazy var greenLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 250), backgroundColor: UIColor.green) &#125;() lazy var cyanLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 350), backgroundColor: UIColor.cyan) &#125;() lazy var blueLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 450), backgroundColor: UIColor.blue) &#125;() override func viewDidLoad() &#123; super.viewDidLoad() redLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 150), toValue: CGPoint(x: 300, y: 150), timingFunction: kCAMediaTimingFunctionLinear), forKey: &quot;basicAnimation&quot;) view.layer.addSublayer(redLayer) greenLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 250), toValue: CGPoint(x: 300, y: 250), timingFunction: kCAMediaTimingFunctionEaseIn), forKey: &quot;basicAnimation&quot;) view.layer.addSublayer(greenLayer) cyanLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 350), toValue: CGPoint(x: 300, y: 350), timingFunction: kCAMediaTimingFunctionEaseOut), forKey: &quot;basicAnimation&quot;) view.layer.addSublayer(cyanLayer) blueLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 450), toValue: CGPoint(x: 300, y: 450), timingFunction: kCAMediaTimingFunctionEaseInEaseOut), forKey: &quot;basicAnimation&quot;) view.layer.addSublayer(blueLayer) &#125; func createLayer(postion: CGPoint, backgroundColor: UIColor) -&gt; CALayer &#123; let layer = CALayer() layer.position = postion layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100) layer.backgroundColor = backgroundColor.cgColor return layer &#125; func createBasicAnimation (fromValue: CGPoint, toValue: CGPoint, timingFunction: String) -&gt; CABasicAnimation &#123; let basicAni = CABasicAnimation() basicAni.keyPath = &quot;position&quot; basicAni.fromValue = fromValue basicAni.toValue = toValue basicAni.duration = 2 // basicAni.fillMode = kCAFillModeForwards // basicAni.isRemovedOnCompletion = false // 1 basicAni.timingFunction = CAMediaTimingFunction(name: timingFunction) basicAni.delegate = self return basicAni &#125;&#125; 1 timingFunction代表移动模式： kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉 kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开 kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地 kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。 代码： 89-Animation/CABasic Animation 参考： 第三篇：iOS动画系列之三：Core Animation。介绍了Core Animation的常用属性和方法。 第四篇：CABasic Animation。iOS动画系列之四：基础动画之平移篇]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画(一)：时钟动画(Swift)]]></title>
    <url>%2F2017%2Fios-animation-1-clock.html</url>
    <content type="text"><![CDATA[一、直接做动画 新建项目clock 加载表盘图片。在viewDidLoad中添加： 123456let dialLayer = CALayer()dialLayer.bounds = CGRect(x: 0, y: 0, width: 150, height: 150)dialLayer.position = self.view.centerdialLayer.contents = UIImage(named: &quot;clock&quot;)?.cgImageview.layer.addSublayer(dialLayer) 懒加载秒针、分针、时针视图。懒加载机制是Swift中一种存储属性：延迟存储属性，具体可擦看 以撸代码的形式学习Swift-10：Properties 1234567891011121314151617181920212223242526272829303132// 秒针lazy var secondHandView: UIView = &#123; let secondHandView = UIView() secondHandView.backgroundColor = UIColor.red secondHandView.bounds = CGRect(x: 0, y: 0, width: 1, height: 60) secondHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1) return secondHandView&#125;()// 分针lazy var minuteHandView: UIView = &#123; let minuteHandView = UIView() minuteHandView.backgroundColor = UIColor.darkGray minuteHandView.bounds = CGRect(x: 0, y: 0, width: 3, height: 60) minuteHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1) return minuteHandView&#125;()// 时针lazy var hourHandView: UIView = &#123; let hourHandView = UIView() hourHandView.backgroundColor = UIColor.darkGray hourHandView.bounds = CGRect(x: 0, y: 0, width: 3, height: 45) hourHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1) return hourHandView&#125;() 把秒针、分针、时针添加到view中。在viewDidLoad中添加： 123456secondHandView.center = view.centerself.view.addSubview(secondHandView)minuteHandView.center = view.centerself.view.addSubview(minuteHandView)hourHandView.center = view.centerself.view.addSubview(hourHandView) 创建CADisplayLink，并将其添加到主线程中。在viewDidLoad中添加： 12let link = CADisplayLink(target: self, selector: #selector(ViewController.clockRunning))link.add(to: RunLoop.main, forMode: .defaultRunLoopMode) 添加方法clockRunning: 123456789101112131415161718func clockRunning() &#123; let tZone = TimeZone.current var calendar = Calendar.current let currentDate = Date() calendar.timeZone = tZone let currentTime = calendar.dateComponents([Calendar.Component.hour, Calendar.Component.minute, Calendar.Component.second], from: currentDate) // 根据当前秒、分、时数分别计算秒针、分针、时针偏转弧度 let secondAngle = CGFloat ( Double(currentTime.second!) * (Double.pi * 2.0 / 60) ) secondHandView.transform = CGAffineTransform(rotationAngle: secondAngle) let minuteAngle = CGFloat ( Double(currentTime.minute!) * (Double.pi * 2.0 / 60) ) minuteHandView.transform = CGAffineTransform(rotationAngle: minuteAngle) let hourAngle = CGFloat ( Double(currentTime.hour!) * (Double.pi * 2.0 / 12) ) hourHandView.transform = CGAffineTransform(rotationAngle: hourAngle)&#125; 现在就完成了文章开头的效果。 二、代码说明 关于anchorPoint（锚点）如果注释掉分针和时针视图，并且关掉动画效果和锚点设置：123456789// secondHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1)// minuteHandView.center = view.center// self.view.addSubview(minuteHandView)// hourHandView.center = view.center// self.view.addSubview(hourHandView) // 创建CADisplayLink，并将其添加到主线程中// let link = CADisplayLink(target: self, selector: #selector(ViewController.clockRunning))// link.add(to: RunLoop.main, forMode: .defaultRunLoopMode) 加上secondHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1)后： anchorPoint的官方描述： Defines the anchor point of the layer’s bounds rectangle. Animatable.You specify the value for this property using the unit coordinate space. The default value of this property is (0.5, 0.5), which represents the center of the layer’s bounds rectangle. All geometric manipulations to the view occur about the specified point. For example, applying a rotation transform to a layer with the default anchor point causes the layer to rotate around its center. Changing the anchor point to a different location would cause the layer to rotate around that new point. anchorPoint的值在 (0,0) 和 (1,1)之间。默认是 (0.5, 0.5),代表锚点在中心位置。 (0,0) 和 (1,1)分别代表左上角和右上角。 关于CALayer的属性position和anchorPoint position类似UIView 的center position决定了layer在父视图上的位置 anchorPoint决定了position在自身的位置。All geometric manipulations to the view occur about the specified point. CADisplayLink 与 NSTimer CADisplayLink精确度高 NSTimer占用系统资源较多 代码和图片位置： 89-Animation/clock 参考： iOS动画系列之一：通过实战学习CALayer和透视的原理。做一个带时分秒指针的时钟动画(上) iOS动画系列之二：通过实战学习CALayer和透视的原理。做一个带时分秒指针的时钟动画。包含了OC和Swift两种源代码(下)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Core ML：建立一个简单的图片内容识别应用]]></title>
    <url>%2F2017%2Fintroducing-coreml.html</url>
    <content type="text"><![CDATA[Xcode 9 beta &amp; iOS11 beta &amp; Swift4 Core ML是一个能集成机器学习模型到app中的框架。 一、新建初始项目 新建项目CoreMLDemo，以single-view application template模板 建立如下如下UI 二、实现照相和获取图片库功能 遵守两个协议：class ViewController: UIViewController, UINavigationControllerDelegate, UIImagePickerControllerDelegate { 添加两个接口，并关联。 12@IBOutlet var imageView: UIImageView!@IBOutlet var classifier: UILabel! 实现两个Action 1234567891011121314151617181920@IBAction func camera(_ sender: Any) &#123; if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; let cameraPicker = UIImagePickerController() cameraPicker.delegate = self cameraPicker.sourceType = .camera cameraPicker.allowsEditing = false present(cameraPicker, animated: true, completion: nil)&#125;@IBAction func openLibrary(_ sender: Any) &#123; let picker = UIImagePickerController() picker.allowsEditing = false picker.delegate = self picker.sourceType = .photoLibrary present(picker, animated: true)&#125; 实现协议UIImagePickerControllerDelegate中的方法： 123func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil)&#125; 在Info.plist中添加📷使用请求，Privacy – Camera Usage Description and Privacy 三、集成Core ML Data Model 到Apple机器学习官网 Machine Learning下载Core ML models，目前有6个Model，识别图片的使用Inception v3。下载得到一个mlmodel结尾的文件，直接拖到项目中，会自动生成对应model名的swift的类文件，可以直接在代码中使用。 在ViewController.swift中引入Core ML:import CoreML 初始Inceptionv3: 12345var model: Inceptionv3!override func viewWillAppear(_ animated: Bool) &#123; model = Inceptionv3()&#125; 实现UIImagePickerControllerDelegate协议的imagePickerController(_:didFinishPickingMediaWithInfo)方法： 12345678910111213141516171819202122232425262728293031323334func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; picker.dismiss(animated: true) classifier.text = &quot;Analyzing Image...&quot; guard let image = info[&quot;UIImagePickerControllerOriginalImage&quot;] as? UIImage else &#123; return &#125; UIGraphicsBeginImageContextWithOptions(CGSize(width: 299, height: 299), true, 2.0) image.draw(in: CGRect(x: 0, y: 0, width: 299, height: 299)) let newImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() let attrs = [kCVPixelBufferCGImageCompatibilityKey: kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey: kCFBooleanTrue] as CFDictionary var pixelBuffer : CVPixelBuffer? let status = CVPixelBufferCreate(kCFAllocatorDefault, Int(newImage.size.width), Int(newImage.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer) guard (status == kCVReturnSuccess) else &#123; return &#125; CVPixelBufferLockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) let pixelData = CVPixelBufferGetBaseAddress(pixelBuffer!) let rgbColorSpace = CGColorSpaceCreateDeviceRGB() let context = CGContext(data: pixelData, width: Int(newImage.size.width), height: Int(newImage.size.height), bitsPerComponent: 8, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer!), space: rgbColorSpace, bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue) //3 context?.translateBy(x: 0, y: newImage.size.height) context?.scaleBy(x: 1.0, y: -1.0) UIGraphicsPushContext(context!) newImage.draw(in: CGRect(x: 0, y: 0, width: newImage.size.width, height: newImage.size.height)) UIGraphicsPopContext() CVPixelBufferUnlockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) imageView.image = newImage 使用Core ML在上面imagePickerController(_:didFinishPickingMediaWithInfo)方法最后添加： 1234guard let prediction = try? model.prediction(image: pixelBuffer!) else &#123; return&#125;classifier.text = &quot;I think this is a \(prediction.classLabel).&quot; 现在就可运行识别图片内容了，我已几个简单的做了实验，效果还可以： 能识别🐶的种类，哈巴狗pug 🍌应该相对而言简单： 朋友家的猫，我也不知道猫的种类，识别为波斯猫(Persian cat): 这个我就不知道是怎么识别为浓咖啡(espresso)的了🤔 当然识别相差比较奇怪的。小米手环识别成听诊器（stethoscope）😢 kindle识别不出😢😢😢 四、Core ML学习资源官方文档 official Core ML documentation WWDC 2017： Introducing Core ML Core ML in Depth 代码 CoreMLDemo （由于Inceptionv3.mlmodel比较大，我就没有上传到github上，直接到 Machine Learning然后拖到项目中即可） 参考：Introduction to Core ML: Building a Simple Image Recognition App]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Core ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github和hexo创建免费的静态个人博客网站]]></title>
    <url>%2F2017%2Fgithub-hexo.html</url>
    <content type="text"><![CDATA[之前刚学编程，接触PHP时，出于学习的目的，兴致勃勃地买了域名、主机、学了Wordpress，找了主题，折腾了好久建了个网站，也写了一些文章，然后就没有然后了，这是从入门到放弃系列的典型案例。前段时间收到主机要到期的通知，正好我也接触到了简书，支持markdown，感觉蛮好，平常也习惯使用markdown格式记录笔记。就觉得不再续费主机了，就主要使用简书，个人博客就使用github和hexo这种支持markdown生成静态网页形式就行了。 已经有很多小伙伴这样搭建自己的个人博客，并写了相关文章，这边我就做一个搭建过程中的简单记录。开始之前需要安装git和nodejs，有github账号，程序员小伙伴一般都会有了，我就不啰嗦了。 关于GitHub PagesGitHub Pages原本是为托管在github上的项目提供介绍页面的一个功能，非常适合托管一些功能简单或者是静态页面的网站。考虑到访问速度，可以考虑国内的coding。 按照GitHub Pages步骤建立自己的GitHub Pages库。 hexohexo文档很详细，也有中文，很方便。 安装 hexonpm install hexo-cli -g 建站123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新生成的目录结构为： _config.yml 是网站的站点配置文件 node_modules 是nodejs库文件目录，就是npm install命令安装的文件位置 package.json是程序信息 scaffolds 新建文章的模板 source 存放用户资源的地方，404、favicon、CNAME 等堵在此处，这是我们主要工作的地方。其中，_posts文件是写文章地方，除_posts文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹（之后生成），而其他文件会被拷贝过去。 themes 是主题存储地方。 配置网站信息_config.yml 文件提供了很多配置，详细可看官网配置信息。先配置两方面的，之后需要再配置。 网站基本信息 1234567# Sitetitle: 欣欣向戎subtitle: AndyRon&apos;s Blogdescription: Just for fun.author: AndyRonlanguage: zh-Hanstimezone: Asia/Shanghai 部署，注意字段，repo就是个人GitHub Pages的地址库。 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:type: git repo: https://github.com/andyRon/andyRon.github.io.gitbranch: master 新建文章 hexo new [layout] &lt;title&gt; ： 也就是在source/_posts/下按照模板新建了一个markdown文件，layout就是指scaffolds文件夹中的模板，也可以直接在_posts中新建markdown文件。 在本地服务器测试hexo server ：在浏览器打开http://localhost:4000/ ，就可以查看 生成静态文件hexo generate（hexo g） ：这个命令会新建一个public文件夹，在其中生成静态文件，这个目录相当于网站的根目录。 发布到githubhexo deploy（hexo d）：把public文件夹内的内容上传到github上。现在访问https://yourname.github.io (我的是https://andyron.github.io )就能访问刚建立的网站了。如果出现ERROR Deployer not found的问题，可通过npm install hexo-deployer-git --save解决。 其他hexo命令hexo clean ：删除public文件夹内容，和清理一些缓存。调试网站可以使用。 域名绑定（如有必要） 在source/下添加文件CNAME，内容只为如andyron.com（没有http和www） 部署到github上：hexo generate，hexo deploy 域名解析。不同的域名服务商大同小异，我的是阿里云，为了防止解析出问题，我把其他默认一些邮件解析等都删了，就添加两个： 可能需要等一短时间（10分钟以上），就可以用 http://andyron.com 访问了。 hexo主题hexo有很多主题，很多网友为hexo贡献了很多主题，可到主题上寻找。我选择的是next主题，这个使用主题用的人比较多，文档很全，也比较简洁。主题的使用非常简单： 将主题文件拷贝至站点目录的themes 目录下 修改站点配置文件： theme: 主题名 主题的一些设置： 设置RSS 安装 hexo-generator-feed插件，在hexo init初始化的目录下执行npm install hexo-generator-feed --save 在站点配置文件添加： 123456feed:type: atompath: atom.xmllimit: 20hub:content: hexo generate 设置搜索有很多搜索方式，这只是一种简单方式 安装hexo-generator-searchdb，在hexo的根目录下：$ npm install hexo-generator-searchdb --save 在站点配置文件添加： 12345search: path: search.xml field: post format: html limit: 10000 在主题配置文件（themes/next/_config.yml）修改：12local_search: enable: true 添加标签页面 $hexo new page tags：结果生成新文件夹source/tags/，并在其中有一个index.md。 在主题配置文件的menu中打开标签 添加分类页面 $hexo new page categories：结果生成新文件夹source/categories，并在其中有一个index.md。 在主题配置文件的menu中打开分类。 添加关于我页面 $hexo new page about：结果生成新文件夹source/about，并在其中有一个index.md，在index.md中直接编写关于我的内容。 在主题配置文件的menu中打开分类。 添加百度分析 注册 百度统计，并添加自己的网站 复制 hm.js? 后面那串统计脚本 id 在主题配置文件中添加字段baidu_analytics`，职位上面的脚本id 参考http://blog.csdn.net/zuoziji416/article/details/53204478]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 传感器(一)：总的介绍和距离传感器]]></title>
    <url>%2F2017%2Fios-sensor-1.html</url>
    <content type="text"><![CDATA[关于传感器（Sensor），Apple官方好像并没有专门列出来介绍过，我只能从前辈的文章寻找，很多文章中都给iOS传感器进行过很详细的分类介绍，但有的传感器只是有过介绍，没有介绍使用方法或API，当然也有可能是我没搜索到，比如湿度传感器很多文章都提到，但详细使用方式就未曾看到过，还有这边的湿度传感器是指iPhone内部的？还是指iPhone所在外部环境的？ iPhone的传感器是经过长时间不停的变化和改进的，因为传感器一听名字就知道这种变化和改进十之八九是要与硬件有关系的。知乎中有一遍文章介绍的很详细，iPhone这十年在传感器上的演进- 知乎专栏。 iOS中传感器分类我姑且按照我查看的资料对iOS传感器进行一个不精确分类。 传感器类型 说明 加速计 Core Motion，感应设备的运动（摇一摇、计步器） 陀螺仪 Core Motion，感应设备的持握方式（赛车类游戏） 步数计 Core Motion 气压计 Core Motion 磁力计 Core Motion 距离传感器 感应是否有其他物体靠近设备屏幕（打电话自动屏） 环境光线传感器 感应周边环境光线的强弱（自动调节屏幕亮度） 内部温度传感器 感应设备内部的温度（提醒用户降温，防止损伤设备） 湿度传感器 感应设备是否进水（方便维修人员） 距离传感器和光线传感器知乎知友 Hi-iD 的答案介绍过这两个传感器的关系，本人简单总结如下： iPhone 5/5s/6之后光线/距离感应器就是iPhone顶部中心一个孔 光线传感器和距离传感器是两个独立的传感器，但两者都是对光作出反应。 距离传感器是基于红外光，距离传感器自身发射出的红外光，经外界反射后折回的红外光被距离传感器进行识别判断，所以距离传感器会有两个单元（反射和接收） 距离传感器的使用距离传感器的使用的使用相对简单：1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() UIDevice.current.isProximityMonitoringEnabled = true NotificationCenter.default.addObserver(self, selector: #selector(ViewController.sensorStateChange(notification:)), name: Notification.Name.UIDeviceProximityStateDidChange, object: nil) &#125; @objc func sensorStateChange(notification: NotificationCenter) &#123; if UIDevice.current.proximityState == true &#123; print(&quot;接近&quot;) &#125; else &#123; print(&quot;远离&quot;) &#125; &#125; 现在对iPhone顶部中心一个孔进行遮挡，就能感受的距离传感器。 Core MotionCore Motion是关于accelerometers(加速计), gyroscopes(陀螺仪), pedometers(步数计), magnetometers( 磁力计), and barometers(气压计)等5个传感器使用的框架， 暂时就按照字面意思翻译成核心运动框架。官方文档的介绍： Core Motion reports motion- and environment-related data from the onboard hardware of iOS devices, including from the accelerometers(加速计), gyroscopes(陀螺仪), pedometers(步数计), magnetometers( 磁力计), and barometers(气压计). You use this framework to access hardware-generated data so that you can use it in your app. For example, a game might use accelerometer and gyroscope data to control onscreen game behavior. 之后的文章就学习Core Motion的使用。😋 参考：1 https://www.zhihu.com/question/25526443/answer/310408872 iPhone这十年在传感器上的演进- 知乎专栏3 iOS开发之传感器4 扒一扒iPhone6的手机传感器5 非典型技术宅 的传感器系列文章 iOS传感器：实现一个随屏幕旋转的图片]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 13：手势处理]]></title>
    <url>%2F2017%2Fios-tutorial-13.html</url>
    <content type="text"><![CDATA[iOS手势处理由UIGestureRecognizer控制，不同手势有这个类的不同子类处理，不同手势处理有不同的相关属性。 子类 描述 UITapGestureRecognizer 点击手势 UIPanGestureRecognizer 跟着手移动手势 UIPinchGestureRecognizer 缩放手势 UIRotationGestureRecognizer 旋转手势 UISwipeGestureRecognizer 轻扫手势 UILongPressGestureRecognizer 长按手势 UIScreenEdgePanGestureRecognizer 屏幕边缘滑动手势 手势处理的步骤一般： 初始化手势，并添加到需要手势的View中 添加手势回调方法 UITapGestureRecognizer属性numberOfTapsRequired表示点击次数，属性numberOfTouchesRequired表示点击手指数。12345678910111213141516171819202122var isChange = false...let tap = UITapGestureRecognizer(target: self, action: #selector(ViewController.tap(tap:)))tap.numberOfTapsRequired = 2...imageView.addGestureRecognizer(tap)...@objc func tap(tap: UITapGestureRecognizer) &#123; let center = imageView.center if isChange &#123; imageView.frame.size.width /= 2 imageView.frame.size.height /= 2 imageView.center = center isChange = false &#125; else &#123; imageView.frame.size.width *= 2 imageView.frame.size.height *= 2 imageView.center = center isChange = true &#125;&#125; UIPanGestureRecognizer1let pan = UIPanGestureRecognizer(target: self, action: #selector(ViewController.pan(pan:))) 12345678910@objc func pan(pan: UIPanGestureRecognizer) &#123; if pan.state == .began || pan.state == .changed &#123; // 移动后的变化（变化值类似向量） let translation = pan.translation(in: imageView.superview) print(translation) imageView.center = CGPoint(x: imageView.center.x + translation.x, y: imageView.center.y + translation.y) // view移动后，把上一步的移动值变为0，否则移动值为递增 pan.setTranslation(CGPoint.zero, in: imageView.superview) &#125;&#125; UIRotationGestureRecognizerlet rotation = UIRotationGestureRecognizer(target: self, action: #selector(ViewController.rotation(rotation:))) 12345@objc func rotation(rotation: UIRotationGestureRecognizer) &#123; if rotation.state == .began || rotation.state == .changed &#123; imageView.transform = CGAffineTransform(rotationAngle: rotation.rotation) &#125;&#125; UISwipeGestureRecognizerlet swipe = UISwipeGestureRecognizer(target: self, action: #selector(ViewController.swipe(swipe:))) swipe.direction = .up swipe.numberOfTouchesRequired = 3 123@objc func swipe(swipe: UISwipeGestureRecognizer) &#123; print(&quot;扫的方向：\(swipe.direction),扫的手指数：\(swipe.numberOfTouchesRequired)&quot;)&#125; UILongPressGestureRecognizernumberOfTouchesRequired 长按的指头数minimumPressDuratio 长按最小时间（秒） let long = UILongPressGestureRecognizer(target: self, action: #selector(ViewController.long(long:))) long.numberOfTouchesRequired = 2 long.minimumPressDuration = 1 123@objc func long(long: UILongPressGestureRecognizer) &#123; print(&quot;长按手势，长按字头数为\(long.numberOfTouchesRequired)&quot;)&#125; UIScreenEdgePanGestureRecognizerlet screenEdge = UIScreenEdgePanGestureRecognizer(target: self, action: #selector(ViewController.screenEdage(screenEdage:))) screenEdge.edges = .left 123@objc func screenEdage(screenEdage: UIScreenEdgePanGestureRecognizer) &#123; print(&quot;屏幕边缘滑动手势：\(screenEdage.edges)&quot;)&#125; 详细代码： GestureDemo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>手势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 12：视频背景]]></title>
    <url>%2F2017%2Fios-tutorial-12.html</url>
    <content type="text"><![CDATA[新建项目 BackgroundVideoDemo 新建BackgroundVideo.swift文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import Foundationimport AVKitimport AVFoundationenum BackgroundVideoErrors: Error &#123; case invalidVideo&#125;class BackgroundVideo &#123; var isMuted = true private var player : AVPlayer? private var videoURL: URL? private var viewController: UIViewController? private var hasBeenUsed: Bool = false init (on viewController: UIViewController, withVideoURL URL: String) &#123; self.viewController = viewController // parse the video string to split it into name and extension let videoNameAndExtension:[String]? = URL.characters.split&#123;$0 == &quot;.&quot;&#125;.map(String.init) if videoNameAndExtension!.count == 2 &#123; if let videoName = videoNameAndExtension?[0] , let videoExtension = videoNameAndExtension?[1] &#123; if let url = Bundle.main.url(forResource: videoName, withExtension: videoExtension) &#123; self.videoURL = url // initialize our player with our fetched video url self.player = AVPlayer(url: self.videoURL!) &#125; else &#123; print(BackgroundVideoErrors.invalidVideo) &#125; &#125; &#125; else &#123; print(&quot;Wrong video name format&quot;) &#125; &#125; deinit&#123; if self.hasBeenUsed &#123; NotificationCenter.default.removeObserver(self, name: .AVPlayerItemDidPlayToEndTime, object: nil) NotificationCenter.default.removeObserver(self, name: .UIApplicationWillEnterForeground, object: nil) &#125; &#125; public func setUpBackground()&#123; self.player?.actionAtItemEnd = .none self.player?.isMuted = isMuted //add the video to your view .. let loginView: UIView = self.viewController!.view//get our view controllers view let playerLayer = AVPlayerLayer(player: self.player) playerLayer.videoGravity = AVLayerVideoGravityResizeAspectFill // preserve aspect ratio and resize to fill screen playerLayer.zPosition = -1 // set it&apos;s possition behined anything in our view playerLayer.frame = loginView.frame // set our player frame to our view&apos;s frame loginView.layer.addSublayer(playerLayer) // prevent video from disturbing audio services from other apps do &#123; try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryAmbient) &#125; catch &#123; print(&quot;failed setting AVAudioSession Category to AVAudioSessionCategoryAmbient&quot;) &#125; self.player?.play() // start the video /// 向通知中心发送视频结束后再次从头播放 NotificationCenter.default.addObserver(self, selector: #selector(self.loopVideo), name: .AVPlayerItemDidPlayToEndTime, object: nil) // 视频进入Foreground后从头播放 NotificationCenter.default.addObserver(self, selector: #selector(self.loopVideo), name: .UIApplicationWillEnterForeground, object: nil) self.hasBeenUsed = true &#125; // 循环播放视频 @objc private func loopVideo() &#123; self.player?.seek(to: kCMTimeZero) self.player?.play() &#125; &#125; 在所需要的视图控制器中定义变量var backgroundPlayer : BackgroundVideo?，然后再在viewDidLoad中定义： 12345678910 override func viewDidLoad() &#123; super.viewDidLoad() let backgroundPlayer = BackgroundVideo(on: self, withVideoURL: &quot;test.mp4&quot;) //是否打开静音// backgroundPlayer?.isMuted = false backgroundPlayer.setUpBackground() &#125; 详细代码： BackgroundVideoDemo 参考：BackgroundVideoiOS]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 9：本地视频播放]]></title>
    <url>%2F2017%2Fios-tutorial-9.html</url>
    <content type="text"><![CDATA[新建项目PlayLocalVideo 在IB中使View ControllerEmbed In &gt; Navigation Controller,并在View Controller**中添加UITableView和UITableViewCell。 在上面的UITableViewCell的中添加一个UIImageView作为视频的预览图、一个UIButton作为开始播放、两个UILabel分别用于显示视频的名称和来源。并修改一定样式和添加一定约束 添加几张图片和一个视频 添加一个cell的类，并添加三个接口。 12345class VideoCell: UITableViewCell &#123; @IBOutlet var previewImageView: UIImageView! @IBOutlet var nameLabel: UILabel! @IBOutlet var sourceLabel: UILabel! 添加一个video枚举，用来存储视频信息。 12345struct video &#123; let image: String let title: String let source: String&#125; 使ViewController符合table view代理和数据的协议，并实现所需方法： 12345678910111213141516171819202122232425func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; return 220 &#125; func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123; return 2 &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return data.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! VideoCell let video = data[indexPath.row] cell.previewImageView.image = UIImage(named: video.image) cell.nameLabel.text = video.title cell.sourceLabel.text = video.source return cell &#125; 引入播放视频所需框架，并定义相关变量。 1234567import AVFoundationimport AVKit... var playViewController : AVPlayerViewController? var playerView : AVPlayer? 实现视频播放按钮方法。 12345678910111213@IBAction func playVideo(_ sender: UIButton) &#123; let path = Bundle.main.path(forResource: &quot;KL&quot;, ofType: &quot;mp4&quot;) playerView = AVPlayer(url: URL(fileURLWithPath: path!)) playViewController = AVPlayerViewController() playViewController?.player = playerView present(playViewController!, animated: true, completion: &#123; self.playViewController?.player?.play() &#125;) &#125; 详细代码： PlayLocalVideo 参考： 30DaysofSwift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 10：UIScrollView滚动视图]]></title>
    <url>%2F2017%2Fios-tutorial-10-uiscrolview.html</url>
    <content type="text"><![CDATA[知识点: UIScrollView 当视图超过屏幕大小时，可通过把视图放在UIScrollView中让视图可以上下滚动的功能。以一张大图片为例。 新建项目 ScrollViewTutorial 代码：12345678910111213141516171819202122class ViewController: UIViewController &#123; var imageView: UIImageView! var scrollView: UIScrollView! override func viewDidLoad() &#123; super.viewDidLoad() imageView = UIImageView(image: UIImage(named: &quot;strandvagen.jpg&quot;)) scrollView = UIScrollView(frame: view.bounds) scrollView.backgroundColor = UIColor.black scrollView.contentSize = imageView.bounds.size scrollView.addSubview(imageView) view.addSubview(scrollView) &#125; &#125; 详细代码：ScrollViewTutorial 参考：Scroll View Tutorial in iOS8 with Swift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 11：照片横屏滑动]]></title>
    <url>%2F2017%2Fios-tutorial-11.html</url>
    <content type="text"><![CDATA[知识点： UICollectionView UIVisualEffectView UICollectionViewDataSource 新建项目Carousel Effect 在IB构建UI。Collection View 里的 Scroll Direction 设置成水平滚动。UIVisualEffectView是用来添加模糊效果的，也可以使用类似如下的代码构建： 1234let blurEffect = UIBlurEffect(style: .dark)let blurEffectView = UIVisualEffectView(effect: blurEffect)blurEffectView.frame = view.boundsbackgroundImageView.addSubview(blurEffectView) 创建数据类Interest 创建UICollectionViewCell 实现UICollectionViewDataSource的方法（有点类似UITableViewDataSource）。12345678910111213141516171819202122232425262728293031323334353637class ViewController: UIViewController, UICollectionViewDataSource &#123; @IBOutlet weak var backgroundImageView: UIImageView! @IBOutlet weak var collectionView: UICollectionView! var interests = Interest.createInterests() override func viewDidLoad() &#123; super.viewDidLoad() collectionView.dataSource = self collectionView.dataSource = self &#125; override var preferredStatusBarStyle : UIStatusBarStyle &#123; return UIStatusBarStyle.lightContent &#125; func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123; return 1 &#125; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return interests.count &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let CellIdentifier = &quot;InterestCell&quot; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CellIdentifier, for: indexPath) as! InterestCollectionViewCell cell.interest = self.interests[indexPath.item] return cell &#125;&#125; 详细代码： Carousel Effect 参考：30DaysofSwift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Alamofire：Swift的HTTP 网络库]]></title>
    <url>%2F2017%2Falamofire-introduce.html</url>
    <content type="text"><![CDATA[安装 CocoaPods和Carthage都很方便安装安装完，如果出现加载不到Alamofire，可以查看Cannot load underlying module for ‘Alamofire’ #441，问题应该可以解决。 手动安装 下载Alamofire 将Alamofire.xcodeproj拖进到项目中 在“Embedded Binaries中添加 command + B 编译后就可以使用 关于 https://httpbin.org/ 网站 https://httpbin.org/ 网站可用来做http的各种请求测试使用，不过遗憾的是没有POST等提交类型请求的测试 基本使用一个简单的请求： 123import AlamofireAlamofire.request(&quot;https://httpbin.org/get&quot;) http中有请求(Request) 和 响应(Response)两个重要概念。大部分http框架，都会使用request和response作为方法名。看看Alamofire的request方法的详细参数： 12345678public func request( _ url: URLConvertible, method: HTTPMethod = .get, parameters: Parameters? = nil, encoding: ParameterEncoding = URLEncoding.default, headers: HTTPHeaders? = nil) -&gt; DataRequest&#123; 有url,method,parameters,encoding,headers五个参数，与http是相互对应的。其中只有url是必须的，其它都有默认值。 请求后的响应处理向http发送请求后，就需对响应结果进行处理。 Alamofire采用链式调用的方式处理响应，这种链式调用的方式最初应该是起源jQuery。响应处理的一般形式如下，response就是响应结果。 123Alamofire.request(&quot;https://httpbin.org/get&quot;).responseJSON &#123; response in&#125; Alamofire 提供了五种不同的响应处理： 123456789101112131415161718192021222324252627282930// Response Handler - Unserialized Responsefunc response( queue: DispatchQueue?, completionHandler: @escaping (DefaultDataResponse) -&gt; Void) -&gt; Self// Response Data Handler - Serialized into Datafunc responseData( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Data&gt;) -&gt; Void) -&gt; Self// Response String Handler - Serialized into Stringfunc responseString( queue: DispatchQueue?, encoding: String.Encoding?, completionHandler: @escaping (DataResponse&lt;String&gt;) -&gt; Void) -&gt; Self// Response JSON Handler - Serialized into Anyfunc responseJSON( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void) -&gt; Self// Response PropertyList (plist) Handler - Serialized into Anyfunc responsePropertyList( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void)) -&gt; Self 五种方法的参数不同，但最后一参数都是一个回调的闭包，都可以写成尾随闭包形式。除了response方法的回调参数是DefaultDataResponse，其它都是DataResponse: 1234567891011121314151617181920212223public struct DataResponse&lt;Value&gt; &#123; /// The URL request sent to the server. public let request: URLRequest? /// The server&apos;s response to the URL request. public let response: HTTPURLResponse? /// The data returned by the server. public let data: Data? /// The result of response serialization. public let result: Result&lt;Value&gt; /// The timeline of the complete lifecycle of the request. public let timeline: Timeline /// Returns the associated value of the result if it is a success, `nil` otherwise. public var value: Value? &#123; return result.value &#125; /// Returns the associated error value if the result if it is a failure, `nil` otherwise. public var error: Error? &#123; return result.error &#125; var _metrics: AnyObject? DataResponse与DefaultDataResponse最大的不同就是多了两个属性result和value，value值就是格式化的不同类型。 响应处理的一些例子 response 123456789Alamofire.request(&quot;https://httpbin.org/get&quot;).response &#123; response in print(&quot;Request: \(response.request)&quot;) print(&quot;Response: \(response.response)&quot;) print(&quot;Error: \(response.error)&quot;) if let data = response.data, let utf8Text = String(data: data, encoding: .utf8) &#123; print(&quot;Data: \(utf8Text)&quot;) &#125;&#125; response方法的响应结果response是DefaultDataResponse，没有进行过格式化处理。 responseData 1234567Alamofire.request(&quot;https://httpbin.org/get&quot;).responseData &#123; response in debugPrint(&quot;All Response Info: \(response)&quot;) if let data = response.result.value, let utf8Text = String(data: data, encoding: .utf8) &#123; print(&quot;Data: \(utf8Text)&quot;) &#125;&#125; responseData方法对响应结果进行了处理，response.result.value就是我们属性的Data类型。 链式调用 1234567Alamofire.request(&quot;https://httpbin.org/get&quot;).responseString &#123; response in print(&quot;Response String: \(response.result.value)&quot;)&#125;.responseJSON &#123; response in print(&quot;Response JSON: \(response.result.value)&quot;)&#125; 响应验证http响应结果中的不同状态码(100..&lt;600)表示不同结果。 手动验证 1234567891011 Alamofire.request(&quot;https://httpbin.org/get&quot;).validate(statusCode: 200..&lt;300).validate(contentType: [&quot;application/json&quot;]).responseData &#123; response in switch response.result &#123; case .success: print(&quot;Validation Successful&quot;) case .failure(let error): print(error) &#125;&#125; 自动验证状态码在200..&lt;300的为正确，其它为错误。12345678Alamofire.request(&quot;https://httpbin.org/get&quot;).validate().responseJSON &#123; response in switch response.result &#123; case .success: print(&quot;Validation Successful&quot;) case .failure(let error): print(error) &#125;&#125; HTTP不同请求方式request方法的method参数表示不同的方法。 12345Alamofire.request(&quot;https://httpbin.org/get&quot;) // method defaults to `.get`Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post)Alamofire.request(&quot;https://httpbin.org/put&quot;, method: .put)Alamofire.request(&quot;https://httpbin.org/delete&quot;, method: .delete) 请求参数编码GET的参数按照固定格式写到URL中，其他类型则按照不同格式写到请求body中。 GET参数编码 12345678let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;]// All three of these calls are equivalentAlamofire.request(&quot;https://httpbin.org/get&quot;, parameters: parameters) // encoding defaults to `URLEncoding.default`Alamofire.request(&quot;https://httpbin.org/get&quot;, parameters: parameters, encoding: URLEncoding.default)Alamofire.request(&quot;https://httpbin.org/get&quot;, parameters: parameters, encoding: URLEncoding(destination: .methodDependent))// https://httpbin.org/get?foo=bar POST参数编码 12345678910111213141516let parameters: Parameters = [ &quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: [&quot;a&quot;, 1], &quot;qux&quot;: [ &quot;x&quot;: 1, &quot;y&quot;: 2, &quot;z&quot;: 3 ]]// All three of these calls are equivalentAlamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters)Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: URLEncoding.default)Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: URLEncoding.httpBody)// HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3 JSON编码 123456789101112let parameters: Parameters = [ &quot;foo&quot;: [1,2,3], &quot;bar&quot;: [ &quot;baz&quot;: &quot;qux&quot; ]]// Both calls are equivalentAlamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: JSONEncoding.default)Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: JSONEncoding(options: []))// HTTP body: &#123;&quot;foo&quot;: [1, 2, 3], &quot;bar&quot;: &#123;&quot;baz&quot;: &quot;qux&quot;&#125;&#125; 添加请求HTTP头部12345678let headers: HTTPHeaders = [ &quot;Authorization&quot;: &quot;Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==&quot;, &quot;Accept&quot;: &quot;application/json&quot;]Alamofire.request(&quot;https://httpbin.org/headers&quot;, headers: headers).responseJSON &#123; response in debugPrint(response)&#125; HTTP认证12345678let user = &quot;user&quot;let password = &quot;password&quot;Alamofire.request(&quot;https://httpbin.org/basic-auth/\(user)/\(password)&quot;) .authenticate(user: user, password: password) .responseJSON &#123; response in debugPrint(response)&#125; 下载文件12345Alamofire.download(&quot;https://httpbin.org/image/png&quot;).responseData &#123; response in if let data = response.result.value &#123; let image = UIImage(data: data) &#125;&#125; 另外可以下文件保存在本地：12345678910111213141516let destination: DownloadRequest.DownloadFileDestination = &#123; _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(&quot;pig.png&quot;) return (fileURL, [.removePreviousFile, .createIntermediateDirectories])&#125;Alamofire.download(&quot;https://httpbin.org/image/png&quot;, to: destination).response &#123; response in print(response) if response.error == nil, let imagePath = response.destinationURL?.path &#123; let image = UIImage(contentsOfFile: imagePath) self.imageView.image = image self.tableView.reloadData() &#125;&#125; 上传 上传 Data 12345let imageData = UIImagePNGRepresentation(image!)!Alamofire.upload(imageData, to: &quot;https://httpbin.org/post&quot;).responseJSON &#123; response in debugPrint(response)&#125; 上传文件 12345let fileURL = Bundle.main.url(forResource: &quot;video&quot;, withExtension: &quot;mov&quot;)Alamofire.upload(fileURL!, to: &quot;https://httpbin.org/post&quot;).responseJSON &#123; response in debugPrint(response)&#125; 上传Multipart Form Data（表单提交） 1234567891011121314151617Alamofire.upload( multipartFormData: &#123; multipartFormData in multipartFormData.append(unicornImageURL, withName: &quot;unicorn&quot;) multipartFormData.append(rainbowImageURL, withName: &quot;rainbow&quot;)&#125;, to: &quot;https://httpbin.org/post&quot;, encodingCompletion: &#123; encodingResult in switch encodingResult &#123; case .success(let upload, _, _): upload.responseJSON &#123; response in debugPrint(response) &#125; case .failure(let encodingError): print(encodingError) &#125;&#125;) 请求中花费的各种时间123Alamofire.request(&quot;https://httpbin.org/get&quot;).responseJSON &#123; response in print(response.timeline)&#125; 结果：1Timeline: &#123; &quot;Latency&quot;: 1.527 secs, &quot;Request Duration&quot;: 1.528 secs, &quot;Serialization Duration&quot;: 0.001 secs, &quot;Total Duration&quot;: 1.529 secs &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[Swift中的问号三种用法]]></title>
    <url>%2F2017%2Fswift-question.html</url>
    <content type="text"><![CDATA[三目运算符(Ternary Conditional Operator)这在大部分语言中都比较常见布尔值 ? &quot;true&quot; : &quot;false&quot; 可选值可选值?和 !是一对。?用在某个类型后面，可以通俗的理解为，这个值不太确实是否是这个类型，如果不是就给个nil吧；!可以理解为，一定要给个类型我，要不老子分分钟挂给你看了。😎 空合运算符(Nil Coalescing Operator) ??这个我在其他语言没见过。e ?? f 相当于 e != nil ? e! : f， 可选类型e不是nil时，就e!,否则为f。 123var e: String?var f = &quot;我是fuck&quot;e ?? f // `e != nil ? e! : f` ， 可选类型`e`不是`nil`时，就`e!`,否则为`f`。（注意`??`前后要空格）]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 8：使用IBInspectable 和 IBDesignable定制UI]]></title>
    <url>%2F2017%2Fios-tutorial-8-ibinspectable-ibdesignable.html</url>
    <content type="text"><![CDATA[例子代码：https://github.com/andyRon/LearniOSByProject/tree/master/77 理解IBInspectable 和 IBDesignable简单地说，IBInspectable 就是允许开发者在IB的属性检查器中添加额外的选项。IBDesignable 能够让 IBInspectable 添加的额外选项产生的变化在IB中实时显示。以Button的圆角为例说明。 正常情况下，Button的圆角需要代码：12button.layer.cornerRadius = 10.0button.layer.masksToBounds = true 或者直接在IB的Identity检查器的 user defined runtime attributes中添加： 注意到，这种修改不是实时，在IB中Button还是直角，只有运行后才是圆角。 以IBInspectable的方式。定义个继承至UIButton的类。12345678class RoundedCornerButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125;&#125; 然后把button的class属性修改成RoundedCornerButton: 发现这个button的属性检查器中多了Corner Radius。 注意： cornerRadius属性变成了Corner Radius，RoundedCornerButton类变成了 Rounded Corner Button，这是Xcode自动转变的，开发者只需要依照swift的命名规范就可以了（类名是大写开头的驼峰命名规则，属性名是小写开头的驼峰命名规则） cornerRadius的类型是CGFloat，在属性检查器中就对应数字的选择。当然不是所有类型都可以添加属性检查器中的，IBInspectable支持如下类型：12345678910IntCGFloat Double String Bool CGPoint CGSize CGRect UIColor UIImage 如果在类RoundedCornerButton前添加@IBDesignable，那在属性检查器中自定义的属性变化就可以在IB中实时显示了。12345678@IBDesignable class RoundedCornerButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125;&#125; 创建Fancy Button创建Fancy Button来更加深入的了解IBInspectable 和 IBDesignable 创建新项目FancyButton 下载图标，也可以随意图标，拖进asset catalog 新建类FancyButton，继承至UIButton 圆角，边宽，边的颜色。 更新FancyButton：12345678910111213141516171819@IBDesignableclass FancyButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125; @IBInspectable var borderWidth: CGFloat = 0.0 &#123; didSet &#123; layer.borderWidth = borderWidth &#125; &#125; @IBInspectable var borderColor: UIColor = .black &#123; didSet &#123; layer.borderColor = borderColor.cgColor &#125; &#125;&#125; Title在FancyButton继续添加属性：1234567891011121314151617181920@IBInspectable var titleLeftPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.left = titleLeftPadding &#125;&#125;@IBInspectable var titleRightPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.right = titleRightPadding &#125;&#125;@IBInspectable var titleTopPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.top = titleTopPadding &#125;&#125;@IBInspectable var titleBottomPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.bottom = titleBottomPadding &#125;&#125; 通过圆角可创建圆形button Image Padding添加图片边距的属性：123456789101112131415161718192021@IBInspectable var imageLeftPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.left = imageLeftPadding &#125;&#125;@IBInspectable var imageRightPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.right = imageRightPadding &#125;&#125;@IBInspectable var imageTopPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.top = imageTopPadding &#125;&#125;@IBInspectable var imageBottomPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.bottom = imageBottomPadding &#125;&#125; 图片靠右对齐根据下图关系，应有imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding。 在FancyButton中添加如下代码： 123456789@IBInspectable var enableImageRightAligned: Bool = falseoverride func layoutSubviews() &#123; super.layoutSubviews() if enableImageRightAligned, let imageView = imageView &#123; imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding &#125;&#125; + `enableImageRightAligned`属性又来自动计算 `imageEdgeInsets.left` 颜色渐变添加三个@IBInspectable属性，并更新layoutSubviews:1234567891011121314151617181920@IBInspectable var enableGradientBackground: Bool = false@IBInspectable var gradientColor1: UIColor = UIColor.black@IBInspectable var gradientColor2: UIColor = UIColor.whiteoverride func layoutSubviews() &#123; super.layoutSubviews() if enableImageRightAligned, let imageView = imageView &#123; imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding &#125; if enableGradientBackground &#123; let gradientLayer = CAGradientLayer() gradientLayer.frame = self.bounds gradientLayer.colors = [gradientColor1.cgColor, gradientColor2.cgColor] gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5) gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5) self.layer.insertSublayer(gradientLayer, at: 0) &#125;&#125; 渐变色需要运行后才能看到 参考：appcode网站的书《Intermediate iOS Programming with Swift》 的Chapter 36]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 1 前言和目录]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-1.html</url>
    <content type="text"><![CDATA[这是我学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的记录，章节和原书不同。 开发环境是Xcode 8，Swift 3，iOS 10。 我的代码在github上，andyRon/Beginning-iOS-Programming-with-Swift 目录 开始用Swift开发iOS 10 - 1 前言和目录 开始用Swift开发iOS 10 - 2 Hello World！第一个Swift APP 开始用Swift开发iOS 10 - 3 介绍Auto Layout 开始用Swift开发iOS 10 - 4 用Stack View设计UI 开始用Swift开发iOS 10 - 5 原型的介绍 开始用Swift开发iOS 10 - 6 创建简单的Table Based App 开始用Swift开发iOS 10 - 7 定制Table Views 开始用Swift开发iOS 10 - 8 Table View和UIAlertController的交互 开始用Swift开发iOS 10 - 9 Table Row的删除, UITableViewRowAction和UIActivityViewController的使用 开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue 开始用Swift开发iOS 10 - 11 面向对象编程介绍 开始用Swift开发iOS 10 - 12 丰富Detail View和定制化Navigation Bar 开始用Swift开发iOS 10 - 13 Self Sizing Cells and Dynamic Type 开始用Swift开发iOS 10 - 14 基础动画，模糊效果和Unwind Segue 开始用Swift开发iOS 10 - 15 使用地图 开始用Swift开发iOS 10 - 16 介绍静态Table Views，UIImagePickerController和NSLayoutConstraint 开始用Swift开发iOS 10 - 17 使用Core Data 开始用Swift开发iOS 10 - 18 Search Bar 和 UISearchController 开始用Swift开发iOS 10 - 19 使用UIPageViewController构建介绍页面 开始用Swift开发iOS 10 - 20 使用Tab Bar Controller 和 拆分Storyboard 开始用Swift开发iOS 10 - 21 使用WKWebView和SFSafariViewController 开始用Swift开发iOS 10 - 22 使用CloudKit 开始用Swift开发iOS 10 - 24 使用TestFlight进行Beta测试 开始用Swift开发iOS 10 - 25 使用3D Touch 开始用Swift开发iOS 10 - 26 使用本地用户通知]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DownGit：怎么下载github中某个文件夹？]]></title>
    <url>%2F2017%2Fdowngit.html</url>
    <content type="text"><![CDATA[怎么下载github中某个文件夹？ github只提供了整个项目下载。下载一个项目中的某个文件夹的内容，这种需求在使用github时，还是经常使用的。 比如：在一些大的项目下，只想看某个文件的内容时。又比如，像我这种andyRon/LearniOSByProject，就是我一些学习iOS的小项目或者Demo的集合，如果只想查看某个小项目，而不下载整个项目时。 方法很简单，早就有前辈想到了，DownGit这个网站就提供这个功能，只要把目录链接（比如：https://github.com/andyRon/LearniOSByProject/tree/master/76）拷贝，然后点击download就可以下载目录的压缩文件。]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS本地化(swift)]]></title>
    <url>%2F2017%2Fios-localize.html</url>
    <content type="text"><![CDATA[示例代码在github上localizationsDemo 1 项目中需要配置的语言这就是项目中其他不同形式本地化可以添加的语种设置。 如下图为项目添加不同语种 弹框中显示要为两个Storyboard文件添加语种信息 添加完多语种后，相关需要本地化的文件会产生一组文件 实际在目录结构中是根据不同语言生成不同的*.lproj目录，再在*.lproj目录中生成了不同的.strings文件。 2 应用名称本地化App的名称在不同语种下显示不同。 新建一个.strings文件，名为InfoPlist.strings。 选中InfoPlist.strings，在右侧的文件检查器中点击Localize，在弹框中可以选择语种，对应项目中需要配置的语言中配置的语种。 可选中需要本地化的应用名称的语种： 在InfoPlist.strings的不同语种文件中添加字段CFBundleDisplayName，表示应用的名称。CFBundleDisplayName = &quot;简体中文名称&quot;; 在模拟器中，可通过Edit Scheme...编辑语种： 3 代码中的字符串的本地化类似应用名称本地化，代码中的字符串的本地也是利用.strings文件存储翻译信息。然后再在代码中利用NSLocalizedString（翻译信息默认在Localizable.strings文件）或NSLocalizedString(_:tableName:bundle:value:comment:)（翻译信息在tableName对应的.strings文件）文件标注。 NSLocalizedString(_:tableName:bundle:value:comment:)这种方式可根据需要把翻译信息保存在自定义的文件中，在多人开发时可以很好的防止冲突。 新建一个名为Localizable.strings的.strings文件。 类似InfoPlist.strings文件的配置方式，配置不同语种。 在代码中需要本地化的字符串修改为类似NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)或NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;) 4 图片的本地化这边所说的图片的本地化就是指，同一个名称图片，在不同语种下显示不同图片。 随意添加一张图片到项目，比如Swift_Logo.png 选中上面的图片，在右侧的文件检查器中点击Localize，类似之前的做法，添加所需的不同语种。 在Finder中的不同语种的*.lproj目录中添加，相同名字但不同的图片 在代码中添加类似的代码： self.imageView.image = UIImage(named: NSLocalizedString(&quot;Swift_Logo&quot;, comment: &quot;&quot;)) 最后的英文中的状态结果为： 5 优化本地化代码书写方式本地化时，NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)或NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;)这两种方法代码写法有点繁琐，参考stackoverflow中一个问题What’s NSLocalizedString equivalent in Swift?Ask的一个答案，扩展一下String：12345678910111213extension String &#123; var localized: String &#123; return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;&quot;) &#125; func localized(withComment:String) -&gt; String &#123; return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: &quot;&quot;, comment: withComment) &#125; func localized(tableName: String) -&gt; String&#123; return NSLocalizedString(self, tableName: tableName, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;&quot;) &#125;&#125; 然后，原本下面的写法：123self.label.text = NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)self.label2.text = NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;)self.imageView.image = UIImage(named: NSLocalizedString(&quot;Swift_Logo&quot;, comment: &quot;&quot;)) 就可以写成：123self.label.text = &quot;labelName&quot;.localizedself.label2.text = &quot;labelName&quot;.localized(tableName: &quot;andy&quot;)self.imageView.image = UIImage(named: &quot;Swift_Logo&quot;.localized) 参考：【iOS】浅谈多语言本地化(国际化)3分钟实现iOS语言本地化/国际化（图文详解）What’s NSLocalizedString equivalent in Swift?Ask]]></content>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习7：内存管理]]></title>
    <url>%2F2017%2Foc-basic-7.html</url>
    <content type="text"><![CDATA[1 对象生命周期 诞生（通过alloc或new方法实现） -&gt; 生存（接收消息并执行操作） -&gt; 交友（通过复合以及向方法传递参数） -&gt; 死去（被释放掉） 引用计数(reference counting) / 保留计数(retain counting) alloc, new, copy: 创建对象，保留计数被设置为1 retain: 保留计数加1。如[[car retain] setTire: tire atIndex:2];表示要求car对象将其保留计数的值加1并执行setTire操作。 release: 保留计数减1 dealloc: 保留计数归0时自动调用 retainCount: 获得对象保留计数当前值1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &lt;Foundation/Foundation.h&gt;@interface RetainTracker : NSObject@end@implementation RetainTracker- (id) init&#123; if (self = [super init]) &#123; NSLog(@&quot;init: Retain count of %lu .&quot;, [self retainCount]); &#125; return self;&#125; // init- (void)dealloc&#123; NSLog(@&quot;dealloc called. Bye Bye.&quot;); [super dealloc];&#125; // dealloc@end // RetainTrackerint main(int argc, const char * argv[]) &#123; RetainTracker *a = [RetainTracker new]; [a retain]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a retain]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a release]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a release]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a release]; NSLog(@&quot;%lu&quot;, [a retainCount]); // 为什么此处是 1 不是 0吗？ return 0;&#125; 对象所有权(object ownership)如果一个对象内有指向其他对象的实例变量，则称 该对象拥有这些对象。 访问方法中的保留和释放所有对象放入池中 @autoreleasepool/NSAutoreleasePool： 自动释放池 NSObject提供autorelease方法：- (id) autorelease; 2 Cocoa的内存管理规则 3 异常与异常有关的关键字 @try @catch @finally @throw 捕捉不同类型的异常123456@try &#123;&#125; @catch (MyCustomException *custom) &#123;&#125; @catch (NSException *exception) &#123;&#125; @catch (id value) &#123;&#125; @finally &#123;&#125; 抛出异常抛出异常的两种方式： @throw异常名 向某个NSException对象发送raise消息1234NSException *theException = [NSException exceptionWithName: ...];@throw theException;[theException raise]; 区别：raise只对NSException对象有效，@throw异常名可用在其他对象上。 异常也需要内存管理异常和自动释放池]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Carthage的使用]]></title>
    <url>%2F2017%2Fcarthage-introduce.html</url>
    <content type="text"><![CDATA[Carthage与CocoaPods的简单比较 CocoaPods 的优势： 使用方便，除编写 Podfile 以外其他几乎都是自动完成； 软件包数量多，主流支持； CocoaPods 的缺点： 每次更新环境都需要连接到中心仓库，比较耗时； 开发者使用比较简单，但是如果创建兼容 CocoaPods 的库，就会相对繁琐一些（尽管有了命令行）； 每次干净编译都会把所有第三方库都重新编译一次（看似很正确，直到我遇见 Carthage…） Carthage 的优势 第三方库不是每一次都重新编译，节省时间； 去中心化，没有中心服务器，这意味着每次配置和更新环境，只会去更新具体的库，而不会有一个向中心服务器获取最新库的索引这么个过程，节省时间； 与 CocoaPods 无缝集成； 结构标准的项目天然就是 Carthage 库； 安装Carthagebrew install carthage 使用Carthage 进入项目文件夹，比如建立新项目 carthageDemo 创建空文件Cartfile，命令：touch Cartfile 编辑Cartfile文件(xcode，或其它文本编辑器)，以SVProgressHUD为例，Cartfile文件内容大致如下： 1github &quot;SVProgressHUD/SVProgressHUD&quot; ~&gt; 1.0 Cartfile文件格式说明: 依赖源有两种，github和git，就是告诉 Carthage到哪里下载第三方库，例子如下：1234567891011121314151617181920212223# Require version 2.3.1 or latergithub &quot;ReactiveCocoa/ReactiveCocoa&quot; &gt;= 2.3.1# Require version 1.xgithub &quot;Mantle/Mantle&quot; ~&gt; 1.0 # (1.0 or later, but less than 2.0)# Require exactly version 0.4.1github &quot;jspahrsummers/libextobjc&quot; == 0.4.1# Use the latest versiongithub &quot;jspahrsummers/xcconfigs&quot;# Use the branchgithub &quot;jspahrsummers/xcconfigs&quot; &quot;branch&quot;# Use a project from GitHub Enterprisegithub &quot;https://enterprise.local/ghe/desktop/git-error-translations&quot;# Use a project from any arbitrary server, on the &quot;development&quot; branchgit &quot;https://enterprise.local/desktop/git-error-translations2.git&quot; &quot;development&quot;# Use a local projectgit &quot;file:///directory/to/project&quot; &quot;branch&quot; 从上面的例子中有很详细的版本号例子： == 1.0 使用1.0版本 &gt;= 1.0 使用1.0或更高的版本 ~&gt; 1.0 使用高于1.0但低于2.0的最新版本 没有的是使用最新版本 branch名称/tag名称/commit名称 使用特定分支/标签/提交版本 运行Carthage carthage update [--platform iOS]--platform iOS是针对iOS的，可选项。在项目根目录下会生成一个Cartfile.resolved文件和Carthage文件夹，Carthage文件夹中的Build目录下有编译好的framework文件，Checkouts目录第三库的源文件。 把库添加到项目中 把编译好的framework文件拖动到Linked Frameworks and Libraries或者点击+选择。 在Build Phases中添加一个Run Script。命令为 /usr/local/bin/carthage copy-frameworks。Input Files下的条目为$(SRCROOT)/Carthage/Build/iOS/SVProgressHUD.framework。具体操作如下图： 编译就可以使用第三方库了 其他 新加库时在Cartfile文件中添加后，然后操作类似上面的 更新指定库：carthage update SVProgressHUD --platform iOS 参考：Carthage的安装和使用【译】Carthage的使用Carthage 初探：四大优势与四大劣势Carthage官方地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 26 使用本地用户通知]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-26.html</url>
    <content type="text"><![CDATA[iOS 10 之前用户通知相对而言是简单的，iOS 10让用户通知更加丰富了，可以有静态图片，动态gif，视频，音频等。 用户通知可以出现在通知中心，主屏，锁屏时，当用户错过了用户通知时，可以在通知中心查看。 用户通知分为两类： 本地通知。 是通过应用本身和用户设备本身触发的。比如：基于用户位置的app，在用户进入某个特殊区域发送通知；to-do list的app在某些特定时间发送通知。 远程通知。 是远程服务器端首先向苹果推送服务器（Apple Push Notification Service ，APNS）发送，然后再经过APNS推送通知到用户设备。 这一篇只讨论本地通知。 三种不同触发的本地通知： 特定数量的时间。 比如是10分钟后。 特定日期和时间点。 特定位置。 询问用户授权向用户发送通知是要得到用户允许的。 在AppDelegate.swift中添加 import UserNotifications 在application(_:didFinishLaunchingWithOptions:)方法中添加授权12345678UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge], completionHandler: &#123; (granted, error) in if granted &#123; print(&quot;User notifications are allowed.&quot;) &#125; else &#123; print(&quot;User notifications are not allowed.&quot;) &#125;&#125;) 创建通知通知的一般结构： 通知用UNMutableNotificationContent类来表示。 在RestaurantTableViewController中添加一个方法 12345678910111213141516171819202122func prepareNotification() &#123; // Make sure the restaurant array is not empty if restaurants.count &lt;= 0 &#123; return &#125; // 1 let randomNum = Int(arc4random_uniform(UInt32(restaurants.count))) let suggestedRestaurant = restaurants[randomNum] // 2 let content = UNMutableNotificationContent() content.title = &quot;Restaurant Recommendation&quot; content.subtitle = &quot;Try new food today&quot; content.body = &quot;I recommend you to check out \(suggestedRestaurant.name!).The restaurant is one of your favorites. It is located at \(suggestedRestaurant.location!). Would you like to give it a try?&quot; content.sound = UNNotificationSound.default() // 3 let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 10, repeats: false) let request = UNNotificationRequest(identifier: &quot;foodpin.restaurantSuggestion&quot;, content: content, trigger: trigger) // Schedule the notification UNUserNotificationCenter.current().add(request, withCompletionHandler: nil) &#125; 1 获得一个随机的restaurant 2 通过UNMutableNotificationContent获得一个通知，配置参数，sound表示需要通知声音。 3 UNTimeIntervalNotificationTrigger是一个时间触发，为了好测试，表示10s后通知一次。 在viewDidLoad中实现上面函数。prepareNotification() 现在运行，注意在应用内是不能接受本应用通知，所以运行后立即进入主屏或锁屏。通知本身有高度限制，内容过长会不显示，只要向下滑动就可以显示完整。 向通知中添加图片图片等富文本内容通过UNMutableNotificationContent的attachments属性添加，attachments属性是UNNotificationAttachment的数组。UNNotificationAttachment可以是图片、音频、音效、视频文件。 在prepareNotification中的触发之前添加代码： 123456789101112// 1let tempDirURL = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)let tempFileURL = tempDirURL.appendingPathComponent(&quot;suggested-restaurant.jpg&quot;)if let image = UIImage(data: suggestedRestaurant.image! as Data) &#123; // 2 try? UIImageJPEGRepresentation(image, 1.0)?.write(to: tempFileURL) if let restaurantImage = try? UNNotificationAttachment(identifier: &quot;restaurantImage&quot;, url: tempFileURL, options: nil) &#123; content.attachments = [restaurantImage] &#125;&#125; 1 由于使用Core Data，图片以NSData形式存储了，所以使用NSTemporaryDirectory来生成临时目录存储临时图片文件 2 UIImageJPEGRepresentation用来生成jpg图片文件 运行查看，同样向下滑动可查看完整。 和通知的交互之前只要点击通知进入应用的交互，这是默认的交互。 在prepareNotification中的触发之前添加代码： 123456789101112 // 1let categoryIdentifer = &quot;foodpin.restaurantaction&quot;// 3let makeReservationAction = UNNotificationAction(identifier: &quot;foodpin.makeReservation&quot;, title: &quot;Reserve a table&quot;, options: [.foreground])let cancelAction = UNNotificationAction(identifier: &quot;foodpin.cancel&quot;, title: &quot;Later&quot;, options: [])// 4let category = UNNotificationCategory(identifier: categoryIdentifer, actions:[makeReservationAction, cancelAction], intentIdentifiers: [], options: [])// 5UNUserNotificationCenter.current().setNotificationCategories([category])// 2 content.categoryIdentifier = categoryIdentifer 1,2 categoryIdentifier是让通知和category关联起来 3 UNNotificationAction有点类似UIAlertAction，options: [.foreground]表示让应用到前台，就是启动应用 4 UNNotificationCategory有点类似UIAlertController 5 把UNNotificationCategory注册到用户中心 处理Actions上面的options: [.foreground]只是启动了应用，没有实现具体操作。UNUserNotificationCenterDelegate中的userNotificationCenter(_:didReceive:withCompletionHandler:)方法在UNNotificationAction被选择时调用，在这个方法内部可实现具体操作。 让AppDelegate符合协议UNUserNotificationCenterDelegate 实现userNotificationCenter(_:didReceive:withCompletionHandler:) 123456789101112131415161718func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) &#123; // 1 if response.actionIdentifier == &quot;foodpin.makeReservation&quot; &#123; print(&quot;Make reservation...&quot;) // 2 if let phone = response.notification.request.content.userInfo[&quot;phone&quot;] &#123; let telURL = &quot;tel://\(phone)&quot; if let url = URL(string: telURL) &#123; if UIApplication.shared.canOpenURL(url) &#123; print(&quot;calling \(telURL)&quot;) // 3 UIApplication.shared.open(url) &#125; &#125; &#125; &#125; completionHandler()&#125; 1 对应之前创建UNNotificationAction时的identifier。 2 response.notification.request.content对应之前创建通知prepareNotification函数中的UNMutableNotificationContent，userInfo属性可用来存储通知想传递的数据。比如在prepareNotification函数中添加content.userInfo = [&quot;phone&quot;: suggestedRestaurant.phone!]，这边就可获得。 3 拨打电话。 在content.userInfo = [&quot;phone&quot;: suggestedRestaurant.phone!]中添加UNUserNotificationCenter.current().delegate = self。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 25 使用3D Touch]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-25.html</url>
    <content type="text"><![CDATA[接着上一篇 开始用Swift开发iOS 10 - 24 使用TestFlight进行Beta测试 ，这一篇学习使用3D Touch。 自从iPhone 6s和iPhone 6s Plus开始，Apple介绍了一种新的交互方式就是3D Touch。这新的特性需要硬件的支持，是iPhone屏幕不仅能感应到触摸，还能感应到压力。 现在3D Touch主要有三类交互方式： Quick Action ：点击应用图标后的快捷操作。👇是例子： Peek(preview) 和 Pop(commit)一般是一起的 ：主要应用于app中快速查看详细内容。自带的Photos app是很好的例子： 微信公众号也是不错的例子： Home Screen Quick Action Quick Action分两种： 静态的：在Info.plist中编写，固定不变的。 动态的：在代码中创建和更新。以自带的News app为例： 不同的频道是随着时间而变化的。 静态的Quick Action 静态的Quick Action只需要在Info.plist中配置UIApplicationShortcutItems数组就可以了，数组的每一项（字典）就是一个Action，每一个Action有6个类型的字段配置： UIApplicationShortcutItemType(必须) UIApplicationShortcutItemTitle(必须) UIApplicationShortcutItemSubtitle(可选) UIApplicationShortcutItemIconType(可选) UIApplicationShortcutItemIconFile(可选) UIApplicationShortcutItemUserInfo(可选)如果是下面配置： 结果就是： 动态的Quick Action动态的的Quick Action配置只要在AppDelegate.swift的application(:didFinishLaunchingWithOptions)中添加如下代码即可： 12let shortcutItem = UIApplicationShortcutItem(type: &quot;com.andyron.NewRestaurant&quot;, localizedTitle: &quot;New Restaurant&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(type: .add), userInfo: nil)UIApplication.shared.shortcutItems = [shortcutItem] 使用动态的Quick Action配置我的FoodPin应用由于我之前使用UIPageViewController创建了开始结束页面，如果在在AppDelegate.swift的application(:didFinishLaunchingWithOptions)中添加动态的Quick Action就会出现直接跳过介绍页面的情况，所以要在看完结束也之后再添加Quick Action。 下载图标，拖进Assets.xcassets 在WalkthroughContentViewController的nextButtonTapped方法的case 2: 里添加3个Action： 123456789101112// 1if traitCollection.forceTouchCapability == UIForceTouchCapability.available &#123; let bundleIdentifier = Bundle.main.bundleIdentifier // 2 let shortcutItem1 = UIApplicationShortcutItem(type: &quot;\(bundleIdentifier).OpenFavorites&quot;, localizedTitle: &quot;Show Favorites&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(templateImageName: &quot;favortie-shortcut&quot;), userInfo: nil) let shortcutItem2 = UIApplicationShortcutItem(type: &quot;\(bundleIdentifier).OpenDiscover&quot;, localizedTitle: &quot;Discover restaurants&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(templateImageName: &quot;discover-shortcut&quot;), userInfo: nil) let shortcutItem3 = UIApplicationShortcutItem(type: &quot;\(bundleIdentifier).NewRestaurant&quot;, localizedTitle: &quot;New Restaurant&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(type: .add), userInfo: nil) // 3 UIApplication.shared.shortcutItems = [shortcutItem1, shortcutItem2, shortcutItem3]&#125; 1 判断设备是否支持3D Touch 2 UIApplicationShortcutIcon可以使用系统的图标，也可以使用外部图标 3 shortcutItems数组顺序对应从靠近图标开始向上或向下显示 实现Quick Action的具体跳转动作UIApplicationDelegate协议中的application(_:performActionFor:completionHandler:)方法会在Quick Action被点击后调用。 在AppDelegate.swift文件中定义一个QuickAction枚举。列举出quick action相关动作。 123456789101112enum QuickAction: String &#123; case OpenFavorites = &quot;OpenFavorites&quot; case OpenDiscover = &quot;OpenDiscover&quot; case NewRestaurant = &quot;NewRestaurant&quot; init?(fullIdentifier: String) &#123; guard let shortcutIdentifier = fullIdentifier.components(separatedBy: &quot;.&quot;).last else &#123; return nil &#125; self.init(rawValue: shortcutIdentifier) &#125;&#125; 在AppDelegate中实现application(_:performActionFor:completionHandler:)方法： 12345678910111213141516171819202122232425262728func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123; completionHandler(handleQuickAction(shortcutItem: shortcutItem))&#125;private func handleQuickAction(shortcutItem: UIApplicationShortcutItem) -&gt; Bool &#123; let shortcutType = shortcutItem.type guard let shortcutIdentifier = QuickAction(fullIdentifier: shortcutType) else &#123; return false &#125; guard let tabBarController = window?.rootViewController as? UITabBarController else &#123; return false &#125; switch shortcutIdentifier &#123; case .OpenFavorites: tabBarController.selectedIndex = 0 case .OpenDiscover: tabBarController.selectedIndex = 1 case .NewRestaurant: if let navController = tabBarController.viewControllers?[0] &#123; let restaurantTableViewController = navController.childViewControllers[0] restaurantTableViewController.performSegue(withIdentifier: &quot;addRestaurant&quot;, sender: restaurantTableViewController) &#125; else &#123; return false &#125; &#125; return false&#125; Peek 和 Pop 在RestaurantTableViewController的viewDidLoad方法中添加如下代码。使用UIViewController中的registerForPreviewing方法注册使用peek和pop。 1234// 如果3D Touch可以用，就注册本控制器可以peek和popif traitCollection.forceTouchCapability == .available &#123; registerForPreviewing(with: self as! UIViewControllerPreviewingDelegate, sourceView: view)&#125; 让RestaurantTableViewController符合UIViewControllerPreviewingDelegate协议： class RestaurantTableViewController: UITableViewController, NSFetchedResultsControllerDelegate, UISearchResultsUpdating, UIViewControllerPreviewingDelegate { 实现UIViewControllerPreviewingDelegate协议的方法： 1234567891011121314151617181920212223242526272829// 当按压时调用（peek）func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? &#123; // 1 guard let indexPath = tableView.indexPathForRow(at: location) else &#123; return nil &#125; // 2 guard let cell = tableView.cellForRow(at: indexPath) else &#123; return nil &#125; // 3 guard let restaurantDetailViewController = storyboard?.instantiateViewController(withIdentifier: &quot;RestaurantDetailViewController&quot;) as? RestaurantDetailViewController else &#123; return nil &#125; let selectedRestaurant = restaurants[indexPath.row] restaurantDetailViewController.restaurant = selectedRestaurant // 4 restaurantDetailViewController.preferredContentSize = CGSize(width: 0.0, height: 450.0) previewingContext.sourceRect = cell.frame return restaurantDetailViewController&#125;// pop时调用func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewController) &#123; show(viewControllerToCommit, sender: self)&#125; 1 通过按压的位置获得indexPath 2 通过indexPath获得cell 3 通过控制器的Storyboard ID获得控制器，之前如果没有填写Storyboard ID，现在也可填写合适Storyboard ID。 4 给peek的预览页面一个高度限制，非必须。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 24 使用TestFlight进行Beta测试]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-24.html</url>
    <content type="text"><![CDATA[Beta测试是在产品发布之前所进行的软件测试活动，它是技术测试的最后一个阶段，通过了验收测试，产品就会进入发布阶段。 在iOS 8 时，Apple发布TestFlight用于Beta测试。之前TestFlight一直是独立用户mobile app测试的mobile平台，在2014年2月，Apple收购的TestFlight母公司Burstly。现在TestFlight已经集成到iTunes Connect中，允许开发只通过邮件地址邀请Beta测试用户。 在iTunes Connect中创建一个App Record iTunes Connect 是为iOS开发者提供在App Store管理销售他们apps的Web应用工具。 在上传app之前，必须要在 iTunes Connect中有App Record。 需要提供下列信息： Platform App name Primary language Bundle ID SKU 创建成果后会跳到下一个页面 App信息这一步主要选择一下App分类的类别。 价格与销售范围 准备提交这一步主要添加截图、app描述、app图标、联系信息等信息 预览图和截图提高至少一张5.5 英寸的截图(1242x2208 pixels) ，iTunes Connect会自动生成其他屏幕尺寸的图片。详细可参考iTunes Connect Developer Guide 或 iTunes Connect 开发人员帮助（中文） app描述填写一些相关描述，关键词（以逗号分隔），URL等 App 综合信息 这边的App Store 图标要求是1024x1024 pixels，不能包含隐藏元素。 App 审核信息 版本发布 更新Build string回到Xcode，确认版本数字与iTunes Connect中一致。 准备App Icon和启动页图片 利用类似图标工场这种移动应用图标生成工具，可生成一些大小的图标。 可以在Finder中直接复制AppIcon.appiconset目录替代即可。 在默人的启动开始页面LaunchScreen.storyboard中，添加一个图片。 打包和验证App在上传app到iTunes Connect之前，如要创建app包，这在Xcode 8之后已经非常容易了。 在主菜单中选择Product &gt; Scheme &gt; Edit Scheme：确认Build Configuration是Release： 在主菜单中选择Product &gt; Archive，可能需要等待一段时间。 打包成功后，在主菜单中打开Window &gt; Organizer，出现如下界面： 选择Validate…，然后选择自己的开发者账号： 点击Validate，之后可能需要一段时间： 上传应用到iTunes Connect 上面的验证成功后，点击Upload to App Store…，然后在点击Upload，这个过程可能也需要比较长的时间。 管理内部测试用户 内部用户也就是 iTunes Connect 用户，最多可添加25个。可在用户和职能中添加。 添加iTunes Connect 用户 添加内部测试用户后，内部测试用户会收到邮件，内面有验证码。 下载 TestFlight 应用然后在 Redeem中输入验证码，即可下载安装应用测试。 管理外部测试用户（Beta测试用户）以前是最大限制2000，现在可以邀请10000名外部测试人员。外部测试用户不需要事先添加。 填写完整测试信息 新建群组，比如就叫外部测试员： 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 22 使用CloudKit]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-22.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 21 使用WKWebView和SFSafariViewController 学习打开网页，这一篇学习使用CloudKit。 iCloud最初乔布斯在WWDC2011是发布的，只为了给Apps、游戏能够在云端数据保存，让Mac和iOS之间数据自动同步所用。 最近几年才渐渐成长为云服务。如果想创建社交类型的，可以分享用户之间数据的app，就可考虑使用iCloud，这样就不需要自己再去构建一个后端APIs了。虽然可能由于国内的网络环境，iCloud实际应用效果并不好，不过还是有必要学一下的🙂。 如果开发了Web应用，同样也可以访问iOS应用的iCloud中数据。Apple分别提供了CloudKit JS和CloudKit库。 CloudKit默认给我们的app提供一些免费的空间： 当app的用户的活跃数提高，免费空间也会随之提高，详细可查看官网介绍。 理解CloudKit框架CloudKit框架不仅提供了存储功能，还提供了开发者与iCloud之间的各种交互。Containers和database是CloudKit框架的基础元素。 默认，一个app就是一个container，代码中就是CKContainer，一个container中包括三个database(CKDatabase)： 一个public database： app中所有用户都能查看 一个shared database：app中一组用户能查看（iOS 10） 一个private database：app中单个用户查看 为应用添加CloudKit 首先需要开发者账号。 然后在Capabilities中打开iCloud。 在CloudKit Dashboard中管理 Record 点击上图中的CloudKit Dashboard，或者直接访问https://icloud.developer.apple.com/dashboard/。最新的CloudKit Dashboard的页面有了一些变化。首先进去的是应用列表（也就是container列表），点击一个就进入如下页面： 点击Development的data，类似下面 选择Record Types（有点像关系数据中的表），创建新的类型Restaurant，并添加几个Field的。 选择Records（类型表中的数据），添加几条数据，注意选择public database。 使用 Convenience API获取public DatabaseCloudKit提供两种APIs让开发与iCloud交互：the convenience API 和 the operational API。 Convenience API的通常调用方式： 12345678let cloudContainer = CKContainer.default()let publicDatabase = cloudContainer.publicCloudDatabaselet predicate = NSPredicate(value: true)let query = CKQuery(recordType: &quot;Restaurant&quot;, predicate: predicate)publicDatabase.perform(query, inZoneWith: nil, completionHandler: &#123; (results, error) -&gt; Void in// Process the records&#125;) CKContainer.default()获取应用的Container。 publicCloudDatabase表示默认的public database。 NSPredicate和CKQuery是搜索条件 新建DiscoverTableViewController，继承至UITableViewController，关联discover.storyboard中的table view的控制器； 并修改其prototype cell的identifier为Cell。 在DiscoverTableViewController.swift中加入import CloudKit，并定义一个CKRecord的数组变量： var restaurants:[CKRecord] = [] 添加获取Records的函数： 12345678910111213141516171819202122232425func fetchRecordsFromCloud() &#123; let cloudContainer = CKContainer.default() let publicDatabase = cloudContainer.publicCloudDatabase let predicate = NSPredicate(value: true) let query = CKQuery(recordType: &quot;Restaurant&quot;, predicate: predicate) publicDatabase.perform(query, inZoneWith: nil, completionHandler: &#123; (results, error) -&gt; Void in if error != nil &#123; print(error) return &#125; if let results = results &#123; print(&quot;Completed the download of Restaurant data&quot;) self.restaurants = results OperationQueue.main.addOperation &#123; self.spinner.stopAnimating() self.tableView.reloadData() &#125; &#125; &#125;)&#125; 在perform中，当确定获取到了数据后，赋值给restaurants，并刷新table。 在viewDidLoad中添加： fetchRecordsFromCloud()。 添加table view相关代理方法： 12345678910111213141516171819202122override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return restaurants.count&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for:indexPath) // Configure the cell... let restaurant = restaurants[indexPath.row] cell.textLabel?.text = restaurant.object(forKey: &quot;name&quot;) as? String if let image = restaurant.object(forKey: &quot;image&quot;) &#123; let imageAsset = image as! CKAsset if let imageData = try? Data.init(contentsOf: imageAsset.fileURL) &#123; cell.imageView?.image = UIImage(data: imageData) &#125; &#125; return cell&#125; object(forKey:)是CKRecord中获取Record Field值的方法。 图片对象转换为CKAsset。 为什么慢？测试以上代码，发现fetchRecordsFromCloud函数中的打印信息”Completed the download of Restaurant data”已经显示在控制台了，但是还需要过一段时间App中才能显示，也就是说向iCloud中获取完数据后才开始准备table view加载。 这边就需要使用到多线程的概念。在iOS中，UI更新（像table重新加载）必须在主线程执行。这样获取iCloud数据的线程在进行时，UI更新也在同步进行。 123OperationQueue.main.addOperation &#123; self.tableView.reloadData()&#125; 使用operational API获取public Database Convenience API只适合简单和少量的查询。 更新fetchRecordsFromCloud方法： 123456789101112131415161718192021222324252627func fetchRecordsFromCloud() &#123; let cloudContainer = CKContainer.default() let publicDatabase = cloudContainer.publicCloudDatabase let predicate = NSPredicate(value: true) let query = CKQuery(recordType: &quot;Restaurant&quot;, predicate: predicate) // Create the query operation with the query let queryOperation = CKQueryOperation(query: query) queryOperation.desiredKeys = [&quot;name&quot;, &quot;image&quot;] queryOperation.queuePriority = .veryHigh queryOperation.resultsLimit = 50 queryOperation.recordFetchedBlock = &#123; (record) -&gt; Void in self.restaurants.append(record) &#125; queryOperation.queryCompletionBlock = &#123; (cursor, error) -&gt; Void in if let error = error &#123; print(&quot;Failed to get data from iCloud - \(error.localizedDescription)&quot;) return &#125; print(&quot;Successfully retrieve the data from iCloud&quot;) OperationQueue.main.addOperation &#123; self.tableView.reloadData() &#125; &#125; // Execute the query publicDatabase.add(queryOperation)&#125; 通过CKQueryOperation代替perform方法,它提供了许多查询选项。 desiredKeys代表需要查询的字段。 resultsLimit代表依次查询最大Record数目 加载指示（菊花转） 可以在viewDidLoad中添加类型如下代码： 123456let spinner:UIActivityIndicatorView = UIActivityIndicatorView()spinner.activityIndicatorViewStyle = .grayspinner.center = view.centerspinner.hidesWhenStopped = trueview.addSubview(spinner)spinner.startAnimating() 也可以通过在discover.storyboard中添加： 添加完发现 activity indicator view在控制器上面，这在Xcode中叫The Extra Views 在DiscoverTableViewController中添加接口，并关联。 @IBOutlet var spinner: UIActivityIndicatorView! 在viewDidLoad中添加代码： 1234spinner.hidesWhenStopped = truespinner.center = view.centertableView.addSubview(spinner)spinner.startAnimating() 数据加载完要隐藏加载提示：1234OperationQueue.main.addOperation &#123; self.spinner.stopAnimating() self.tableView.reloadData() &#125; 懒加载图片懒加载图片就是先加载一个本地默认图片，暂时不加载远程图片，当图片准备好在去更新图片视图。 修改请求字段desireKeys，让开始时不加图片: queryOperation.desiredKeys = [&quot;name&quot;] 更新 tableView(_:cellForRowAt:)： 1234567891011121314151617181920212223242526272829303132333435override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) let restaurant = restaurants[indexPath.row] cell.textLabel?.text = restaurant.object(forKey: &quot;name&quot;) as? String // Set the default image cell.imageView?.image = UIImage(named: &quot;photoalbum&quot;) // Fetch Image from Cloud in background let publicDatabase = CKContainer.default().publicCloudDatabase let fetchRecordsImageOperation = CKFetchRecordsOperation(recordIDs:[restaurant.recordID]) fetchRecordsImageOperation.desiredKeys = [&quot;image&quot;] fetchRecordsImageOperation.queuePriority = .veryHigh fetchRecordsImageOperation.perRecordCompletionBlock = &#123; (record, recordID, error) -&gt; Void in if let error = error &#123; print(&quot;Failed to get restaurant image: \(error.localizedDescription)&quot;) return &#125; if let restaurantRecord = record &#123; OperationQueue.main.addOperation() &#123; if let image = restaurantRecord.object(forKey: &quot;image&quot;) &#123; let imageAsset = image as! CKAsset print(imageAsset.fileURL) if let imageData = try? Data.init(contentsOf: imageAsset.fileURL) &#123; cell.imageView?.image = UIImage(data: imageData) &#125; &#125; &#125; &#125; &#125; publicDatabase.add(fetchRecordsImageOperation) return cell&#125; CKFetchRecordsOperation通过recordID获得特定的Record。 CKFetchRecordsOperation一些方法类似CKQueryOperation。 懒加载后发现，图片在其它视图显示后慢慢先后加载显示。 下拉刷新UIRefreshControl提供了标准的下拉刷新特性。 在DiscoverTableViewController的viewDidLoad中添加：12345// Pull To Refresh ControlrefreshControl = UIRefreshControl()refreshControl?.backgroundColor = UIColor.whiterefreshControl?.tintColor = UIColor.grayrefreshControl?.addTarget(self, action: #selector(fetchRecordsFromCloud), for: UIControlEvents.valueChanged) 每一次下拉是显示菊花转，并且调用fetchRecordsFromCloud方法。 在fetchRecordsFromCloud方法的queryCompletionBlock添加数据加载完成后去除菊花转代码： 12345if let refreshControl = self.refreshControl &#123; if refreshControl.isRefreshing &#123; refreshControl.endRefreshing() &#125;&#125; 刷新会出现重复数据，要在fetchRecordsFromCloud方法开始时，清理数据： 12restaurants.removeAll()tableView.reloadData() 使用CloudKit保存数据到iCloudCKDatabase的save(_:completionHandler:)的方法可用来保存数据到iCloud。实现用户新加数据时，既保存在本地的Core Data，有保存在iCloud中。 在AddRestaurantController中添加：import CloudKit。 在AddRestaurantController添加方法： 12345678910111213141516171819202122232425262728// 保存到Core Data的同时也保存的iCloud中func saveRecordToCloud(restaurant:RestaurantMO!) -&gt; Void &#123; // Prepare the record to save let record = CKRecord(recordType: &quot;Restaurant&quot;) record.setValue(restaurant.name, forKey: &quot;name&quot;) record.setValue(restaurant.type, forKey: &quot;type&quot;) record.setValue(restaurant.location, forKey: &quot;location&quot;) record.setValue(restaurant.phone, forKey: &quot;phone&quot;) let imageData = restaurant.image as! Data // Resize the image let originalImage = UIImage(data: imageData)! let scalingFactor = (originalImage.size.width &gt; 1024) ? 1024 / originalImage.size.width : 1.0 let scaledImage = UIImage(data: imageData, scale: scalingFactor)! // Write the image to local file for temporary use let imageFilePath = NSTemporaryDirectory() + restaurant.name! let imageFileURL = URL(fileURLWithPath: imageFilePath) try? UIImageJPEGRepresentation(scaledImage, 0.8)?.write(to: imageFileURL) // Create image asset for upload let imageAsset = CKAsset(fileURL: imageFileURL) record.setValue(imageAsset, forKey: &quot;image&quot;) // Get the Public iCloud Database let publicDatabase = CKContainer.default().publicCloudDatabase // Save the record to iCloud publicDatabase.save(record, completionHandler: &#123; (record, error) -&gt; Void in try? FileManager.default.removeItem(at: imageFileURL) &#125;)&#125; 在save方法的dismiss(animated:completion:)的前面添加： saveRecordToCloud(restaurant: restaurant) 排序CKQuery有属性sortDescriptors可用来排序。在DiscoverTableViewController的fetchRecordsFromCloud方法，query定义后添加： query.sortDescriptors = [NSSortDescriptor(key: &quot;creationDate&quot;, ascending: false)] creationDate是默认的创建时间字段。 Exercise：修改Discover样式 新建一个DiscoverTableViewCell，继承至UITableViewCell，并关联Discover的cell。 修改cell合适的样式，比如下面 在DiscoverTableViewCell中新建四个接口，并关联。 1234@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!@IBOutlet var thumbnailImageView: UIImageView! 更新tableView(_:cellForRowAt:)和fetchRecordsFromCloud相关代码 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 21 使用WKWebView和SFSafariViewController]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-21.html</url>
    <content type="text"><![CDATA[上一篇开始用Swift开发iOS 10 - 20 使用Tab Bar Controller 和 拆分Storyboard学习了工具栏和Storyboard的拆分，这一篇学习怎么在app中显示网页内容。由于原书中使用了的网站在国内不好访问，我就用了我的简书、博客、Github代替🙂。 设计about view 下载图片拖进Assets.xcasset。 打开about.storyboard，拖进一个Image View到table view header，height为190，image为about-logo，content mode为Aspect fit。选择table view cell，identifier为Cell，style为Basic。 新建AboutTableViewController继承至UITableViewController，关联about中的table view controller。 在AboutTableViewController，添加：123var sectionTitles = [&quot;Leave Feedback&quot;, &quot;Follow Us&quot;]var sectionContent = [[&quot;Rate us on App Store&quot;, &quot;Tell us your feedback&quot;], [&quot;Jianshu&quot;, &quot;Blog&quot;, &quot;Github&quot;]]var links = [&quot;http://www.jianshu.com/u/efce1a2a95ab&quot;, &quot;http://andyron.com&quot;, &quot;https://github.com/andyRon&quot;] table view的相关代理协议方法实现，这次使用俩个section，tableView(_:titleForHeaderInSection:)是获取section的title方法。1234567891011121314151617181920override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return sectionTitles.count&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // #warning Incomplete implementation, return the number of rows return sectionContent[section].count&#125;override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123; return sectionTitles[section]&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) cell.textLabel?.text = sectionContent[indexPath.section][indexPath.row] return cell&#125; 移除Tableview下面分割线，在viewDidLoad中添加： tableView.tableFooterView = UIView(frame: CGRect.zero) 用Mobile Safari打开Web可直接给出网址，通过Mobile Safari打开网站，UIApplication.shared.open(_:options:completionHandler:)。 123456789101112131415override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; switch indexPath.section &#123; case 0: if indexPath.row == 0 &#123; if let url = URL(string: &quot;http://www.apple.com/itunes/charts/paid-apps/&quot;) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125; &#125; default: break &#125; // 取消被选中状态 tableView.deselectRow(at: indexPath, animated: false)&#125; 使用WKWebView载入Web使用使用WKWebView载入Web的例子1234if let url = URL(string: &quot;http://andyron.com&quot;) &#123; let request = URLRequest(url: url) webView.load(request)&#125; 直接载入本地html文件的例子：123let url = URL(fileURLWithPath: &quot;about.html&quot;)let request = URLRequest(url: url)webView.load(request) 在about.storyboard中拖进一个新的View Controller，用来展示Web内容。使用ctrl-drag建立Show类型的segue，identifier为 showWebView。 新建WebViewController继承至UIViewController，关联上面的用来显示Web内容的View Controller。 在WebViewController.swift中添加import WebKit，变量var webView: WKWebView!。 更新 viewDidLoad： 123456789override func viewDidLoad() &#123; super.viewDidLoad() if let url = URL(string: &quot;http://andyron.com&quot;) &#123; let request = URLRequest(url: url) webView.load(request) &#125;&#125; 添加loadView，这个方法会在viewDidLoad之前调用创建WKWebView。 1234override func loadView() &#123; webView = WKWebView() view = webView&#125; 更新AboutTableViewController中的tableView(_didSelectRowAtIndexPath:)： 123456789101112131415161718override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; switch indexPath.section &#123; case 0: if indexPath.row == 0 &#123; if let url = URL(string: &quot;http://www.apple.com/itunes/charts/paid-apps/&quot;) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125; &#125; else if indexPath.row == 1 &#123; performSegue(withIdentifier: &quot;showWebView&quot;, sender: self) &#125; default: break &#125; // 取消被选中状态 tableView.deselectRow(at: indexPath, animated: false)&#125; 由于自从iOS 9之后，出于安全考虑，默认只能访问HTTPS的网站，如果需要访问HTTP的网站，就需要在plist文件中添加许可： 使用SFSafariViewController载入Web在AboutTableViewController.swift中加入import SafariServices，然后更新tableView(_didSelectRowAtIndexPath:)，只用通过url创建一个SFSafariViewController对象，然后使用present方法展示就可以了。1234567891011121314151617181920212223override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; switch indexPath.section &#123; case 0: if indexPath.row == 0 &#123; if let url = URL(string: &quot;http://www.apple.com/itunes/charts/paid-apps/&quot;) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125; &#125; else if indexPath.row == 1 &#123; performSegue(withIdentifier: &quot;showWebView&quot;, sender: self) &#125; case 1: if let url = URL(string: links[indexPath.row]) &#123; let safariController = SFSafariViewController(url: url) present(safariController, animated: true, completion: nil) &#125; default: break &#125; // 取消被选中状态 tableView.deselectRow(at: indexPath, animated: false)&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 20 使用Tab Bar Controller 和 拆分Storyboard]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-20.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 19 使用UIPageViewController构建介绍页面构建了开始介绍页面，这一篇学习使用Tab Bar Controller和拆分Storyboard。 创建 Tab Bar Controller 选择开始的Navigation Controller，Editor &gt; Embed in &gt; Tab Bar Controller，然后自动添加一个新的Tab Bar Controller 作为初始的控制器，之前Navigation Controller变成Tab Bar Controller的一部分了。 在Navigation Controller中选择 tab item，修改System Item为Favorites。 隐藏 Tab Bar工具栏在其他页面隐藏，选择Detail View，勾选Hide Bottom Bar on Push就可以。 也可以用代码形式，在RestaurantTableViewController中的prepare(for:)中添加： destinationController.hidesBottomBarWhenPushed = true 添加新的Tabs 添加一个新的Navigation Controller， 选中tab item，修改System Item为Recents；table view的navigation item的title为Discover 把新加的Navigation Controller加入到 Tab Bar Controller。用ctrl+drag从Tab Bar Controller到新的Navigation Controller，选择Relationship Segue - View Controllers。 改变新的Navigation Controller的tab bar的title为Recent，修改system item为Recents 同样的方式添加一个新的Navigation Controller， 选中tab item，修改System Item为More；table view的navigation item的title为About。也用ctrl+drag与Tab Bar Controller建立关系。 最终创建有三个Tab Bar Item的Tab Bar。 定制Tab Bar的样式修改Tab Bar的样式在application(_:didFinishLaunchingWithOptions:)中进行，类似下面的代码，详细的API可参考官方文档：123UITabBar.appearance().tintColor = UIColor(red: 235.0/255.0, green: 75.0/255.0,blue: 27.0/255.0, alpha: 1.0)UITabBar.appearance().barTintColor = UIColor.black 改变 Tab Bar Item的图片 从图片下载图片到Assets.xcasset。 在SB中修改三个Tab Bar Item的System Item都为Custom，修改Title和Image为想要的值，类似下图 在application(_:didFinishLaunchingWithOptions:)中修改样式：12UITabBar.appearance().tintColor = UIColor(red: 235.0/255.0, green: 75.0/255.0, blue: 27.0/255.0, alpha: 1.0)UITabBar.appearance().barTintColor = UIColor(red: 236/255.0, green: 240.0/255.0, blue: 241.0/255.0, alpha: 1.0) 改变选择指示图片（Selection Indicator Image）Selection Indicator Image就是指tab bar item被选中后与其它tab bar item不同的样式,在代码中和SB中都可以修改。 UITabBar.appearance().selectionIndicatorImage = UIImage(named: &quot;tabitem-selected&quot;) 最终效果： 拆分Storyboard当项目变大时，一个Storyboard就会很大，如果是项目中有很多人合作的话，一个Storyboard也很难管理。从Xcode7之后，新功能storyboard references解决了这个问题。 在Main.storyboard中选择，about相关的两个view controller，然后Editor &gt; Refactor to Storyboard…，新建名为about.storyboard的storyboard文件，就把这个两个独立出去了。 把about相关的view controller拆分出去后，在Main.storyboard里有一个关联图标，双击就可以跳转到about.storyboard中。 同样的方法，独立出discover相关view controller，生成discover.storyboard文件。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-tutorial-7：解析XML(swift)]]></title>
    <url>%2F2017%2Fios-tutorial-7-xml.html</url>
    <content type="text"><![CDATA[使用XMLParser解析XML文件，然后用table展示数据。 以Single View Application模板新建项目XMLParserTutorial。 删除SB中的View Controller，拖进一个Navigation Controller。选择新的View Controller为 “Is Initial View Controller”。设置Navigation Bar的title为Books。 新建一个继承至UITableViewController，名为TableViewController的控制器文件，并与SB的控制器关联。 新建一个xml文件Books.xml，用于之后解析，文件内容为: 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot;?&gt;&lt;catalog&gt; &lt;book id=&quot;1&quot;&gt; &lt;title&gt;To Kill a Mockingbird&lt;/title&gt; &lt;author&gt;Harper Lee&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;2&quot;&gt; &lt;title&gt;1984&lt;/title&gt; &lt;author&gt;George Orwell&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;3&quot;&gt; &lt;title&gt;The Lord of the Rings&lt;/title&gt; &lt;author&gt;J.R.R Tolkien&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;4&quot;&gt; &lt;title&gt;The Catcher in the Rye&lt;/title&gt; &lt;author&gt;J.D. Salinger&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;5&quot;&gt; &lt;title&gt;The Great Gatsby&lt;/title&gt; &lt;author&gt;F. Scott Fitzgerald&lt;/author&gt; &lt;/book&gt;&lt;/catalog&gt; 新建一个文件 Book.swift： 123456import Foundationclass Book &#123; var bookTitle: String = &quot;&quot; var bookAuthor: String = &quot;&quot;&#125; 在TableViewController中添加几个变量： 1234var books: [Book] = []var eName: String = &quot;&quot;var bookTitle = &quot;&quot;var bookAuthor = &quot;&quot; 在viewDidLoad方法中，添加读取XMl文件代码： 123456789override func viewDidLoad() &#123; super.viewDidLoad() if let path = Bundle.main.url(forResource: &quot;Books&quot;, withExtension: &quot;xml&quot;) &#123; if let parser = XMLParser(contentsOf: path) &#123; parser.delegate = self parser.parse() &#125; &#125; 添加Table View的数据源代理方法： 1234567891011121314151617override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return books.count&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) let book = books[indexPath.row] cell.textLabel?.text = book.bookTitle cell.detailTextLabel?.text = book.bookAuthor return cell&#125; 让TableViewController采纳XMLParserDelegate协议： class TableViewController: UITableViewController, XMLParserDelegate 实现XMLParserDelegate中的三个方法： 12345678910111213141516171819202122232425262728293031323334// 解析XMl元素开始时func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String] = [:]) &#123; print(&quot;开始 \(elementName)&quot;) eName = elementName if elementName == &quot;book&quot; &#123; bookTitle = &quot;&quot; bookAuthor = &quot;&quot; &#125;&#125;// 正在解析XMl元素func parser(_ parser: XMLParser, foundCharacters string: String) &#123; print(&quot;ing \(eName)&quot;) let data = string.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines) if (!data.isEmpty) &#123; if eName == &quot;title&quot; &#123; bookTitle += data &#125; else if eName == &quot;author&quot; &#123; bookAuthor += data &#125; &#125;&#125;// 结束解析XMl元素func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) &#123; print(&quot;结束 \(elementName)&quot;) if elementName == &quot;book&quot; &#123; let book = Book() book.bookTitle = bookTitle book.bookAuthor = bookAuthor books.append(book) &#125;&#125; 三个方法分别在XMl元素开始解析、正在解析、结束解析时调用，也就是说有很多元素时就不停在调用这三个方法。 代码XMLParserTutorial 参考：Parsing XML Tutorial]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 19 使用UIPageViewController构建介绍页面]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-19.html</url>
    <content type="text"><![CDATA[继续上一篇 开始用Swift开发iOS 10 - 18 Search Bar 和 UISearchController ，这一篇使用UIPageViewController构建介绍页面，与使用LaunchScreen.storyboard的启动页不同。 向Storyboard中添加UIPageViewController 在Storyboard拖进一个UIPageViewController。修改相关属性。 修改UIPageViewController的 storyboard ID 为 WalkthroughController。 类似UINavigationController，UIPageViewController也是一种容器类型的控制器。这种容器类型的控制器是用来管理其它多个控制器的。 如果容器内的控制器页面元素类似（上图就是这种情况），可以通过一个控制器重复利用。 设计介绍页 下载介绍页所需的图片，拖到Assets.xcasset。 拖动一个新的View Controller到SB中（作为重复使用的控制器），做一些UI设计： 设置背景为红色 添加一个Label名为Personalize，选择合适的字体和大小，居中。 添加一个Image View，300*232，居中。 添加另一个Label名为Pin your favorite restaurants and create your own food guide，282*64，行数为0，居中，选择合适的字体和大小。 添加一些约束 设置新的View Controller的 storyboard ID 为 WalkthroughContentViewController。最后大概如下： 创建WalkthroughContentViewController 创建WalkthroughContentViewController类文件，继承至UIViewController，并关联上面添加的新View Controller。 添加三个接口，关联两个Label和一个image view；添加四个变量，其中index是指多个介绍页的索引。 12345678@IBOutlet var headingLabel: UILabel!@IBOutlet var contentLabel: UILabel!@IBOutlet var contentImageView: UIImageView!var index = 0var heading = &quot;&quot;var imageFile = &quot;&quot;var content = &quot;&quot; 修改viewDidLoad为： 1234567override func viewDidLoad() &#123; super.viewDidLoad() headingLabel.text = heading contentLabel.text = content contentImageView.image = UIImage(named: imageFile)&#125; 实现 UIPageViewController 新建类WalkthroughPageViewController，继承至UIPageViewController。 让WalkthroughPageViewControlle符合UIPageViewControllerDataSource协议。 class WalkthroughPageViewController: UIPageViewController, UIPageViewControllerDataSource 新建几个变量，用于显示介绍页中的内容。 123var pageHeadings = [&quot;Personalize&quot;, &quot;Locate&quot;, &quot;Discover&quot;]var pageImages = [&quot;foodpin-intro-1&quot;, &quot;foodpin-intro-2&quot;, &quot;foodpin-intro-3&quot;]var pageContent = [&quot;Pin your favorite restaurants and create your own foodguide&quot;, &quot;Search and locate your favourite restaurant on Maps&quot;, &quot;Find restaurants pinned by your friends and other foodies around the world&quot;] 实现UIPageViewControllerDataSource协议的两个方法，分别在介绍页翻到下一个和翻到上一个时调用。contentViewController函数的作用是根据介绍页的索引获取不同的数据。instantiateViewController方法根据storyboard的中storyboard ID生成视图控制器。 1234567891011121314151617181920212223242526272829303132func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -&gt; UIViewController? &#123; var index = (viewController as! WalkthroughContentViewController).index index -= 1 return contentViewController(at: index)&#125;func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -&gt; UIViewController? &#123; var index = (viewController as! WalkthroughContentViewController).index index += 1 return contentViewController(at: index)&#125;func contentViewController(at index: Int) -&gt; WalkthroughContentViewController? &#123; if index &lt; 0 || index &gt;= pageHeadings.count &#123; return nil &#125; if let pageContentViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughContentViewController&quot;) as? WalkthroughContentViewController &#123; pageContentViewController.imageFile = pageImages[index] pageContentViewController.heading = pageHeadings[index] pageContentViewController.content = pageContent[index] pageContentViewController.index = index return pageContentViewController &#125; return nil&#125; 修改viewDidLoad： 12345678override func viewDidLoad() &#123; super.viewDidLoad() dataSource = self if let startingViewController = contentViewController(at: 0) &#123; setViewControllers([startingViewController], direction: .forward, animated: true, completion: nil) &#125;&#125; setViewControllers方法是设置UIPageViewController管理的视图控制器。 让介绍页在首页显示后跳出。 在RestaurantTableViewControlle中添加：123456override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) if let pageViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughController&quot;) as? WalkthroughPageViewController &#123; present(pageViewController, animated: true, completion: nil) &#125;&#125; 添加默认页面指示页面指示就是一般在页面下用于分辨当前是第一个页面的几个小点。实现UIPageViewControllerDataSource协议的两个方法：presentationCount(for:)表示总共有几个小点（页面）。presentationIndex(for:)表示当前页面的索引。12345678910func presentationCount(for pageViewController: UIPageViewController) -&gt; Int &#123; return pageHeadings.count&#125;func presentationIndex(for pageViewController: UIPageViewController) -&gt; Int &#123; if let pageContentViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughContentViewController&quot;) as? WalkthroughContentViewController &#123; return pageContentViewController.index &#125; return 0&#125; 修改页面指示的样式不用默认的页面指示，就要把上面两个方法删除，然后使用UIPageControl。 删除上面实现的两个方法。从对象库中拖一个Page Control到walkthrough content view controller底部，在属性检查器中修改适当属性，并添加约束。 在WalkthroughContentViewController中添加接口@IBOutlet var pageControl: UIPageControl!并与Page Control关联。在viewDidLoad中添加pageControl.currentPage = index 添加NEXT/DONE按钮 在walkthrough content view controller右下角添加一个按钮名为NEXT。 在WalkthroughContentViewController中添加接口，并按钮关联。 @IBOutlet var forwardButton: UIButton! 在viewDidLoad中添加根据索引判断按钮名的代码： 12345switch index &#123;case 0...1: forwardButton.setTitle(&quot;NEXT&quot;, for: .normal)case 2: forwardButton.setTitle(&quot;DONE&quot;, for: .normal)default: break&#125; 添加点击按钮的action，并与按钮关联 12345678910@IBAction func nextButtonTapped(sender: UIButton) &#123; switch index &#123; case 0...1: let pageViewController = parent as! WalkthroughPageViewController pageViewController.forward(index: index) case 2: dismiss(animated: true, completion: nil) default: break &#125;&#125; 在WalkthroughPageViewController中添加方法： 12345func forward(index: Int) &#123; if let nextViewController = contentViewController(at: index + 1) &#123; setViewControllers([nextViewController], direction: .forward, animated: true, completion: nil) &#125;&#125; 完成类似下面： 但因为之前是利用RestaurantTableViewController的viewDidAppear方法显示介绍页的，而viewDidAppear方法是页面显示后就调用一下，这样就出现不停进入介绍页。实际上只需要第一次打开app的时显示介绍页就可以了。 UserDefaults的使用UserDefaults是用来管理应用和用户相关的设置的。也就是可以用UserDefaults存储一些用户相关的少量数据，比如上面的是否看过介绍页，也就是是否点击过DONE按钮了。UserDefaults也是通过单例模式进行操作的，通过类属性standard获取单例。 nextButtonTapped中点击DONE按钮时设置一个值标志： 1234567891011@IBAction func nextButtonTapped(sender: UIButton) &#123; switch index &#123; case 0...1: let pageViewController = parent as! WalkthroughPageViewController pageViewController.forward(index: index) case 2: UserDefaults.standard.set(true, forKey: &quot;hasViewedWalkthrough&quot;) dismiss(animated: true, completion: nil) default: break &#125;&#125; 再到RestaurantTableViewController的viewDidAppear判断对应key值。 123456789override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) if UserDefaults.standard.bool(forKey: &quot;hasViewedWalkthrough&quot;) &#123; return &#125; if let pageViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughController&quot;) as? WalkthroughPageViewController &#123; present(pageViewController, animated: true, completion: nil) &#125;&#125; 完成介绍页。学习了UIPageViewController和UserDefaults。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 18 Search Bar 和 UISearchController]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-18.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 17 使用Core Data 是使用Core Data存储数据，这一篇是添加搜索功能。 使用 UISearchControllerUISearchController是一个简洁的创建搜索条和管理搜索结果的API。通常情况下，为以table为基础的app添加搜索条只需要下面三行代码就可以了，searchResultsController为nil时搜索结果显示就在当前搜索的页面以当前的样式显示。123searchController = UISearchController(searchResultsController: nil)searchController.searchResultsUpdater = selftableView.tableHeaderView = searchController.searchBar 为我的FoodPin应用添加搜索条: 在RestaurantTableViewController中添加一个变量： var searchController: UISearchController! 在viewDidLoad中初始化： searchController = UISearchController(searchResultsController: nil) tableView.tableHeaderView = searchController.searchBar 这样就添加了搜索条，但还每天添加搜索逻辑，搜索没效。 筛选内容 在RestaurantTableViewController中继续添加一个变量，用户存储筛选结果： var searchResults: [RestaurantMO] = [] 添加筛选方法： 1234567891011func filterContent(for searchText: String) &#123; searchResults = restaurants.filter(&#123; (restaurant) -&gt; Bool in if let name = restaurant.name &#123; let isMatch = name.localizedCaseInsensitiveContains(searchText) return isMatch &#125; return false &#125;)&#125; filter是数组的一个方法，它遍历数组的每一项进行闭包中的操作，根据结果判断是否删除对应项，最后得到一个筛选的数组。localizedCaseInsensitiveContains方法用来判断name中是否包含searchText（忽略大小写） 更新搜索结果 让RestaurantTableViewController “符合” UISearchResultsUpdating协议： class RestaurantTableViewController: UITableViewController, NSFetchedResultsControllerDelegate, UISearchResultsUpdating 实现UISearchResultsUpdating协议：中的updateSearchResults(for:)方法，这个方法在搜索条被选则和输入搜索字时调用： 123456func updateSearchResults(for searchController: UISearchController) &#123; if let searchText = searchController.searchBar.text &#123; filterContent(for: searchText) tableView.reloadData() &#125;&#125; 更新tableView(_:numberOfRowsInSection:)。UISearchController有一个isActive属性用来判断搜索控制器当前活跃状态。 1234567override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; if searchController.isActive &#123; return searchResults.count &#125; else &#123; return restaurants.count &#125;&#125; 更新tableView(_:cellForRowAt:)。根据UISearchController的状态判断是从restaurants中获取数据还是searchResults。 1234567891011121314151617override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell let restaurant = (searchController.isActive) ? searchResults[indexPath.row] : restaurants[indexPath.row] cell.nameLabel.text = restaurant.name cell.thumbnailImageView.image = UIImage(data: restaurant.image! as Data) cell.thumbnailImageView.layer.cornerRadius = 30.0 cell.thumbnailImageView.clipsToBounds = true cell.locationLabel.text = restaurant.location cell.typeLabel.text = restaurant.type cell.accessoryType = restaurant.isVisited ? .checkmark: .none return cell&#125; 实现一个新的方法，让table在搜索状态下不可以滑动编辑。 1234567override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool &#123; if searchController.isActive &#123; return false &#125; else &#123; return true &#125;&#125; 更新prepare(for:)，让segue在传输数据到detail view时的数据也相对应。 destinationController.restaurant = searchController.isActive ? searchResults[indexPath.row] : restaurants[indexPath.row 在viewDidLoad中添加两行代码： 12searchController.searchResultsUpdater = selfsearchController.dimsBackgroundDuringPresentation = false 现在就完成了搜索功能。 定制搜索条的样式UISearchBar提供一些属性用来定制。在viewDidLoad中添加：1234searchController.searchBar.placeholder = &quot;Search restaurants...&quot;searchController.searchBar.tintColor = UIColor.whitesearchController.searchBar.barTintColor = UIColor(red: 218.0/255.0, green:100.0/255.0, blue: 70.0/255.0, alpha: 1.0) Exercise：添加地址搜索只需要更改搜索函数filterContent：12345678910111213searchResults = restaurants.filter(&#123; (restaurant) -&gt; Bool in if let name = restaurant.name, let location = restaurant.location &#123; let isMatchName = name.localizedCaseInsensitiveContains(searchText) let isMatchLocation = location.localizedCaseInsensitiveContains(searchText) if isMatchName || isMatchLocation &#123; return true &#125; &#125; return false &#125;) 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 17 使用Core Data]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-17.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 16 介绍静态Table Views，UIImagePickerController和NSLayoutConstraint 中添加新建restaurant页面，但最后数据并没有保存下来，这一篇使用Core Data方式来持久化保存数据。 数据持久化一般是指数据库保存。在Web开发中，常用Oracle或MySQL等关系数据库来保存数据，通过SQL语句查询。在iOS中对应的数据库是SQLite。Core Data不是数据库，它是让开发者通过面向对象方式与数据库进行交互的库。 使用Core Data的例子新建一个使用Core Data的项目，在AppDelegate类中会比平常多了一个变量和一方法，另外还多了一个文件CoreDataDemo.xcdatamodeld。 123456789101112131415161718192021222324252627282930313233343536373839404142lazy var persistentContainer: NSPersistentContainer = &#123; /* The persistent container for the application. This implementation creates and returns a container, having loaded the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail. */ let container = NSPersistentContainer(name: &quot;CoreDataDemo&quot;) container.loadPersistentStores(completionHandler: &#123; (storeDescription, error) in if let error = error as NSError? &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. /* Typical reasons for an error here include: * The parent directory does not exist, cannot be created, or disallows writing. * The persistent store is not accessible, due to permissions or data protection when the device is locked. * The device is out of space. * The store could not be migrated to the current model version. Check the error message to determine what the actual problem was. */ fatalError(&quot;Unresolved error \(error), \(error.userInfo)&quot;) &#125; &#125;) return container&#125;()// MARK: - Core Data Saving supportfunc saveContext () &#123; let context = persistentContainer.viewContext if context.hasChanges &#123; do &#123; try context.save() &#125; catch &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nserror = error as NSError fatalError(&quot;Unresolved error \(nserror), \(nserror.userInfo)&quot;) &#125; &#125;&#125; 变量persistentContainer是NSPersistentContainer的实例，let container = NSPersistentContainer(name: &quot;CoreDataDemo&quot;)对应CoreDataDemo.xcdatamodeld文件，如果是自己添加时名字需要对应。 当数据变化(insert/update/delete)时 ，调用saveContext方法保存数据。 向项目中添加Data Model 右击FoodPin文件夹，选择新建Data Model文件，文件名为FoodPin。 选中新生成的FoodPin.xcdatamodeld，添加一个Restaurant Entity，然后再在此Entity下添加一些属性。 选中特定属性后可在右侧检查器中设置相关特性，比如是否强制需要。 创建Managed ObjectsCore Data框架中的 Managed Objects与Entity之间的关系，有点像代码中 接口变量 和 UI objects之间的关系。xcode可自动生成Managed Objects。 选中Restaurant Entity，在检查器中修改class的name为RestaurantMO，Codegen 为 Class Definition。 command-R 或 comman-B一下，表面上没有什么变化，在project navigator中没有多出文件。实际上已经生成RestaurantMO类，代码已经可以使用了，如果使用command+点击 RestaurantMO，就可以看到RestaurantMO的代码： 修改相关受影响的代码 RestaurantTableViewController.swift重新定义restaurants: var restaurants:[RestaurantMO] = []由于CoreData中存储图片是二进制，引用时不能用文件名: 12cell.thumbnailImageView.image = UIImage(data: restaurants[indexPath.row].imageas! Data) 12 if let imageToShare = UIImage(data: self.restaurants[indexPath.row].image as!Data) &#123; 由于RestaurantMO的属性值是可选值，使用时需要解包： 1let defaultText = &quot;Just checking in at &quot; + self.restaurants[indexPath.row].name! RestaurantDetailViewController.swift 1var restaurant:RestaurantMO! 1restaurantImageView.image = UIImage(data: restaurant.image as! Data) 12 geoCoder.geocodeAddressString(restaurant.location!, completionHandler: &#123;placemarks, error in MapViewController.swift 1var restaurant:RestaurantMO! 1leftIconView.image = UIImage(data: restaurant.image as! Data) ReviewViewController.swift 1var restaurant:RestaurantMO! 1restaurantImageView.image = UIImage(data: restaurant.image as! Data) 现在能成功运行，发现是没有数据的。 保存新数据到数据库 在AddTableViewController.swift中引入Core Data：import CoreData。添加变量var restaurant:RestaurantMO!。 在AppDelegate中加入上面例子一个变量和一方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// MARK: - Core Data stack lazy var persistentContainer: NSPersistentContainer = &#123; /* The persistent container for the application. This implementation creates and returns a container, having loaded the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail. */ let container = NSPersistentContainer(name: &quot;FoodPin&quot;) container.loadPersistentStores(completionHandler: &#123; (storeDescription, error) in if let error = error as NSError? &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. /* Typical reasons for an error here include: * The parent directory does not exist, cannot be created, or disallows writing. * The persistent store is not accessible, due to permissions or data protection when the device is locked. * The device is out of space. * The store could not be migrated to the current model version. Check the error message to determine what the actual problem was. */ fatalError(&quot;Unresolved error \(error), \(error.userInfo)&quot;) &#125; &#125;) return container &#125;() // MARK: - Core Data Saving support func saveContext () &#123; let context = persistentContainer.viewContext if context.hasChanges &#123; do &#123; try context.save() &#125; catch &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nserror = error as NSError fatalError(&quot;Unresolved error \(nserror), \(nserror.userInfo)&quot;) &#125; &#125; &#125; 在AddTableViewController的save方法的dismiss之前插入： 123456789101112131415161718// 1if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; restaurant = RestaurantMO(context: appDelegate.persistentContainer.viewContext) restaurant.name = nameTextField.text restaurant.type = typeTextField.text restaurant.location = locationTextField.text restaurant.isVisited = isVisited if let restaurantImage = photoImageView.image &#123; // 2 if let imageData = UIImagePNGRepresentation(restaurantImage) &#123; restaurant.image = NSData(data: imageData) &#125; &#125; print(&quot;Saving data to context ...&quot;) appDelegate.saveContext()&#125; UIApplication.shared这种形式是iOS SDK中比较常用单例模式，就是通过一个类属性shared获取整个app运行过程只需要一个实例的方法。UIApplication.shared.delegate as? AppDelegate就获取了AppDelegate对象。 获取图片的二进制数据对象。 运行，添加新的restaurant后并没有在Food Pin中显示，实际已经添加到数据库中，在RestaurantTableViewController里没有向数据库获取。 通过CoreData获取数据 在RestaurantTableViewController.swift中添加import CoreData。实现协议NSFetchedResultsControllerDelegate，这个协议中有方法，任何时候当获取来的数据有变化时立即通知代理。class RestaurantTableViewController: UITableViewController, NSFetchedResultsControllerDelegate 定义一个变量var fetchResultController: NSFetchedResultsController&lt;RestaurantMO&gt;! 在viewDidLoad中添加 123456789101112131415161718192021// 1 let fetchRequest: NSFetchRequest&lt;RestaurantMO&gt; = RestaurantMO.fetchRequest()// 2let sortDescriptor = NSSortDescriptor(key: &quot;name&quot;, ascending: true)fetchRequest.sortDescriptors = [sortDescriptor]if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; let context = appDelegate.persistentContainer.viewContext fetchResultController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: context, sectionNameKeyPath: nil, cacheName: nil) fetchResultController.delegate = self&#125;do &#123; // 3 try fetchResultController.performFetch() if let fetchedObjects = fetchResultController.fetchedObjects &#123; // 4 restaurants = fetchedObjects &#125;&#125; catch &#123; print(error)&#125; 1 从RestaurantMO对象获得数据请求对象NSFetchRequest。 2 通过NSSortDescriptor来设置获取结果的排序方式。 3 performFetch方法执行从数据库中获取数据请求。 4 把请求结果复制给变量restaurants。 数据库中数据变化，将调用来自NSFetchedResultsControllerDelegate三个方法，调用三个方法的时间可以简单的理解分别为数据将要改变、数据正在改变、数据改变后：controllerWillChangeContent(_:)controller(_:didChange:at:for:newIndexPath:)controllerDidChangeContent(_:) 方法的实现，也分别对table view有不同处理： 123456789101112131415161718192021222324252627282930func controllerWillChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) &#123; tableView.beginUpdates()&#125;func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) &#123; switch type &#123; case .insert: if let newIndexPath = newIndexPath &#123; tableView.insertRows(at: [newIndexPath], with: .fade) &#125; case .delete: if let indexPath = indexPath &#123; tableView.deleteRows(at: [indexPath], with: .fade) &#125; case .update: if let indexPath = indexPath &#123; tableView.reloadRows(at: [indexPath], with: .fade) &#125; default: tableView.reloadData() &#125; if let fetchedObjects = controller.fetchedObjects &#123; restaurants = fetchedObjects as! [RestaurantMO] &#125;&#125;func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) &#123; tableView.endUpdates()&#125; 现在运行程序，添加新的Restaurant就能同步显示了。 通过CoreData删除数据更新RestaurantTableViewController的tableView(_:editActionsForRowAt:_)方法中的 deleteAction。1234567891011let deleteAction = UITableViewRowAction(style: .default, title: &quot;Delete&quot;, handler: &#123; (action, indexPath) -&gt; Void in if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; let context = appDelegate.persistentContainer.viewContext let restaurantToDelete = self.fetchResultController.object(at: indexPath) context.delete(restaurantToDelete) appDelegate.saveContext() &#125; &#125;) 现在删除一项后，重新启动后，数据消失。 更新数据更新RestaurantDetailViewController的中的ActionratingButtonTapped: ：12345678910111213141516171819202122@IBAction func ratingButtonTapped(segue: UIStoryboardSegue) &#123; if let rating = segue.identifier &#123; restaurant.isVisited = true switch rating &#123; case &quot;great&quot;: restaurant.rating = &quot;Absolutely love it! Must try.&quot; case &quot;good&quot;: restaurant.rating = &quot;Pretty good.&quot; case &quot;dislike&quot;: restaurant.rating = &quot;I don&apos;t like it.&quot; default: break &#125; &#125; if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; appDelegate.saveContext() &#125; tableView.reloadData()&#125; 现在评价一项后，重新启动后评价就会保留。 Exercise：添加新字段之前新建Restaurant页面没有Phone字段，现在添加 在SB的New Restaurant添加新Cell，在AddRestaurantController中添加相关接口并关联。 更新AddRestaurantController中的save:Action相关代码。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-0：说明和目录]]></title>
    <url>%2F2017%2Fswift-0.html</url>
    <content type="text"><![CDATA[这是我学习Swift的一个笔记和总结，以playground的形式放在我的github上，学习的版本是swift 3 。 学习资源 官方文档 The Swift Programming Language任何好的技术官方文档总是最好的学习资源。😋 官方文档的中文版好多小伙伴一起合作翻译，从swift刚才来就很快翻译，以后不断更新，发起者在开始发起翻译时还是个在校学生，很厉害，真的非常感谢。 这是raywenderlich.com网站出的书，不过是收费的。😑 有需要的小伙伴可私信我😎 为什么是playground的形式很多概念单用文字描述不大好理解，playground方便利用Xcode查看和调试。很多时候一些不常用的语法很容易忘记，通过playground很方便温习。 目录 以撸代码的形式学习Swift-1：The Basics 以撸代码的形式学习Swift-2：Basic Operators 以撸代码的形式学习Swift-3：Strings and Characters 以撸代码的形式学习Swift-4：Collection Type 以撸代码的形式学习Swift-5：Control Flow 以撸代码的形式学习Swift-6：Functions 以撸代码的形式学习Swift-7：Closure 以撸代码的形式学习Swift-8：Enumerations 以撸代码的形式学习Swift-9：Classes and Structures 以撸代码的形式学习Swift-10：Properties 以撸代码的形式学习Swift-11：Methods 以撸代码的形式学习Swift-12：Subscripts 以撸代码的形式学习Swift-13：Inheritance 以撸代码的形式学习Swift-14：Initialization 以撸代码的形式学习Swift-15：(类的)Deinitialization 以撸代码的形式学习Swift-16：Automatic Reference Counting 以撸代码的形式学习Swift-17：Optional Chaining 以撸代码的形式学习Swift-18：Error Handling 以撸代码的形式学习Swift-19：Type Casting(类型转换) 以撸代码的形式学习Swift-20：Nested Types(嵌套类型) 以撸代码的形式学习Swift-21：Extensions 以撸代码的形式学习Swift-22：Protocols 以撸代码的形式学习Swift-23：Generics 以撸代码的形式学习Swift-24：Access Control 以撸代码的形式学习Swift-25：Advanced Operators]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 16 介绍静态Table Views，UIImagePickerController和NSLayoutConstraint]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-16.html</url>
    <content type="text"><![CDATA[继续上一篇开始用Swift开发iOS 10 - 15 使用地图，这一篇通过添加一个新建Restaurant页面来介绍静态Table Views，UIImagePickerController，NSLayoutConstraint。静态Table Views就是固定cell数目的Table Views；UIImagePickerController用来从设备图片库中获取图片；NSLayoutConstraint就是约束类，用来用代码形式添加约束。 添加新的Table View Controller 拖动一个Table View Controller到SB中。 修改成Table View的content为static cells。 选中Table View Section，修改Rows成5。 下载 [图片] (http://www.appcoda.com/resources/swift3/photoicons.zip)，拖进`Assets` 修改第一个Cell高度为250。添加Image View， image为photoalbum，大小64*64，水平和垂直居中。 第二个cell高度为72。添加一个Label文本NAME。添加一个Text Field,placeholder为Restaurant Name，border style为 none，宽度为339。添加适当约束。 第三个和第四个Cell与第二个类似，Label文本分别为TYPE LOCATION，Text Field的 placeholder 分别为Restaurant Type，Restaurant Location。 第五个 高度为72。 添加一个Label文本Have You Been Here 。添加两个Button，title分别为YES、NO，字体颜色都为white，背景颜色分别为red，gray。 添加segue 在Food Pin Controller的Navigation bar的右边添加一个bar button item，System Item为Add。 把上面新建是我table view controller内嵌在一个Navigation controller中，选中table view controller，在菜单栏中选择Editor &gt; Embed in &gt; Navigation Controller，设置其navigation bar的title为New Restaurant。 关联Add按钮和New Restaurant Controller的Navigation controller，segue类型present modally，identifier为addRestaurant。 在New Restaurant Controller的Navigation bar的左边添加一个bar button item，System Item为 Cancel，tint为white。 在RestaurantTableViewController中添加unwind segue的action。用control-drag关联。 12@IBAction func unwindToHomeScreen(segue:UIStoryboardSegue) &#123;&#125; 使用UIImagePickerController调用相册 新建AddRestaurantController，继承至UITableViewController。关联New Restaurant Controller。 删除除了viewDidLoad方法的其他方法，静态类型不需要了。 添加tableView(_:didSelectRowAt:)：1234567891011override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; if indexPath.row == 0 &#123; if UIImagePickerController.isSourceTypeAvailable(.photoLibrary) &#123; let imagePicker = UIImagePickerController() imagePicker.allowsEditing = false imagePicker.sourceType = .photoLibrary present(imagePicker, animated: true, completion: nil) &#125; &#125;&#125; 选择第一个cell，也就是图片，通过isSourceTypeAvailable方法判断是否有图库可用。 在Info.plist中添加使用图库的请求描述， Privacy - Photo Library Usage Description -&gt; You need to grant the app access to your photo library so you can pick your favorite restaurant photo. 。 实现UIImagePickerControllerDelegate协议 添加UIImagePickerControllerDelegate 和UINavigationControllerDelegate class AddRestaurantController: UITableViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate { 添加接口@IBOutlet var photoImageView: UIImageView!，并关联。 添加函数imagePickerController(_:didFinishPickingMediaWithInfo:)，当用户从图库中选择图片时调用。 12345678910func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let selectedImage = info[UIImagePickerControllerOriginalImage] as? UIImage &#123; photoImageView.image = selectedImage photoImageView.contentMode = .scaleAspectFill photoImageView.clipsToBounds = true &#125; dismiss(animated: TUREAD, completion: nil)&#125; 在tableView(_:didSelectRowAt:)中的imagePicker定义后添加： imagePicker.delegate = self 用代码的方式定义约束之前都是通过storyboard设置约束，其实也可以通过代码的形式设置。 之前的地图的约束例子，storyboard 中的Map View.leading = leading等价于： let leadingConstraint = NSLayoutConstraint(item: mapView, attribute: NSLayoutAttribute.leading, relatedBy: .equal, toItem: mapView.superview, attribute: .leading, multiplier: 1, constant: 0) leadingConstraint.isActive = true 在添加imagePickerController(_:didFinishPickingMediaWithInfo:)的dismiss(animated: true, completion: nil)之前添加4个约束代码。 123456789let leadingConstraint = NSLayoutConstraint(item: photoImageView, attribute: .leading, relatedBy: .equal, toItem: photoImageView.superview, attribute: .leading, multiplier: 1, constant: 0) leadingConstraint.isActive = true let trailingConstrain = NSLayoutConstraint(item: photoImageView, attribute: .trailing, relatedBy: .equal, toItem: photoImageView.superview, attribute: .trailing, multiplier: 1, constant: 0) trailingConstrain.isActive = true let topConstraint = NSLayoutConstraint(item: photoImageView, attribute: .top, relatedBy: .equal, toItem: photoImageView.superview, attribute: .top, multiplier: 1, constant: 0) let buttomConstraint = NSLayoutConstraint(item: photoImageView, attribute: .bottom, relatedBy: .equal, toItem: photoImageView.superview, attribute: .bottom, multiplier: 1, constant: 0) 添加约束前后对比： Exercise：验证添加数据 在New Restaurant Controller的Navigation controller的有右上角添加Save按钮。 在AddRestaurantController中添加五个接口和一个变量，并关联。 123456@IBOutlet var nameTextField:UITextField!@IBOutlet var typeTextField:UITextField!@IBOutlet var locationTextField:UITextField!@IBOutlet var yesButton:UIButton!@IBOutlet var noButton:UIButton! var isVisited: Bool = true 添加一个Action，关联save按钮。 1234567891011121314@IBAction func save(_ sender: Any) &#123; if (nameTextField.text?.isEmpty)! || (typeTextField.text?.isEmpty)! || (locationTextField.text?.isEmpty)! &#123; let alertController = UIAlertController(title: &quot;Oops&quot;, message: &quot;We can&apos;t proceed because one of the fields is blank....&quot;, preferredStyle: .alert) let alertAction = UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil) alertController.addAction(alertAction) present(alertController, animated: true, completion: nil) &#125; else &#123; print(nameTextField.text, typeTextField.text, locationTextField.text, isVisited) dismiss(animated: true, completion: nil)// performSegue(withIdentifier: &quot;unwindToHomeScreen&quot;, sender: self) &#125;&#125; 去除 Add Restaurant view controller回到主界面有两种方法，一是dismiss(animated: true, completion: nil)，而是利用unwind segue。 添加一个Action toggleBeenHereButton:，用于yesButton和noButton的操作。1234567891011@IBAction func toggleBeenHereButton(sender: UIButton) &#123; if sender == yesButton &#123; isVisited = true yesButton.backgroundColor = UIColor.red noButton.backgroundColor = UIColor.gray &#125; else &#123; isVisited = false yesButton.backgroundColor = UIColor.gray noButton.backgroundColor = UIColor.red &#125;&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 15 使用地图]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-15.html</url>
    <content type="text"><![CDATA[继续上一盘开始用Swift开发iOS 10 - 14 基础动画，模糊效果和Unwind Segue，这一篇使用地图。添加MapKit框架： 添加Map到应用中效果图如下： 在Detail view的table view底部添加一个Map View。高度设置为135，取消一些属性zooming, scrolling, rotating等，使地图没有交互功能。 删除之前去掉table view底部的代码，让底部显示。tableView.tableFooterView = UIView(frame: CGRect.zero) 添加新的视图控制器，并在其中添加Map View，调整大小为全屏。 control-drag从detail视图控制器到新的地图视图控制器，选择show。因为table view的头部和底部是不能选择的，所有不能从table view的底部control-drag到地图视图控制器。 为了能检测的table view底部map的是否被接触，需要为地图添加UITapGestureRecognizer 。在RestaurantDetailViewController.swift中引入 import MapKit;定义地图接口@IBOutlet var mapView: MKMapView!，并关联;在viewDidLoad中添加：12let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(showMap))mapView.addGestureRecognizer(tapGestureRecognizer) 另外添加方法：123func showMap() &#123; performSegue(withIdentifier: &quot;showMap&quot;, sender: self)&#125; 用Geocoder转换地址到经纬度类似下面：1234567let geoCoder = CLGeocoder()geoCoder.geocodeAddressString(&quot;上海东方明珠&quot;, completionHandler: &#123; placemarks, error in for p in placemarks! &#123; print(p.location?.coordinate) &#125;&#125;) placemarks是CLPlacemark的数组。 地图标注（annotation）介绍通过地址文本获得经纬度后就可在地图上标注指示，类似下面的样子： 地图标注的代码一般如下，先通过地址文本生成的经纬度，规定MKPointAnnotation的经纬度，然后把MKPointAnnotation添加到地图视图中即可。12345let annotation = MKPointAnnotation()if let location = placemark.location &#123; annotation.coordinate = location.coordinate mapView.addAnnotation(annotation)&#125; 为没有交互的地图添加标注在RestaurantDetailViewController.swift的viewDidLoad中添加：123456789101112131415161718192021222324252627let geoCoder = CLGeocoder()geoCoder.geocodeAddressString(restaurant.location, completionHandler: &#123; placemarks, error in if error != nil &#123; print(error) return &#125; if let placemarks = placemarks &#123; let placemark = placemarks[0] let annotation = MKPointAnnotation() if let location = placemark.location &#123; annotation.coordinate = location.coordinate self.mapView.addAnnotation(annotation) // 规定地图显示半径 250米 let region = MKCoordinateRegionMakeWithDistance(annotation.coordinate, 250, 250) self.mapView.setRegion(region, animated: false) &#125; &#125;&#125;)``` ### 为全屏的地图添加标注- 新建一个视图控制器`MapViewController`，关联全屏地图控制器，引入地图框架 `import MapKit`。- 第一个地图接口和`restaurant`变量 @IBOutlet var mapView: MKMapView!var restaurant:Restaurant!1- 更新`viewDidLoad`： override func viewDidLoad() { super.viewDidLoad() let geoCoder = CLGeocoder() geoCoder.geocodeAddressString(restaurant.location, completionHandler: { placemarks, error in if error != nil { print(error) return } if let placemarks = placemarks { // Get the first placemark let placemark = placemarks[0] // 1 let annotation = MKPointAnnotation() annotation.title = self.restaurant.name annotation.subtitle = self.restaurant.type if let location = placemark.location { annotation.coordinate = location.coordinate // 2 self.mapView.showAnnotations([annotation], animated: true) self.mapView.selectAnnotation(annotation, animated: true) } } }) } 123456 + 1 设置`MKPointAnnotation`一些属性 + 2 在地图展示标注。地图上课展示很多标注。`selectAnnotation:`方法是标注显示被选中的样式。### 在标注中添加图片- 让`MapViewController`实现`MKMapViewDelegate`协议，并在`viewDidLoad`中设置`mapView.delegate = self`- 添加`mapView(_:viewFor:)`方法，当地图每次需要annotation时调用： func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? { let identifier = &quot;MyPin&quot; // 1 if annotation.isKind(of: MKUserLocation.self) { return nil } // 2 var annotationView: MKPinAnnotationView? = mapView.dequeueReusableAnnotationView(withIdentifier: identifier) as? MKPinAnnotationView if annotationView == nil { annotationView = MKPinAnnotationView(annotation: annotation, reuseIdentifier: identifier) annotationView?.canShowCallout = true } // 3 let leftIconView = UIImageView(frame: CGRect(x: 0, y: 0, width: 53, height: 53)) leftIconView.image = UIImage(named: restaurant.image) annotationView?.leftCalloutAccessoryView = leftIconView // 4 annotationView?.pinTintColor = UIColor.orange return annotationView } ``` 1 判断是否用户当前位置。用户当前位置算是一种特殊的标注，是当前位置，就不需要另外添加标注了。 2 创建MKPinAnnotationView。有点类似创建table view cell。 3 在MKPinAnnotationView上添加图片。 4 改变标注针的颜色。 地图定制mapView.showsCompass = true mapView.showsScale = true mapView.showsTraffic = true showsCompass表示在右上角显示罗盘。showsScale 表示在左上角显示缩放比例尺。 showsTraffic表示显示交通信息。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 14 基础动画，模糊效果和Unwind Segue]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-14.html</url>
    <content type="text"><![CDATA[动画是通过一系列静态图片（帧）快速显示来模拟动作和形状的变化过程。 在iOS中，创建基础动画很简单，只需要利用UIView的类型方法：animate(withDuration:animations:)。这个方法的原理就是，设置好开始状体和结束状态，然后 UIView animation 创建中间的过程效果。继续上一篇开始用Swift开发iOS 10 - 13 Self Sizing Cells and Dynamic Type。 添加评级Button 下载图片包，添加到xcassets里。 在detail view右上角添加一个Button，设置其内容为空，image为更添加的图片check（一个对勾图标），type为system，tint为white。 为Button添加四个约束，右、上两个spacing约束，宽度和高度约束。 创建Restaurant Review视图控制器 在storyboard中新建一个View Controller。 在新建视图控制器中添加Image View，并改变其大小为整个view，先设置image属性为一个随机图片，比如cafeloisl。 并设置一些约束。 按照下图设置之后是UI： 在Review的图片上添加一个UIView，x、y、宽度、高度分别是53、40、269、420。 添加Image View，宽度和高度分别为269，200，随机设置image 添加一个内容为You&#39;ve dined here. What do you think?的Label。字体风格为Light，大小为27，居中退器，行数为2。 添加三个按钮内容分别为Absolutely love it!，Good，I don&#39;t like it。背景为红色，tint为white，字体是Light和16。 设置三个按钮为一个stack view，改变distribution为Fill Equally，spaing为5。 为上面添加的UIView添加四个约束。上左右的spacing约束分别为20，37，37。高度约束为420。 为label添加左右下三个spacing约束，值都是15。 为stack view天机左右下三个spacing约束，分别为8，8，10。 创建Present modally类型的Segue在开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue中介绍过Segue类型。Present modally是新页面将以动画形式从底部出现到覆盖整个手机屏幕。 contrl-drag从对勾button到Review视图控制，选择Present modally。并设置新生成segue的identifier为showReview。 定义如何退出Review View Controller在Navigation Controller中自带了返回按钮，这边需要自己设置unwind segue。 在Review View Controller中的UIView的右上角添加一个关闭按钮，类似于对勾按钮，添加右上和宽度高度约束。 为了实现unwind segue，需要做两件事：首先，在返回的的视图控制器（RestaurantDetailViewController）中定义一个方法，定义这个方法是为了告诉xcode这个segue是可以返回的。12@IBAction func close(segue:UIStoryboardSegue) &#123;&#125; 其次在IB中关联返回。control+drag关闭按钮到Exit，选择closeWithSegue:。 为背景图片添加模糊效果UIVisualEffectView 新建ReviewViewController继承至UIViewController，关联上面新建视图控制器。 在ReviewViewController中添加背景图片结构，并关联图片。@IBOutlet var backgroundImageView: UIImageView! 在ReviewViewController的viewDidLoad中添加：1234let blurEffect = UIBlurEffect(style: .dark)let blurEffectView = UIVisualEffectView(effect: blurEffect)blurEffectView.frame = view.boundsbackgroundImageView.addSubview(blurEffectView) 模糊效果有点像在要添加的视图上面添加一个视图(UIVisualEffectView)，这图有模糊效果(UIBlurEffect)，模糊样式通过UIBlurEffectStyle控制，有三种extraLight, light, dark。 实现 UIView Animation 为准备实现动画效果的UIView添加接口，并关联。@IBOutlet var containerView: UIView! 定义初始状态：在ReviewViewController的viewDidLoad中添加:containerView.transform = CGAffineTransform.init(scaleX: 0, y: 0) 定义介绍状态：在ReviewViewController的viewDidAppear中添加：12345override func viewDidAppear(_ animated: Bool) &#123; UIView.animate(withDuration: 0.3, animations: &#123; self.containerView.transform = CGAffineTransform.identity &#125;)&#125; CGAffineTransform.identity表示原本设置的大小和位置状态。 Spring 动画只要修改一下结束状态就可以了：123UIView.animate(withDuration: 0.4, delay: 0.0, usingSpringWithDamping: 0.3, initialSpringVelocity: 0.2, options: .curveEaseInOut, animations: &#123; self.containerView.transform = CGAffineTransform.identity&#125;, completion: nil) 从上向下的动画只要修改一下初始状态，把初始位置设置在上面即可：1containerView.transform = CGAffineTransform.init(translationX: 0, y: -1000) 组合两种变化把containerView.transform = CGAffineTransform.init(translationX: 0, y: -1000)修改成：1234let scaleTransform = CGAffineTransform.init(scaleX: 0, y: 0)let translateTransform = CGAffineTransform.init(translationX: 0, y: -1000)let combineTransform = scaleTransform.concatenating(translateTransform)containerView.transform = combineTransform Unwind Segues 和数据传输在Review View中点击三个不同评价按钮也通过Unwind Segues返回并传输数据。 在RestaurantDetailViewController在添加另外一个unwind action方法。 12@IBAction func ratingButtonTapped(segue: UIStoryboardSegue) &#123;&#125; 分别对三个按钮control+drag到Exit，选择ratingButtonTappedWithSegue:，并分别把三个unwind segue的identifier改成 great good dislike。 在Restaurant中添加rating属性： var rating = &quot;&quot; 更新 ratingButtonTapped(segue:)： 1234567891011121314151617@IBAction func ratingButtonTapped(segue: UIStoryboardSegue) &#123; if let rating = segue.identifier &#123; restaurant.isVisited = true switch rating &#123; case &quot;greate&quot;: restaurant.rating = &quot;Absolutely love it! Must try.&quot; case &quot;good&quot;: restaurant.rating = &quot;Pretty good.&quot; case &quot;dislike&quot;: restaurant.rating = &quot;I don&apos;t like it.&quot; default: break &#125; &#125; tableView.reloadData()&#125; 更新RestaurantDetailViewController的tableView(_:cellForRowAt:)中当fieldLabel为“Been here”的valueLabel的值： cell.valueLabel.text = (restaurant.isVisited) ? &quot;Yes, I&apos;ve been herebefore. \(restaurant.rating)&quot; : &quot;No&quot; 修改ReviewViewController中的图片为相应的图片 在ReviewViewController中添加一个属性：var restaurant: Restaurant! 在RestaurantDetailViewController中添加prepare(for:sender:)方法，作为RestaurantDetailViewController到ReviewViewController的segue时调用，用于传输数据。 123456override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showReview&quot; &#123; let destinationController = segue.destination as! ReviewViewController destinationController.restaurant = self.restaurant &#125;&#125; 在ReviewViewController 中添加图片接口。@IBOutlet var topImageView: UIImageView! 在ReviewViewController的viewDidLoad中显示图片：123let image = UIImage(named: self.restaurant.image)backgroundImageView.image = imagetopImageView.image = image 为closeButton添加动画效果 添加接口@IBOutlet var closeButton: UIButton! 在viewDieLoad中添加：closeButton.transform = CGAffineTransform.init(scaleX: 1000, y: 0) 在 viewDidAppear:添加：12345UIView.animate(withDuration: 0.5, delay: 0.5, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.3, options: .curveEaseInOut, animations: &#123; self.closeButton.transform = CGAffineTransform.identity &#125;, completion: nil) 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习6：Fondation-Kit介绍]]></title>
    <url>%2F2017%2Foc-basic-6.html</url>
    <content type="text"><![CDATA[12macOS -&gt; Cocoa -&gt; Foundation, AppKitiOS -&gt; Cocoa Touch -&gt; Foundation, UIKit(UIView, UIController) Foundation框架的基础是CoreFoundation（C语言），如果函数或变量是以CF开头，就是CoreFoundation框架中的。 Foundation中一些有用的数据类型范围： NSRange1234typedef struct _NSRange &#123; NSUInteger location; NSUInteger length;&#125; NSRange; 表示相关事务的范围。有三种方式初始化： 直接给字段赋值： 123NSRange range;range.location = 12;range.length = 5; 应用C语言的聚合结构赋值：NSRange range = {17, 4} 函数NSMakeRange()：NSRange range3 = NSMakeRange(12, 5);这个方法的好处是可以在任何能够使用函数的地方直接使用：[anObject flarbulateWithRange: NSMakeRange(13, 15)]; 几何数据类型CG前缀，表示Core Graphics框架（C语言），用来进行2D渲染。 CGPoint表示坐标 12345struct CGPoint&#123; float x; float y;&#125; CGSize表示大小，用来存储长度和宽度 12345struct CGSize&#123; float width; float height;&#125; CGRect 表示矩形，由坐标和大小复合而成 12345struct CGRect&#123; CGPoint origin; CGSize size;&#125; 对应创建函数： CGPointMake(), CGSizeMake(), CGRectMake() 集合数据类型是C语言结构体而不是类，是考虑性能的原因。 字符串字符串类： NSString。 通过格式字符串和参数创建NSString： 12NSString *height;height = [NSString stringWithFormat:@&quot;%d, %d&quot;, 4, 3]; 类方法： 以+为起始符的。 字符长度，实例方法length： - (NSUInteger) length; 字符串比较 (BOOL)isEqualToString:(NSString *)aString;，表示字符串内容是否相同，返回BooL；==判断字符串的指针是否相同，也就是是否是同一个事务。 12345678910NSString *thing1 = @&quot;hello 5&quot;;NSString *thing2 = [NSString stringWithFormat:@&quot;hello %d&quot;, 5]; if ([thing1 isEqualToString:thing2]) &#123; NSLog(@&quot;两个字符串内容相同&quot;);&#125;if (thing1 == thing2) &#123; NSLog(@&quot;两个字符串是同一个对象&quot;);&#125; - (NSComparisonResult)compare:(NSNumber *)decimalNumber;，逐个比较字符串的每个字符，判断大小。返回一个枚举类型NSComparisonResult，三个枚举值分别表示左小于右，左等于右，左大于右。 - (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;，根据options的不同值有不同的功能。 字符串内是否还包含别的字符串检测字符串是否以另一个字符开头或结尾： 12- (BOOL)hasPrefix:(NSString *)str;- (BOOL)hasSuffix:(NSString *)str; 一个字符串在另一个字符串内的返回：- (NSRange)rangeOfString:(NSString *)searchString; 可变性NSString是不可变的。也就是一旦被创建，就不能以删除字符或添加字符的方式改变它。NSMutableString是NSString的子类，可以改变。 可通过类方法stringWithCapacity:来创建，表示分配一块内存用于存储字符串，+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;。NSMutableString *string = [NSMutableString stringWithCapacity:1]; appendString:和appendFormat: 添加字符串： 123NSMutableString *string = [NSMutableString stringWithCapacity:50];[string appendString:@&quot;Hello there &quot;];[string appendFormat:@&quot;human %d!&quot;, 39]; // Hello there human 39! deleteCharactersInRange: 删除字符串，经常和rangeOfString:一起使用。 12345NSMutableString *friends = [NSMutableString stringWithCapacity:50]; [friends appendString:@&quot;James BethLynn Jack Evan&quot;]; NSRange jackRange = [friends rangeOfString:@&quot;Jack&quot;]; jackRange.length++; [friends deleteCharactersInRange:jackRange]; // James BethLynn Evan 集合 NSArray两个限制：只能存储OC对象；不能存储nil。 创建类方法arrayWithObjects:(nil表示结束)：NSArray *array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;, nil];直接字面量：NSArray *array2 = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; 数组对象个数： [array count]; 按索引获取对象： 12[array objectAtIndex:1];array[1]; 字符串切分成数组，数组合并成字符串。 123NSMutableString *string2 = @&quot;oop:ack:bork:greeble:ponies&quot;; NSArray *chunks = [string2 componentsSeparatedByString:@&quot;:&quot;]; string2 = [chunks componentsJoinedByString:@&quot;:-)&quot;]; // oop:-)ack:-)bork:-)greeble:-)ponies NSMutableArrayNSArray包含的对象个数是不能变化的（包含的对象是可以变化的）。NSMutableArray是可以变化数目。 创建: + (instancetype)arrayWithCapacity:(NSUInteger)numItems; 末尾添加 - (void) addObject: (id) anObject; 删除特定索引的对象 - (void)removeObjectAtIndex:(NSIndexSet *)index; 枚举：对数组进行遍历。NSEnumerator 1234NSEnumerator *emumerator = [array objectEnumerator];while (id thingie = [emumerator nextObject]) &#123; &#125; 快速枚举 123for (NSString *string in array) &#123; NSLog()&#125; NSDictionary同样也有对应的NSMutableDictionary。 123456789101112131415161718 // 创建 NSDictionary Tire *t1 = [Tire new]; Tire *t2 = [Tire new]; Tire *t3 = [Tire new]; Tire *t4 = [Tire new]; NSDictionary *tires = [NSDictionary dictionaryWithObjectsAndKeys:t1, @&quot;front-left&quot;, t2, @&quot;front-right&quot;, t3, @&quot;back-left&quot;, t4, @&quot;back-right&quot;, nil];// NSDictionary *tires = @&#123;@&quot;front-left&quot;: t1, @&quot;front-right&quot;: t2, @&quot;back-left&quot;: t3,@&quot;back-right&quot;: t4,&#125;; // 访问特定key的对象 Tire *tire = [tires objectForKey:@&quot;back-right&quot;];// Tire *tire = tires[@&quot;back-right&quot;]; // 创建NSMutableDictionary NSMutableDictionary *tires_m = [NSMutableDictionary dictionaryWithCapacity:10];// NSMutableDictionary *tires_m = [NSMutableDictionary dictionary]; // 为NSMutableDictionary添加元素 [tires_m setObject:t1 forKey:@&quot;front-left&quot;]; // 从NSMutableDictionary中删除元素 [tires_m removeObjectForKey:@&quot;front-left&quot;]; 其他数据类型NSArray和NSDictionary只能存储对象，不能直接存储任何基本类型的数据，如int、float、和struct。 NSNumber NSValue NSNull]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 13 Self Sizing Cells and Dynamic Type]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-13.html</url>
    <content type="text"><![CDATA[接着上一遍开始用Swift开发iOS 10 - 12 丰富Detail View和定制化Navigation Bar的代码稍作修改，为Restaurant多加一个phone属性,修改过location的长度。 修改RestaurantTableViewController中的restaurants变量（添加字段phone，location字段内容增多）： 1234567891011121314151617181920212223var restaurants:[Restaurant] = [ Restaurant(name: &quot;Cafe Deadend&quot;, type: &quot;Coffee &amp; Tea Shop&quot;,location: &quot;G/F, 72 Po Hing Fong, Sheung Wan, Hong Kong&quot;, phone: &quot;232-923423&quot;,image: &quot;cafedeadend.jpg&quot;, isVisited: false), Restaurant(name: &quot;Homei&quot;, type: &quot;Cafe&quot;, location: &quot;Shop B, G/F, 22-24A Tai Ping San Street SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;348-233423&quot;, image:&quot;homei.jpg&quot;, isVisited: false), Restaurant(name: &quot;Teakha&quot;, type: &quot;Tea House&quot;, location: &quot;Shop B, 18 Tai Ping Shan Road SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;354-243523&quot;, image: &quot;teakha.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe loisl&quot;, type: &quot;Austrian / Causual Drink&quot;, location: &quot;Shop B, 20 Tai Ping Shan Road SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;453-333423&quot;, image: &quot;cafeloisl.jpg&quot;, isVisited: false), Restaurant(name: &quot;Petite Oyster&quot;, type: &quot;French&quot;, location: &quot;24 Tai Ping Shan Road SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;983-284334&quot;, image: &quot;petiteoyster.jpg&quot;, isVisited: false), Restaurant(name: &quot;For Kee Restaurant&quot;, type: &quot;Bakery&quot;, location: &quot;Shop J-K., 200 Hollywood Road, SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;232-434222&quot;, image: &quot;forkeerestaurant.jpg&quot;, isVisited: false), Restaurant(name: &quot;Po&apos;s Atelier&quot;, type: &quot;Bakery&quot;, location: &quot;G/F, 62 Po Hing Fong, Sheung Wan, Hong Kong&quot;, phone: &quot;234-834322&quot;, image: &quot;posatelier.jpg&quot;, isVisited: false), Restaurant(name: &quot;Bourke Street Backery&quot;, type: &quot;Chocolate&quot;, location: &quot;633 Bourke St Sydney New South Wales 2010 Surry Hills&quot;, phone: &quot;982-434343&quot;, image:&quot;bourkestreetbakery.jpg&quot;, isVisited: false), Restaurant(name: &quot;Haigh&apos;s Chocolate&quot;, type: &quot;Cafe&quot;, location: &quot;412-414 George St Sydney New South Wales&quot;, phone: &quot;734-232323&quot;, image: &quot;haighschocolate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Palomino Espresso&quot;, type: &quot;American / Seafood&quot;, location: &quot;Shop 1 61 York St Sydney New South Wales&quot;, phone: &quot;872-734343&quot;, image: &quot;palominoespresso.jpg&quot;, isVisited: false), Restaurant(name: &quot;Upstate&quot;, type: &quot;American&quot;, location: &quot;95 1st Ave New York, NY 10003&quot;, phone: &quot;343-233221&quot;, image: &quot;upstate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Traif&quot;, type: &quot;American&quot;, location: &quot;229 S 4th St Brooklyn, NY 11211&quot;, phone: &quot;985-723623&quot;, image: &quot;traif.jpg&quot;, isVisited: false), Restaurant(name: &quot;Graham Avenue Meats&quot;, type: &quot;Breakfast &amp; Brunch&quot;, location: &quot;445 Graham Ave Brooklyn, NY 11211&quot;, phone: &quot;455-232345&quot;, image: &quot;grahamavenuemeats.jpg&quot;, isVisited: false), Restaurant(name: &quot;Waffle &amp; Wolf&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;413 Graham Ave Brooklyn, NY 11211&quot;, phone: &quot;434-232322&quot;, image: &quot;wafflewolf.jpg&quot;, isVisited: false), Restaurant(name: &quot;Five Leaves&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;18 Bedford Ave Brooklyn, NY 11222&quot;, phone: &quot;343-234553&quot;, image: &quot;fiveleaves.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe Lore&quot;, type: &quot;Latin American&quot;, location: &quot;Sunset Park 4601 4th Ave Brooklyn, NY 11220&quot;, phone: &quot;342-455433&quot;, image: &quot;cafelore.jpg&quot;, isVisited: false), Restaurant(name: &quot;Confessional&quot;, type: &quot;Spanish&quot;, location: &quot;308 E 6th St New York, NY 10003&quot;, phone: &quot;643-332323&quot;, image: &quot;confessional.jpg&quot;, isVisited: false), Restaurant(name: &quot;Barrafina&quot;, type: &quot;Spanish&quot;, location: &quot;54 Frith Street London W1D 4SL United Kingdom&quot;, phone: &quot;542-343434&quot;, image: &quot;barrafina.jpg&quot;, isVisited: false), Restaurant(name: &quot;Donostia&quot;, type: &quot;Spanish&quot;, location: &quot;10 Seymour Place London W1H 7ND United Kingdom&quot;, phone: &quot;722-232323&quot;, image: &quot;donostia.jpg&quot;, isVisited: false), Restaurant(name: &quot;Royal Oak&quot;, type: &quot;British&quot;, location: &quot;2 Regency Street London SW1P 4BZ United Kingdom&quot;, phone: &quot;343-988834&quot;, image: &quot;royaloak.jpg&quot;, isVisited: false), Restaurant(name: &quot;CASK Pub and Kitchen&quot;, type: &quot;Thai&quot;, location: &quot;22 Charlwood Street London SW1V 2DY Pimlico&quot;, phone: &quot;432-344050&quot;, image: &quot;caskpubkitchen.jpg&quot;, isVisited: false)] 为Restaurant添加属性phone。 修改RestaurantDetailViewController中两个table view方法：123456789101112131415161718192021222324252627282930313233func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 5&#125;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! RestaurantDetailTableViewCell // Configure the cell... switch indexPath.row &#123; case 0: cell.fieldLabel.text = &quot;Name&quot; cell.valueLabel.text = restaurant.name case 1: cell.fieldLabel.text = &quot;Type&quot; cell.valueLabel.text = restaurant.type case 2: cell.fieldLabel.text = &quot;Location&quot; cell.valueLabel.text = restaurant.location case 3: cell.fieldLabel.text = &quot;Phone&quot; cell.valueLabel.text = restaurant.phone case 4: cell.fieldLabel.text = &quot;Been here&quot; cell.valueLabel.text = (restaurant.isVisited) ? &quot;Yes, I&apos;ve been herebefore&quot; : &quot;No&quot; default: cell.fieldLabel.text = &quot;&quot; cell.valueLabel.text = &quot;&quot; &#125; cell.backgroundColor = UIColor.clear return cell&#125; 使Cell自适应 在RestaurantDetailViewController中的viewDidLoad中添加： 12tableView.estimatedRowHeight = 36.0 tableView.rowHeight = UITableViewAutomaticDimension estimatedRowHeight是cell的预计高度，这边就设置成原本prototype cell的高度。 UITableViewAutomaticDimension表示超过预计高度后自动适应高度。 修改Value label的numberOfLines属性为0，就是不限制行数。 添加spacing约束当value label超过两行，文本显示出问题： 这是因为虽然value label的高度自适应了合适的高度，但是stack view的高度没有约束，不能计算的出来，因此要给stack view添加两个上下的相等spcing约束。 这样不管value label是多少行，高度都会自适应了。 Dynamic TypeDynamic Type当在手机设置 &gt;通用 &gt; 辅助功能 &gt; 更大字体设置字体大小时，app中的应用也相应的变化。只要把字体设置成text style - Headline就会有Dynamic Type功能。目前只有name label的字体设置成了text style - Headline，其他设置成固定大小的字体，不会随着在手机设置 &gt;通用 &gt; 辅助功能 &gt; 更大字体设置字体大小时而变化。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习4：复合（composition）]]></title>
    <url>%2F2017%2Foc-basic-4-composition.html</url>
    <content type="text"><![CDATA[复合: 对象间的组合（类中中包括类）composition在音乐中翻译为作曲：将多个组件组合在一起，配合使用，从而得到完整的作品。在OC中，复合是通过包含作为实例变量的对象指针实现的。1234567@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;* (void)print;@end //Car 自定义NSLog()NSLog()使用%@格式说明符表示输出对象，也就是NSLog()会给这个对象发送了description消息，然后对象的description方法生成一个NSString并将其返回。**在类中提供description方法就可以自定义NSLog()如何输出对象。123456789101112131415@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@&quot;I am a tire.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; Tire *tire = [Tire new]; NSLog(@&quot;%@&quot;, tire); // 输出 &quot;I am a tire.&quot; return 0;&#125; 存取方法 存取(accessor) 方法是用来读取或改变某个对象属性的方法。分为 getter方法 和 setter方法。 应该尽量使用对象提供的存取方法，不要直接改变对象里面的值。存取方法总是成对出现的。命名方式：setter方法在要更改属性的加上前缀set；getter方法直接是属性名称。 1234567891011@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 在OC中所有对象间的交互都是通过指针实现的。 复合还是继承继承的关系：“Is a”（是一个）。如三角形是一个形状，Slant6是一个发动机……复合的关系：“has a”（有一个）。如形状有个填充颜色，汽车有个发动机和四个轮胎…… 详细代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@&quot;I am a tire.&quot;);&#125;@end@interface Engine : NSObject@end //Engine@implementation Engine- (NSString *)description &#123; return (@&quot;I am a Engine.&quot;);&#125; //description@end@interface Slant6 : Engine@end //slant-6型号的发动机@implementation Slant6- (NSString *)description &#123; return (@&quot;I am a slant-6型号的发动机.VROOM!&quot;);&#125;@end@interface AllWeatherRadial : Tire@end // 新型轮胎@implementation AllWeatherRadial-(NSString *)description&#123; return (@&quot;I am a tire for rain or shine.&quot;);&#125;@end@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car@implementation Car- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@&quot;%@&quot;, engine); NSLog(@&quot;%@&quot;, tires[0]); NSLog(@&quot;%@&quot;, tires[1]); NSLog(@&quot;%@&quot;, tires[2]); NSLog(@&quot;%@&quot;, tires[3]);&#125;@endint main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习5：源文件组织]]></title>
    <url>%2F2017%2Foc-basic-5.html</url>
    <content type="text"><![CDATA[将程序拆分为多个小文件有助于更快地找到重要的代码，而且其他人在查看项目时也能有个大致的了解。 拆分接口和实现根据@interface和@implementation，OC的代码通常放在两种文件里： 接口部分(.h)：类的@interface指令、公共struct定义、enum常量、#defines和extern全局变量等。 实现部分(.m): 类的@implementation指令、全局变量的定义、私有struct等。 另外，复杂的项目可以拥有多个目标，它们源文件的配置各不相同，构建规则也不同。群组关系仅仅是有Xcode负责管理的一项奇妙的功能。 拆分Car程序 #import 带尖号的是导入系统头文件(只读)，如#import &lt;Foundation/Foundation.h&gt;；双引号是项目本地的代码文件，如#import &quot;Engine.h&quot;。 拆分上一篇中的Car程序首先拆分继承自NSObject的类：Tire和Engine。 1234567// Tire.h#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end 1234567891011// Tire.m#import &quot;Tire.h&quot;@implementation Tire//#pragma mark -- (NSString *)description &#123; return (@&quot;I am a Tire.&quot;);&#125; //description@end 1234567// Engine.h#import &lt;Foundation/Foundation.h&gt;@interface Engine : NSObject@end 12345678// Engine.m#import &quot;Engine.h&quot;@implementation Engine- (NSString *)description &#123; return (@&quot;I am a Engine.&quot;);&#125; //description@end 使用跨文件依赖关系 @class 是告诉编译器：“这是一个类，只会通过指针来引用它，不需要关注此类的更多信息”。可减少必须导入的头文件的数量，从而缩短编译时间。拆分Car类： 1234567891011121314// Car.h#import &lt;Foundation/Foundation.h&gt;@class Engine;@class Tire;@interface Car : NSObject- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Car.m#import &quot;Car.h&quot;#import &quot;Tire.h&quot;#import &quot;Engine.h&quot;@implementation Car&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@&quot;%@&quot;, engine); NSLog(@&quot;%@&quot;, tires[0]); NSLog(@&quot;%@&quot;, tires[1]); NSLog(@&quot;%@&quot;, tires[2]); NSLog(@&quot;%@&quot;, tires[3]);&#125;@end //Car 编译器需要先知道所有关于超类的信息才能成功地为其子类编译@interface部分。拆分Slant6和AllWeatherRadial： 1234567// Slant6.h#import &quot;Engine.h&quot;@interface Slant6 : Engine@end 123456789// Slant6.m#import &quot;Slant6.h&quot;@implementation Slant6- (NSString *)description &#123; return (@&quot;I am a slant-6.VROOM!&quot;);&#125;@end 1234567// AllWeatherRadial.h#import &quot;Tire.h&quot;@interface AllWeatherRadial : Tire@end 12345678910// AllWeatherRadial.m#import &quot;AllWeatherRadial.h&quot;@implementation AllWeatherRadial-(NSString *)description&#123; return (@&quot;I am a tire for rain or shine.&quot;);&#125;@end 最后是main.m文件：123456789101112131415161718192021222324// main.m#import &lt;Foundation/Foundation.h&gt;#import &quot;Car.h&quot;#import &quot;Tire.h&quot;#import &quot;Engine.h&quot;#import &quot;Slant6.h&quot;#import &quot;AllWeatherRadial.h&quot;int main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习2：面向对象编程的基础知识]]></title>
    <url>%2F2017%2Foc-basic-2.html</url>
    <content type="text"><![CDATA[间接(indirection) “只要再多添加一层间接，计算机科学中就没有解决不了的问题。” 例子 电话薄 让他人代替你自己去完成工作 编写一段代码来查询其他代码，并通过它继续访问另一层代码。 推诿 变量与间接 使用文件名的间接 在面向对象编程中使用间接 使用间接来调用代码，不是直接调用某个函数，而是间接调用。 过程式编程(Procedual Programming) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kCircle, kRectangle, kEgg,&#125; ShapeType;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//图形结构typedef struct &#123; ShapeType type; ShapeColor fillColor; ShapeRect bounds;&#125; Shape;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @&quot;red&quot;; break; case kGreenColor: return @&quot;green&quot;; break; case kBlueColor: return @&quot;blue&quot;; break; &#125; return @&quot;no clue&quot;;&#125;//绘制图形void drawCircle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawRectangle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Rectangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawEgg(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Egg at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawShapes(Shape shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; switch (shapes[i].type) &#123; case kCircle: drawCircle(shapes[i].bounds, shapes[i].fillColor); break; case kRectangle: drawRectangle(shapes[i].bounds, shapes[i].fillColor); break; case kEgg: drawEgg(shapes[i].bounds, shapes[i].fillColor); break; default: break; &#125; &#125;&#125;int main(int argc, const char * argv[]) &#123; Shape shapes[3]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0].type = kCircle; shapes[0].fillColor = kRedColor; shapes[0].bounds = rect0; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1].type = kRectangle; shapes[1].fillColor = kGreenColor; shapes[1].bounds = rect1; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2].type = kEgg; shapes[2].fillColor = kBlueColor; shapes[2].bounds = rect2; drawShapes(shapes, 3); return 0;&#125; 修改过去正常工作的代码很可能会引入新的错误。建立在函数之上，数据为函数服务。代码例子 3.2.1 Shapes-Procedural 面向对象编程 以数据为中心，函数为数据服务 代码例子 3.2.2 Shapes-Object id是一种泛型，可以用来引用任何类型的对象(id实际上是一个指向结构体的指针)。 方括号在OC中其他意义：用于通知某个对象该去做什么。[shape draw];表示通知shape对象执行draw操作 发送消息（调用方法）：通知对象执行某种操作。 类是一种能够实例化成对象的结构体。 如果在运行时改变某个类，则该类的所有对象自动继承这些变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @&quot;red&quot;; break; case kGreenColor: return @&quot;green&quot;; break; case kBlueColor: return @&quot;blue&quot;; break; &#125; return @&quot;no clue&quot;;&#125;@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Rectangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Rectangle@implementation Rectangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Rectangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Egg : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Egg@implementation Egg- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Egg at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end// 补充一个三角形@interface Triangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Triangle@implementation Triangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Triangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@endvoid drawShapes(id shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; id shape = shapes[i]; [shape draw]; &#125;&#125;int main(int argc, const char * argv[]) &#123; id shapes[4]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0] = [Circle new]; [shapes[0] setBounds:rect0]; [shapes[0] setFillColor:kRedColor]; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1] = [Rectangle new]; [shapes[1] setBounds:rect1]; [shapes[1] setFillColor:kGreenColor]; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2] = [Egg new]; [shapes[2] setBounds:rect2]; [shapes[2] setFillColor:kBlueColor]; ShapeRect rect3 = &#123;3, 4, 5, 0&#125;; shapes[3] = [Triangle new]; [shapes[3] setBounds:rect3]; [shapes[3] setFillColor:kBlueColor]; drawShapes(shapes, 4); return 0;&#125; 有关术语 class object instance message method method dispatcher interface implementation OC中的OOP12345678910111213141516171819202122232425262728293031@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end``` 1. `@interface` OC编译器需要一些有关类的信息 + `@` 可以看成是对C语言的扩展 + **instance variable**(实例变量) ： `@interface`下的花括号的内容： { @private ShapeColor fillColor; ShapeRect bounds;} 1+ **method declaration**(方法声明)。有点像C语言中的函数原型。`-`表示对象方法，`+`表示类方法。`(void)`表示返回类型。 - (void) setFillColor: (ShapeColor) fillColor; - (void) setBounds: (ShapeRect) bounds; - (void) draw; ``` + **infix notation**(中缀符) ： *方法的名称及其参数都是合在一起的* `[circle setFillColor: kRedColor]` 表示调用带一个参数的方法 + 如果方法使用参数，则需要冒号，否则不需要冒号 + 提倡@end语言后添加注释来注明类的名称 @implementation @implementation中可以定义在@interface中声明过和没有声明过的方法 OC中不存在真正的私有方法 实例化对象 instantiation（实例化） [Circle new] 发送new消息 软件实体应该对扩展开放，而对修改关闭。 —- 开放/关闭原则(Bertrand Meyer)]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习3：继承(inheritance)]]></title>
    <url>%2F2017%2Foc-basic-3-inheritance.html</url>
    <content type="text"><![CDATA[为何使用继承 UML(Unified Modeling Language, 统一建模语言) 是一种用图表来表示类、类的内容以及它们之间关系。 将重复的代码合并到一处。 继承的语法格式 只能继承一个 只有代码精简，bug才无处藏身 没有声明实例变量时可以省略花括号 相关术语 refactoring (重构) superclass parent class subclass child class override 继承的工作机制OOP一个强大之处：可以对一个程序做一些重大改变，程序仍然可以正常运行。 方法调度：当代码发送信息时，将在当前的类中搜索相应方法，如果无法在接收消息的对象的类文件中找到相应的文件，就会在该对象的超类中进行查找。 实例变量 在创建一个新类时，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。 polymorphism(多态性) self：指向接收消息的对象的指针 重写方法 super 调用继承的方法可以确保获得方法实现的所有特性]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习1：对C的扩展]]></title>
    <url>%2F2017%2Foc-basic-1-c.html</url>
    <content type="text"><![CDATA[分析最简单的Hello Objective-C程序1234567#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;Hello, World!&quot;); return 0;&#125; // main OC本质上就是C语言，它用来声明main()和返回数值的语法和C语言是一样的。 扩展名.m代表message 与C类似，OC使用头文件来包含结构体、符号常量和函数原型等元素的声明。 #import类似于C的#include，但#import可保证头文件只被包含一次。 #import &lt;Foundation/Foundation.h&gt;语句告诉编译器查找Foundation框架中的Foundation.h头文件。 int argc, const char * argv[]中 argc是指命令行参数个数，argv[0]是指可执行文件的路径，argv[1]是指命令行第一个参数，argv[2]是指命令行第二个参数，以此类推。 框架 ：一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。 如Cocoa,Carbon,QuickTime,OpenGL Cocoa包括Foundation和Application Kit(AppKit) 每一个框架都有一个主头文件，它包含了框架内所有的头文件。 Foundation的头文件 1MB 14000行 100多文件 。通过#import &lt;Foundation/Foundation.h&gt; 就获得了整个集合 Xcode使用预编译头文件（一种经过压缩的，摘要形式的头文件）来加快读取速度。 NSLog()和@”字符串” NS前缀是NextSTEP（很早之前苹果公司收购的公司） NSLog()类似于C的printf() @符号是Objective-C在标准C语言基础上添加的特性，意味着引号内的字符串应作为Cocoa的NSString元素来处理 @符号可以看成之后是对C语言的扩展 布尔类型OC中的布尔值YES是1， NO是0，是与C语言中不同的。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 12 丰富Detail View和定制化Navigation Bar]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-12.html</url>
    <content type="text"><![CDATA[上一篇开始用Swift开发iOS 10 - 11 面向对象编程介绍对代码做了一点修改，这一篇来丰富一下详情页和定制化Navigation Bar。 重新设计详细页面 选中Main.storyboard，删除Image View和三个Label。 添加Table View，修改其大小为整个View，并且添加一些约束。设置prototype cells为1；table view cell的identifier为Cell，row height为36。 在table view的头部添加一个image view，给变其高度为300，宽度为View的宽度。 连接image view和RestaurantDetailViewController中的restaurantImageView接口。 修改Image View的content mode为 Aspect Fit，并勾选Clip to Bounds 定制 Prototype Cell 增加两个label，分别命名为Field，Value ，字体修改成自己想要的。把它们组成一个Stack View。 为Stack View添加一些约束。在cell中垂直居中；Trailing Space 和 Leading Space都为零。 用Ctrl-drag从FieldLabel到ValueLabel，选择Equal Widths，生成一个FieldLabel与ValueLabel宽度相同的约束。修改Multiplier值为0.5，就是FieldLabel的宽度是ValueLabel的一半。 新建RestaurantDetailTableViewCell类文件，继承至UITableViewCell。添加两个接口，并关联上面的两个Label。12@IBOutlet var fieldLabel:UILabel!@IBOutlet var valueLabel:UILabel! 更新 RestaurantDetailViewController 实现UITableViewDataSource和UITableViewDelegate: class RestaurantDetailViewController: UIViewController, UITableViewDataSource, UITableViewDelegate { 实现UITableViewDataSource的相关方法： 123456789101112131415161718192021222324252627282930func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 4&#125;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! RestaurantDetailTableViewCell // Configure the cell... switch indexPath.row &#123; case 0: cell.fieldLabel.text = &quot;Name&quot; cell.valueLabel.text = restaurant.name case 1: cell.fieldLabel.text = &quot;Type&quot; cell.valueLabel.text = restaurant.type case 2: cell.fieldLabel.text = &quot;Location&quot; cell.valueLabel.text = restaurant.location case 3: cell.fieldLabel.text = &quot;Been here&quot; cell.valueLabel.text = (restaurant.isVisited) ? &quot;Yes, I&apos;ve been herebefore&quot; : &quot;No&quot; default: cell.fieldLabel.text = &quot;&quot; cell.valueLabel.text = &quot;&quot; &#125; cell.backgroundColor = UIColor.clear return cell&#125; 把table view的delegate和dataSource接口设置成Restaurant Detail View Controller 。 定制table view 的样式 在RestaurantDetailViewController中添加一个接口变量，并关联storyboard中的table view。@IBOutlet var tableView:UITableView! 设置table view的背景颜色，在viewDidLoad中添加:tableView.backgroundColor = UIColor(red: 240.0/255.0, green: 240.0/255.0, blue: 240.0/255.0, alpha: 0.2)新加的颜色是亮灰色（和白色相近，可以设置成其他深颜色做对比），运行后不是整个table view都变色。这是因为，每一个cell都是重新添加的，cell的背景颜色还是默认的白色，覆盖了table view的背景颜色，要在tableView(_:cellForRowAt:)的return之前添加：cell.backgroundColor = UIColor.clear 移除table view中空cell的分割线，在viewDidLoad中添加: tableView.tableFooterView = UIView(frame: CGRect.zero) 改变分割线的颜色， 在viewDidLoad中添加:tableView.separatorColor = UIColor(red: 240.0/255.0, green: 240.0/255.0, blue: 240.0/255.0, alpha: 0.8) 定制Navigation Bar的样式通过UINavigationBar.appearance()修改Navigation Bar的样式。 Navigation Bar的样式修改是整体修改的，所以修改Navigation Bar的样式代码要写在application(_:didFinishLaunchingWithOptions:)方法中。 修改navigation bar的背景颜色：UINavigationBar.appearance().barTintColor = UIColor(red: 216.0/255.0, green: 74.0/255.0, blue: 32.0/255.0, alpha: 1.0) 修改title样式：123if let barFont = UIFont(name: &quot;Avenir-Light&quot;, size: 24.0) &#123; UINavigationBar.appearance().titleTextAttributes = [NSForegroundColorAttributeName:UIColor.white, NSFontAttributeName:barFont]&#125; Avenir-Light是字体名称，详细的iOS字体可查 http://iosfonts.com 。 tintColor控制Navigation items和bar button items的颜色UINavigationBar.appearance().tintColor = UIColor.white 目前，Navigation bar的返回按钮是一个&lt;和Food Pin，想删除Food Pin，需要修改RestaurantTableViewController的backBarButtonItem属性。 在 RestaurantTableViewController的viewDidLoad中添加： navigationItem.backBarButtonItem = UIBarButtonItem(title: &quot;&quot;, style: .plain, target: nil, action: nil) 为 detail view 的 Navigation bar 添加title，在 RestaurantDetailViewController的viewDidLoad中添加：title = restaurant.name 隐藏Navigation Bar 自从iOS 8后，Navigation Bar可以在不同情况下隐藏，在storyboard中选择Navigation Controller修改。（On Swipe是向上滑） 但这种设置整个app的Navigation Bar都会隐藏。如果只想在restaurant table view controller中隐藏，在detail view中不隐藏，就需要在两个控制器的viewDidLoad分别设置：navigationController?.hidesBarsOnSwipe = true 和 navigationController?.hidesBarsOnSwipe = false 。 运行反复测试后发现两个问题： 当从detail view返回后，restaurant table view controller的 Navigation Bar不能隐藏。 当restaurant table view controller的 Navigation Bar隐藏后进入detail view后， Navigation Bar消失不能再显示。 首先明确两个控制器中的navigationController属性指的是同一个Navigation Controller ，viewDidLoad方法是view第一次加载时调用，之后就不再调用了。 也就是说当从detail view返回，hidesBarsOnSwipe已经被设置为false，而到restaurant table view controller的viewDidLoad不再调用，所以Navigation Bar不能再隐藏。 解决办法是使用viewWillAppear，这个方法是在视图每一次显示时调用。在RestaurantTableViewController中添加：1234override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) navigationController?.hidesBarsOnSwipe = true&#125; 在RestaurantDetailViewController中添加：12345override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) navigationController?.hidesBarsOnSwipe = false navigationController?.setNavigationBarHidden(false, animated: true)&#125; 修改Status Bar样式app中Status Bar的默认样式是黑色。 在Info.plist中添加一个key为View controller-based status bar appearance，值为NO。然后application(_:didFinishLaunchingWithOptions:)中添加：UIApplication.shared.statusBarStyle = .lightContent。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 6：使用Quick Look框架预览文件(Swift)]]></title>
    <url>%2F2017%2Fios-tutorial-6-quicklook.html</url>
    <content type="text"><![CDATA[iOS SDK中有很多不常见，却非常好用的库，Quick Look框架就是一个非常好的例子。Quick Look框架提供了预览很多不同类型文件的功能，而不需要打开不同的APP查看，有点像Mac中的空格键功能。 Quick Look框架可以预览的文件类型： iWork documents (Pages, Numbers and Keynote) Microsoft Office documents (as long as they’ve been created with Office 97 or any other newer version) PDF files Images Text files Rich-Text Format documents Comma-Separated Value files (csv) 开始项目到开始项目处下载开始项目，这是原文提供了一个开始项目，代码是老版本的，需要转换一下。这个开始项目中包括了六种不同的类型的文件，一个navigation controller，一个table view controller（FileListViewController），另外还做了一些初始化工作。之后代码就在FileListViewController中完成。 文件和文件的URLS 在FileListViewController中定义一个文件名字的数组变量：let fileNames = [&quot;AppCoda-PDF.pdf&quot;, &quot;AppCoda-Pages.pages&quot;, &quot;AppCoda-Word.docx&quot;, &quot;AppCoda-Keynote.key&quot;, &quot;AppCoda-Text.txt&quot;, &quot;AppCoda-Image.jpeg&quot;] 继续定义一个数组变量，用户存储不同的文件的URL：var fileURLs = [NSURL]() 创建一个方法prepareFileURLs()，用于为fileURLs添加值： 123456789101112func prepareFileURLs() &#123; for file in fileNames &#123; // 1 let fileParts = file.components(separatedBy: &quot;.&quot;) if let fileURL = Bundle.main.url(forResource: fileParts[0], withExtension: fileParts[1]) &#123; // 2 if FileManager.default.fileExists(atPath: fileURL.path) &#123; fileURLs.append(fileURL as NSURL) &#125; &#125; &#125;&#125; 1 components(separatedBy:)方法用于把String按照给定的分隔符，分解成[String]。 2 判断文件地址是否真实存在。 在 viewDidLoad()中实现上面的函数： 12345override func viewDidLoad() &#123; ... prepareFileURLs()&#125; 展示文件用table view展示不同的文件： 根据文件的URL，获得文件名和文件后缀（文件类型），添加函数extractAndBreakFilenameInComponents(:)。 12345678910func extractAndBreakFilenameInComponents(fileURL: NSURL) -&gt; (fileName: String, fileExtension: String) &#123; let fileURLParts = fileURL.path!.components(separatedBy: &quot;/&quot;) let fileName = fileURLParts.last let filenameParts = fileName?.components(separatedBy: &quot;.&quot;) return (filenameParts![0], filenameParts![1])&#125; 修改 tableView(tableView:cellForRowAtIndexPath)： 123456789func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCellWithIdentifier(&quot;idCellFile&quot;, forIndexPath: indexPath) let currentFileParts = extractAndBreakFilenameInComponents(fileURLs[indexPath.row]) cell.textLabel?.text = currentFileParts.fileName return cell&#125; 根据不同的后缀名，定义不同的文件类型名称，添加函数getFileTypeFromFileExtension(:)： 12345678910111213141516171819202122232425func getFileTypeFromFileExtension(fileExtension: String) -&gt; String &#123; var fileType = &quot;&quot; switch fileExtension &#123; case &quot;docx&quot;: fileType = &quot;Microsoft Word document&quot; case &quot;pages&quot;: fileType = &quot;Pages document&quot; case &quot;jpeg&quot;: fileType = &quot;Image document&quot; case &quot;key&quot;: fileType = &quot;Keynote document&quot; case &quot;pdf&quot;: fileType = &quot;PDF document&quot; default: fileType = &quot;Text document&quot; &#125; return fileType&#125; 回到tableView(tableView:cellForRowAtIndexPath)，添加一段cell配置： cell.detailTextLabel?.text = getFileTypeFromFileExtension(fileExtension: currentFileParts.fileExtension) 修改每个section中row的数目为文件数目： 123func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return fileNames.count&#125; QLPreviewControllerDataSource 引入框架Quick Look import QuickLook 定义QLPreviewController let quickLookController = QLPreviewController() 让FileListViewController实现QLPreviewControllerDataSource协议 实现QLPreviewControllerDataSource协议的必须要实现的方法。第一方法表示有多少个文件需要预览： 123func numberOfPreviewItems(in controller: QLPreviewController) -&gt; Int &#123; return fileURLs.count&#125; 第二个方法：123func previewController(_ controller: QLPreviewController, previewItemAt index: Int) -&gt; QLPreviewItem &#123; return fileURLs[index]&#125; 在viewDidLoad()中添加：quickLookController.dataSource = self 预览文件在table view中选中文件，就要跳转的预览页面。实现方法tableView(_:didSelectRowAt:)：123456func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; if QLPreviewController.canPreview(fileURLs[indexPath.row]) &#123; quickLookController.currentPreviewItemIndex = indexPath.row navigationController?.pushViewController(quickLookController, animated: true) &#125; &#125; navigationController?.pushViewController(quickLookController, animated: true)可用presentViewController(quickLookController, animated: true, completion: nil)代替。 运行可预览文件： 观察上图，可发现 Quick Look Preview Controller自带了toolbar，左边一个是分享按钮(通过UIActivityViewController实现的)，右边一个是类似目录功能，当有很多预览文件时，来跳转到不同预览文件。 代码QuickLookDemo 参考 Using Quick Look Framework for Previewing Documents]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-25：Advanced Operators]]></title>
    <url>%2F2017%2Fswift-25.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** Advanced Operators */// 1 位运算符// 按位取反运算符let initialBits: UInt8 = 0b00001111let invertedBits = ~initialBits // 等于 0b11110000// 按位与运算符let firstSixBits: UInt8 = 0b11111100let lastSixBits: UInt8 = 0b00111111let middleFourBits = firstSixBits &amp; lastSixBits // 等于 00111100// 按位或运算符let someBits: UInt8 = 0b10110010let moreBits: UInt8 = 0b01011110let combinedbits = someBits | moreBits // 等于 11111110// 按位异或运算符let firstBits: UInt8 = 0b00010100let otherBits: UInt8 = 0b00000101let outputBits = firstBits ^ otherBits // 等于 00010001// 按位左移、右移运算符let shiftBits: UInt8 = 4 // 00000100shiftBits &lt;&lt; 1 // 00001000shiftBits &lt;&lt; 2 // 00010000shiftBits &lt;&lt; 5 // 10000000shiftBits &lt;&lt; 6 // 00000000shiftBits &gt;&gt; 2 // 00000001// 使用移位运算对颜色进行RGB分解let pink: UInt32 = 0xCC6699let redComponent = (pink &amp; 0xFF0000) &gt;&gt; 16 // redComponent 是 0xCC，即 204let greenComponent = (pink &amp; 0x00FF00) &gt;&gt; 8 // greenComponent 是 0x66， 即 102let blueComponent = pink &amp; 0x0000FF // blueComponent 是 0x99，即 153// 有符号整数的移位运算// 2 溢出运算符// 在默认情况下，当向一个整数赋予超过它容量的值时，Swift默认会报错，而不是生成一个无效的数。var potentialOverflow = Int16.max // potentialOverflow 的值是 32767，这是 Int16 能容纳的最大整数//potentialOverflow += 1 // 这里会报错// 可以选择让系统在数值溢出的时候采取截断处理，而非报错。 `&amp;+` `&amp;-` `&amp;*`var unsignedOverflow = UInt8.max // unsignedOverflow 等于 UInt8 所能容纳的最大整数 255 unsignedOverflow = unsignedOverflow &amp;+ 1 // 此时 unsignedOverflow 等于 0var unsignedOverflow2 = UInt8.min // unsignedOverflow 等于 UInt8 所能容纳的最小整数 0unsignedOverflow2 = unsignedOverflow2 &amp;- 1 // 此时 unsignedOverflow 等于 255// 3 优先级和结合性// 4 运算符函数// *运算符重载*: 类和结构体可以为现有的运算符提供自定义的实现。// 例子：向量的相加struct Vector2D &#123; var x = 0.0, y = 0.0&#125;extension Vector2D &#123; static func + (left: Vector2D, right: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: left.x + right.x, y: left.y + right.y) &#125; static prefix func - (vector: Vector2D) -&gt; Vector2D &#123; return Vector2D(x: -vector.x, y: -vector.y) &#125; static func += (left: inout Vector2D, right: Vector2D) &#123; left = left + right &#125; static func == (left: Vector2D, right: Vector2D) -&gt; Bool &#123; return (left.x == right.x) &amp;&amp; (left.y == right.y) &#125; static func != (left: Vector2D, right: Vector2D) -&gt; Bool &#123; return !(left == right) &#125;&#125;let vector = Vector2D(x: 3.0, y: 1.0)let anotherVector = Vector2D(x: 2.0, y: 4.0)let combinedVector = vector + anotherVector // combinedVector 是一个新的 Vector2D 实例，值为 (5.0, 5.0)let negative = -vector // negative 是一个值为 (-3.0, -1.0) 的 Vector2D 实例var original = Vector2D(x: 1.0, y: 2.0)let vectorToAdd = Vector2D(x: 3.0, y: 4.0)original += vectorToAdd // original 的值现在为 (4.0, 6.0)let twoThree = Vector2D(x: 2.0, y: 3.0)let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)if twoThree == anotherTwoThree &#123; print(&quot;These two vectors are equivalent.&quot;)&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 11 面向对象编程介绍]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-11.html</url>
    <content type="text"><![CDATA[关于面向对象编程（Object Oriented Programming ，OOP）的知识就不多介绍了，这不是一门编程语言中的概念，而是编程方法。OOP最好的一地方是，它让复杂的软件分解成一个个小的部分，方便程序员开放和管理。 这一篇文章就把上一篇文章开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue的代码整理成OOP形式。 重新修改FoodPin项目 之前在RestaurantTableViewController类中，定义了restaurantNames,restaurantImages, restaurantLocations,restaurantTypes四个数组变量，分别表示restaurant的名字，图片名称，位置，类型。每个restaurant的信息分散在四个数组中，而且数组的内容顺序要对应，现在把四个信息组成在一个类中Restaurant。 添加类文件Restaurant.swift 123456789101112131415161718import Foundationclass Restaurant &#123; var name = &quot;&quot; var type = &quot;&quot; var location = &quot;&quot; var image = &quot;&quot; var isVisited = false // 1 init(name: String, type: String, location: String, image: String, isVisited: Bool) &#123; self.name = name self.type = type self.location = location self.image = image self.isVisited = isVisited &#125;&#125; 1 自定义的初始化方法。在Swift中，类的所有变量都需要被初始化，或者声明为可选值。 用Restaurant对象数组代替RestaurantTableViewController中的几个数组变量。 var restaurants:[Restaurant] = [ Restaurant(name: &quot;Cafe Deadend&quot;, type: &quot;Coffee &amp; Tea Shop&quot;, location: &quot;HongKong&quot;, image: &quot;cafedeadend.jpg&quot;, isVisited: false), Restaurant(name: &quot;Homei&quot;, type: &quot;Cafe&quot;, location: &quot;Hong Kong&quot;, image:&quot;homei.jpg&quot;, isVisited: false), Restaurant(name: &quot;Teakha&quot;, type: &quot;Tea House&quot;, location: &quot;Hong Kong&quot;, image:&quot;teakha.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe loisl&quot;, type: &quot;Austrian / Causual Drink&quot;, location: &quot;Hong Kong&quot;, image: &quot;cafeloisl.jpg&quot;, isVisited: false), Restaurant(name: &quot;Petite Oyster&quot;, type: &quot;French&quot;, location: &quot;Hong Kong&quot;, image: &quot;petiteoyster.jpg&quot;, isVisited: false), Restaurant(name: &quot;For Kee Restaurant&quot;, type: &quot;Bakery&quot;, location: &quot;HongKong&quot;, image: &quot;forkeerestaurant.jpg&quot;, isVisited: false), Restaurant(name: &quot;Po&apos;s Atelier&quot;, type: &quot;Bakery&quot;, location: &quot;Hong Kong&quot;, image: &quot;posatelier.jpg&quot;, isVisited: false), Restaurant(name: &quot;Bourke Street Backery&quot;, type: &quot;Chocolate&quot;, location: &quot;Sydney&quot;, image: &quot;bourkestreetbakery.jpg&quot;, isVisited: false), Restaurant(name: &quot;Haigh&apos;s Chocolate&quot;, type: &quot;Cafe&quot;, location: &quot;Sydney&quot;, image: &quot;haighschocolate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Palomino Espresso&quot;, type: &quot;American / Seafood&quot;, location: &quot;Sydney&quot;, image: &quot;palominoespresso.jpg&quot;, isVisited: false), Restaurant(name: &quot;Upstate&quot;, type: &quot;American&quot;, location: &quot;New York&quot;, image: &quot;upstate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Traif&quot;, type: &quot;American&quot;, location: &quot;New York&quot;, image: &quot;traif.jpg&quot;, isVisited: false), Restaurant(name: &quot;Graham Avenue Meats&quot;, type: &quot;Breakfast &amp; Brunch&quot;, location: &quot;New York&quot;, image: &quot;grahamavenuemeats.jpg&quot;, isVisited: false), Restaurant(name: &quot;Waffle &amp; Wolf&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;NewYork&quot;, image: &quot;wafflewolf.jpg&quot;, isVisited: false), Restaurant(name: &quot;Five Leaves&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;New York&quot;,image: &quot;fiveleaves.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe Lore&quot;, type: &quot;Latin American&quot;, location: &quot;New York&quot;, image: &quot;cafelore.jpg&quot;, isVisited: false), Restaurant(name: &quot;Confessional&quot;, type: &quot;Spanish&quot;, location: &quot;New York&quot;, image: &quot;confessional.jpg&quot;, isVisited: false), Restaurant(name: &quot;Barrafina&quot;, type: &quot;Spanish&quot;, location: &quot;London&quot;, image: &quot;barrafina.jpg&quot;, isVisited: false), Restaurant(name: &quot;Donostia&quot;, type: &quot;Spanish&quot;, location: &quot;London&quot;, image: &quot;donostia.jpg&quot;, isVisited: false), Restaurant(name: &quot;Royal Oak&quot;, type: &quot;British&quot;, location: &quot;London&quot;, image: &quot;royaloak.jpg&quot;, isVisited: false), Restaurant(name: &quot;CASK Pub and Kitchen&quot;, type: &quot;Thai&quot;, location: &quot;London&quot;, image: &quot;caskpubkitchen.jpg&quot;, isVisited: false) ] 更新 tableView(_:numberOfRowsInSection:) : 1234override func tableView(_ tableView: UITableView, numberOfRowsInSectionsection: Int) -&gt; Int &#123; return restaurants.count&#125; 更新 tableView(_:cellForRowAtIndexPath:) ： 12345678910111213141516override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell // Configure the cell... cell.nameLabel.text = restaurants[indexPath.row].name cell.thumbnailImageView.image = UIImage(named: restaurants[indexPath.row].image) cell.thumbnailImageView.layer.cornerRadius = 30.0 cell.thumbnailImageView.clipsToBounds = true cell.locationLabel.text = restaurants[indexPath.row].location cell.typeLabel.text = restaurants[indexPath.row].type cell.accessoryType = restaurants[indexPath.row].isVisited ? .checkmark : .none return cell&#125; 更新tableView(_:commit:forRowAt:) : 123456override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; restaurants.remove(at: indexPath.row) &#125; tableView.deleteRows(at: [indexPath], with: .fade)&#125; 更新 tableView(_:editActionsForRowAt:) ： override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? { let shareAction = UITableViewRowAction(style: .default, title: &quot;Share&quot;, handler: { (action, indexPath) -&gt; Void in let defaultText = &quot;Just checking in at &quot; + self.restaurants[indexPath.row].name if let imageToShare = UIImage(named: self.restaurants[indexPath.row].image) { let activityController = UIActivityViewController(activityItems: [defaultText, imageToShare], applicationActivities: nil) self.present(activityController, animated: true, completion: nil) } }) let deleteAction = UITableViewRowAction(style: .default, title: &quot;Delete&quot;, handler: { (action, indexPath) -&gt; Void in self.restaurants.remove(at: indexPath.row) tableView.deleteRows(at: [indexPath], with: .fade) }) shareAction.backgroundColor = UIColor(red: 48.0/255.0, green: 173.0/255.0, blue: 99.0/255.0, alpha: 1.0) deleteAction.backgroundColor = UIColor(red: 202.0/255.0, green: 202.0/255.0, blue: 203.0/255.0, alpha: 1.0) return [deleteAction,shareAction] } RestaurantDetailViewController中的四个变量： 1234var nameText = &quot;&quot;var locationText = &quot;&quot;var typeText = &quot;&quot;var restaurantImage = &quot;&quot; 更新为：var restaurant: Restaurant! 与之对应的viewDidLoad()也修改为： override func viewDidLoad() { super.viewDidLoad() restaurantImageView.image = UIImage(named: restaurant.image) nameLabel.text = restaurant.name locationLabel.text = restaurant.location typeLabel.text = restaurant.type } 最后prepare(for:sender:)方法也做对应修改： 12345678override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showRestaurantDetail&quot; &#123; if let indexPath = tableView.indexPathForSelectedRow &#123; let destinationController = segue.destination as! RestaurantDetailViewController destinationController.restaurant = restaurants[indexPath.row] &#125; &#125;&#125; 运行没有问题。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-10.html</url>
    <content type="text"><![CDATA[接着上一篇开始用Swift开发iOS 10 - 9 Table Row的删除, UITableViewRowAction和UIActivityViewController的使用的代码，继续学习Navigation Controller和Segue。 创造Navigation Controller 选中Restaurant Table View Controller然后点击菜单栏中的Editor &gt; Embed in &gt; Navigation Controller；生成了新的一Scene（Navigation Controller Scene）。 选中之前Scene中的Navigation bar，修改其title为Food Pin。 添加 Detail View Controller之前添加导航栏，现在添加另一个view controller，用来显restaurant的详细内容。 拖动一个新的View Controller。 拖动一个image View，调整合适大小，并添加相关约束。Content Mode属性修改为 Aspect Fill。 用segue连接prototype cell和detail scene。 Ctrl-drag从prototype cell到detail scene。如果不方便选择prototype cell，可以在document outline中拖动。选择Show连接风格。 iOS 10中有几种sugue类型： Show：新的view controller将被添加view controller栈的顶部。跳转的页面有Navigation bar，并且有返回原来页面的返回按钮。这是非常常用的的类型。 Show detail：在view controller栈中，新的view controller将被替代原来的view controller。跳转的页面没有Navigation bar，也没有返回原来页面的返回按钮。 Present modally：新页面将以动画形式从底部出现到覆盖整个手机屏幕。这种形式最常见的列子是iOS自带的日历应用： Present as popover：以带有箭头锚点的弹框显示。通常使用的iPad应用中 不再需要action sheet，去除tableView(_:didSelectRowAt:)方法 创建新类文件RestaurantDetailViewController，继承至UIViewController。是新建scene与RestaurantDetailViewController的联系。 在RestaurantDetailViewController中加入一个outlet和一个变量，outlet关联Image View，restaurantImage用与接受table view传来的图像名称数据。 12345678@IBOutlet var restaurantImageView:UIImageView!var restaurantImage = &quot;&quot;override func viewDidLoad() &#123; super.viewDidLoad() restaurantImageView.image = UIImage(named: restaurantImage)&#125; 通过segues传递数据segue管理view controller之间的过渡。当segue触发时，storyboard会通知源view controller（如RestaurantTableViewController）调用方法prepare(for:sender:)，可以通过此方法传递数据。 当storyboard中结构复杂时，segue可能会有很多，同一个view controller可能与各级view controller之间有segue，这种情况最好给segue一个唯一identifier。设置segue的identifier为 showRestaurantDetail。 在RestaurantTableViewController中添加prepareForSegue: 12345678override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showRestaurantDetail&quot; &#123; if let indexPath = tableView.indexPathForSelectedRow &#123; let destinationController = segue.destination as! RestaurantDetailViewController destinationController.restaurantImage = restaurantImages[indexPath.row] &#125; &#125;&#125; 为详情页面添加三个标签 添加三个标签，Text分别为Name，Location，Type（注意：虽然Text会被替代，但不要开始留空，因为留空会使之后生成stack view时，大小不确定）；三个label生成一个stack view，调整字体和大小，添加适当的约束。 添加三个outlet，和三个与之对应的变量。 12345678910111213141516@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!var nameText = &quot;&quot;var locationText = &quot;&quot;var typeText = &quot;&quot;override func viewDidLoad() &#123; super.viewDidLoad() restaurantImageView.image = UIImage(named: restaurantImage) nameLabel.text = nameText locationLabel.text = locationText typeLabel.text = typeText&#125; 修改RestaurantTableViewController中的prepareForSegue方法： 1234567891011override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showRestaurantDetail&quot; &#123; if let indexPath = tableView.indexPathForSelectedRow &#123; let destinationController = segue.destination as! RestaurantDetailViewController destinationController.restaurantImage = restaurantImages[indexPath.row] destinationController.nameText = restaurantNames[indexPath.row] destinationController.locationText = restaurantLocations[indexPath.row] destinationController.typeText = restaurantTypes[indexPath.row] &#125; &#125;&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 5：关于地理定位和特定区域(Swift)]]></title>
    <url>%2F2017%2Fios-tutorial-5.html</url>
    <content type="text"><![CDATA[用户带着iPhone进入某个区域，并在某些区域待多久在开发肯能会有很大用处。 初始化项目 创建新的项目GeoTargeting，使用Single View Appliction模板 添加一个Map View，大小为整个页面 添加相关outlet 实现两个协议 123class ViewController: UIViewController, MKMapViewDelegate, CLLocationManagerDelegate &#123; @IBOutlet weak var mapView: MKMapView! 设置CLLocationManager和MKMapView。 1234567891011121314151617// 1let locationManager = CLLocationManager()override func viewDidLoad() &#123; super.viewDidLoad() // 2 locationManager.delegate = self locationManager.distanceFilter = kCLLocationAccuracyNearestTenMeters locationManager.desiredAccuracy = kCLLocationAccuracyBest // 3 mapView.delegate = self mapView.showsUserLocation = true mapView.userTrackingMode = .follow setupData() &#125; 1 创建一个CLLocationManager的实例，用于检测用户的位置变化 2 设置locationManager一些参数，确定精确性 在viewDidAppear中核查用户授权状态1234567891011121314151617override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) let authorizationStatus = CLLocationManager.authorizationStatus() // 1 if authorizationStatus == .notDetermined &#123; locationManager.requestAlwaysAuthorization() &#125; // 2 else if authorizationStatus == .denied &#123; showAlert(&quot;Location services &quot;) &#125; // 3 else if authorizationStatus == .authorizedAlways &#123; locationManager.startUpdatingLocation() &#125;&#125; 1 如果用户授权状态是不确定，就检查是否是一直的状态。 2 如果用户授权状态是拒绝，就用弹框显示信息给用户看。showAlert(title:)是弹框函数： 1234567891011func showAlert(_ title: String) &#123; print(title) let alertController = UIAlertController(title: title, message: nil, preferredStyle: .alert) let action = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler: nil) alertController.addAction(action) present(alertController, animated: true, completion: nil) &#125; 3 如果用户授权状态是一直，就开始更新地理位置。 另外，还需要在.plist文件中添加key为NSLocationAlwaysUsageDescription的提示信息 需要一直能获取你的位置 才可以。在调用requestAlwaysAuthorization()时这个key是必须的。允许获取当前位置。 添加函数setupData()1234567891011121314151617181920212223242526272829303132333435func setupData() &#123; // 1 if CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) &#123; // 2 let title = &quot;全季酒店&quot; let coordinate = CLLocationCoordinate2DMake(31.1849700000,121.6303200000) let regionRadius = 300.0 // 3 let region = CLCircularRegion(center: CLLocationCoordinate2D(latitude: coordinate.latitude, longitude: coordinate.longitude), radius: regionRadius, identifier: title) locationManager.startMonitoring(for: region) // 4 let restaurantAnnotation = MKPointAnnotation() restaurantAnnotation.coordinate = coordinate restaurantAnnotation.title = title mapView.addAnnotation(restaurantAnnotation) // 5 let circle = MKCircle(center: coordinate, radius: regionRadius) mapView.add(circle) &#125; else &#123; print(&quot;不能追踪区域&quot;) &#125;&#125;// 6func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123; let circleRenderer = MKCircleRenderer(overlay: overlay) circleRenderer.strokeColor = UIColor.red circleRenderer.lineWidth = 1.0 return circleRenderer&#125; 1 判断是否监控区域功能是否可用。当用户拒绝状态，或用户不让app背景下刷新，或飞行模式时这个功能不可用 2 随意构建一个位置（如全季酒店），经纬度可通过经纬度查询查询，并设置区域半径regionRadius，单位是米。 3 初始化CLCircularRegion。 4 添加一个注解，类似大头针形状。 5 添加区域圆圈标志。 6 这是MKMapViewDelegate的方法，用户画圆 CLRegionCLRegion就是上面标定的圆形区域。下面添加两个CLLocationManagerDelegate的回调方法，分别在是设备的定位位置进和出标定的区域时调用。12345678// MARK:- CLLocationManagerDelegatefunc locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;)&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;)&#125; Xcode中的位置调试上面设备的位置，不可能拿着手机到处跑，Xcode提高了方便的调式方式。可以建立位置文件.GPX: xcode也提供世界上一些常用的位置文件：点击上图调试栏最后的位置标志就可以调式了。 复杂逻辑下的位置处理如果位置不停变化，在监控区域停留时间比较短，或者监控区域比较多是，处理位置问题就比较复杂了。更新部分代码：123456789101112131415161718// 1var monitoredRegions: Dictionary&lt;String, NSDate&gt; = [:] func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;) // 2 monitoredRegions[region.identifier] = NSDate()&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;) // 3 monitoredRegions.removeValue(forKey: region.identifier)&#125;// 4func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; updateRegions()&#125; 1 定义以字典用于存储用户进入监控区的时间。 2 记录进入时间。 3 删除进入时间。 4 用户位置变化后调用 加入函数updateRegions()代码：1234567891011121314151617181920func updateRegions() &#123; // 1 let regionMaxVisiting = 10.0 var regionsToDelete: [String] = [] // 2 for regionIdentifier in monitoredRegions.keys &#123; // 3 if NSDate().timeIntervalSince(monitoredRegions[regionIdentifier]! as Date) &gt; regionMaxVisiting &#123; showAlert(&quot;谢谢访问&quot;) regionsToDelete.append(regionIdentifier) &#125; &#125; // 4 for regionIdentifier in regionsToDelete &#123; monitoredRegions.removeValue(forKey: regionIdentifier) &#125;&#125; 1 加的用户到某个区域10s，就确定用户已经到访问过这个区域。regionsToDelete用来存储即将删除的区域的identifier，也就用户待过超过10s的区域。 2 遍历所有监控区域 3 timeIntervalSince用来计算某个时间到当前时间的差值，单位为秒。 4 删除用户待过超过regionMaxVisiting的区域。 代码GeoTargeting 参考 Building a Geo Targeting iOS App in Swift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 4：CALayer介绍(swift)]]></title>
    <url>%2F2017%2Fios-tutorial-4-calayer.html</url>
    <content type="text"><![CDATA[Layers是Core Animation Framework的一部分。Core Animation Framework在iOS架构的位置： 访问CALayer凡是继承至UIView的都将有一个属性layer来表示CALayer。myView.layer 初始化项目 新建CALayerDemo，single View Application模板 新建一个UIView和一个UILabel 圆角CALayer的cornerRadius属性大小表示UIView圆角处圆的半径大小。类似于box.layer.cornerRadius = 20，就形成了圆角，数字越大圆角效果越大，当cornerRadius等于box半径时，box就会变成一个园。 阴影效果1234box.layer.shadowOffset = CGSize(width: 5, height: 5)box.layer.shadowOpacity = 0.7box.layer.shadowRadius = 10box.layer.shadowColor = UIColor.blue.cgColor shadowOffset表示阴影偏移大小，也就是阴影向box的下放偏移5和向右方偏移5距离。 shadowOpacity是阴影透明度 shadowRadius是阴影涉及的半径，并且这个半径越大，阴影的颜色深浅就会越来越小。shadowRadius与shadowOffset是共同作用的 设置边的宽度和颜色12box.layer.borderColor = UIColor.black.cgColorbox.layer.borderWidth = 3 展示图片123box.layer.contents = UIImage(named: &quot;tree.jpg&quot;)?.cgImagebox.layer.contentsGravity = kCAGravityResizebox.layer.masksToBounds = true CALayer的contents属性是open var contents: Any?，可以设置为图片 contentsGravity设置成kCAGravityResize，表示contents的内容会调整大小以适应layer。如果设置成其他值可能出现大小不适的形象，比如kCAGravityBottomRight，将是： masksToBounds为true表示按照layer的边框范围显示内容；如果是false，将会是如下结果 背景颜色和透明度12box.layer.backgroundColor = UIColor.green.cgColorbox.layer.opacity = 0.5 代码CALayerDemo 参考 A Beginner’s Guide to CALayer]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-24：Access Control]]></title>
    <url>%2F2017%2Fswift-24.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081/** Access Control */// 可以明确地给单个类型(类、结构体、枚举)设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围内使用，包括协议里的全局常量、变量和函数。// 为某些典型场景提供了默认的访问级别// *实体(entities)* : 对于代码中可以设置访问级别的特性(属性、基本类型、函数等)一种统称// 1 模块和源文件// *模块*：独立的代码单元// *框架或应用程序*会作为一个独立的模块来构建和发布// 一个模块可以使用import关键字导入另外一个模块// Xcode的每个target(例如框架或应用程序)都被当作独立的模块处理// *源文件*：Swift中的源代码文件// 2 访问级别（低→高）// open: 类似public。可以被访问和被继承// public: 可以访问同一模块源文件中的任何实体，在模块外也可以通过导入该模块来访问源文件里的所有实体。可以被访问不可以被继承// internal: 可以访问同一模块源文件中的任何实体，但是不能从模块外访问该模块源文件中的实体。通常情况下，某个接口只在应用程序或框架内部使用时，你可以将其设置为internal级别。// fileprivate: 限制实体只能在所在的源文件内部使用。// private: 只在定义的实体中使用// 访问级别基本原则: 不可以在某个实体中定义访问级别更高的实体// 函数的访问级别不能高于它的参数类型和返回类型的访问级别。// 一般，默认为 internal 级别// 在导入应用程序模块的语句前使用 @testable 特性，然后在允许测试的编译设置( Build Options -&gt; Enable Testability )下编译这个应用程序模块，单元测试 target 就可以访问应用程序模块中所有 internal 级别的实体。// 3 访问控制语法// 4 自定义类型// 一个类型的访问级别也会影响到类型成员(属性、方法、构造器、下标)的默认访问级别。// 元组：元组的访问级别将由元组中访问级别最严格的类型来决定。// 函数：函数的访问级别根据访问级别最严格的参数类型或返回类型的访问级别来决定。但是，如果这种访问级别不符合函数定义所在环境的默认访问级别，那么就需要明确地指定该函数的访问级别。// 枚举类型：枚举成员的访问级别和该枚举类型相同，你不能为枚举成员单独指定不同的访问级别。枚举定义中的任何原始值或关联值的类型的访问级别至少不能低于枚举类型的访问级别。// 5 子类// 子类的访问级别不得高于父类的访问级别。// 可以在符合当前访问级别的条件下重写任意类成员(方法、属性、构造器、下标等)。public class A &#123; fileprivate func someMethod() &#123;&#125;&#125;internal class B: A &#123; override internal func someMethod() &#123; super.someMethod() &#125;&#125;// 6 常量、变量、属性、下标// 常量、变量、属性访问级别不能高于它们所属的类型。struct TrackedString &#123; private(set) var numberOfEdits = 0 var value: String = &quot;&quot; &#123; didSet &#123; numberOfEdits += 1 &#125; &#125;&#125;var stringToEdit = TrackedString()stringToEdit.value = &quot;This string will be tracked.&quot;stringToEdit.value += &quot; This edit will increment numberOfEdits.&quot;stringToEdit.value += &quot; So will this one.&quot;print(&quot;The number of edits is \(stringToEdit.numberOfEdits)&quot;) // 打印 “The number of edits is 3”public struct TrackedString2 &#123; public private(set) var numberOfEdits = 0 // Getter的访问级别是public，Setter的访问级别是private。 public var value: String = &quot;&quot; &#123; didSet &#123; numberOfEdits += 1 &#125; &#125; public init() &#123;&#125;&#125;// 7 构造器// *必要构造器* 的访问级别必须和所属类型相同。// 8 协议// 9 扩展// 10 泛型// 11 类型别名// 类型别名的访问级别不可高于其表示的类型的访问级别]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 3：Speech Framework的简单使用]]></title>
    <url>%2F2017%2Fios-tutorial-3-speechframework.html</url>
    <content type="text"><![CDATA[在WWDC 2016时，Apple介绍了Speech framework，这是一个很有用的声音识别框架。实际上这是利用Siri进行声音识别。 初始化项目 新建SpeechToTextDemo，模板是Single View Application。 添加简单的UI 分别定义UITextView和UIButton的两个outlet，为textView和microphoneButton。 再为UIButton添加一个action：123@IBAction func microphoneTapped(_ sender: AnyObject) &#123;&#125; 使用Speech Framework import Speech 实现SFSpeechRecognizerDelegate协议 用户授权获取声音数据是要获得用户的授权的。 在ViewController类中定义一个变量，作为语音识别器。参数identifier是识别的语种，可参考这个列表，中文是“ zh_Hans_CN”。private let speechRecognizer = SFSpeechRecognizer(locale: Locale.init(identifier: &quot;zh_Hans_CN&quot;)) 在viewDidLoad()中： 1234567891011121314151617181920212223242526272829override func viewDidLoad() &#123; super.viewDidLoad() // 1 microphoneButton.isEnabled = false speechRecognizer?.delegate = self // 2 SFSpeechRecognizer.requestAuthorization&#123; (authStatus) in var isButtionEnabled = false switch authStatus &#123; case .authorized: isButtionEnabled = true case .denied: isButtionEnabled = false print(&quot;用户拒绝接受语音识别&quot;) case .notDetermined: isButtionEnabled = false print(&quot;语音识别功能没有经过认可&quot;) case .restricted: isButtionEnabled = false print(&quot;当前设备不能语音识别&quot;) &#125; self.microphoneButton.isEnabled = isButtionEnabled &#125; startRecording()&#125; 1 默认按钮设成不可用 2 授权结果回调 Apple需要每个app如要用户授权时，都应该定制一个反馈信息（info.plist）。在info.plist中添加两个key，分别是麦克风和语音识别的授权，Privacy - Microphone Usage Description和Privacy - Speech Recognition Usage Description。 处理语音识别 在ViewController类中添加三个变量 123private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest? //识别请求private var recognitionTask: SFSpeechRecognitionTask? // 提供识别请求的结果private let audioEngine = AVAudioEngine() // SFSpeechAudioBufferRecognitionRequest对象处理语音识别的请求，代表语音进入语音识别器。 SFSpeechRecognitionTask 识别任务，用于操作识别器的停止和开始 AVAudioEngine 语音引擎，提供语音输出 创建新函数startRecording()，这个函数在点击button后调用，也就是microphoneTapped(:)中最后调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162func startRecording() &#123; // 1 if recognitionTask != nil &#123; recognitionTask?.cancel() recognitionTask = nil &#125; // 2 let audioSession = AVAudioSession.sharedInstance() do &#123; try audioSession.setCategory(AVAudioSessionCategoryRecord) try audioSession.setMode(AVAudioSessionModeMeasurement) try audioSession.setActive(true, with: .notifyOthersOnDeactivation) &#125; catch &#123; print(&quot;audioSession的属性设置失败&quot;) &#125; // 3 recognitionRequest = SFSpeechAudioBufferRecognitionRequest() // 4 guard let inputNode = audioEngine.inputNode else &#123; fatalError(&quot;Audio engine has no input node&quot;) &#125; // 5 guard let recognitionRequest = recognitionRequest else &#123; fatalError(&quot;Unable to create an SFSpeechAudioBufferRecognitionRequest object&quot;) &#125; // 6 recognitionRequest.shouldReportPartialResults = true // 7 recognitionTask = speechRecognizer?.recognitionTask(with: recognitionRequest, resultHandler: &#123; (result, error) in var isFinal = false if result != nil &#123; self.textView.text = result?.bestTranscription.formattedString isFinal = (result?.isFinal)! &#125; if error != nil || isFinal &#123; self.audioEngine.stop() inputNode.removeTap(onBus: 0) self.recognitionRequest = nil self.recognitionTask = nil self.microphoneButton.isEnabled = true &#125; &#125;) let recordingFormat = inputNode.outputFormat(forBus: 0) inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) &#123; (buffer, when) in self.recognitionRequest?.append(buffer) &#125; audioEngine.prepare() do &#123; try audioEngine.start() &#125; catch &#123; print(&quot;audioEngine couldn&apos;t start beacause of an error.&quot;) &#125; textView.text = &quot;Say something, I&apos;m listening!&quot;&#125; 1 开始录音时的初始化 2 AVAudioSession提供语音录音，设置一些参数 3 初始化SFSpeechAudioBufferRecognitionRequest 4 核查audioEngine是否可用 5 核查recognitionRequest 7 检测的音频后的回调方法，也就是开始录音后，有音频进入后都调用 语音识别的开关 实现代理方法speechRecognizer(_:availabilityDidChange:)。这个方法在语音识别器可用性发生变化时被调用。 1234567func speechRecognizer(_ speechRecognizer: SFSpeechRecognizer, availabilityDidChange available: Bool) &#123; if available &#123; microphoneButton.isEnabled = true &#125; else &#123; microphoneButton.isEnabled = false &#125;&#125; 点击button时的操作： 1234567891011@IBAction func microphoneTapped(_ sender: AnyObject) &#123; if audioEngine.isRunning &#123; audioEngine.stop() recognitionRequest?.endAudio() microphoneButton.isEnabled = false microphoneButton.setTitle(&quot;Start Recording&quot;, for: .normal) &#125; else &#123; startRecording() microphoneButton.setTitle(&quot;Stop Recording&quot;, for: .normal) &#125; &#125; 总结语音识别在iPhone的自带键盘中有这个功能，中文识别率很高，如果不高兴或不方便打字，很方便使用。 代码SpeechToTextDemo 参考： Building a Speech-to-Text App Using Speech Framework in iOS 10]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-23：Generics]]></title>
    <url>%2F2017%2Fswift-23.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** Generics 泛型是 Swift 最强大的特性之一，许多 Swift 标准库是通过泛型代码构建的。 */// 1 泛型函数// T是一个占位类型，其他字母也可以，只要在尖括号中就行。// 可以理解为：在定义的时候还不知道是啥类型，那就假设是T类型，等到调用时，给过来什么类型的参数，那T就是上面类型。func swapValue&lt;T&gt;(_ a: inout T, _ b: inout T) &#123; let tmp = a a = b b = tmp&#125;var a = 1var b = 3swapValue(&amp;a, &amp;b)print(a,b)var s1 = &quot;word&quot;var s2 = &quot;单词&quot;swapValue(&amp;s1, &amp;s2)print(s1, s2)// 2 类型参数// T就是类型参数。可以定义多个类型参数。// 3 命名类型参数：就是把类型参数命名为一个容易阅读的名字（大写字母开头的驼峰命名法）。// Dictionary&lt;Key, Value&gt;// Array&lt;Element&gt;// 4 泛型类型struct Stack&lt;Element&gt; &#123; var items = [Element]() mutating func push(item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125;&#125;var stackOfStrings = Stack&lt;String&gt;()stackOfStrings.push(item: &quot;uno&quot;)stackOfStrings.push(item: &quot;dos&quot;)stackOfStrings.push(item: &quot;tres&quot;)stackOfStrings.push(item: &quot;cuatro&quot;)// 5 扩展一个泛型类型// 不需要在扩展的定义中提供类型参数列表。原始类型定义中声明的类型参数列表在扩展中可以直接使用，并且这些来自原始类型中的参数名称会被用作原始定义中类型参数的引用。extension Stack &#123; var topItem: Element? &#123; return items.isEmpty ? nil : items[items.count - 1] &#125;&#125;// 6 类型约束：指定一个类型参数必须继承自指定类，或者符合一个特定的协议或协议组合。/*func someFunction&lt;T: SomeClass, U: SomeProtocol&gt;(someT: T, someU: U) &#123; // 这里是泛型函数的函数体部分&#125; *//*func findIndex&lt;T&gt;(array: [T], _ valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125; */// 不是所有的 Swift类型都可以用等式符(==)进行比较。// Swift标准库中定义了一个 Equatable 协议，该协议要求任何遵循该协议的类型必须实现等式符( == )及不等符( != )。func findIndex&lt;T: Equatable&gt;(array: [T], _ valueToFind: T) -&gt; Int? &#123; for (index, value) in array.enumerated() &#123; if value == valueToFind &#123; return index &#125; &#125; return nil&#125;// 7 关联类型// 关联类型为协议中的 某个类型提供了一个占位名(或者说别名)，其代表的实际类型在协议被采纳时才会被指定。protocol Container &#123; associatedtype ItemType mutating func append(item: ItemType) var count: Int &#123; get &#125; subscript(i: Int) -&gt; ItemType &#123; get &#125;&#125;struct Stack2&lt;Element&gt;: Container &#123; // Stack&lt;Element&gt; 的原始实现部分 var items = [Element]() mutating func push(item: Element) &#123; items.append(item) &#125; mutating func pop() -&gt; Element &#123; return items.removeLast() &#125; // Container 协议的实现部分 mutating func append(item: Element) &#123; self.push(item: item) &#125; var count: Int &#123; return items.count &#125; subscript(i: Int) -&gt; Element &#123; // swift 可以推断出ItemType就是Element return items[i] &#125;&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-22：Protocols]]></title>
    <url>%2F2017%2Fswift-22.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327/** Protocols 协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。 类、结构体或枚举都可以采纳协议，并为协议定义的这些要求提供具体实现。 xx conform xxx protocol (xx“符合”xxx协议) */// 1 属性要求// 可以要求提供特定名称和类型的实例属性或类型属性protocol SomeProtocol &#123; var mustBeSettable: Int &#123; get set &#125; var doesNotNeedToBeSettable: Int &#123; get &#125;&#125;protocol AnotherProtocol &#123; static var someTypeProperty: Int &#123; get set &#125;&#125;protocol FullyNamed &#123; var fullName: String &#123; get &#125;&#125;struct Person: FullyNamed &#123; var fullName: String&#125;let john = Person(fullName: &quot;John Appleseed&quot;)class Starship: FullyNamed &#123; var prefix: String? var name: String init(name: String, prefix: String? = nil) &#123; self.name = name self.prefix = prefix &#125; var fullName: String &#123; return (prefix != nil ? prefix! + &quot; &quot; : &quot;&quot;) + name &#125;&#125;// 2 方法要求// 不需要大括号和方法体; 不支持为协议中的方法的参数提供默认值protocol SomeProtocol2 &#123; static func someTypeMethod()&#125;protocol RandomNumberGenerator &#123; func random() -&gt; Double&#125;// 线性同余生成器(linear congruential generator)的伪随机数算法。class LinearCongruentialGenerator: RandomNumberGenerator &#123; var lastRandom = 42.0 let m = 139968.0 let a = 3877.0 let c = 29573.0 func random() -&gt; Double &#123; // a.truncatingRemainder(dividingBy:m) = b 相当于 x*m + b = a。（a是浮点数，x是整数） lastRandom = ((lastRandom * a + c).truncatingRemainder(dividingBy:m)) return lastRandom / m &#125;&#125;// 3 Mutating 方法要求// 实现协议中的 mutating 方法时，若是类类型，则不用写 mutating 关键字。而对于结构体和枚举，则必须写 mutating 关键字。protocol Togglable &#123; mutating func toggle()&#125;enum OnOffSwitch: Togglable &#123; case Off, On mutating func toggle() &#123; switch self &#123; case .Off: self = .On case .On: self = .Off &#125; &#125;&#125;var lightSwitch = OnOffSwitch.OfflightSwitch.toggle()// 4 构造器要求protocol SomeProtocol3 &#123; init(someParameter: Int)&#125;class SomeClass: SomeProtocol3 &#123; required init(someParameter: Int) &#123; // 必须要加required &#125;&#125;// 5 协议作为类型// 1 作为函数、方法或构造器中的参数类型或返回值类型// 2 作为常量、变量或属性的类型// 3 作为数组、字典或其他容器中的元素类型class Dice &#123; // 骰子 let sides: Int let generator: RandomNumberGenerator init(sides: Int, generator: RandomNumberGenerator) &#123; self.sides = sides self.generator = generator &#125; func roll() -&gt; Int &#123; return Int(generator.random() * Double(sides)) + 1 &#125;&#125;var d6 = Dice(sides: 6, generator: LinearCongruentialGenerator())for _ in 1...5 &#123; print(&quot;Random dice roll is \(d6.roll())&quot;)&#125;let a = 8.625a.truncatingRemainder(dividingBy: 0.75)let b = 5.5b.truncatingRemainder(dividingBy: 3)// 6 委托(代理)模式// 委托是一种设计模式，它允许类或结构体将一些需要它们负责的功能委托给其他类型的实例。// 委托模式的实现: 定义协议来封装那些需要被委托的功能，这样就能确保采纳协议的类型能提供这些功能。protocol DiceGame &#123; var dice: Dice &#123; get &#125; func play()&#125;protocol DiceGameDelegate &#123; func gameDidStart(game: DiceGame) func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll:Int) func gameDidEnd(game: DiceGame)&#125;class SnakesAndLadders: DiceGame &#123; let finalSquare = 25 let dice = Dice(sides: 6, generator: LinearCongruentialGenerator()) var square = 0 var board: [Int] init() &#123; board = [Int](repeating: 0, count: finalSquare + 1) board[03] = +08; board[06] = +11; board[09] = +09; board[10] = +02 board[14] = -10; board[19] = -11; board[22] = -02; board[24] = -08 &#125; var delegate: DiceGameDelegate? func play() &#123; square = 0 delegate?.gameDidStart(game: self) gameLoop: while square != finalSquare &#123; let diceRoll = dice.roll() delegate?.game(game: self, didStartNewTurnWithDiceRoll: diceRoll) switch square + diceRoll &#123; case finalSquare: break gameLoop case let newSquare where newSquare &gt; finalSquare: continue gameLoop default: square += diceRoll square += board[square] &#125; &#125; delegate?.gameDidEnd(game: self) &#125;&#125;class DiceGameTracker: DiceGameDelegate &#123; var numberOfTurns = 0 func gameDidStart(game: DiceGame) &#123; numberOfTurns = 0 if game is SnakesAndLadders &#123; print(&quot;Started a new game of Snakes and Ladders&quot;) &#125; print(&quot;The game is using a \(game.dice.sides)-sided dice&quot;) &#125; func game(game: DiceGame, didStartNewTurnWithDiceRoll diceRoll: Int) &#123; numberOfTurns += 1 print(&quot;Rolled a \(diceRoll)&quot;) &#125; func gameDidEnd(game: DiceGame) &#123; print(&quot;The game lasted for \(numberOfTurns) turns&quot;) &#125;&#125;let tracker = DiceGameTracker()let game = SnakesAndLadders()game.delegate = trackergame.play()// 7 通过扩展添加协议一致性// 通过扩展令已有类型采纳并符合协议时，该类型的所有实例也会随之获得协议中定义的各项功能。protocol TextRepresentable &#123; var textualDescription: String &#123; get &#125;&#125;extension Dice: TextRepresentable &#123; var textualDescription: String &#123; return &quot;A \(sides)-sided dice&quot; &#125;&#125;let d12 = Dice(sides: 12, generator: LinearCongruentialGenerator())print(d12.textualDescription)// 8 通过扩展采纳协议// 当一个类型已经符合了某个协议中的所有要求，却还没有声明采纳该协议时，可以通过空扩展体的扩展来采纳该协议struct Hamster &#123; var name: String var textualDescription: String &#123; return &quot;A hamster named \(name)&quot; &#125;&#125;extension Hamster: TextRepresentable &#123;&#125;let simonTheHamster = Hamster(name: &quot;Simon&quot;)let somethingTextRepresentable: TextRepresentable = simonTheHamster// 9 协议类型的集合let things: [TextRepresentable] = [ d12, simonTheHamster] for thing in things &#123; print(thing.textualDescription)&#125;// 10 协议的继承protocol PrettyTextRepresentable: TextRepresentable &#123; var prettyTextualDescription: String &#123; get &#125;&#125;// 11 类类型专属协议protocol SomeClassOnlyProtocol: class &#123; // 只能类可以实现这个协议 &#125;//struct SomeStruct: SomeClassOnlyProtocol &#123;//&#125;// 12 协议合成protocol Named &#123; var name: String &#123; get &#125;&#125;protocol Aged &#123; var age: Int &#123; get &#125;&#125;struct Person2: Named, Aged &#123; var name: String var age: Int&#125;// 参数celebrator的类型是`Named &amp; Aged`，意味着它不关心参数的具体类型，只要参数符合这两个协议即可func wishHappyBirthday(to celebrator: Named &amp; Aged) &#123; print(&quot;Happy birthday, \(celebrator.name), you&apos;re \(celebrator.age)!&quot;)&#125;let birthdayPerson = Person2(name: &quot;Malcolm&quot;, age: 21)wishHappyBirthday(to: birthdayPerson)// 13 检查协议一致性/** 检查和转换到某个协议类型在语法上和类型的检查和转换完全相同: • is 用来检查实例是否符合某个协议，若符合则返回 true ，否则返回 false 。 • as? 返回一个可选值，当实例符合某个协议时，返回类型为协议类型的可选值，否则返回 nil 。 • as! 将实例强制向下转换到某个协议类型，如果强转失败，会引发运行时错误。 */protocol HasArea &#123; var area: Double &#123; get &#125;&#125;class Circle: HasArea &#123; let pi = 3.1415927 var radius: Double var area: Double &#123; return pi * radius * radius &#125; init(radius: Double) &#123; self.radius = radius &#125;&#125;class Country: HasArea &#123; var area: Double init(area: Double) &#123; self.area = area &#125;&#125;class Animal &#123; var legs: Int init(legs: Int) &#123; self.legs = legs &#125;&#125;let objects: [AnyObject] = [ Circle(radius: 2.0), Country(area: 243_610), Animal(legs: 4)]for object in objects &#123; if let objectWithArea = object as? HasArea &#123; print(&quot;Area is \(objectWithArea.area)&quot;) &#125; else &#123; print(&quot;Something that doesn&apos;t have an area&quot;) &#125;&#125;// 14 可选的协议要求import Foundation@objc protocol CounterDataSource &#123; @objc optional func increment(forCount count: Int) -&gt; Int @objc optional var fixedIncrement: Int &#123; get &#125;&#125;class Counter &#123; var count = 0 var dataSource: CounterDataSource? func increment() &#123; if let amount = dataSource?.increment?(forCount: count) &#123; count = count + amount &#125; else if let amount = dataSource?.fixedIncrement &#123; count = count + amount &#125; &#125;&#125;class ThreeSource: NSObject, CounterDataSource &#123; let fixedIncrement = 3&#125;var counter = Counter()counter.dataSource = ThreeSource()for _ in 1...4 &#123; counter.increment() print(counter.count)&#125;// 15 协议扩展// 协议可以通过扩展来为采纳协议的类型提供属性、方法以及下标的实现。extension RandomNumberGenerator &#123; func randomBool() -&gt; Bool &#123; return random() &gt; 0.5 &#125;&#125;let generator = LinearCongruentialGenerator()print(&quot;Here&apos;s a random number: \(generator.random())&quot;)print(&quot;And here&apos;s a random Boolean: \(generator.randomBool())&quot;)// 提供默认实现。// 如果符合PrettyTextRepresentable协议某个类、结构体或枚举，有属性prettyTextualDescription的实现，那属性prettyTextualDescription的结果就是这个实现，否则就会使用扩展当中的实现。extension PrettyTextRepresentable &#123; var prettyTextualDescription: String &#123; return textualDescription &#125;&#125;// 为协议扩展添加限制条件extension Collection where Iterator.Element: TextRepresentable &#123; var textualDescription: String &#123; let itemsAsText = self.map &#123; $0.textualDescription &#125; return &quot;[&quot; + itemsAsText.joined(separator: &quot;, &quot;) + &quot;]&quot; &#125;&#125;let murrayTheHamster = Hamster(name: &quot;Murray&quot;)let morganTheHamster = Hamster(name: &quot;Morgan&quot;)let mauriceTheHamster = Hamster(name: &quot;Maurice&quot;)let hamsters = [murrayTheHamster, morganTheHamster, mauriceTheHamster]print(hamsters.textualDescription)]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[swift的文档注释]]></title>
    <url>%2F2017%2Fswift-document.html</url>
    <content type="text"><![CDATA[在Xcode中Quick Help 为开发者提供方便快捷的简洁文档查看方式。option+点击查看弹框，option+command+2在检查器中查看。swift的中有两种注释方式，让Xcode在Quick Help中显示。这种注释可以认为是将文档以某种规范的格式嵌入在实际代码的上方，这样就可以通过某些工具自动生成漂亮的文档文件。这种内嵌式的文档在现代编程中是很普遍的。在swift中，这两种注释方式是： /** */ /// 这些注释中还可以有其他一些规范 可以支持markdown 关键词 三个关键词：parameter， returns， throws。这三个关键词会在最左边显示。 还有一些关键词会被提取到description中作为一些特殊字段显示，其他都会在description正常显示：author, authors, copyright, date；since, version；attention, important, note, remark, warning；bug, TODO, experiment； complexity； precondition, postcondition, requires, invariant see* 参考http://swifter.tips/documentation/http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 2：用Core Image进行面部识别(Swift)]]></title>
    <url>%2F2017%2Fios-tutorial-2-facerecognition.html</url>
    <content type="text"><![CDATA[面部识别API不仅可以是识别面部，也可识别面部的特殊细节，例如微笑甚至眨眼睛。 建立初始项目原文建好了初始项目，我自己新建了初始项目 新建项目Detector 删除IB中原本View Controller Scene。 拖动UITabBarController到IB中，得到三个Scene。选择UITabBarController的Is Initial View Controller，使其作为初始控制器。 修改Item 1的title和其Bar Item都为Photo，修改其Class为ViewController。 向Assets中添加几张人物图片 想Photo Scene中添加一个Image View，Content Mode改为Aspect Fit，选择一个图片。在ViewController添加图片对应@IBOutlet：@IBOutlet var personPic: UIImageView! 选中Item 2，点击菜单栏EDitor &gt; Embed In &gt; Navigation Controller，新生成一个与之关联的Scene。 新建CameraViewController类，继承至UIViewController。修改上面生成的Scene的Class属性为CameraViewController。 拖动一个UIBarButtonItem到Camera View Controller Scene的UINavigationItem的右边，并选择System Item为Camera 在CameraViewController中建立outlet和Action 识别照片的面部 在 ViewController.swift中引入CoreImage:import CoreImage 在 ViewController.swift中添加函数detect(): 12345678910111213141516171819202122232425262728293031func detect() &#123; // 1 guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; // 2 let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // 3 for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) let faceBox = UIView(frame: face.bounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) // 4 if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 1 根据UIImage获取CoreImage中图片对象。guard与if功能类似，区别可查看以撸代码的形式学习Swift-5：Control Flow的6 guard 与 if。 2 初始化检测器CIDetector， accuray是检查器配置选项，表示精确度；因为CIDetector可以进行几种类型的检测，所以CIDetectorTypeFace用来表示面部检测；features方法返回具体的检测结果 3 给每个检测到的脸添加红色框 4 检测是否有左眼位置 在viewDidLoad中添加 detect()，运行结果类似： 打印结果，显示检测到的面部位置是不对的：Found bounds are (177.0, 416.0, 380.0, 380.0)这是因为UIKit的坐标系统与Core Image的坐标系统是不同的： 把Core Image的坐标系统转换为UIKit的坐标系统，修改detect()为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func detect() &#123; guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // let ciImageSize = personciImage.extent.size var transform = CGAffineTransform(scaleX: 1, y: -1) transform = transform.translatedBy(x: 0, y: -ciImageSize.height) for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) // Apply the transform to convert the coordinates var faceViewBounds = face.bounds.applying(transform) // Calculate the actual position and size of the rectangle in the image view let viewSize = personPic.bounds.size let scale = min(viewSize.width / ciImageSize.width, viewSize.height / ciImageSize.height) let offsetX = (viewSize.width - ciImageSize.width * scale) / 2 let offsetY = (viewSize.height - ciImageSize.height * scale) / 2 faceViewBounds = faceViewBounds.applying(CGAffineTransform(scaleX: scale, y: scale)) faceViewBounds.origin.x += offsetX faceViewBounds.origin.y += offsetY let faceBox = UIView(frame: faceViewBounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 运行可看到正确识别位置： 相机拍照后的脸部识别之前是项目中照片识别，现在是拍完照再识别，原理是相同的，就是多一个拍完照，取照片的过程。 更新CameraViewController类的代码 1234567891011121314151617181920212223242526272829303132333435363738// 1class CameraViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate &#123; @IBOutlet var imageView: UIImageView! // 2 let imagePicker = UIImagePickerController() override func viewDidLoad() &#123; super.viewDidLoad() imagePicker.delegate = self &#125; @IBAction func takePhoto(_ sender: AnyObject) &#123; // 3 if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; imagePicker.allowsEditing = false imagePicker.sourceType = .camera present(imagePicker, animated: true, completion: nil) &#125; // 4 //MARK: -UIImagePickerControllerDelegate func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage &#123; imageView.contentMode = .scaleAspectFit imageView.image = pickedImage &#125; dismiss(animated: true, completion: nil) self.detect() &#125; // 5 func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil) &#125;&#125; 1 实现UIImagePickerControllerDelegate协议，用于拍照相关代理。 2 初始化UIImagePickerController。UIImagePickerController是照相或摄影界面和功能管理的类。 3 判断设备照相机是否可用。 4 实现一个UIImagePickerControllerDelegate中的代理方法，当拍摄完备确实使用照片时调用。 5 也是UIImagePickerControllerDelegate中的代理方法，取消拍摄时调用。 添加detect()代码，与ViewController中不同的是，不用红色框框处识别出的面部，而是识别出面部的细节，并用UIAlertController弹出显示。 1234567891011121314151617181920212223242526272829303132333435363738394041func detect() &#123; let imageOptions = NSDictionary(object: NSNumber(value: 5) as NSNumber, forKey: CIDetectorImageOrientation as NSString) let personciImage = CIImage(cgImage: imageView.image!.cgImage!) let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage, options: imageOptions as? [String : AnyObject]) if let face = faces?.first as? CIFaceFeature &#123; print(&quot;found bounds are \(face.bounds)&quot;) var message = &quot;有个脸&quot; if face.hasSmile &#123; print(&quot;脸是笑的&quot;) message += &quot;,脸是笑的&quot; &#125; if face.hasMouthPosition &#123; print(&quot;有嘴唇&quot;) message += &quot;,有嘴唇&quot; &#125; if face.hasLeftEyePosition &#123; print(&quot;左眼镜的位置是 \(face.leftEyePosition)&quot;) message += &quot;,左眼镜的位置是 \(face.leftEyePosition)&quot; &#125; if face.hasRightEyePosition &#123; print(&quot;右眼镜的位置是 \(face.rightEyePosition)&quot;) message += &quot;,右眼镜的位置是 \(face.rightEyePosition)&quot; &#125; let alert = UIAlertController(title: &quot;嘿嘿&quot;, message: message, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; else &#123; let alert = UIAlertController(title: &quot;没脸了&quot;, message: &quot;没有检测到脸&quot;, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; &#125; 运行就可以识别照片的面部具体细节CIFaceFeature还提供了其他很多面部细节：1234567891011121314151617181920212223242526272829open var hasLeftEyePosition: Bool &#123; get &#125;open var leftEyePosition: CGPoint &#123; get &#125;open var hasRightEyePosition: Bool &#123; get &#125;open var rightEyePosition: CGPoint &#123; get &#125;open var hasMouthPosition: Bool &#123; get &#125;open var mouthPosition: CGPoint &#123; get &#125;open var hasTrackingID: Bool &#123; get &#125;open var trackingID: Int32 &#123; get &#125;open var hasTrackingFrameCount: Bool &#123; get &#125;open var trackingFrameCount: Int32 &#123; get &#125;open var hasFaceAngle: Bool &#123; get &#125;open var faceAngle: Float &#123; get &#125;open var hasSmile: Bool &#123; get &#125;open var leftEyeClosed: Bool &#123; get &#125;open var rightEyeClosed: Bool &#123; get &#125; 代码Detector 参考：Face Detection in iOS Using Core Image]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-21：Extensions]]></title>
    <url>%2F2017%2Fswift-21.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** Extensions 为一个已有的类、结构体、枚举类型或者协议类型添加新功能。 包括在没有权限获取原始源代码的情况下扩展类型的能力(即**逆向建模**) */// 扩展可以为一个类型添加新的功能，但是不能重写已有的功能。// 1 扩展语法(Extension Syntax)/** extension SomeType &#123; // 为 SomeType 添加的新功能写到这里 &#125; // 扩展一个已有类型，使其实现一些协议。 extension SomeType: SomeProtocol, AnotherProctocol &#123; // 协议实现写到这里 &#125; */// 如果你通过扩展为一个已有类型添加新功能，那么新功能对该类型的所有已有实例都是可用的，即使它们是在这个扩展定义之前创建的。// 2 计算型属性(Computed Properties)extension Double &#123; var km: Double &#123; return self * 1_000.0 &#125; var m : Double &#123; return self &#125; var cm: Double &#123; return self / 100.0 &#125; var mm: Double &#123; return self / 1_000.0 &#125; var ft: Double &#123; return self / 3.28084 &#125;&#125;let oneInch = 25.4.mm// 扩展可以添加新的计算型属性，但是不可以添加存储型属性，也不可以为已有属性添加属性观察器。// 3 构造器(Initializers)struct Size &#123; var width = 0.0, height = 0.0&#125;struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size()&#125;let defaultRect = Rect()let memberwiseRect = Rect(origin: Point(x: 2.0, y: 2.0), size: Size(width: 5.0, height: 5.0))extension Rect &#123; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125;let centerRect = Rect(center: Point(x: 4.0, y: 4.0), size: Size(width: 3.0, height: 3.0))// 4 方法(Methods)extension Int &#123; func repetitions(task: () -&gt; Void) &#123; // 将闭包中的任务执行整数对应的次数 for _ in 0..&lt;self &#123; task() &#125; &#125;&#125;5.repetitions(task: &#123; print(&quot;Hello!&quot;)&#125;)// 可变实例方法(Mutating Instance Methods)extension Int &#123; mutating func square() &#123; self = self * self &#125;&#125;var someInt = 3someInt.square() // 不能直接用字面量`3.square()`// 5 下标(Subscripts)extension Int &#123; subscript(digitIndex: Int) -&gt;Int &#123; var decimalBase = 1 for _ in 0..&lt;digitIndex &#123; decimalBase *= 10 &#125; return (self/decimalBase) % 10 &#125;&#125;12345678[2]// 6 嵌套类型(Nested Types)extension Int &#123; enum Kind &#123; case Negative, Zero, Positive &#125; var kind: Kind &#123; switch self &#123; case 0: return .Zero case let x where x &gt; 0: return .Positive default: return .Negative &#125; &#125;&#125;func printIntegerKinds(numbers: [Int]) &#123; for number in numbers &#123; switch number.kind &#123; case .Negative: print(&quot;- &quot;, terminator: &quot;&quot;) case .Zero: print(&quot;0 &quot;, terminator: &quot;&quot;) case .Positive: print(&quot;+ &quot;, terminator: &quot;&quot;) &#125; &#125; print(&quot;&quot;)&#125;printIntegerKinds(numbers: [3, 19, -27, 0, -6, 0, 7])]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 9 Table Row的删除, UITableViewRowAction和UIActivityViewController的使用]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-9.html</url>
    <content type="text"><![CDATA[上一篇开始用Swift开发iOS 10 - 8 Table View和UIAlertController的交互是Table Row选择的操作，这一篇继续上一篇的代码实现删除操作。 滑动删除 实现UITableViewDataSource中相应方法：123override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; &#125; 此时滑动有删除按钮： 删除数据123456789override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; restaurantNames.remove(at: indexPath.row) restaurantLocations.remove(at: indexPath.row) restaurantTypes.remove(at: indexPath.row) restaurantIsVisited.remove(at: indexPath.row) restaurantImages.remove(at: indexPath.row) &#125;&#125; UITableViewCellEditingStyle有两种insert和delete。运行后发现删除动作后，相应的table view row被没有消失，因为上面的删除只是删除了相应数组中的数据，并没有在视图上显示，如要重新加载才会删除。 重新加载UITableView在tableView(_:commit:forRowAt:)后添加：tableView.reloadData()另外，更好的刷新table view的方法是使用UITableView的deleteRows(at:with:)方法，还有动画效果：tableView.deleteRows(at: [indexPath], with: .fade) 用UITableViewRowAction为滑动产生更多动作1234567891011121314151617181920212223override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? &#123; // 1 let shareAction = UITableViewRowAction(style: .default, title: &quot;Share&quot;, handler: &#123; (action, indexPath) -&gt; Void in // 3 let defaultText = &quot;Just checking in at &quot; + self.restaurantNames[indexPath.row] let activityController = UIActivityViewController(activityItems: [defaultText], applicationActivities: nil) self.present(activityController, animated: true, completion: nil) &#125;) // 1 let deleteAction = UITableViewRowAction(style: .default, title: &quot;Delete&quot;, handler: &#123; (action, indexPath) -&gt; Void in self.restaurantNames.remove(at: indexPath.row) self.restaurantLocations.remove(at: indexPath.row) self.restaurantTypes.remove(at: indexPath.row) self.restaurantIsVisited.remove(at: indexPath.row) self.restaurantImages.remove(at: indexPath.row) &#125;) // 2 return [deleteAction, shareAction] &#125; 1 UITableViewRowAction的用法和UIAlertAction类似。style相同，具体功能是在回调闭包中实现的。 UIActivityViewController继承是UIViewController，提供一些服务，例如拷贝到剪贴板，分享内容到社交媒体，通过Messages发送项目等。 一旦实现了tableView(_:editActionsForRowAt:)方法，tableView(_:commit:forRowAt:)方法产生delete按钮将不再产生，所以要在tableView(_:commit:forRowAt:)中添加delete按钮。 2 返回的UITableViewRowAction的数组，action的显示顺序是，按照数组的顺序在屏幕从有到左显示。 3 defaultText是分享的内容，不仅可以是文本，也可以添加图片对象UIImage。此处代码修改一下：12345let defaultText = &quot;Just checking in at &quot; + self.restaurantNames[indexPath.row]if let imageToShare = UIImage(named: self.restaurantImages[indexPath.row]) &#123; let activityController = UIActivityViewController(activityItems: [defaultText, imageToShare], applicationActivities: nil) self.present(activityController, animated: true, completion: nil)&#125; 定制UITableViewRowAction可以修改背景颜色：1234shareAction.backgroundColor = UIColor(red: 48.0/255.0, green: 173.0/255.0, blue: 99.0/255.0, alpha: 1.0) deleteAction.backgroundColor = UIColor(red: 202.0/255.0, green: 202.0/255.0, blue: 203.0/255.0, alpha: 1.0) 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 8 Table View和UIAlertController的交互]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-8.html</url>
    <content type="text"><![CDATA[继续上一部分开始用Swift开发iOS 10 - 7 定制Table Views项目FoodPin的代码，添加两个功能： 点击cell时，产生弹框，弹框中有两个功能选项 Call 和 Check-in 当点击Check-in选项时，为cell加上对号 理解UITableViewDelegate协议代理模式在iOS编程中非常常见的。每个代理负责特定的角色或任务，维持系统的简单和干净。当一个对象需要完成特定任务时，可以依靠另一个对象完成。这在软件设计模式中通常叫做“separation of concerns”。UITableViewController就应用了代理模式。两个协议完成不同的任务。UITableViewDataSource协议负责提供和管理table的数据。UITableViewDelegate协议负责设置table的section headings 和 footers，以及操作cell selections和cell recording。 阅读文档 怎么知道UITableViewDelegate中有那些方法呢？ 阅读Apple的官方iOS开发文档(https://developer.apple.com/library/ios/))。作为iOS开发者，需要经常阅读API 文档。目前没有单个的书籍可覆盖所有iOS SDK。 Xcode中提供方便的查看文档的方法，在相关代码处option+点击，出现弹框展示文档简介，再在弹框上点击相关代码就直接进入详细文档处。文档对不同方法进行了分类，比如UITableViewDelegate的文档就有上面提到的Managing Selections：12func tableView(UITableView, willSelectRowAt: IndexPath)func tableView(UITableView, didSelectRowAt: IndexPath) 实现协议中管理列选项方法 在RestaurantTableViewController类中实现tableView(_:didSelectRowAt:)方法： 123456789101112override func tableView(_ tableView: UITableView, didSelectRowAt indexPath:IndexPath) &#123; // 1 let optionMenu = UIAlertController(title: nil, message: &quot;What do you wantto do?&quot;, preferredStyle: .actionSheet) // 2 let cancelAction = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler:nil) optionMenu.addAction(cancelAction) // 3 present(optionMenu, animated: true, completion: nil)&#125; 1 创建了UIAlertController。UIAlertController是从iOS8被引入，用来替代以前的UIAlertView和UIActionSheet，向用户弹出警示信息；preferredStyle参数有两个值：.actionSheet 和 .alert，表示替代的两种样式。 2 创建一个cancel样式的UIAlertAction。UIAlertController的警示弹出框一般是由最上面的title+message（都不是非必须的）和一些Action组成，cancel action在最下面。 3 present是UIViewController中的方法，用于展示。 添加Actions到ALert Controller中 Call action1234567891011let callActionHandler = &#123; (action:UIAlertAction!) -&gt; Void in let alertMessage = UIAlertController(title: &quot;Service Unavailable&quot;, message:&quot;Sorry, the call feature is not available yet. Please retry later.&quot;,preferredStyle: .alert) alertMessage.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler:nil)) self.present(alertMessage, animated: true, completion: nil)&#125;let callAction = UIAlertAction(title: &quot;Call &quot; + &quot;123-000-\(indexPath.row)&quot;,style: .default, handler: callActionHandler)optionMenu.addAction(callAction) callActionHandler是swift闭包结构的一种写法，关于闭包可查看以撸代码的形式学习Swift-7：Closure。这个代码块在Call action被点击是执行。 Check-in action12345678// Check-in actionlet checkInAction = UIAlertAction(title: &quot;Check in&quot;, style: .default, handler:&#123; (action:UIAlertAction!) -&gt; Void in let cell = tableView.cellForRow(at: indexPath) cell?.accessoryType = .checkmark&#125;)optionMenu.addAction(checkInAction) 当用户点击“Check in”action时，为选中的cell增加一个对号，表明是用户喜欢的。accessoryType包括disclosureIndicator, detailDisclosureButton, checkmark 和 detailButton。当cell被选中后，这个cell会一直灰色高亮。去掉：tableView.deselectRow(at: indexPath, animated: false) 解决Bug现在应用运行后，check-in某一cell时，可能会出现其他cell同时也被check-in。这个问题是因为cell重复使用导致的。当一个屏幕滚动时，新进的cell就会利用滚出的得cell，以提高效率。解决方法：为每个cell创造一个是否被check-in的标志。 在RestaurantTableViewController中创建一个Boolean类型的数组：var restaurantIsVisited = Array(repeating: false, count: 21) check-in后就把对应的标志修改为true： 1234567let checkInAction = UIAlertAction(title: &quot;Check in&quot;, style: .default, handler:&#123; (action:UIAlertAction!) -&gt; Void in let cell = tableView.cellForRow(at: indexPath) cell?.accessoryType = .checkmark self.restaurantIsVisited[indexPath.row] = true&#125; 在每一次生成cell是也要检查是否check-in，在tableView(_:cellForRowAt:)放的return cell之前加入：cell.accessoryType = restaurantIsVisited[indexPath.row] ? .checkmark : .none 练习当选中也被check-in的cell时，check-in Action的文本变成Undo Check in，点击后取消其对号。修一下check-in代码：123456789101112131415161718let cell = tableView.cellForRow(at: indexPath)if cell?.accessoryType == .checkmark &#123; let checkInAction = UIAlertAction(title: &quot;Undo Check in&quot;, style: .default, handler: &#123; (action:UIAlertAction!) -&gt; Void in cell?.accessoryType = .none self.restaurantIsVisited[indexPath.row] = false &#125;) optionMenu.addAction(checkInAction)&#125; else &#123; let checkInAction = UIAlertAction(title: &quot;Check in&quot;, style: .default, handler: &#123; (action:UIAlertAction!) -&gt; Void in cell?.accessoryType = .checkmark self.restaurantIsVisited[indexPath.row] = true &#125;) optionMenu.addAction(checkInAction)&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-20：Nested Types(嵌套类型)]]></title>
    <url>%2F2017%2Fswift-20.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** Nested Types 嵌套类型 */// 1 🌰struct BlackjackCard &#123; // 二十一点 // nested Suit enumeration enum Suit: Character &#123; // 描述扑克牌的四种花色 case spades = &quot;♠&quot;, hearts = &quot;♡&quot;, diamonds = &quot;♢&quot;, clubs = &quot;♣&quot; &#125; // nested Rank enumeration enum Rank: Int &#123; case two = 2, three, four, five, six, seven, eight, nine, ten case jack, queen, king, ace struct Values &#123; // 用来反映Ace的两个数值() let first: Int, second: Int? &#125; var values: Values &#123; switch self &#123; case .ace: return Values(first: 1, second: 11) case .jack, .queen, .king: return Values(first: 10, second: nil) default: return Values(first: self.rawValue, second: nil) &#125; &#125; &#125; // BlackjackCard properties and methods let rank: Rank, suit: Suit var description: String &#123; var output = &quot;suit is \(suit.rawValue),&quot; output += &quot; value is \(rank.values.first)&quot; if let second = rank.values.second &#123; output += &quot; or \(second)&quot; &#125; return output &#125;&#125;let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)print(&quot;theAceOfSpades: \(theAceOfSpades.description)&quot;)// 2 引用嵌套类型let heartsSymbol = BlackjackCard.Suit.hearts.rawValue]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 7 定制Table Views]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-7.html</url>
    <content type="text"><![CDATA[开始用Swift开发iOS 10 - 6 创建简单的Table Based App是basic风格的Table，这一部分将： 使用UITableViewController 代替 UITableView 展示table view cell中不同的图片显示方式 设计定制的table view cell来替代basic的table view cell 使用UITableViewController新建一个Table View App 新建项目FoodPin，模板为”Single View application” 删除Main.storyboard中的 view controller，删除ViewController.swift 拖动一个Table View Controller到IB中，选中其Is Initial View Controller 新建类RestaurantTableViewController，继承至UITableViewController。将Table View Controller的Class属性设置为RestaurantTableViewController。 在simpletable-image1.zip和simpletable-image2.zip处下载图片，拖到asset catalog 在类RestaurantTableViewController中添加以变量 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats&quot;,&quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;, &quot;Barrafina&quot;,&quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 在类RestaurantTableViewController中添加代码： 123456789override func tableView(_ tableView: UITableView, cellForRowAt indexPath:IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier,for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;)return cell &#125; 插入代码 123456789101112131415161718 override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;) return cell &#125; override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSectionsection: Int) -&gt; Int &#123; return restaurantNames.count &#125; 在类RestaurantTableViewController中加入图片名称变量： 123456var restaurantImages = [&quot;cafedeadend.jpg&quot;, &quot;homei.jpg&quot;, &quot;teakha.jpg&quot;,&quot;cafeloisl.jpg&quot;, &quot;petiteoyster.jpg&quot;, &quot;forkeerestaurant.jpg&quot;, &quot;posatelier.jpg&quot;,&quot;bourkestreetbakery.jpg&quot;, &quot;haighschocolate.jpg&quot;, &quot;palominoespresso.jpg&quot;,&quot;upstate.jpg&quot;, &quot;traif.jpg&quot;, &quot;grahamavenuemeats.jpg&quot;, &quot;wafflewolf.jpg&quot;,&quot;fiveleaves.jpg&quot;, &quot;cafelore.jpg&quot;, &quot;confessional.jpg&quot;, &quot;barrafina.jpg&quot;,&quot;donostia.jpg&quot;, &quot;royaloak.jpg&quot;, &quot;caskpubkitchen.jpg&quot;] 并修改对应代码：cell.imageView?.image = UIImage(named: restaurantImages[indexPath.row]) 定制Table View Cells 修改Table View Cell的Sytle变为Custom，Identifier为Cell 修改Table View 的Row Height为80 确认Table View Cell 的Custom被选择和Row Height为80 拖动image view到Cell中 拖动三个label到Cell中，文本分别是Name，Location，Type。Name 的font为Headline；Location的font style为Light，font size为14，font color为Dark Gray；Type**font style为Light，font size**为13。 把三个label设置成一个vertical stack view，其spacing为1 把vertical stack view和Image View设置成一个horizontal stack view，其spacing为10 为vertical stack view设置上下左右边距约束；为图片设置宽和高的约束 处理约束问题 为Custom Cell创建类 创建继承至UITableViewCell的类RestaurantTableViewCell 在RestaurantTableViewCell中建立四个outlet，分别对应图片和三个label 1234@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!@IBOutlet var thumbnailImageView: UIImageView! 建立代码中接口与storyboard之间的联系 修改Table View Controller代码 由于已经为Custom Cell创建了类RestaurantTableViewCell，所以Table View Controller中生成Cell的待修改为： 12let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell 由于Cell的风格不是sytle了，而是定制的，所以文本和图片代码要做出修改： 12cell.nameLabel.text = restaurantNames[indexPath.row]cell.thumbnailImageView.image = UIImage(named: restaurantImages[indexPath.row]) 图片圆角 可通过UIView的layer属性（CALayer）修改图片圆脚，cornerRadius表示圆角的半径，由于图片的尺寸是60*60，所以圆角的半径设置为30后，图片看上去是个圆。12cell.thumbnailImageView.layer.cornerRadius = 30.0cell.thumbnailImageView.clipsToBounds = true 练习 添加“Type”和“Location”。添加如下两个数组变量：1234var restaurantLocations = [&quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;NewYork&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;] var restaurantTypes = [&quot;Coffee &amp; Tea Shop&quot;, &quot;Cafe&quot;, &quot;Tea House&quot;, &quot;Austrian Causual Drink&quot;, &quot;French&quot;, &quot;Bakery&quot;, &quot;Bakery&quot;, &quot;Chocolate&quot;, &quot;Cafe&quot;, &quot;American Seafood&quot;, &quot;American&quot;, &quot;American&quot;, &quot;Breakfast &amp; Brunch&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Latin American&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;British&quot;, &quot;Thai&quot;] 然后再在Cell时赋值即可：12cell.locationLabel.text = restaurantLocations[indexPath.row] cell.typeLabel.text = restaurantTypes[indexPath.row] 重新设计界面： 修改Table View和Table View Cell的Row Height都为300。 重新设计图片与label的之间的层次结构，并修改图片的大小和其他一些约束。 删除图片圆角 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-19：Type Casting(类型转换)]]></title>
    <url>%2F2017%2Fswift-19.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift /** Type Casting(类型转换) `is` `as` */ // 1 定义一个类层次作为例子 class MediaItem { var name: String init(name: String) { self.name = name } } class Movie: MediaItem { var director: String init(name: String, director: String) { self.director = director super.init(name: name) } } class Song: MediaItem { var artist: String init(name: String, artist: String) { self.artist = artist super.init(name: name) } } let library = [ Movie(name: &quot;Casablanca&quot;, director: &quot;Michael Curtiz&quot;), Song(name: &quot;Blue Suede Shoes&quot;, artist: &quot;Elvis Presley&quot;), Movie(name: &quot;Citizen Kane&quot;, director: &quot;Orson Welles&quot;), Song(name: &quot;The One And Only&quot;, artist: &quot;Chesney Hawkes&quot;), Song(name: &quot;Never Gonna Give You Up&quot;, artist: &quot;Rick Astley&quot;) ] // 数组 library 的类型被推断为 [MediaItem] for v in library { // v 在此处是 MediaItem 类型 print(v.name) } // 2 检查类型(Checking Type) `is` var movieCount = 0 var songCount = 0 for item in library { if (item is Movie) { movieCount += 1 } else if (item is Song) { songCount += 1 } } // 3 向下转型(Downcasting) `as?` `as!` // 条件形式(conditional form) as? 返回一个你试图向下转成的类型的可选值(optional value) // 强制形式 as! 把试图向下转型和强制解包(force-unwraps)转换结果结合为一个操作。 for item in library { if let movie = item as? Movie { print(&quot;Movie: &apos;\(movie.name)&apos;, dir. \(movie.director)&quot;) } else if let song = item as? Song { print(&quot;Song: &apos;\(song.name)&apos;, by \(song.artist)&quot;) } } // 4 Any和AnyObject的类型转换 // AnyObject可以表示任何类类型的实例 // Any可以表示任何类型，包括函数类型]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode中Scene里的名称]]></title>
    <url>%2F2017%2Fxcode-scene-name.html</url>
    <content type="text"><![CDATA[默认的Scene名称 Xcode中新建一个控制器对象后会产生一个Scene，而Scene的名称就与其关联的控制器名称相关，比如默认的View Controller的对象的Scene的名称就是View Controller Scene。 如果把控制器改成SFSafariViewController，那么Scene的名字就会变成Safari View Scene。 如果把控制器改成自建的，Scene名字也会随着变化，比如ASAndyViewController对应的Scene名字是 Andy View Scene 总的来说，apple在程序中代码命名规范，一般是前面连续大写的是框架名称，然后后面使用驼峰命名法。要显示时就把框架前缀去掉，然后根据驼峰命名规则分隔显示。 自定义Scene的名称Scene的名称也是可以自定义的，在其属性检查器中，修改title即可，当然这种修改只是停留在IB中，为了开发时便于查看，不影响代码中的名称。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 1： 识别二维码（swift3）]]></title>
    <url>%2F2017%2Fios-tutorial-1-arcode.html</url>
    <content type="text"><![CDATA[这是一篇使用AVFoundation框架识别二维码的文章，原文提供了初始化项目QRCodeReaderStarter，我重新建立项目，图片是从原文提供的初始化项目中copy的。 初始化项目 新建一个名为QRCodeReader的单页项目 删除ViewController.swift文件，在项目目录处右击新建文件，新建一个QRCodeViewController类继承自UIViewController。 点击Main.storyboard，选中View Controller，修改其属性Class为QRCodeViewController，使两者关联。 向Main.storyboard中拖动一个View Controller对象，以1的方法新建一个继承自UIViewController的类QRScannerController，然后与Main.storyboard中新建的View Controller关联。 下载图片。从原文的初始化项目QRCodeReaderStarter复制。 修改Code View Controller Scene的view背景颜色做修改；添加一个label，名称改为Quick Scan，字体，和字体大小也做修改；添加button，删除文本，大小为150150，Type为System，image为focus*，Tint为黄色；添加一些约束。 Scanner Controller Scene： 在顶部添加一个View，在这个View中添加以label和button，button的image为cross；在顶部添加一个label；添加一些约束。 构建 segue 用control-drag从Code View Controller Scene中的button到Scanner Controller Scene，选择Present Modally 在QRCodeViewController中添加代码： 1234@IBAction func unwindToHomeScreen(segue: UIStoryboardSegue) &#123; //去除模态视图 dismiss(animated: true, completion: nil) &#125; 在Scanner Controller Scene 中，用control-drag从button到Exit，选择unwindToHomeScreenWithSegue: 6和7中样式和约束，合适即可。 加载 AVFoundation 框架 在QRScannerController.swift文件中引入AVFoundation Framework：import AVFoundation QRScannerController实现AVCaptureMetadataOutputObjectsDelegate协议：class QRScannerController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {表示当捕获的元数据产生时，需要一些回调方法。 QRScannerController中添加三个变量：123var captureSession: AVCaptureSession?var videoPreviewLayer: AVCaptureVideoPreviewLayer?var qrCodeFrameView: UIView? 实现视频捕获 在QRScannerController的viewDidLoad中添加代码： 123456789101112131415161718192021222324252627// 1let captureDevice = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)do &#123; // 2 let input = try AVCaptureDeviceInput(device: captureDevice) // 3 captureSession = AVCaptureSession() // 4 captureSession?.addInput(input) // 5 let captureMetadataOutput = AVCaptureMetadataOutput() captureSession?.addOutput(captureMetadataOutput) // 6 captureMetadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main) captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode] videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession) videoPreviewLayer?.videoGravity = AVLayerVideoGravityResizeAspectFill videoPreviewLayer?.frame = view.layer.bounds view.layer.addSublayer(videoPreviewLayer!) captureSession?.startRunning()&#125; catch &#123; print(error) return&#125; 1 初始化AVCaptureDevice，它表示物理捕获设备；AVMediaTypeVideo是Media types，表示视频类型，还有AVMediaTypeAudio，AVMediaTypeText等其他类型 2 根据AVCaptureDevice初始化捕获设备的输入数据对象AVCaptureDeviceInput。这边的try是swift中错误处理的标识，对应public init(device: AVCaptureDevice!) throws。 3 AVCaptureSession 用于协调输入与输出之间的数据流。 4 为AVCaptureSession 添加输入数据 5 定义输出数据对象AVCaptureMetaDataOutput，并把它添加给AVCaptureSession 6 设置self为输出数据对象的代理，这就对应了QRScannerController类实现AVCaptureMetadataOutputObjectsDelegate协议。metadataObjectTypes是识别的元数据类型，AVMetadataObjectTypeQRCode表示二维码类型。 在Info.plist中添加key为NSCameraUsageDescription或”Privacy – Camera Usage Description”，值为 为了扫描二维码，需要使用你的相机。 运行应用时，点击scan button后，使用了相机，但messageLabel和tapbar没有了，因为被AVCaptureVideoPreviewLayer覆盖了，加入两行代码就可以显示了：12view.bringSubview(toFront: messageLabel)view.bringSubview(toFront: topbar) 实现二维码读取当检测到二维码时，用绿色框高亮；然后二维码被解码成文本信息展示在messagelabel中。 初始化绿色框。继续在上述代码后添加:12345678qrCodeFrameView = UIView() if let qrCodeFrameView = qrCodeFrameView &#123; qrCodeFrameView.layer.borderColor = UIColor.green.cgColor qrCodeFrameView.layer.borderWidth = 2 view.addSubview(qrCodeFrameView) view.bringSubview(toFront: qrCodeFrameView)&#125; 由于qrCodeFrameView没有设置大小，默认是0，所以不会显示，当之后发现二维码时再让它显示。 解码二维码当AVCaptureMetadataOutput识别出二维码时，AVCaptureMetadataOutputObjectsDelegate中的代理方法将被调用：optional public func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) 回调方法定义： func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) { if metadataObjects == nil || metadataObjects.count == 0 { qrCodeFrameView?.frame = CGRect.zero messageLabel.text = &quot;没有二维码/条形码&quot; return } let metadataObj = metadataObjects[0] as! AVMetadataMachineReadableCodeObject if metadataObj.type == AVMetadataObjectTypeQRCode { // 1 let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil { // 2 messageLabel.text = metadataObj.stringValue } } } 第二个参数metadataObjects是个数组，就是所有被识别出来的元数据对象。如果这个参数为nil或数组为空数组，就表示没有识别出对象。 1 通过transformedMetadataObject方法获得AVMetadataObject对象，更加这个对象可以获得二维码的位置，然后显示绿框。 2 把二维码信息显示在messagelabel上。 识别条形码除了识别二维码以外，还可以识别条形码。只要在captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode]添加更多的元数据类型。，然后回调方法中修改检测类型就可以。 123456789101112131415161718192021222324let supportedCodeTypes = [AVMetadataObjectTypeUPCECode, AVMetadataObjectTypeCode39Code, AVMetadataObjectTypeCode39Mod43Code, AVMetadataObjectTypeCode93Code, AVMetadataObjectTypeCode128Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeAztecCode, AVMetadataObjectTypePDF417Code, AVMetadataObjectTypeQRCode ]captureMetadataOutput.metadataObjectTypes = supportedCodeTypes// ....if supportedCodeTypes.contains(metadataObj.type) &#123; let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil &#123; messageLabel.text = metadataObj.stringValue &#125;&#125; 代码QRCodeReader]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 6 创建简单的Table Based App]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-6.html</url>
    <content type="text"><![CDATA[table view应该是iOS应用中最常用的UI element。最好的例子就是iPhone自带的一些应用，如电话，邮件，设置等。TED，Google+，Airbnb，微信等等都是很好例子。 创建一个项目 项目名称为SimpleTable，模板为”Single View application” 设计UI 选中Main.storyboard，从Object library中拖动Table View进入视图 改变Table View的大小至整个view，修改属性Prototype Cells为1 选中Table View Cell，修改Style为Basic，Identifier为Cell。table view cell的标准类型有 basic、right detail、left detail 和 subtitle，当然还有定制类型custom。 选中Table View，设置四个spacing约束，上下左右的距离都设置为0 为UITableView添加两个协议 Object library中的每一UI component都是对应一个class，如 Table View就是对应UITableView。可以通过点击并悬停在UI component上查看对应的class和介绍。 在ViewController.swift文件的UIViewController后，添加代码, UITableViewDataSource, UITableViewDelegate，表示ViewController类实现了UITableViewDataSource，UITableViewDelegate两个协议。出现红色感叹号，这是xcode的问题提示，点击参看问题描述： Type ‘ViewController’ does not conform to protocol‘UITableViewDataSource’ 问题描述为ViewController不符合协议UITableViewDataSource。通过command+点击 （最新的xcode9变成了command+option+点击）到UITableViewDataSource中看看你：1234567891011121314151617181920212223242526272829303132public protocol UITableViewDataSource : NSObjectProtocol &#123; @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int // Row display. Implementers should *always* try to reuse cells by setting each cell&apos;s reuseIdentifier and querying for available reusable cells with dequeueReusableCellWithIdentifier: // Cell gets various attributes set automatically based on table (separators) and data source (accessory views, editing controls) @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell @available(iOS 2.0, *) optional public func numberOfSections(in tableView: UITableView) -&gt; Int // Default is 1 if not implemented @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? // fixed font style. use custom view (UILabel) if you want something different @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? // Editing // Individual rows can opt out of having the -editing property set for them. If not implemented, all rows are assumed to be editable. @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool ... UITableViewDataSource协议中定义了很多方法，除了前两个方法没有optional其它都有，有的表示这个方法不一定要实现，没有的就一定要实现，把这个两个方法实现了，问题提示就会消失。这两个方法从名字和返回值类型也大概能知道做了什么： public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int 一个section有几行，也就是一个section有几个UITableViewCell， section就是一组UITableViewCell的意思，Table View可以定义多个section，默认是一个。 public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell 返回每一行的 UITableViewCell 在ViewController.swift中定义一个变量restaurantNames，类型是数组，表示一系列餐馆的名字。 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats AndDeli&quot;, &quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;,&quot;Barrafina&quot;, &quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 定义UITableViewDataSource的两个方法： 12345678910111213141516func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // 1 return restaurantNames.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 2 let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // 3 cell.textLabel?.text = restaurantNames[indexPath.row] return cell &#125; 1 餐馆的数目就是section的行数 2 “Cell”与之前定义的UITableViewCell的Identifier属性是对应的。dequeueReusableCell方法是产生一个UITableViewCell。 3 UITableViewCell中有可算属性textLabel，其实就是一个UILabel，由于是可选属性，调用时也用可选链式调用cell.textLabel?.text 连接 DataSource 和 Delegate运行app，没有数据显示。尽管上面已经在代码中让ViewController继承了UITableViewDataSource, UITableViewDelegate，但storyboard并不知道。 在document outline中选择Table View，使用control-drag到View Controller，在弹出框中选择dataSource。同样的方法选择delegate 确认连接是否成功。选中Table View，在connetion检查器中查看；或者直接在document outline中右击Table View 运行app 添加图片到Table View 从simpletable-image1.zip下载图片，解压后一起拖到asset catalog 在ViewController.swift的tableView(_:cellForRowAtIndexPath:)方法的return cell前添加代码cell.imageView?.image = UIImage(named: &quot;restaurant&quot;)。使每个UITableViewCell的image都是一样的。 隐藏状态栏顶部状态来和table view 数据重叠了，只要在ViewController加一段代码就可以：123override var prefersStatusBarHidden: Bool &#123; return true&#125; prefersStatusBarHidden是父类UIViewController中的属性，所以要加 override，表示重写了。 不同的Cell对应不同的图片 从simpletable-image2.zip下载图片，解压后一起拖到asset catalog 修改ViewController.swift的tableView(_:cellForRowAtIndexPath:)为： 12345678910111213141516171819func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // Configure the cell... let restaurantName = restaurantNames[indexPath.row] cell.textLabel?.text = restaurantName // 1 let imageName = restaurantName.lowercased().replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;) if let image = UIImage(named: imageName) &#123; cell.imageView?.image = image &#125; else &#123; cell.imageView?.image = UIImage(named: &quot;restaurant&quot;) &#125; return cell &#125; 1 把菜馆名字字符串先修改成小写，然后去空格 最终结果 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS应用程序的状态]]></title>
    <url>%2F2017%2Fios-application-status.html</url>
    <content type="text"><![CDATA[iOS应用程序一共有五种状态： Not Running 程序还没运行 Inactive 程序运行在foreground但没有接收事件 Active 程序运行在foreground接收事件 Background 程序运行在background正在执行代码 Suspended 程序运行在background没有执行代码 iOS应用程序状态变化会回调APPDelegate中的方法，但不是每一种状态变化都会有对应的方法(上图的红框的两个变化就没有对应的方法) application:didFinishLaunchingWithOptions: Not Running -&gt; Inactive applicationDidBecomeActive: Inactive -&gt; Active applicationWillResignActive: Active -&gt; Inactive applicationDidEnterBackground: Background -&gt; Suspended applicationWillEnterForeground: Background -&gt; Inactive applicationWillTerminate: Suspended -&gt; Not Running 常见的应用状态变化场景 程序第一次启动（或者被杀掉以后启动）： Not Running -&gt; Inactive -&gt; Active 点击Home键（没有在Inof.plist中设置Application does not run in background）： Active -&gt; Inactive -&gt; Background -&gt; Suspended 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 挂起重新运行 Suspended -&gt; Background -&gt; Inactive -&gt; Active 内存清除（杀掉应用或删除应用） Suspended -&gt; Not Running 应用之间的切换 Active -&gt; Inactive Inactive -&gt; Active 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 可通过在APPDelegate的回调方法中打印数据，来查看应用状态变化 123456789101112131415161718192021222324252627282930func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; print(&quot;`application:didFinishLaunchingWithOptions:` Not Running -&gt; Inactive&quot;) return true&#125;func applicationWillResignActive(_ application: UIApplication) &#123; print(&quot;`applicationWillResignActive:` Active -&gt; Inactive&quot;)&#125;func applicationDidEnterBackground(_ application: UIApplication) &#123; print(&quot;`applicationDidEnterBackground:` Background -&gt; Suspended&quot;)&#125;func applicationWillEnterForeground(_ application: UIApplication) &#123; print(&quot;`applicationWillEnterForeground:` Background -&gt; Inactive&quot;)&#125;func applicationDidBecomeActive(_ application: UIApplication) &#123; print(&quot;`applicationDidBecomeActive:` Inactive -&gt; Active&quot;)&#125;func applicationWillTerminate(_ application: UIApplication) &#123; print(&quot;`applicationWillTerminate:` Suspended -&gt; Not Running&quot;)&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-18：Error Handling]]></title>
    <url>%2F2017%2Fswift-18.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** Error Handling 错误处理(Error handling)是响应错误以及从错误中恢复的过程。 */// 1 表示并抛出错误// `Error`空协议表明该类型可以用于错误处理enum VendingMachineError: Error &#123; case InvalidSelection //选择无效 case InsufficientFunds(coinsNeeded: Int) //金额不足 case OutOfStock //缺货&#125;throw VendingMachineError.InsufficientFunds(coinsNeeded: 5)// 2 处理错误// 为了标识出代码中可能会抛出错误的地方，在调用一个能抛出错误的函数、方法或者构造器之前，加上 try 关键字，或者 try? 或 try!这种变体。// 四个处理错误的方式:// 1) 用throwing函数传递错误/* **throwing函数**: 在函数声明的参数列表之后加上 throws 关键字，为了表示一个函数、方法或构造器可以抛出错误。 func canThrowErrors() throws -&gt; String func cannotThrowErrors() -&gt; String 一个 throwing 函数可以在其内部抛出错误，并将错误传递到函数被调用时的作用域。 只有 throwing 函数可以传递错误。任何在某个非throwing函数内部抛出的错误只能在函数内部处理。 */struct Item &#123; var price: Int var count: Int&#125;class VendingMachine &#123; var inventory = [ &quot;Candy Bar&quot;: Item(price: 12, count: 7), &quot;Chips&quot;: Item(price: 10, count: 4), &quot;Pretzels&quot;: Item(price: 7, count: 11) ] var coinsDeposited = 0 func dispenseSnack(snack: String) &#123; print(&quot;Dispensing \(snack)&quot;) &#125; func vend(itemNamed name: String) throws &#123; guard let item = inventory[name] else &#123; throw VendingMachineError.InvalidSelection &#125; guard item.count &gt; 0 else &#123; throw VendingMachineError.OutOfStock &#125; guard item.price &lt;= coinsDeposited else &#123; throw VendingMachineError.InsufficientFunds(coinsNeeded: item.price - coinsDeposited) &#125; coinsDeposited -= item.price var newItem = item newItem.count -= 1 inventory[name] = newItem dispenseSnack(snack: name) &#125;&#125;let favoriteSnacks = [ &quot;Alice&quot;: &quot;Chips&quot;, &quot;Bob&quot;: &quot;Licorice&quot;, &quot;Eve&quot;: &quot;Pretzels&quot;,]func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws &#123; let snackName = favoriteSnacks[person] ?? &quot;Candy Bar&quot; try vendingMachine.vend(itemNamed: snackName)&#125;// throwing构造器能像throwing函数一样传递错误。struct PurchasedSnack &#123; let name: String init(name: String, vendingMachine: VendingMachine) throws &#123; try vendingMachine.vend(itemNamed: name) self.name = name &#125;&#125;// 2) 用 Do-Catch 处理错误var vendingMachine = VendingMachine()vendingMachine.coinsDeposited = 8do &#123; try buyFavoriteSnack(person: &quot;Alice&quot;, vendingMachine: vendingMachine)&#125; catch VendingMachineError.InvalidSelection &#123; print(&quot;Invalid Selection.&quot;)&#125; catch VendingMachineError.OutOfStock &#123; print(&quot;Out of Stock.&quot;)&#125; catch VendingMachineError.InsufficientFunds(let coinsNeeded) &#123; print(&quot;Insufficient funds. Please insert an additional \(coinsNeeded) coins.&quot;)&#125;// 打印 “Insufficient funds. Please insert an additional 2 coins.”// 3) 将错误转换成可选值// 如果 someThrowingFunction() 抛出一个错误， x 和 y 的值是 nil，否则 x 和 y 的值就是该函数的返回值。// 无论 someThrowingFunction() 的返回值类型是什么类型， x 和 y 都是这个类型的可选类型。// x，y的两种形式类似，try? 更简洁。func someThrowingFunction() throws -&gt; Int &#123; // ... return 0&#125;let x = try? someThrowingFunction()let y: Int?do &#123; y = try someThrowingFunction()&#125; catch &#123; y = nil&#125;// 4) 禁用错误传递// try! 禁止错误传递，如真有错误抛出，就出现运行错误。//let photo = try! loadImage(&quot;./Resources/John Appleseed.jpg&quot;)// 3 指定清理操作]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 4 用Stack View设计UI]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-4.html</url>
    <content type="text"><![CDATA[前一篇开始用Swift开发iOS 10 - 3 介绍Auto Layout中提到Auto Layout工具栏有个stack按钮，这是Stack View功能。为了解决复杂UI时布局约束定义困难，Apple从iOS 9开始引入Stack View。这篇文章将学习到： 用Stack View布局UI。 用image views展示图片。 用内建的asset catalog管理图片。 用Size Classes适配Stack View Stack View是什么Stack View为在纵向或横向布置一个视图的集合，提供了一个流线型界面。可以用stack view将很多UI对象合成一个。视图嵌入一个stack view里以后,就不再需要定义自动布局约束. Stack View管理它子视图的布局,然后自动提供布局约束。这意味着子视图已经准备好去适应不同的屏幕尺寸。此外，也可以嵌入一个stack view到另一个stack view来构建更复杂的用户界面。但是，这并不意味着不需要处理自动布局。仍然需要定义stack view的布局。这样不仅能够节约在创作每个UI元素的约束的时间，也可以轻松的从布局里来添加/移除视图。 Xcode提供两种方法使用Stack View： 直接从Object library中拖出stack view（纵向或横向），然后把其他视图拖动stack view 选中一些视图，然后点击Interface Builder editor右下角一组按钮中的stack按钮 一个小程序 新建项目 StackViewDemo 向Xcode中添加图片 从图片下载所需图片，加压后有3组9张图片，每组有3张不同类型的图片，针对不同类型的设备： user1.png （ non-Retina的一些老设备） user1@2x.png （iPhone 4/4s/5/5s/6） user1@3x.png （iPhone 6 Plus等高分辨的） 拖动图片竟然xcode的asset catalog中，xcode会自动组织这些有规律的图片，使用时直接用user1,不需要靠后面的@2或@3。 用Stack View布局title的label 选择Main.storyboard，从Object library中拖出Vertical Stack View到storyboard中 拖出一个label到stack view中。一旦label进入stack view中，它就自动调整大小以适应label 修改label的title为“Instant Developer”，字体大小为40 points，font style为medium，字体颜色为红色 另外拖出一个label到stack view中，修改label的title为“Get help from experts in 15 minutes” 选择stack view，在属性检查器中修改Alignment参数为center，这样使stack view中的label水平居中对齐。 多个视图在一起不方便选择时，可以用 shift + 右击：stack view的几个属性： axis stack view中对象是水平放置还是垂直放置，也就是Vertical Stack View和Horizontal Stack View之间的切换 alignment stack view中对象的对齐方式 distribution 用Stack按钮布局多个图片 拖动一个image view对象，并修改其image属性为user1 同样的方法再添加两个image view对象，image属性分别为user2，user3。粗略调整图片的带下，放在一个水平，大概如下： 选中三个image view，击Interface Builder editor右下角一组按钮中的stack按钮，则生成一个新的horizontal stack view。 修改新生成的horizontal stack view的属性，spacing为 10，表示图片之间的间距，Distribution为Fill Equally 同时选中两个stack view，点击stack 按钮，再生成一个新的大vertical stack view 为stack view添加布局约束 选中大的stack view，添加space constraints，上，左右，分别为70，0，0添加约束后，如果出现布局问题，可通过issue indicator解决，可参考上一篇文章。 看预览assistant editor，查看其它设备会发现两个问题： Instant Developer label文本在小屏幕设备被截断 图片的宽高比改变了 选择Instant Developer label，修改Autoshrink属性为Minimum Font Size，值为20，这样就设置了label的字体可以变化，最小值为20 ，小屏幕就不会被截断了。 横向control-drag图片的stack view，选择Aspect Ratio，使图片的宽高比不变化。 在图片stack view下添加一个label 拖动一个label到图片下，看到一个蓝色线后松开 改变label的文本：Need help with your coding problems? We’ll find you the right developer who can help you in 15 minutes. label的属性lines改为0，表示不限制行数 选择大stack view，修改间距sapcing为10，修改Alignment为居中 用stack view布局Buttons 添加两个Button：”Sign in” 和 “Sign up with Facebook” 修改白字体，红背景，宽度为200 选择两个Button生成vertical stack view，spacing为10 为vertical stack view添加两个约束，水平居中和底边距20 当把两个button聚合成stack view时，button的大小会自动调节到适宜大小，也就是”Sign up with Facebook”的宽度变为155 。需要再添加一个宽度约束，修改Constant值为200 。 用Size Classes来调节Stack view landscape orientation vs portrait orientation直译就是风景画方向和肖像画方向，其实就是指横屏和竖屏 上面设计的UI看上去以不错了，但一直没有考虑的横屏的情况。因为横屏上下高度变小，原本在竖屏下适宜的stack view上边距，就有点大了，需要小一点。这也导致了，从iOS 8开始引入了一个新的UI设计概念Adaptive Layout（自适应布局），为此，Apple引入了Size Classes。通过Size Classes 和 auto layout一起设计自适应UI。Size Classes仅仅是对屏幕进行了分类, 实际上的布局还是交给autolayout Size Classes有两种类型：regular 和 compact（可以理解为大[R] 和 小[C]）。而这两种类型应用在两个方向上：vertical (height) 和 horizontal (width) ，就对应不同类型的设备：Regular width-Regular Height, Regular width-Compact Height, Compact width-Regular Height and Compact width-Compact Height 最新版本的Xcode已经为我们提供了不同设备和方向的Size Classes查看： 选择上边距约束。在属性检查器中，点击Constant前面的+号，弹框中分别选择：Width：Any，Height：Compact，Gamunt：Any，后面的值为0，表示只有在Compact height下上边距为0 为了更加简洁也可以在有些屏幕状态下把”Need help with your …” label隐藏掉，就是height为0。也就是为label添加一个只有在Width：Any，Height：Compact，Gamunt：Any这个Size Classes下，的height约束。用control-drag方法添加height约束： 选择现价的height约束，修改Constant为0；去除选中Installed，点击Installed前的+，弹出框选择Width：Any，Height：Compact，Gamunt：Any，并选择新加的Installed（height约束颜色变浅了，说明这个约束不是在任何状态下都有效的）： 练习还有考虑特殊的一些设备的情况，添加一些特殊的约束： 在wR hR时，修改两个按钮的宽度为300 在iphone 6/7 和一些老的iphone等设备竖屏时，修改”Need help with …” label 字体为15 在wR hR时，修改图像stack view的上下空间为30 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-17：Optional Chaining]]></title>
    <url>%2F2017%2Fswift-17.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** Optional Chaining 可选链式调用 一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法 */// 1 使用可选链式调用代替强制展开// 可选链式调用的返回结果与原本的返回结果具有相同的类型，但是被包装成了一个可选值。class Person &#123; var residence: Residence?&#125;class Residence &#123; var numberOfRooms = 1&#125;let john = Person()if let roomCount = john.residence?.numberOfRooms &#123; print(&quot;John&apos;s residence has \(roomCount) room(s).&quot;)&#125; else &#123; print(&quot;Unable to retrieve the number of rooms.&quot;)&#125;john.residence = Residence()if let roomCount = john.residence?.numberOfRooms &#123; print(&quot;John&apos;s residence has \(roomCount) room(s).&quot;)&#125; else &#123; print(&quot;Unable to retrieve the number of rooms.&quot;)&#125;// 2 为可选链式调用定义模型类class Person2 &#123; var residence: Residence2?&#125;class Residence2 &#123; var rooms = [Room]() var numberOfRooms: Int &#123; return rooms.count &#125; subscript(i: Int) -&gt; Room &#123; get &#123; return rooms[i] &#125; set &#123; rooms[i] = newValue &#125; &#125; func printNumberOfRooms() &#123; print(&quot;The number of rooms is \(numberOfRooms)&quot;) &#125; var address: Address?&#125;class Room &#123; let name: String init(name: String) &#123; self.name = name &#125;&#125;class Address &#123; var buildingName: String? var buildingNumber: String? var street: String? func buildingIdentifier() -&gt; String? &#123; if buildingName != nil &#123; return buildingName &#125; else if buildingNumber != nil &amp;&amp; street != nil &#123; return &quot;\(buildingNumber) \(street)&quot; &#125; else &#123; return nil &#125; &#125;&#125;func createAddress() -&gt; Address &#123; print(&quot;Function was called.&quot;) let someAddress = Address() someAddress.buildingNumber = &quot;29&quot; someAddress.street = &quot;Acacia Road&quot; return someAddress&#125;// 3 通过可选链式调用访问属性let andy = Person2()andy.residence?.address = createAddress() // andy.residence结果为nil，可选链式调用失败时，等号右侧的代码不会被执行。// 4 通过可选链式调用调用方法if let firstRoomName = andy.residence?[0].name &#123; print(&quot;The first room name is \(firstRoomName).&quot;)&#125; else &#123; print(&quot;Unable to retrieve the first room name.&quot;)&#125;let andyHouse = Residence2()andyHouse.rooms.append(Room(name: &quot;Living Room&quot;))andyHouse.rooms.append(Room(name: &quot;Kitchen&quot;))andy.residence = andyHouseif let firstRoomName = andy.residence?[0].name &#123; print(&quot;The first room name is \(firstRoomName).&quot;)&#125; else &#123; print(&quot;Unable to retrieve the first room name.&quot;)&#125;// 5 访问可选类型的下标var testScores = [&quot;Dave&quot;: [86, 82, 84], &quot;Bev&quot;: [79, 94, 81]]testScores[&quot;Dave&quot;]?[0] = 91testScores[&quot;Bev&quot;]?[0] += 1testScores[&quot;Brian&quot;]?[0] = 72// 6 连接多层可选链式调用if let andyStreet = andy.residence?.address?.street &#123; print(&quot;John&apos;s street name is \(andyStreet).&quot;)&#125; else &#123; print(&quot;Unable to retrieve the address.&quot;)&#125;let andyAddress = Address()andyAddress.buildingName = &quot;东方明珠&quot;andyAddress.street = &quot;南京东路100号&quot;andy.residence?.address = andyAddressif let andyStreet = andy.residence?.address?.street &#123; print(&quot;John&apos;s street name is \(andyStreet).&quot;)&#125; else &#123; print(&quot;Unable to retrieve the address.&quot;)&#125;// 7 在方法的可选返回值上进行可选链式调用if let buildingIdentifier = andy.residence?.address?.buildingIdentifier() &#123; print(&quot;John&apos;s building identifier is \(buildingIdentifier).&quot;)&#125;if let beginsWithThe = andy.residence?.address?.buildingIdentifier()?.hasPrefix(&quot;东&quot;) &#123; if beginsWithThe &#123; print(&quot;John&apos;s building identifier begins with \&quot;东\&quot;.&quot;) &#125; else &#123; print(&quot;John&apos;s building identifier does not begin with \&quot;东\&quot;.&quot;) &#125;&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-16：Automatic Reference Counting]]></title>
    <url>%2F2017%2Fswift-16.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** Automatic Reference Counting(ARC) 引用计数仅仅应用于类的实例 */// 1 自动引用计数的工作机制// 每次创建一个类的新的实例的时候，ARC会分配一块内存来储存该实例信息(包含实例的类型信息，以及这个实例所有相关的存储型属性的值)。// ARC会跟踪和计算每一个实例正在被多少属性，常量和变量所引用。// 引用数为0时，内存释放。// 2 🌰class Person &#123; let name: String init(name: String) &#123; self.name = name print(&quot;\(name) is being initialized&quot;) &#125; deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;&#125;var reference1: Person?var reference2: Person?var reference3: Person?reference1 = Person(name: &quot;John Appleseed&quot;)reference2 = reference1reference3 = reference1reference1 = nilreference2 = nilreference3 = nil// 3 类实例之间的循环强引用class Person2 &#123; let name: String init(name: String) &#123; self.name = name &#125; var apartment: Apartment2? deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;&#125;class Apartment2 &#123; let unit: String init(unit: String) &#123; self.unit = unit &#125; var tenant: Person2? deinit &#123; print(&quot;Apartment \(unit) is being deinitialized&quot;) &#125;&#125;var andy: Person2?var unit4A: Apartment2?andy = Person2(name: &quot;Andy Ron&quot;)unit4A = Apartment2(unit: &quot;4A&quot;)andy!.apartment = unit4Aunit4A!.tenant = andyandy = nilunit4A = nil// john和unit4A两个变量虽然已经被赋值为nil，但之前它们引用两个实例之间的强引用关系保留了下来并且不会被断开// 4 解决实例之间的循环强引用// 弱引用(weak reference)和无主引用(unowned reference)允许循环引用中的一个实例引用另外一个实例而不保持强引用。// 4.1 弱引用:弱引用必须被声明为变量，表明其值能在运行时被修改。`weak`class Person3 &#123; let name: String init(name: String) &#123; self.name = name &#125; var apartment: Apartment3? deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;&#125;class Apartment3 &#123; let unit: String init(unit: String) &#123; self.unit = unit &#125; weak var tenant: Person3? deinit &#123; print(&quot;Apartment \(unit) is being deinitialized&quot;) &#125;&#125;var andy3: Person3?var unit5A: Apartment3?andy3 = Person3(name: &quot;Andy Ron3&quot;)unit5A = Apartment3(unit: &quot;5A&quot;)andy3!.apartment = unit5Aunit5A!.tenant = andy3andy3 = nil // Person3的实例被销毁，虽然tenant还引用它，但因为时弱引用在ARC计数范围内。unit5A = nil// 4.2 无主引用 `unowned`// 和弱引用不同的是，无主引用是永远有值的。// Customer是客户，CreditCard是信用卡。客户可以有或五信用卡，但信用卡必须有对应的用户。class Customer &#123; let name: String var card: CreditCard? init(name: String) &#123; self.name = name &#125; deinit &#123; print(&quot;\(name) is being deinitialized&quot;) &#125;&#125;class CreditCard &#123; let number: UInt64 unowned let customer: Customer init(number: UInt64, customer: Customer) &#123; self.number = number self.customer = customer &#125; deinit &#123; print(&quot;Card #\(number) is being deinitialized&quot;) &#125;&#125;var john: Customer?john = Customer(name: &quot;John Appleseed&quot;)john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)john = nil // 客户被销毁，对应的信用卡也要被销毁。// 打印 “John Appleseed is being deinitialized”// 打印 ”Card #1234567890123456 is being deinitialized”// 4.3 无主引用以及隐式解析可选属性 ？？class Country &#123; let name: String var capitalCity: City! init(name: String, capitalName: String) &#123; self.name = name self.capitalCity = City(name: capitalName, country: self) &#125;&#125;class City &#123; let name: String unowned let country: Country init(name: String, country: Country) &#123; self.name = name self.country = country &#125;&#125;var country = Country(name: &quot;Canada&quot;, capitalName: &quot;Ottawa&quot;)print(&quot;\(country.name)&apos;s capital city is called \(country.capitalCity.name)&quot;)]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-15：(类的)Deinitialization]]></title>
    <url>%2F2017%2Fswift-15.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** (类的)Deinitialization */// 1 析构过程原理// 每个类最多只能有一个析构器，而且析构器不带任何参数// 析构器是在实例释放发生前被自动调用。不能主动调用析构器。// 子类继承了父类的析构器，并且在子类析构器实现的最后，父类的析构器会被自动调用。// 2 析构器实践class Bank &#123; static var coinsInBank = 10_000 static func vendCoins(numberOfCoinsRequested: Int) -&gt; Int &#123; let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank) coinsInBank -= numberOfCoinsToVend return numberOfCoinsToVend &#125; static func receiveCoins(coins: Int) &#123; coinsInBank += coins &#125;&#125;class Player &#123; var coinsInPurse: Int init(coins: Int) &#123; coinsInPurse = Bank.vendCoins(numberOfCoinsRequested: coins) &#125; func winCoins(coins: Int) &#123; coinsInPurse += Bank.vendCoins(numberOfCoinsRequested: coins) &#125; deinit &#123; Bank.receiveCoins(coins: coinsInPurse) &#125;&#125;var playerOne: Player? = Player(coins: 100)print(&quot;A new player has joined the game with \(playerOne!.coinsInPurse) coins&quot;)print(&quot;There are now \(Bank.coinsInBank) coins left in the bank&quot;)playerOne!.winCoins(coins: 2_000)print(&quot;PlayerOne won 2000 coins &amp; now has \(playerOne!.coinsInPurse) coins&quot;)print(&quot;The bank now only has \(Bank.coinsInBank) coins left&quot;)playerOne = nilprint(&quot;PlayerOne has left the game&quot;)print(&quot;The bank now has \(Bank.coinsInBank) coins&quot;)]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-14：Initialization]]></title>
    <url>%2F2017%2Fswift-14.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283/** Initialization */// 构造过程是使用类、结构体或枚举类型的实例之前的准备过程// 通过定义构造器( Initializers )来实现构造过程// 1 存储属性的初始赋值// 类和结构体在创建实例时，必须为所有存储型属性设置合适的初始值。// 当你为存储型属性设置默认值或者在构造器中为其赋值时，它们的值是被直接设置的，不会触发任何属性观察者。// 2 自定义构造过程struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125;&#125;let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)// boilingPointOfWater.temperatureInCelsius 是 100.0let freezingPointOfWater = Celsius(fromKelvin: 273.15)// freezingPointOfWater.temperatureInCelsius 是 0.0struct Color &#123; let red, green, blue: Double init(red: Double, green: Double, blue: Double) &#123; self.red = red self.green = green self.blue = blue &#125; init(white: Double) &#123; red = white green = white blue = white &#125;&#125;let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)let halfGray = Color(white: 0.5)// 不带外部名的构造器参数struct Celsius2 &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125; init(_ celsius: Double)&#123; temperatureInCelsius = celsius &#125;&#125;// 可选属性类型class SurveyQuestion &#123; var text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125;// 对于类的实例来说，它的常量属性只能在定义它的类的构造过程中修改;不能在子类中修改。class SurveyQuestion2 &#123; let text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125;// 3 默认构造器// 如果结构体或类的所有属性都有默认值，相当于有一个自定义的构造器class ShoppingListItem &#123; var name: String? var quantity = 1 var purchased = false&#125;var item = ShoppingListItem()// 结构体的逐一成员构造器struct Size &#123; var width = 0.0, height = 0.0&#125;let twoByTwo = Size(width: 2.0, height: 2.0)// 4 值类型(结构体和枚举类型)的构造器代理(调用其它构造器来完成实例的部分构造过程)struct Point &#123; var x = 0.0, y = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() init() &#123;&#125; // 功能上与所有属性都有默认值的默认构造器类似 init(origin: Point, size: Size) &#123; // 功能上与结构体的逐一成员构造器类似 self.origin = origin self.size = size &#125; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125;// 5 类的继承和构造过程/* 指定构造器(designated initializers)：主要，至少有一个。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。 init(parameters) &#123; statements &#125; *//* 便利构造器(convenience initializers)：次要，辅助。 convenience init(parameters) &#123; statements &#125; */// 类的构造器代理规则// 1 指定构造器必须调用其直接父类的的指定构造器。// 2 便利构造器必须调用同一类中定义的其它构造器。// 3 便利构造器必须最终导致一个指定构造器被调用。// 两段式构造过程// 第一阶段：每个存储型属性被引入它们的类指定一个初始值// 第二阶段：给每个类一次机会，在新实例准备使用之前进一步定制它们的存储型属性// 4种有效的安全检查(确保两段式构造过程能不出错地完成)// 1 指定构造器必须保证它所在类引入的所有属性都必须先初始化完成，之后才能将其它构造任务向上代理给父类中的构造器。(一个对象的内存只有在其所有存储型属性确定之后才能完全初始化)// 2 指定构造器必须先向上代理调用父类构造器，然后再为继承的属性设置新值。如果没这么做，指定构造器赋予的新值将被父类中的构造器所覆盖。// 3 便利构造器必须先代理调用同一类中的其它构造器，然后再为任意属性赋新值。如果没这么做，便利构造器赋予的新值将被同一类中其它指定构造器所覆盖。// 4 构造器在第一阶段构造完成之前，不能调用任何实例方法，不能读取任何实例属性的值，不能引用self作为一个值。// 构造器的继承和重写class Vehicle &#123; var numberOfWheels = 0 var description: String &#123; return &quot;\(numberOfWheels) wheel(s)&quot; &#125;&#125;class Bicycle: Vehicle &#123; override init() &#123; super.init() // 确保`Bicycle`在修改`Vehicle`的属性之前，它所继承的属性`numberOfWheels`能被`Vehicle`初始化 numberOfWheels = 2 &#125;&#125;let bicycle = Bicycle()bicycle.numberOfWheels// 注：子类可以在初始化时修改继承来的变量属性，但是不能修改继承来的常量属性。// 构造器的自动继承// 规则1：如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。// 规则2：如果子类提供了所有父类指定构造器的实现——无论是通过规则1继承过来的，还是提供了自定义实现——它将自动继承所有父类的便利构造器。// 指定构造器和便利构造器实践class Food &#123; var name: String init(name: String) &#123; self.name = name &#125; convenience init() &#123; self.init(name: &quot;[Unnamed]&quot;) &#125;&#125;let namedMeat = Food(name: &quot;Bacon&quot;)let mysteryMeat = Food()class RecipeIngredient: Food &#123; // 食谱中的一项原料 var quantity: Int init(name: String, quantity: Int) &#123; self.quantity = quantity super.init(name: name) &#125; override convenience init(name: String) &#123; self.init(name: name, quantity: 1) &#125;&#125;let oneMysteryItem = RecipeIngredient()oneMysteryItem.quantity// `RecipeIngredient()`使用从`Food`自动继承的便利构造器`convenience init()`，并在这个便利构造器调用自身的`override convenience init(name: String)`let oneBacon = RecipeIngredient(name: &quot;Bacon&quot;)let sixEggs = RecipeIngredient(name: &quot;Eggs&quot;, quantity: 6)class ShoppingListItem2: RecipeIngredient &#123; // 购物单中出现的某一种食谱原料 var purchased = false var description: String &#123; var output = &quot;\(quantity) x \(name)&quot; output += purchased ? &quot; 有&quot; : &quot; 无&quot; return output &#125;&#125;var breakfastList = [ ShoppingListItem2(), ShoppingListItem2(name: &quot;Bacon&quot;), ShoppingListItem2(name: &quot;Eggs&quot;, quantity: 6),]breakfastList[0].name = &quot;Orange juice&quot;breakfastList[0].purchased = truefor item in breakfastList &#123; print(item.description)&#125;// 6 可失败构造器 init?struct Animal &#123; let species: String init?(species: String) &#123; if species.isEmpty &#123; return nil &#125; self.species = species &#125;&#125;let someCreature = Animal(species: &quot;Giraffe&quot;) // someCreature的类型是可选类型Animal?，而不是Animalif let giraffe = someCreature &#123; print(&quot;An animal was initialized with a species of \(giraffe.species)&quot;)&#125;enum TemperatureUnit &#123; case Kelvin, Celsius, Fahrenheit init?(symbol: Character) &#123; switch symbol &#123; case &quot;K&quot;: self = .Kelvin case &quot;C&quot;: self = .Celsius case &quot;F&quot;: self = .Fahrenheit default: return nil &#125; &#125;&#125;// 带原始值的枚举类型的可失败构造器// 带原始值的枚举类型会自带一个可失败构造器 init?(rawValue:)enum TemperatureUnit2: Character &#123; case Kelvin = &quot;K&quot;, Celsius = &quot;C&quot;, Fahrenheit = &quot;F&quot;&#125;let fahrenheitUnit = TemperatureUnit2(rawValue: &quot;X&quot;)// 构造失败的传递// 类，结构体，枚举的可失败构造器可以横向代理到类型中的其他可失败构造器。// 传递过程中，一个可失败构造器触发构造失败，整个构造过程将立即终止。class Product &#123; let name: String init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125;class CartItem: Product &#123; let quantity: Int init?(name: String, quantity: Int) &#123; if quantity &lt; 1 &#123; return nil &#125; self.quantity = quantity super.init(name: name) &#125;&#125;if let zeroShirts = CartItem(name: &quot;shirt&quot;, quantity: 0) &#123; print(&quot;Item: \(zeroShirts.name), quantity: \(zeroShirts.quantity)&quot;)&#125; else &#123; print(&quot;Unable to initialize zero shirts&quot;)&#125;if let oneUnnamed = CartItem(name: &quot;&quot;, quantity: 1) &#123; print(&quot;Item: \(oneUnnamed.name), quantity: \(oneUnnamed.quantity)&quot;)&#125; else &#123; print(&quot;Unable to initialize one unnamed product&quot;)&#125;// 可以用非可失败构造器重写可失败构造器，但不可反过来。// init!类型的可失败构造器构造失败，会触发断言。// 7 必要构造器// 在类的构造器前添加`required`修饰符表明所有该类的子类都必须实现该构造器// 在重写父类中必要的指定构造器时，不需要添加 override 修饰符// 8 通过闭包或函数设置属性的默认值// 在闭包执行时，实例的其它部分都还没有初始化。也就说不能在闭包里访问其它属性，即使这些属性有默认值。同样，也不能使用隐式的self属性，或者调用任何实例方法。struct Checkerboard &#123; // 西洋跳棋棋盘，boardColors是棋盘颜色数组(8*8) let boardColors: [Bool] = &#123; var temporaryBoard = [Bool]() var isBlack = false for i in 1...8 &#123; for j in 1...8 &#123; temporaryBoard.append(isBlack) isBlack = !isBlack &#125; isBlack = !isBlack &#125; return temporaryBoard &#125;() func squareIsBlackAtRow(row: Int, column: Int) -&gt; Bool &#123; return boardColors[(row * 8) + column] &#125;&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-13：Inheritance]]></title>
    <url>%2F2017%2Fswift-13.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** Inheritance */// 一个类可以继承(inherit)另一个类的方法(methods)，属性(properties)和其它特性// 类可以调用和访问超类的方法，属性和下标(subscripts)，并且可以重写(override)这些方 法，属性和下标来优化或修改它们的行为。// 可以为类中继承来的属性添加属性观察器(property observers)// 1 基类(base class)class Vehicle &#123; var currentSpeed = 0.0 var description: String &#123; return &quot;traveling at \(currentSpeed) miles per hour&quot; &#125; func makeNoise() &#123; // 什么也不做-因为车辆不一定会有噪音 &#125;&#125;let someVehicle = Vehicle()// 2 子类生成(Subclassing)class Bicycle: Vehicle &#123; var hasBasket = false&#125;let bicycle = Bicycle()bicycle.hasBasket = truebicycle.currentSpeed = 15.0print(&quot;Bicycle: \(bicycle.description)&quot;)class Tandem: Bicycle &#123; var currentNumberOfPassengers = 0&#125;// 3 重写(Overriding)// 任何缺少`override`关键字的重写都会在编译时被诊断为错误。// 访问超类的方法，属性及下标。 `super`class Train: Vehicle &#123; override func makeNoise() &#123; print(&quot;Choo Choo&quot;) &#125;&#125;let train = Train()train.makeNoise()class Car: Vehicle &#123; var gear = 1 override var description: String &#123; return super.description + &quot; in gear \(gear)&quot; &#125;&#125;class AutomaticCar: Car &#123; override var currentSpeed: Double &#123; didSet &#123; gear = Int(currentSpeed / 10.0) + 1 &#125; &#125;&#125;// 4 防止重写 (`final var`, `final func`, `final class func`, `final subscript`)]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-12：Subscripts]]></title>
    <url>%2F2017%2Fswift-12.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** Subscripts */// 下标 (subscripts)可以定义在类(class)、结构体(structure)和枚举(enumeration)中，是访问集合(c ollection)，列表(list)或序列(sequence)中元素的快捷方式。// 一个类型可以定义多个下标，通过不同索引类型进行重载。// 1 下标语法struct TimesTable &#123; let multiplier: Int subscript(index: Int) -&gt; Int &#123; return multiplier * index &#125;&#125;let threeTimesTable = TimesTable(multiplier: 3)print(&quot;six times three is \(threeTimesTable[6])&quot;)// 2 下标用法// 字典通过下标返回是可选类型var numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]numberOfLegs[&quot;bird&quot;] = 2// 3 下标选项// 下标可以接受任意数量的入参，并且这些入参可以是任意类型。下标的返回值也可以是任意类型。下标可以使用变量参数和可变参数，但不能使用输入输出参数，也不能给参数设置默认值。// 一个 Double 类型的二维矩阵struct Matrix &#123; let rows: Int, columns: Int var grid: [Double] init(rows: Int, columns: Int) &#123; self.rows = rows self.columns = columns grid = Array(repeating: 0.0, count: rows * columns) &#125; func indexIsValidForRow(row: Int, column: Int) -&gt; Bool &#123; return row &gt;= 0 &amp;&amp; row &lt; rows &amp;&amp; column &gt;= 0 &amp;&amp; column &lt; columns &#125; subscript(row: Int, column: Int) -&gt; Double &#123; get &#123; assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;) return grid[(row * columns) + column] &#125; set &#123; assert(indexIsValidForRow(row: row, column: column), &quot;Index out of range&quot;) grid[(row * columns) + column] = newValue &#125; &#125;&#125;var matrix = Matrix(rows: 2, columns: 3)matrix[1, 2] = 2]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 3 介绍Auto Layout]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-3.html</url>
    <content type="text"><![CDATA[Auto layout是一种基于约束的，描述性的布局系统。 iPhone尺寸 为什么使用Auto Layout前面的一部分的项目HelloWorld默认是运行的iPhone 7(iPhone 6)的竖屏下的，button是在屏幕中间的，但是如果其他屏幕大小或不同方位就不一定了。按照在默认iPhone 7的条件下，button的左上角的坐标是(147,318)，其他尺寸的设备和不同方位显示时也会按照这种坐标显示，就不会在中间了，这也就是为什么需要使用Auto Layout。 Auto Layout就是关于所有约束关于“Hello World”按钮的位置信息的描述可能比较好的是： 无论屏幕的分辨率和方位，这个按钮在水平和垂直方向都应该是居中的 这实际就定义了两个约束： 水平居中 垂直居中 在Auto Layout中约束都被描述成数学表示，例如上述两个限制就会被表示成： Hello World.centerX = centerX ， Hello World.centerY = centerY。当然我们不需要直接处理这种数学公式，Xcode会帮我们处理。 使用Auto Layout使Button到中央Xcode提供了两种方法定义Auto Layout的约束： Auto Layout工具栏 Control-drag Auto Layout工具栏提供了四个按钮： Stack - 组合views变成一个stack view Align - 构建对齐约束 Pin - 构建空间约束，例如UI的宽度，高度，边距等 Issues - 解决布局问题 使用Align来定义两个约束：水平居中 和 垂直居中。弹窗中”Horizontal in container”后的数字表示button中心点的x坐标与父视图中心点的x坐标的相差数， “Vertically in container”后的数字表示button中心点的y坐标与父视图中心点的y坐标的相差数。如果都为零就表示button的中心和父视图的中心是相同的，也就是说button水平和垂直方向都居中。 点击 “Add 2 Constraints” 后，会出现如下情况。在document outline中出现两个约束选项，在视图中出现垂直两条蓝色的实线，在size检查器中也能看到约束。 如果点击每个约束，在size检查器中还能看到每个约束的具体信息，也能在此修改约束。 解决布局约束问题Xcode可以非常智能的检测的布局约束方面的问题。当创建了模棱两可或冲突的约束时就会出现布局问题。试着将button拖动左下角，视图中原本的蓝色实线变成了黄色实线，并且线上还有数字，这些数字表示button现在的位置偏离约束的距离，document outline右上角出现一个黄色箭头(disclosure arrow)。 点击disclosure arrow，出现布局问题列表，红色框中的Expected表示现在约束所期望的位置也就是居中位置，Actual表示现在实际位置。每个问题右侧有个indicator icon，点击它出现一个弹框，选择Update Frame然后点击Fix Misplacement，按钮回到原来中央位置；选择Update constraints表示button的位置不变，更新到最新位置的约束。 实际上，点击Auto Layout工具栏最右侧的issue，也会出现类似的功能： 不同设备同时预览Xcode提供了一个同时预览不同设备下视图的界面。按住option，然后按menu &gt; Preview(1) &gt; Main.storyboard (Preview)，就能打开用于预览的assistant editor。 这个预览窗口可以预览目前所有iOS设备。 添加一个Label 添加一个”Welcome to Auto Layout”的标签在右下角，并打开预览窗口查看，发现出来除了默认的iPhone 7，其他设备要不偏离了，要不不见了。 用control+drag方法来添加spacing constraint。按住control，从label上向右拖动，拖出label到视图后松开，出现弹框，选择 “Trailing space to container margin” ，表示设置右边距的约束。 类似2的方法，向下拖动松开，选择弹框中的”Vertical Spacing to Bottom Layout Guide”，表示设置了下边距约束。所有约束线变成了蓝色实线，蓝色实线表示约束正常。 document outline上又出现两个约束： 此时如果用预览窗口查看，发现label在不同的设备上都在右下角了： 编辑约束前面也提到约束本身可以手动修改的，选择约束，然后在size检查器中修改。默认label的”trailingMargin”约束的constant值是0，可以试着修改。 练习 添加新的label，修改文本为Learn Swift 把字体大小改为30 point，调整label为适宜大小 添加两个约束 label的上边距为40point label水平居中 代码HelloWorldAutoLayoutHelloWorldAutoLayoutExercise 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 2 Hello World！第一个Swift APP]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-2.html</url>
    <content type="text"><![CDATA[“Hello,World”已经成为编程世界里开始的惯例。 开始：先动起来，忘记代码 打开Xcode，选择”Create a new Xcode project” 选择 iOS &gt; Single View Application and click Next 填写项目的一些选项: Product Name: HelloWorld - app的名字 Team - Apple ID Organization Name: andyron - 这一般是组织的名字，或个人用户的名字；尽量保持不与别人重复 Organization Identifier: cn.andyron Bundle Identifier: com.andyron.HelloWorld - 根据Organization Identifier和Product Name自动组合而成 Language: Swift Devices: iPhone Use Core Data: [unchecked] Include Unit Tests: [unchecked] Include UI Tests: [unchecked] 选择一个项目保持位置，然后生成项目 熟悉Xcode界面Xcode Help中详细介绍了Xcode，主界面如下： 主要分六个区域： Toolbar(工具栏) Tab bar(便签页栏)：类似浏览器的标签页，快捷键也和大部分软件的相同(⌘+T新建，⌘+W关闭)，单个标签页时是隐藏的 Navigator area(导航区域)这个区域最上面有八个图标（快捷键分别对应⌘+1 ~ ⌘+8）： project navigator(源代码文件、图片文件、数据模型、属性列表等) symbol navigator(编译器能识别的：OC类、枚举类型、结构体、全局变量) find navigator issues navigator test navigator debug navigator breakpoint navigator log navigator Editor area（编辑区）这个区域最上面是jump bar(跳转栏) Debug area Utilities area（实用工具面板）分上下两块： Inspector pane(检查器)：选择不同文件会有不同个数的检查器，最多六个(快捷键分别对应⌘+option+1 ~ ⌘+option+6)。 Library pane(库面版, 快捷键分别对应⌘+option+control+1 ~ ⌘+option+control+4) 文件库模板(File Template Library) : 管理文件模板, 可以快速创建指定类型文件, 可以直接拖入项目中; 代码片段库(Code Snippet Library) : 管理各种代码片段, 可以直接拖入源代码中; 对象库(Object Library) : 界面组件, 可以直接拖入 故事板中; 媒体库(Media Library) : 管理各种 图片, 音频 等多媒体资源; 第一次运行AppRun和Stop分别对应 ⌘+R和⌘+.，Simulator用于选择模拟器或真实设备 快速了解Interface Builder（IB）在project navigator中选择main.storyboardThe Interface Builder editor为创造和设计app的UI提高了一个可视化的方法。在这里既可以设计单个页面，也可以设计多个页面。可以直接从右下角Object library拖动可用对象到IB中。当开始新建项目，选择了Single View Application模板时，Xcode默认在storyboard中生成一个view controller scene，对应一个view controller。通常app的每一个screen代表一个view controller。The Document Outline view在选择storyboard特定对象时特别有用。 设计UI 拖动一个Button到IB中 双击Button或在属性检查器中修改name为”Hello World** 根据蓝色虚线辅助线可以把Button拖到中心位置 写代码 选择main.storyboard，点击工具栏右侧的Assistant editor(option+⌘+return)，编辑区出现两部分，Ctrl拖动按钮到右侧ViewController类中： 然后写下如下代码：1234567@IBAction func showMessage() &#123; let alertController = UIAlertController(title: &quot;Welcome to My First App&quot;,message: &quot;Hello World&quot;, preferredStyle: UIAlertControllerStyle.alert) alertController.addAction(UIAlertAction(title: &quot;OK&quot;, style:UIAlertActionStyle.default, handler: nil)) present(alertController, animated: true, completion: nil)&#125; 上面的方法是先连接关系，然后写代码；也可以先写好代码，然后建立关系：@IBAction表示一个Action的标识符，没有特殊意义，当建立好关系后，@IBAction右侧会出现一个实心的点，点击会出现会出现以个弹框表示连接的地方： 修改按钮的颜色。选中按钮，在属性检查器中修改对应属性 测试应用选择特定的模拟器或设备，⌘+R Hello world 应用中事件流 更近一步 同上的方法添加几个按钮，并修改button的name为一些emoji表情（control+⌘+space） 添加@IBAction方法代码 通过先写好代码然后建立关系的方法，把几个button都与同一个@IBAction方法建立关系 代码HelloWorldHelloWordExercise 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-11：Methods]]></title>
    <url>%2F2017%2Fswift-11.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** Methods 方法是与某些特定类型相关联的函数 实例方法为给定类型的实例封装了具体的任务与功能 类、结构体、枚举都可以定义**实例方法**，也都可以定义**类型方法** 在OC中，类是唯一能定义方法的类型 */// 1 实例方法 (Instance Methods)// 实例方法只能被它所属的类的某个特定实例调用class Counter &#123; var count = 0 func increment() &#123; count += 1 &#125; func incrementBy(amount: Int) &#123; count += amount &#125; func reset() &#123; count = 0 &#125;&#125;// 方法的局部参数名称和外部参数名称 (Local and External Parameter Names for Methods)class Counter2 &#123; var count: Int = 0 func incrementBy(amount: Int, numberOfTimes: Int) &#123; count += amount * numberOfTimes &#125;&#125;let counter = Counter2()counter.incrementBy(amount: 5, numberOfTimes: 3)// self 属性(The self Property)：`self`完全等同于该实例本身。// 消除方法参数 x 和实例属性 x 之间的歧义:struct Point &#123; var x = 0.0, y = 0.0 func isToTheRightOfX(x: Double) -&gt; Bool &#123; return self.x &gt; x &#125;&#125;// 在实例方法中修改值类型(Modifying Value Types from Within Instance Methods)// 结构体和枚举的属性不能在它的实例方法中被修改(因为结构体和枚举是值类型)，但可通过`mutating`（可变方法）修改。struct Point2 &#123; var x = 0.0, y = 0.0 mutating func moveByX(_ deltaX: Double, y deltaY: Double) &#123; x += deltaX y += deltaY &#125;&#125;var somePoint = Point2(x: 1.0, y: 1.0)somePoint.moveByX(2.0, y: 3.0)// 在可变方法中给 self 赋值(Assigning to self Within a Mutating Method)struct Point3 &#123; var x = 0.0, y = 0.0 mutating func moveByX(_ deltaX: Double, y deltaY: Double) &#123; self = Point3(x: x + deltaX, y: y + deltaY) &#125;&#125;enum TriStateSwitch &#123; case Off, Low, High mutating func next() &#123; switch self &#123; case .Off: self = .Low case .Low: self = .High case .High: self = .Off &#125; &#125;&#125;// 2 类型方法 (Type Methods)// `static` `class`// 在类型方法的方法体(body)中，`self`指向这个类型本身，而不是类型的某个实例。struct LevelTracker &#123; static var highestUnlockedLevel = 1 static func unlockLevel(level: Int) &#123; if level &gt; highestUnlockedLevel &#123; highestUnlockedLevel = level &#125; &#125; static func levelIsUnlocked(level: Int) -&gt; Bool &#123; return level &lt;= highestUnlockedLevel &#125; var currentLevel = 1 mutating func advanceToLevel(level: Int) -&gt; Bool &#123; if LevelTracker.levelIsUnlocked(level: level) &#123; currentLevel = level return true &#125; else &#123; return false &#125; &#125;&#125;class Player &#123; var tracker = LevelTracker() let playerName: String func completedLevel(level: Int) &#123; LevelTracker.unlockLevel(level: level + 1) tracker.advanceToLevel(level: level + 1) &#125; init(name: String) &#123; playerName = name &#125;&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-10：Properties]]></title>
    <url>%2F2017%2Fswift-10.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146/** Properties */// 1 存储属性 Stored Properties （只能用于类和结构体）// 描述整数的范围，且这个范围值在被创建后不能被修改.struct FixedLengthRange &#123; var firstValue: Int let length: Int&#125;// 该区间表示整数0，1，2var rangeOfThreeItems = FixedLengthRange(firstValue: 0, length: 3)// 该区间现在表示整数6，7，8rangeOfThreeItems.firstValue = 6// 常量结构的属性不能修改let rangeOfFourItems = FixedLengthRange(firstValue: 0, length: 4)// 尽管 firstValue 是个变量属性，这里还是会报错//rangeOfFourItems.firstValue = 6// 延迟存储属性: 第一次被调用的时候才会计算其初始值。 `lazy var` (常量属性在构造过程完成之前必须要有初始值，因此无法声明成延迟属性)class DataImporter &#123; /* DataImporter 是一个负责将外部文件中的数据导入的类。 这个类的初始化会消耗不少时间。 */ var fileName = &quot;data.txt&quot; // 这里会提供数据导入功能&#125;class DataManager &#123; lazy var importer = DataImporter() var data = [String]() // 这里会提供数据管理功能&#125;let manager = DataManager() // DataImporter 实例的 importer 属性还没有被创建manager.data.append(&quot;Some data&quot;)manager.data.append(&quot;Some more data&quot;)manager.importer.fileName// 2 计算属性(Computed Properties)// 不直接存储值，而是提供一个getter和一个可选的setter,来间接获取和设置其他属性或变量的值。struct Point &#123; var x = 0.0, y = 0.0&#125;struct Size &#123; var width = 0.0, height = 0.0&#125;struct Rect &#123; var origin = Point() var size = Size() var center: Point &#123; get &#123; let centerX = origin.x + (size.width / 2) let centerY = origin.y + (size.height / 2) return Point(x: centerX, y: centerY) &#125; set(newCenter) &#123; origin.x = newCenter.x - (size.width / 2) origin.y = newCenter.y - (size.height / 2) &#125; &#125;&#125;var square = Rect(origin: Point(x: 0.0, y: 0.0), size: Size(width: 10.0, height: 10.0))let initialSquareCenter = square.centersquare.center = Point(x: 15.0, y: 15.0)print(&quot;square.origin is now at (\(square.origin.x), \(square.origin.y))&quot;)// 输出 &quot;square.origin is now at (10.0, 10.0)”// 只读计算属性struct Cuboid &#123; var width = 0.0, height = 0.0, depth = 0.0 var volume: Double &#123; // 只用get时可简写 return width*height*depth &#125;&#125;// 3 属性观察器(Property Observers)// 设置属性时（就算值不变），就会调用`willSet`， `didSet`class StepCounter &#123; var totalSteps: Int = 0 &#123; willSet &#123; print(&quot;设置成\(newValue)&quot;) &#125;// willSet(newTotalSteps) &#123;// print(&quot;About to set totalSteps to \(newTotalSteps)&quot;)// &#125; didSet &#123; if totalSteps &gt; oldValue &#123; print(&quot;Added \(totalSteps - oldValue) steps&quot;) &#125; &#125;// didSet(old) &#123;// print(old)// &#125; &#125;&#125;let stepCounter = StepCounter()stepCounter.totalSteps = 1stepCounter.totalSteps = 20// 4 全局变量和局部变量(Global and Local Variables)// 计算属性和属性观察器所描述的功能也可以用于全局变量和局部变量// 5 类型属性(Type Properties)：用于某个类型所有实例共享的数据。(类似于其他语言的静态属性)// 存储型类型属性是延迟初始化的struct SomeStructure &#123; static var storedTypeProperty = &quot;Some value.&quot; static var computedTypeProperty: Int &#123; return 1 &#125;&#125;enum SomeEnumeration &#123; static var storedTypeProperty = &quot;Some value.&quot; static var computedTypeProperty: Int &#123; return 6 &#125;&#125;class SomeClass &#123; static var storedTypeProperty = &quot;Some value.&quot; static var computedTypeProperty: Int &#123; return 27 &#125; class var overrideableComputedTypeProperty: Int &#123; return 107 &#125;&#125;SomeStructure.storedTypeProperty// 声道模型struct AudioChannel &#123; static let thresholdLevel = 10 // 音量的最大 上限阈值 static var maxInputLevelForAllChannels = 0 // 实例的最大 音量 var currentLevel: Int = 0 &#123; didSet &#123; if currentLevel &gt; AudioChannel.thresholdLevel &#123; // 将当前音量限制在阀值之内 currentLevel = AudioChannel.thresholdLevel &#125; if currentLevel &gt; AudioChannel.maxInputLevelForAllChannels &#123; // 存储当前音量作为新的最大输入音量 AudioChannel.maxInputLevelForAllChannels = currentLevel &#125; &#125; &#125;&#125;var leftChannel = AudioChannel()var rightChannel = AudioChannel()leftChannel.currentLevel = 7print(leftChannel.currentLevel)print(AudioChannel.maxInputLevelForAllChannels)]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-9：Classes and Structures]]></title>
    <url>%2F2017%2Fswift-9.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** Classes and Structures */// 一个单一文件中定义一个类或者结构体，系统将会自动生成面向其它代码的外部接口。/** 类和结构体的共同点： 定义属性用于存储值 定义方法用于提供功能 定义下标操作使得可以通过下标语法来访问实例所包含的值 定义构造器用于生成初始化值 通过扩展以增加默认实现的功能 实现协议以提供某种标准功能 类还有如下的附加功能： 继承允许一个类继承另一个类的特征 类型转换允许在运行时检查和解释一个类实例的类型 析构器允许一个类实例释放任何其所被分配的资源 引用计数允许对一个类的多次引用 **结构体总是通过被复制的方式在代码中传递，不使用引用计数。** */// 新类或结构体命名用*UpperCamelCase*（Swift类型的命名规范）// 属性和方法命名用*lowerCamelCase*struct Resolution &#123; var width = 0 var height = 0&#125;class VideoMode &#123; var resolution = Resolution() var interlaced = false var frameRate = 0.0 var name: String?&#125;// 类和结构体实例// 结构体和类都使用构造器语法来生成新的实例， `()`是最简单的构造器语法。let someResolution = Resolution()let someVideoMode = VideoMode()// 结构体的成员逐一构造器let hd = Resolution(width: 1920, height: 1080)// 结构体和枚举是值类型。所有的基本类型:整数(Integer)、浮 点数(floating-point)、布尔值(Boolean)、字符串(string)、数组(array)和字典(dictionary)，都是 值类型，并且在底层都是以结构体的形式所实现。var cinema = hdcinema.width = 2048print(&quot;hd is still \(hd.width) pixels wide&quot;)// 类是引用类型let tenEighty = VideoMode()tenEighty.resolution = hdtenEighty.interlaced = truetenEighty.name = &quot;1080i&quot;tenEighty.frameRate = 25.0let alsoTenEighty = tenEightyalsoTenEighty.frameRate = 30.0tenEighty.frameRate// 恒等运算符:判定两个常量或者变量是否引用同一个类实例tenEighty === alsoTenEighty/** 建议选择结构体的情况： - 该数据结构的主要目的是用来封装少量相关简单数据值。 - 有理由预计该数据结构的实例在被赋值或传递时，封装的数据将会被拷贝而不是被引用。 - 该数据结构中储存的值类型属性，也应该被拷贝，而不是被引用。 - 该数据结构不需要去继承另一个既有类型的属性或者行为。 */struct Shape &#123; var width: Double = 1.0 var height: Double = 1.0&#125;struct Path &#123; var start: Int var length: Int&#125;struct Point &#123; var x: Double var y: Double var z: Double&#125;// Swift中的String，Array和Dictionary是值类型，OC中的NSString， NSArray和NSDictionary是引用类型]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-8：Enumerations]]></title>
    <url>%2F2017%2Fswift-8.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** Enumerations */// 一等(first-class)类型// 每个枚举定义了一个全新的类型。以大写字母开头// 成员值(或成员) 原始值 关联值// 不会被赋予一个默认的整型值// 1 枚举语法enum CompassPoint &#123; case North case South case East case West&#125;enum Planet &#123; case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Neptune&#125;var directionToHead = CompassPoint.WestdirectionToHead = .East// 2 Switch 语句匹配枚举值switch directionToHead &#123; case .North: print(&quot;Lots of planets have a north&quot;) case .South: print(&quot;Watch out for penguins&quot;) case .East: print(&quot;Where the sun rises&quot;) case .West: print(&quot;Where the skies are blue&quot;)&#125;// 3 关联值(Associated Values) 任意类型，可以各不相同// “定义一个名为 Barcode 的枚举类型，它的一个成员值是具有 (Int，Int，Int，Int) 类型关联值的 UPCA ，另一个成员值是具有 String 类型关联值的 QRCode 。”enum Barcode &#123; case UPCA(Int, Int, Int, Int) case QRCode(String)&#125;var productBarcode = Barcode.UPCA(8, 85909, 51226, 3)productBarcode = .QRCode(&quot;ABCDEFGHIJKLMNOP&quot;)switch productBarcode &#123;case .UPCA(let numberSystem, let manufacturer, let product, let check): print(&quot;UPC-A: \(numberSystem), \(manufacturer), \(product), \(check).&quot;)case .QRCode(let productCode): print(&quot;QR code: \(productCode).&quot;)&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-7：Closure]]></title>
    <url>%2F2017%2Fswift-7.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * Closure */// 闭包是自包含的函数代码块，可以在代码中被传递和使用。// Swift 中的闭包与 C 和 Objective-C 中的代码块(blocks)以及其他一些编程语言中的匿名函数比较相似。// 闭包可以捕获和存储其所在上下文中任意常量和变量的引用。// 1 闭包表达式(Closure Expressions)// sorted 方法(The Sorted Method)// 原数组不会被 sorted(by:) 方法修改。let names = [&quot;Chris&quot;, &quot;Alex&quot;, &quot;Ewa&quot;, &quot;Barry&quot;, &quot;Daniella&quot;, &quot;Andy&quot;, &quot;Amni&quot;]func backward(_ s1: String, _ s2: String) -&gt; Bool &#123; return s1 &gt; s2&#125;var reversedNames = names.sorted(by: backward)/** 闭包表达式语法: &#123; (parameters) -&gt; returnType in statements &#125; 关键字`in`表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。 */var reversedNames2 = names.sorted(by: &#123;(s1:String, s2:String) -&gt; Bool in return s1&gt;s2&#125;)// 根据上下文推断类型(Inferring Type From Context)var reversedNames3 = names.sorted(by: &#123;(s1, s2)-&gt;Bool in return s1&gt;s2&#125;)// 根据上下文推断类型(Inferring Type From Context) 省略 return 和 返回值var reversedNames4 = names.sorted(by: &#123;(s1, s2) in s1&gt;s2&#125;)// 参数名称缩写(Shorthand Argument Names)：直接通过 $0 ， $1 ， $2 来顺序调用闭包的参数var reversedNames5 = names.sorted(by: &#123;$0&gt;$1&#125;)// 运算符方法(Operator Methods)var reversedNames6 = names.sorted(by: &gt;)// 2 尾随闭包(Trailing Closures):将一个很长的闭包表达式作为最后一个参数传递给函数/**// 以下是不使用尾随闭包进行函数调用 func someFunctionThatTakesAClosure(closure: &#123;// 闭包主体部分 &#125;)// 以下是使用尾随闭包进行函数调用 func someFunctionThatTakesAClosure() &#123;// 闭包主体部分 &#125; */var reversedNames7 = names.sorted()&#123;$0&gt;$1&#125;var reversedNames8 = names.sorted&#123;$0&gt;$1&#125; // 当闭包表达式是唯一参数时， ()可省略let digitNames = [ 0: &quot;Zero&quot;, 1: &quot;One&quot;, 2: &quot;Two&quot;, 3: &quot;Three&quot;, 4: &quot;Four&quot;, 5: &quot;Five&quot;, 6: &quot;Six&quot;, 7: &quot;Seven&quot;, 8: &quot;Eight&quot;, 9: &quot;Nine&quot;]let numbers = [16, 58, 510]let strings = numbers.map &#123; (number) -&gt; String in var number = number var output = &quot;&quot; repeat &#123; output = digitNames[number%10]! + output // 字典下标返回一个可选值(optional value) number /= 10 &#125; while number &gt; 0 return output&#125;// 3 值捕获(Capturing Values)// 闭包可以在其被定义的上下文中捕获常量或变量。即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。// 嵌套函数 是 捕获值的闭包的最简单形式func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer&#125;var funcby10 = makeIncrementer(forIncrement: 10)var funcby50 = makeIncrementer(forIncrement: 50)// 新生成的incrementer函数，都会各自获得类似全局变量的 amount和runingTotalfuncby50()funcby50()funcby10()// 4 闭包是引用类型(Closures Are Reference Types)// 函数和闭包都是引用类型// 无论将函数或闭包赋值给一个常量还是变量，实际上都是将常量或变量的值设置为对应函数或闭包的引用。let funcbyTen = funcby10funcbyTen()]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-6：Functions]]></title>
    <url>%2F2017%2Fswift-6.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/** Functions */// 1 函数的定义与调用 (Defining and Calling Functions)// 参数，parameters// 返回类型，return type// 实参，argumentsfunc greet(person: String) -&gt; String &#123; return &quot;Hello, &quot; + person + &quot;!&quot;&#125;// 2 函数参数与返回值 (Function Parameters and Return Values)// 无参数函数 (Functions Without Parameters)func sayHelloWorld() -&gt; String &#123; return &quot;hello, world&quot;&#125;// 多参数函数 (Functions With Multiple Parameters)func greet(person: String, alreadyGreeted: Bool) -&gt; String &#123; if alreadyGreeted &#123; return &quot;Hello, &quot; + person + &quot; again!&quot; &#125; else &#123; return &quot;Hello, &quot; + person + &quot;!&quot; &#125;&#125;// 无返回值函数 (Functions Without Return Values)// 没有定义返回类型的函数会 返回一个特殊的Void值。它其实是一个空的元组(tuple)，没有任何元素，可以写成()。func greet(person: String) &#123; print(&quot;Hello, \(person)!&quot;)&#125;// 多个返回值函数 (Functions with Multiple Return Values)func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)// 可选元组返回类型 (Optional Tuple Return Types)func minMax2(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;if let bounds = minMax2(array: [8, -6, 2, 109, 3, 71]) &#123; print(&quot;min is \(bounds.min) and max is \(bounds.max)&quot;)&#125;// 3 函数参数标签和参数名称 (Function Argument Labels and Parameter Names)// 每个函数参数都有一个参数标签( argument label )以及一个参数名称( parameter name )。参数标签在调用函 数的时候使用;调用的时候需要将函数的参数标签写在对应的参数前面。参数名称在函数的实现中使用。func someFunction(argumentLabel parameterName: Int) &#123;&#125;// 忽略参数标签(Omitting Argument Labels)// 默认参数值 (Default Parameter Values)// 可变参数 (Variadic Parameters) 一个函数最多只能拥有一个可变参数func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;print(arithmeticMean(1,2,3))print(arithmeticMean(1.2,3.45,5,6,3.12))// 输入输出参数(In-Out Parameters)// 函数参数默认是常量。输入输出参数可以在函数中修改参数，并且在函数调用结束后仍然存在。// 只能传递变量给输入输出参数// 输入输出参数不能有默认值，而且可变参数不能用inout标记。func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt)print(&quot;someInt is now \(someInt), and anotherInt is now \(anotherInt)&quot;)// 4 函数类型 (Function Types)func addTwoInts(_ a: Int, _ b: Int) -&gt; Int &#123; // `(Int, Int) -&gt; Int` return a + b&#125;func printHelloWorld() &#123; // `() -&gt; Void` print(&quot;hello, world&quot;)&#125;// 使用函数类型 (Using Function Types)var mathFunction: (Int, Int) -&gt; Int = addTwoIntsprint(&quot;Result: \(mathFunction(2, 3))&quot;)// 函数类型作为参数类型 (Function Types as Parameter Types)func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print(&quot;Result: \(mathFunction(a, b))&quot;)&#125;printMathResult(addTwoInts, 3, 5)// 函数类型作为返回类型 (Function Types as Return Types)func stepForward(_ input: Int) -&gt; Int &#123; return input + 1&#125;func stepBackward(_ input: Int) -&gt; Int &#123; return input - 1&#125;func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; return backward ? stepBackward : stepForward&#125;// 5 嵌套函数 (Nested Functions)func chooseStepFunction2(backward: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-5：Control Flow]]></title>
    <url>%2F2017%2Fswift-5.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163/** Control Flow */// 1 for in// for in 可用来遍历 Array Dictionary Set Range Stringfor index in 1...5 &#123;&#125;for _ in 1...5 &#123;&#125;for v in [1,2,3] &#123;&#125;let numberOfLegs = [&quot;spider&quot;: 8, &quot;ant&quot;: 6, &quot;cat&quot;: 4]for (animalName, legCount) in numberOfLegs &#123;&#125;let countrys:Set = [&quot;China&quot;, &quot;USA&quot;, &quot;Japan&quot;]for country in countrys &#123;&#125;for s in &quot;andyron&quot;.characters &#123;&#125;// 2 whilevar i = 1while i &gt; 10 &#123; // ... i += 1&#125;// repeat-while 类似其他语言的 do-while repeat &#123; // ... i += 1&#125; while i &gt; 10// 3 ifvar temperatureInFahrenheit = 30if temperatureInFahrenheit &lt;= 32 &#123; print(&quot;It&apos;s very cold. Consider wearing a scarf.&quot;)&#125; else if temperatureInFahrenheit &gt;= 86 &#123; print(&quot;It&apos;s really warm. Don&apos;t forget to wear sunscreen.&quot;)&#125; else &#123; print(&quot;It&apos;s not that cold. Wear a t-shirt.&quot;)&#125;// 4 switch// 不存在隐式的贯穿(No Implicit Fallthrough)，不需要breaklet anotherCharacter: Character = &quot;a&quot;switch anotherCharacter &#123;case &quot;a&quot;, &quot;A&quot;: print(&quot;The letter A&quot;)default: print(&quot;Not the letter A&quot;)&#125;// 区间匹配let approximateCount = 62let countedThings = &quot;moons orbiting Saturn&quot;var naturalCount: Stringswitch approximateCount &#123;case 0: naturalCount = &quot;no&quot;case 1..&lt;5: naturalCount = &quot;a few&quot;case 5..&lt;12: naturalCount = &quot;several&quot;case 12..&lt;100: naturalCount = &quot;dozens of&quot;case 100..&lt;1000: naturalCount = &quot;hundreds of&quot;default: naturalCount = &quot;many&quot;&#125;// 元组匹配let somePoint = (1, 1)switch somePoint &#123;case (0, 0): print(&quot;(0, 0) is at the origin&quot;)case (_, 0): print(&quot;(\(somePoint.0), 0) is on the x-axis&quot;)case (0, _): print(&quot;(0, \(somePoint.1)) is on the y-axis&quot;)case (-2...2, -2...2): print(&quot;(\(somePoint.0), \(somePoint.1)) is inside the box&quot;)default: print(&quot;(\(somePoint.0), \(somePoint.1)) is outside of the box&quot;)&#125;// 值绑定(Value Bindings)let anotherPoint = (2, 0)switch anotherPoint &#123;case (let x, 0): print(&quot;on the x-axis with an x value of \(x)&quot;)case (0, let y): print(&quot;on the y-axis with a y value of \(y)&quot;)case let (x, y): print(&quot;somewhere else at (\(x), \(y))&quot;)&#125;// case分句中使用wherelet yetAnotherPoint = (1, -1)switch yetAnotherPoint &#123;case let (x, y) where x == y: print(&quot;(\(x), \(y)) is on the line x == y&quot;)case let (x, y) where x == -y: print(&quot;(\(x), \(y)) is on the line x == -y&quot;)case let (x, y): print(&quot;(\(x), \(y)) is just some arbitrary point&quot;)&#125;// 复合匹配// 当多个条件可以使用同一种方法来处理时，可以将这几种可能放在同一个case后面，并且用逗号隔开。let stillAnotherPoint = (9, 0)switch stillAnotherPoint &#123;case (let distance, 0), (0, let distance): print(&quot;On an axis, \(distance) from the origin&quot;)default: print(&quot;Not on an axis&quot;)&#125;// 5 控制转移语句(Control Transfer Statements): continue break fallthrough return throw// 贯穿(Fallthrough) 执行完一个case后，继续向下执行let integerToDescribe = 5var description = &quot;The number \(integerToDescribe) is&quot;switch integerToDescribe &#123;case 2, 3, 5, 7, 11, 13, 17, 19: description += &quot; a prime number, and also&quot; fallthroughdefault: description += &quot; an integer.&quot;&#125;// 6 guard 与 if// 功能类似。区别：1 guard减少嵌套，会简洁 2 解包时，guard的结果作用域不限于本身。// greet(person: [&quot;name&quot;: &quot;Jane&quot;, &quot;location&quot;: &quot;Cupertino&quot;])func greet(person: [String: String]) &#123; if let name = person[&quot;name&quot;] &#123; print(&quot;Hello \(name)!&quot;) if let location = person[&quot;location&quot;] &#123; print(&quot;I hope the weather is nice in \(location).&quot;) &#125; else &#123; print(&quot;I hope the weather is nice near you.&quot;) &#125; &#125; else &#123; print(&quot;Hello stranger!&quot;) &#125;// print(name) //name的作用于只限于if中&#125;func greet2(person: [String: String]) &#123; guard let name = person[&quot;name&quot;] else &#123; print(&quot;Hello stranger!&quot;) return &#125; print(&quot;Hello \(name)!&quot;) guard let location = person[&quot;location&quot;] else &#123; print(&quot;I hope the weather is nice near you.&quot;) return &#125; print(&quot;I hope the weather is nice in \(location).&quot;)&#125;// 7 检测 API 可用性if #available(iOS 10, macOS 10.12, *) &#123; // 在 iOS 使用 iOS 10 的 API, 在 macOS 使用 macOS 10.12 的 API&#125; else &#123; // 使用先前版本的 iOS 和 macOS 的 API&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-4：Collection Type]]></title>
    <url>%2F2017%2Fswift-4.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104/** Collection Type */// Collection 分为 Arrays, Sets, Dictionaries(Collection，Sets有时都翻译成集合)// 1 数组(Arrays)是有序数据的集。// 一个数组中只能有一种数据类型var someInts = [Int]() // 创建一个由特定数据类型构成的空数组someInts = [] // someInts 现在是空数组，但是仍然是 [Int] 类型的。let unmutableArray = [2, 3, 5] // 定义为let，数组内容和数量就不能变化var threeDoubles = [Double](repeating:0.0, count: 3) // `Array`创建特定大小并且所有数据都有相同默认值的构造方法var anotherThreeDoubles = [Double](repeating: 2.5, count: 3)var sixDoubles = threeDoubles + anotherThreeDoubles // 数组相加sixDoubles.countsixDoubles.isEmptysixDoubles.append(2.6)sixDoubles += [3.2, 3.3]sixDoubles[0]sixDoubles[4...6] // 通过区间获取多个数组项组成的新数组，注意区间大小不能超过数组的下标sixDoubles.insert(4.4, at: 2)sixDoubles.remove(at: 0)sixDoubles.removeLast()sixDoubles.removeAll()// 数组遍历var shoppingList = [&quot;Eggs&quot;, &quot;Milk&quot;]for item in shoppingList &#123;&#125;for (index, value) in shoppingList.enumerated() &#123; // enumerated()把数组的索引和值生成sequence用于遍历&#125;// 数组特殊操作 //var a = (1...10)var arr = [1,3,7,11]var arr2 = arr.map&#123;$0 * 2&#125;var sum = arr.reduce(0,+)// 验证tweet中是否包含选定的若干关键字中的一个let words = [&quot;Swift&quot;,&quot;iOS&quot;,&quot;cocoa&quot;,&quot;OSX&quot;,&quot;tvOS&quot;]let tweet = &quot;This is an example tweet larking about Swift&quot;//words.contains(tweet.containsString)//words.filter(&#123;tweet.containsString($0)&#125;)tweet.characters .split(separator: &quot; &quot;) .lazy .map(String.init) .contains(where: Set(words).contains)let name = &quot;andyron&quot;(1...4).forEach&#123;print(&quot;Happy Birthday &quot; + (($0 == 3) ? &quot;dear \(name)&quot;:&quot;to You&quot;))&#125;// 2 集合(Sets)是无序无重复数据的集。// 存在集合的中数据类型必须是 可哈希化（必须提供一个方法来计算它的哈希值， 相等的对象哈希值必须相同， a.hashValue == b.hashValue）// Swift的所有基本类型(比如 String , Int , Double 和 Bool)默认都是可哈希化的// 在Swift内部可哈希化的类型都接触了`Hashable`协议，它提高了一个属性`hashValue`var letters = Set&lt;Character&gt;() // 创建和构造一个空的类型为`Set&lt;Character&gt;`的集合letters.insert(&quot;a&quot;)letters = []var favoriteGenres: Set&lt;String&gt; = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]var favoriteGenres2: Set = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]favoriteGenres.insert(&quot;Jazz&quot;)favoriteGenres.countfavoriteGenres.remove(&quot;Classical&quot;) // 有成员就返回此成员，否则返回`nil`//favoriteGenres.removeAll()favoriteGenres.contains(&quot;Rock&quot;)// 遍历集合for genre in favoriteGenres &#123; print(genre)&#125;for genre in favoriteGenres.sorted() &#123; print(genre)&#125;// 集合操作favoriteGenres = [&quot;Rock&quot;, &quot;Classical&quot;, &quot;Hip hop&quot;]favoriteGenres2 = [&quot;Hip hop&quot;, &quot;R&amp;B&quot;, &quot;rap&quot;]favoriteGenres.intersection(favoriteGenres2) // 交集favoriteGenres.symmetricDifference(favoriteGenres2) // 对称差集favoriteGenres.union(favoriteGenres2) // 并集favoriteGenres.subtracting(favoriteGenres2) // 差集favoriteGenres.subtract(favoriteGenres2) // 区别于subtracting，没有返回值直接修改favoriteGenresvar fg3: Set = [&quot;rap&quot;]favoriteGenres == favoriteGenres2favoriteGenres2.isSubset(of: fg3) // favoriteGenres2中所有元素是否在fg3中favoriteGenres2.isSuperset(of: fg3) // favoriteGenres2是否包括fg3中所有元素favoriteGenres2.isStrictSubset(of: fg3) // favoriteGenres2中所有元素是否在fg3中，并且两者不相同favoriteGenres2.isStrictSuperset(of: fg3) // favoriteGenres2是否包括fg3中所有元素，并且两者不相同favoriteGenres.isDisjoint(with: fg3) // favoriteGenres与fg3是否没有交集// 3 字典(Dictionaries)是无序的键值对的集。var namesOfIntegers = [Int: String]()namesOfIntegers[16] = &quot;sixteen&quot;namesOfIntegers = [:]var airports: [String: String] = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]var airports2 = [&quot;YYZ&quot;: &quot;Toronto Pearson&quot;, &quot;DUB&quot;: &quot;Dublin&quot;]airports.countairports.isEmptyairports[&quot;hongqiao&quot;] = &quot;shanghai&quot;airports.updateValue(&quot;nanjing&quot;, forKey: &quot;jichang&quot;)airports[&quot;jichang&quot;] = nil; //airports.remove(at: &quot;jichang&quot;)airports.keysairports.values// 遍历for (code, name) in airports &#123;&#125;for code in airports.keys &#123;&#125;]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-3：Strings and Characters]]></title>
    <url>%2F2017%2Fswift-3.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687/** Strings and Characters */// 1 字符串字面量(String Literals)&quot;Some string literal value&quot;// 2 初始化空字符串 (Initializing an Empty String)var emptyString = &quot;&quot;var anotherEmptyString = String()if emptyString.isEmpty &#123; print(&quot;Nothing to see here&quot;)&#125;// 3 字符串可变性(String Mutability)var variableString = &quot;Horse&quot;variableString += &quot; and carriage&quot;//let constantString = &quot;Highlander&quot;//constantString += &quot; and another Highlander&quot;// 4 字符串是值类型(Strings Are Value Types)// 在实际编译时，Swift 编译器会优化字符串的使用，使实际的复制只发生在绝对必要的情况下，这意味着您将字符串作为值类型的同时可以获得极高的性能。// 5 使用字符(Working with Characters)for character in &quot;Dog!?🐶&quot;.characters &#123; print(character)&#125;let exclamationMark: Character = &quot;!&quot; // `Character`是字符（注意也是双引号，不是单引号）let catCharacters: [Character] = [&quot;C&quot;, &quot;a&quot;, &quot;t&quot;, &quot;!&quot;, &quot;?&quot;]let catString = String(catCharacters) // 字符数组生成字符串// 6 连接字符串和字符 (Concatenating Strings and Characters)let string1 = &quot;Hello&quot;let string2 = &quot; there&quot;var welcome0 = string1 + string2welcome0 += string1welcome0.append(exclamationMark)// 7 字符串插值 (String Interpolation)// 插值字符串中写在括号中的表达式不能包含非转义双引号 (&quot;) 和反斜杠 (\)，并且不能包含回车或换行符。let multiplier = 3let message = &quot;\(multiplier) times 2.5 is \(Double(multiplier) * 2.5)&quot; // message is &quot;3 times 2.5 is 7.5&quot;// 8 Unicode// Swift的String和Character类型是完全兼容Unicode标准的。let dollarSign = &quot;\u&#123;24&#125;&quot; // Unicode 标量 U+0024let blackHeart = &quot;\u&#123;2665&#125;&quot; // Unicode 标量 U+2665let sparklingHeart = &quot;\u&#123;1F496&#125;&quot; // Unicode 标量 U+1F496// 可扩展的字形群集(Extended Grapheme Clusters)// 9 计算字符数量 (Counting Characters)welcome0.characters.count// 10 访问和修改字符串 (Accessing and Modifying a String)let greeting = &quot;Guten Tag!&quot;greeting[greeting.startIndex] // Ggreeting[greeting.index(before: greeting.endIndex)] // !greeting[greeting.index(after: greeting.startIndex)] // ulet index = greeting.index(greeting.startIndex, offsetBy: 6) // 从某个索引开始向后offsetBy的索引greeting[index]for index in greeting.characters.indices &#123; print(&quot;\(greeting[index]) &quot;, terminator: &quot;&quot;)&#125;// Inserting and Removingvar welcome = &quot;hello&quot;welcome.insert(&quot;!&quot;, at: welcome.endIndex) // welcome now equals &quot;hello!&quot;welcome.insert(contentsOf:&quot; there&quot;.characters, at: welcome.index(before: welcome.endIndex)) // welcome now equals &quot;hello there!welcome.remove(at: welcome.index(before: welcome.endIndex)) // welcome now equals &quot;hello there&quot;let range = welcome.index(welcome.endIndex, offsetBy: -6) ..&lt; welcome.endIndexwelcome.removeSubrange(range) // welcome now equals &quot;hello&quot;// 11 比较字符串 (Comparing Strings)// 12 字符串的 Unicode 表示形式(Unicode Representations of Strings)// 13 String的常见方法和属性welcome.characters // `String`没有继承`Sequence`，不能直接遍历，用 `String.characters`welcome.characters.countfor c in welcome.characters &#123;&#125;welcome.isEmptywelcome.startIndexwelcome.hashValuewelcome.hasPrefix(&quot;he&quot;) // 是否有前缀welcome.hasSuffix(&quot;!&quot;) // 是否有后缀welcome.lowercased() // 变成小写welcome.uppercased() // 变成大写]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-2：Basic Operators]]></title>
    <url>%2F2017%2Fswift-2.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** Basic Operators */// 1 赋值运算符(Assignment Operator)// 赋值操作并不返回任何值let b = 10var c = 5let (x, y) = (2, 5)// 2 算术运算符(Arithmetic Operators)1 + 25 - 32 * 310.0 / 2.5&quot;hello, &quot; + &quot;world&quot;// 溢出运算(如 a &amp;+ b )// 求余运算符(Remainder Operator)// a % b a = (b × 倍数) + 余数 倍数是整数，可以是负数9 % 4 // 1 9 = 4*2 + 1-9 % 4 // -1 -9 = 4*-2 + (-1)// 自增和自减运算 (最新版的swift已经去掉)// 一元负号运算符/一元正号运算符// 3 复合赋值(Compound Assignment Operators)// 复合赋值运算没有返回值var a = 1a += 2// 4 比较运算符(Comparsion Operators)1 == 11 &lt;= 22 &gt;= 11 &lt; 11 &gt; 2class A &#123; &#125;var obja = A()var objb = A()var objc = objaobja === objb // false 恒等 === 和不恒等 !== 只用来两个对象是否引用同一个对象实例obja !== objc // false// 5 三目运算符(Ternary Conditional Operator)true ? &quot;true&quot; : &quot;false&quot;// 6 空合运算符(Nil Coalescing Operator)var e: String?var f = &quot;我是fuck&quot;e ?? f // `e != nil ? e! : f` ， 可选类型`e`不是`nil`时，就`e!`,否则为`f`。（注意`??`前后要空格）// 7 区间运算符(Range Operators)for index in 1...5 &#123; print(&quot;\(index) * 5 = \(index * 5)&quot;)&#125;for index in 1..&lt;5 &#123; print(&quot;\(index) * 5 = \(index * 5)&quot;)&#125;// 逻辑运算(Logical Operators) 操作对象是逻辑布尔值var mybool = falsevar youbool = true!myboolmybool &amp;&amp; youboolmybool || youbool]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[以撸代码的形式学习Swift-1：The Basics]]></title>
    <url>%2F2017%2Fswift-1.html</url>
    <content type="text"><![CDATA[playground文件在andyRon/LearnSwift 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158/** The Basics */// 1 常量和变量(Constants and Variables)// 声明：常量 let 变量 varlet constants = 10var variables = 0// 多个声明var x = 0.0, y = 0.0, z = 0.0// 类型标注(type annotation)var welcomeMessage: String// 常量和变量的命名// 常量与变量名不能包含数学符号，箭头，保留的(或者非法的)Unicode 码位，连线与制表符。也不能以数字开头。// 常量与变量不能修改类型也不能互换// 使用反引号（`）来使用保留关键字let π = 3.14159let 你好 = &quot;你好世界&quot;let `let` = &quot;hihi&quot;// 输出常量和变量 `func print(_ items: Any..., separator: String = default, terminator: String = default)` 三种参数：输出项、分隔符、结束符print(1,`let`, separator: &quot;,&quot;, terminator: &quot;&lt;br/&gt;&quot;)print(x, y, z, `let`)// 字符串插值(string interpolation)print(&quot;The current value of constants is \(constants)&quot;)// 2 注释(Comment)// 单行注释/* /* 多行注释可以嵌套在其它的多行注释之中 */ */// 3 分号(Semicolons) 单行单挑语句不一定需要，单行多条语句必须let cat = &quot;?&quot;; print(cat)// 4 整数(Integers)// U代表无符号// Int类型与当前系统的位数相同UInt8.maxUInt8.minInt8.maxInt32.maxUInt32.maxInt64.maxUInt64.maxInt.max// 5 浮点数(Floating-Point Numbers)Double(11.1) // 64位Float(11.1) // 32位// 6 类型安全(type safe)和类型推断(type inference)let meaningOfLife = 42 // meaningOfLife 会被推测为 Int 类型let pi = 3.14159 // pi 会被推测为 Double 类型(优先选择 Double 而不是 Float )// 7 数值型字面量(Numeric Literals)// 整数字面量150b1111 // 二进制150o17 // 八进制150xf // 十六进制15// 浮点字面量1.025e2 // 1.025*10^21.025e-2 // 1.025*10^-20xbp3 // 11*2^30xbp-3 // 11*2^-30xC.3p0 // (12+3/16)*2^0100_000 // _增强可读性// 8 数值型类型转换(Numeric Type Conversion)// 整数转换let twoThousand: UInt16 = 2_000let one: UInt8 = 1let twoThousandAndOne = twoThousand + UInt16(one) // `UInt16`有一个构造器，接受`UInt8`类型的参数生成`UInt16`// 整数和浮点数转换let three = 3let pointOneFourOneFiveNine = 0.14159let pi2 = Double(three) + pointOneFourOneFiveNinelet integerPi = Int(pi2)let pi3 = 3 + 0.14159 // 字面量没有特定的类型，所以可以直接相加// 9 类型别名(type aliases)typealias AudioSample = UInt16AudioSample.max// 10 布尔值truefalse// 11 元组(tuples) 把多个值组合成一个复合值// 元组在临时组织值的时候很有用，但是并不适合创建复杂的数据结构。let http404Error = (404, &quot;Not Found&quot;) // 一个类型为 (Int, String) 的元组， 用于描述 HTTP 状态码let (statusCode, statusMessage) = http404Error // 元组的内容分解(decompose)let (justTheStatusCode, _) = http404Errorhttp404Error.0 // 下标访问let http200Status = (statusCode: 200, description: &quot;OK&quot;) // 给元组元素命名http200Status.description// 12 可选类型(optionals)// 声明一个可选常量或者变量但是没有赋值，它们会自动被设置为 nilvar optionalString: String? // optionalString的类型要么是String，要么是nillet possibleNumber = &quot;123&quot;let convertedNumber = Int(possibleNumber) // convertedNumber 被推测为可选的`Int`// if 语句以及强制解析// 使用 if 语句和 nil 比较来判断一个可选值是否包含值if convertedNumber != nil &#123; print(&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;) // `!`称为可选值的强制解析(forced unwrapping)&#125;// optionalString! 报错， 使用!来强制解析值之前，一定要确定可选包含一个非nil 的值。// 可选绑定(optional binding)if let actualNumber = Int(possibleNumber) &#123; // 如果`Int(possibleNumber)`强制解析的值不是nil，就赋值给actualNumber，并且语句为ture print(&quot;\&apos;\(possibleNumber)\&apos; has an integer value of \(actualNumber)&quot;)&#125; else &#123; print(&quot;\&apos;\(possibleNumber)\&apos; could not be converted to an integer&quot;)&#125;var someOptional: String? = &quot;some&quot;var someOtherOptional: String?if let constantName = someOptional, let anotherConstantName = someOtherOptional&#123; print(&quot;多个可选绑定可以用逗号分隔, 需要每一个语句都为true&quot;)&#125;// 隐式解析可选类型(implicitly unwrapped optionals): 一个可以自动解析的可选类型let possibleString: String? = &quot;An optional string.&quot;let forcedString: String = possibleString! // 需要惊叹号来获取值let assumedString: String! = &quot;An implicitly unwrapped optional string.&quot;let implicitString: String = assumedString // 不需要感叹号if assumedString != nil &#123; print(assumedString)&#125;// 13 错误处理func canThrowAnErrow() throws &#123; // 这个函数有可能抛出错误&#125;do &#123; try canThrowAnErrow() // 没有错误消息抛出&#125; catch &#123; // 有一个错误消息抛出&#125;enum myError: Error &#123; case OutOfCleanDishes case MissingIngredients&#125;func makeASandwich() throws &#123; // ... throw myError.OutOfCleanDishes&#125;do &#123; try makeASandwich()&#125; catch myError.OutOfCleanDishes &#123; // washDishes()&#125; catch myError.MissingIngredients&#123; // buyGroceries&#125;// 14 断言(assertion)let age = -3//assert(age &gt;= 0, &quot;A person&apos;s age cannot be less than zero&quot;)]]></content>
      <categories>
        <category>swift</category>
      </categories>
  </entry>
</search>
