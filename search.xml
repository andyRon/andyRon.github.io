<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初识Core ML：建立一个简单的图片内容识别应用]]></title>
    <url>%2F2017%2FIntroducing-Core-ML%2F</url>
    <content type="text"><![CDATA[参考：Introduction to Core ML: Building a Simple Image Recognition App Xcode 9 beta &amp; iOS11 beta &amp; Swift4 Core ML是一个能集成机器学习模型到app中的框架。 一、新建初始项目 新建项目CoreMLDemo，以single-view application template模板 建立如下如下UI 二、实现照相和获取图片库功能 遵守两个协议：class ViewController: UIViewController, UINavigationControllerDelegate, UIImagePickerControllerDelegate { 添加两个接口，并关联。 12@IBOutlet var imageView: UIImageView!@IBOutlet var classifier: UILabel! 实现两个Action 1234567891011121314151617181920@IBAction func camera(_ sender: Any) &#123; if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; let cameraPicker = UIImagePickerController() cameraPicker.delegate = self cameraPicker.sourceType = .camera cameraPicker.allowsEditing = false present(cameraPicker, animated: true, completion: nil)&#125;@IBAction func openLibrary(_ sender: Any) &#123; let picker = UIImagePickerController() picker.allowsEditing = false picker.delegate = self picker.sourceType = .photoLibrary present(picker, animated: true)&#125; 实现协议UIImagePickerControllerDelegate中的方法： 123func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil)&#125; 在Info.plist中添加📷使用请求，Privacy – Camera Usage Description and Privacy 三、集成Core ML Data Model 到Apple机器学习官网 Machine Learning下载Core ML models，目前有6个Model，识别图片的使用Inception v3。下载得到一个mlmodel结尾的文件，直接拖到项目中，会自动生成对应model名的swift的类文件，可以直接在代码中使用。 在ViewController.swift中引入Core ML:import CoreML 初始Inceptionv3: 12345var model: Inceptionv3!override func viewWillAppear(_ animated: Bool) &#123; model = Inceptionv3()&#125; 实现UIImagePickerControllerDelegate协议的imagePickerController(_:didFinishPickingMediaWithInfo)方法： 12345678910111213141516171819202122232425262728293031323334func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; picker.dismiss(animated: true) classifier.text = &quot;Analyzing Image...&quot; guard let image = info[&quot;UIImagePickerControllerOriginalImage&quot;] as? UIImage else &#123; return &#125; UIGraphicsBeginImageContextWithOptions(CGSize(width: 299, height: 299), true, 2.0) image.draw(in: CGRect(x: 0, y: 0, width: 299, height: 299)) let newImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() let attrs = [kCVPixelBufferCGImageCompatibilityKey: kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey: kCFBooleanTrue] as CFDictionary var pixelBuffer : CVPixelBuffer? let status = CVPixelBufferCreate(kCFAllocatorDefault, Int(newImage.size.width), Int(newImage.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer) guard (status == kCVReturnSuccess) else &#123; return &#125; CVPixelBufferLockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) let pixelData = CVPixelBufferGetBaseAddress(pixelBuffer!) let rgbColorSpace = CGColorSpaceCreateDeviceRGB() let context = CGContext(data: pixelData, width: Int(newImage.size.width), height: Int(newImage.size.height), bitsPerComponent: 8, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer!), space: rgbColorSpace, bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue) //3 context?.translateBy(x: 0, y: newImage.size.height) context?.scaleBy(x: 1.0, y: -1.0) UIGraphicsPushContext(context!) newImage.draw(in: CGRect(x: 0, y: 0, width: newImage.size.width, height: newImage.size.height)) UIGraphicsPopContext() CVPixelBufferUnlockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) imageView.image = newImage 使用Core ML在上面imagePickerController(_:didFinishPickingMediaWithInfo)方法最后添加： 1234guard let prediction = try? model.prediction(image: pixelBuffer!) else &#123; return&#125;classifier.text = &quot;I think this is a \(prediction.classLabel).&quot; 现在就可运行识别图片内容了，我已几个简单的做了实验，效果还可以： 能识别🐶的种类，哈巴狗pug 🍌应该相对而言简单： 朋友家的猫，我也不知道猫的种类，识别为波斯猫(Persian cat): 这个我就不知道是怎么识别为浓咖啡(espresso)的了🤔 当然识别相差比较奇怪的。小米手环识别成听诊器（stethoscope）😢 kindle识别不出😢😢😢 四、Core ML学习资源官方文档 official Core ML documentation WWDC 2017： Introducing Core ML Core ML in Depth 代码 CoreMLDemo （由于Inceptionv3.mlmodel比较大，我就没有上传到github上，到 Machine Learning拖到项目中即可） 本文作者: AndyRon]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Core ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github和hexo创建免费的静态个人博客网站]]></title>
    <url>%2F2017%2Fgithub-hexo%2F</url>
    <content type="text"><![CDATA[之前刚学编程，接触PHP时，出于学习的目的，兴致勃勃地买了域名、主机、学了Wordpress，找了主题，折腾了好久建了个网站，也写了一些文章，然后就没有然后了，这是从入门到放弃系列的典型案例。前段时间收到主机要到期的通知，正好我也接触到了简书，支持markdown，感觉蛮好，平常也习惯使用markdown格式记录笔记。就觉得不再续费主机了，就主要使用简书，个人博客就使用github和hexo这种支持markdown生成静态网页形式就行了。 已经有很多小伙伴这样搭建自己的个人博客，并写了相关文章，这边我就做一个搭建过程中的简单记录。开始之前需要安装git和nodejs，有github账号，程序员小伙伴一般都会有了，我就不啰嗦了。 关于GitHub PagesGitHub Pages原本是为托管在github上的项目提供介绍页面的一个功能，非常适合托管一些功能简单或者是静态页面的网站。考虑到访问速度，可以考虑国内的coding。 按照GitHub Pages步骤建立自己的GitHub Pages库。 hexohexo文档很详细，也有中文，很方便。 安装 hexonpm install hexo-cli -g 建站 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新生成的目录结构为： 123456789101112131415161718 . ├── _config.yml ├── node_modules ├── package.json ├── scaffolds ├── source └── themes ``` + `_config.yml` 是网站的[站点配置文件](https://hexo.io/zh-cn/docs/configuration.html) + `node_modules` 是nodejs库文件目录，就是`npm install`命令安装的文件位置 + `package.json`是程序信息 + `scaffolds` 新建文章的模板 + `source` 存放用户资源的地方，404、favicon、CNAME 等堵在此处，这是我们主要工作的地方。其中，`_posts`文件是写文章地方，除` _posts`文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹（之后生成），而其他文件会被拷贝过去。 + `themes` 是主题存储地方。- 配置网站信息`_config.yml` 文件提供了很多配置，详细可看官网[配置信息](https://hexo.io/zh-cn/docs/configuration.html)。先配置两方面的，之后需要再配置。 + 网站基本信息 Sitetitle: 欣欣向戎subtitle: AndyRon’s Blogdescription: Just for fun.author: AndyRonlanguage: zh-Hanstimezone: Asia/Shanghai 1+ 部署，注意字段，`repo`就是个人GitHub Pages的地址库。 DeploymentDocs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/andyRon/andyRon.github.io.gitbranch: master 1234567891011121314151617181920212223242526272829303132333435- 新建文章 `hexo new [layout] &lt;title&gt;` ： 也就是在`source/_posts/`下按照模板新建了一个markdown文件，layout就是指`scaffolds`文件夹中的模板，也可以直接在`_posts`中新建markdown文件。- 在本地服务器测试`hexo server` ：在浏览器打开http://localhost:4000/ ，就可以查看- 生成静态文件`hexo generate`（`hexo g`） ：这个命令会新建一个`public`文件夹，在其中生成静态文件，这个目录相当于网站的根目录。- 发布到github`hexo deploy`（`hexo d`）：把`public`文件夹内的内容上传到github上。现在访问https://yourname.github.io (我的是https://andyron.github.io )就能访问刚建立的网站了。如果出现[**ERROR Deployer not found**](https://github.com/hexojs/hexo/issues/1040)的问题，可通过`npm install hexo-deployer-git --save`解决。- 其他hexo命令`hexo clean` ：删除public文件夹内容，和清理一些缓存。调试网站可以使用。### 域名绑定（如有必要）- 在`source/`下添加文件`CNAME`，内容只为如`andyron.com`（没有http和www）- 部署到github上：`hexo generate`，`hexo deploy`- 域名解析。不同的域名服务商大同小异，我的是阿里云，为了防止解析出问题，我把其他默认一些邮件解析等都删了，就添加两个：![](http://upload-images.jianshu.io/upload_images/1678135-248c8a30a3115f53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)可能需要等一短时间（10分钟以上），就可以用 http://andyron.com 访问了。### hexo主题hexo有很多主题，很多网友为hexo贡献了很多主题，可到[主题](https://hexo.io/themes/)上寻找。我选择的是[next](https://github.com/iissnan/hexo-theme-next)主题，这个使用主题用的人比较多，[文档](http://theme-next.iissnan.com/getting-started.html)很全，也比较简洁。主题的使用非常简单： - 将主题文件拷贝至站点目录的`themes` 目录下 - 修改**站点配置文件**： `theme: 主题名`主题的一些设置：- 设置RSS + 安装 [hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed)插件，在`hexo init`初始化的目录下执行`npm install hexo-generator-feed --save` + 在**站点配置文件**添加： feed:type: atompath: atom.xmllimit: 20hub:content: 123456 + `hexo generate`- 设置搜索有很多搜索方式，这只是一种简单方式 + 安装`hexo-generator-searchdb`，在`hexo`的根目录下：`$ npm install hexo-generator-searchdb --save` + 在**站点配置文件**添加： search: path: search.xml field: post format: html limit: 10000 1+ 在**主题配置文件**（`themes/next/_config.yml`）修改： local_search: enable: true ``` 添加标签页面 $hexo new page tags：结果生成新文件夹source/tags/，并在其中有一个index.md。 在主题配置文件的menu中打开标签 添加分类页面 $hexo new page categories：结果生成新文件夹source/categories，并在其中有一个index.md。 在主题配置文件的menu中打开分类。 添加关于我页面 $hexo new page about：结果生成新文件夹source/about，并在其中有一个index.md，在index.md中直接编写关于我的内容。 在主题配置文件的menu中打开分类。 添加百度分析 注册 百度统计，并添加自己的网站 复制 hm.js? 后面那串统计脚本 id 在主题配置文件中添加字段baidu_analytics`，职位上面的脚本id 参考http://blog.csdn.net/zuoziji416/article/details/53204478 本文作者: AndyRon]]></content>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 传感器(一)：总的介绍和距离传感器]]></title>
    <url>%2F2017%2FiOS-Sensor-1%2F</url>
    <content type="text"><![CDATA[参考：1 https://www.zhihu.com/question/25526443/answer/310408872 iPhone这十年在传感器上的演进- 知乎专栏3 iOS开发之传感器4 扒一扒iPhone6的手机传感器5 非典型技术宅 的传感器系列文章 iOS传感器：实现一个随屏幕旋转的图片 关于传感器（Sensor），Apple官方好像并没有专门列出来介绍过，我只能从前辈的文章寻找，很多文章中都给iOS传感器进行过很详细的分类介绍，但有的传感器只是有过介绍，没有介绍使用方法或API，当然也有可能是我没搜索到，比如湿度传感器很多文章都提到，但详细使用方式就未曾看到过，还有这边的湿度传感器是指iPhone内部的？还是指iPhone所在外部环境的？ iPhone的传感器是经过长时间不停的变化和改进的，因为传感器一听名字就知道这种变化和改进十之八九是要与硬件有关系的。知乎中有一遍文章介绍的很详细，iPhone这十年在传感器上的演进- 知乎专栏。 iOS中传感器分类我姑且按照我查看的资料对iOS传感器进行一个不精确分类。 传感器类型 说明 加速计 Core Motion，感应设备的运动（摇一摇、计步器） 陀螺仪 Core Motion，感应设备的持握方式（赛车类游戏） 步数计 Core Motion 气压计 Core Motion 磁力计 Core Motion 距离传感器 感应是否有其他物体靠近设备屏幕（打电话自动屏） 环境光线传感器 感应周边环境光线的强弱（自动调节屏幕亮度） 内部温度传感器 感应设备内部的温度（提醒用户降温，防止损伤设备） 湿度传感器 感应设备是否进水（方便维修人员） 距离传感器和光线传感器知乎知友 Hi-iD 的答案介绍过这两个传感器的关系，本人简单总结如下： iPhone 5/5s/6之后光线/距离感应器就是iPhone顶部中心一个孔 光线传感器和距离传感器是两个独立的传感器，但两者都是对光作出反应。 距离传感器是基于红外光，距离传感器自身发射出的红外光，经外界反射后折回的红外光被距离传感器进行识别判断，所以距离传感器会有两个单元（反射和接收） 距离传感器的使用距离传感器的使用的使用相对简单：1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() UIDevice.current.isProximityMonitoringEnabled = true NotificationCenter.default.addObserver(self, selector: #selector(ViewController.sensorStateChange(notification:)), name: Notification.Name.UIDeviceProximityStateDidChange, object: nil) &#125; @objc func sensorStateChange(notification: NotificationCenter) &#123; if UIDevice.current.proximityState == true &#123; print(&quot;接近&quot;) &#125; else &#123; print(&quot;远离&quot;) &#125; &#125; 现在对iPhone顶部中心一个孔进行遮挡，就能感受的距离传感器。 Core MotionCore Motion是关于accelerometers(加速计), gyroscopes(陀螺仪), pedometers(步数计), magnetometers( 磁力计), and barometers(气压计)等5个传感器使用的框架， 暂时就按照字面意思翻译成核心运动框架。官方文档的介绍： Core Motion reports motion- and environment-related data from the onboard hardware of iOS devices, including from the accelerometers(加速计), gyroscopes(陀螺仪), pedometers(步数计), magnetometers( 磁力计), and barometers(气压计). You use this framework to access hardware-generated data so that you can use it in your app. For example, a game might use accelerometer and gyroscope data to control onscreen game behavior. 之后的文章就学习Core Motion的使用。😋 本文作者: AndyRon]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 13：手势处理]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-13%2F</url>
    <content type="text"><![CDATA[iOS手势处理由UIGestureRecognizer控制，不同手势有这个类的不同子类处理，不同手势处理有不同的相关属性。 子类 描述 UITapGestureRecognizer 点击手势 UIPanGestureRecognizer 跟着手移动手势 UIPinchGestureRecognizer 缩放手势 UIRotationGestureRecognizer 旋转手势 UISwipeGestureRecognizer 轻扫手势 UILongPressGestureRecognizer 长按手势 UIScreenEdgePanGestureRecognizer 屏幕边缘滑动手势 手势处理的步骤一般： 初始化手势，并添加到需要手势的View中 添加手势回调方法 UITapGestureRecognizer属性numberOfTapsRequired表示点击次数，属性numberOfTouchesRequired表示点击手指数。12345678910111213141516171819202122var isChange = false...let tap = UITapGestureRecognizer(target: self, action: #selector(ViewController.tap(tap:)))tap.numberOfTapsRequired = 2...imageView.addGestureRecognizer(tap)...@objc func tap(tap: UITapGestureRecognizer) &#123; let center = imageView.center if isChange &#123; imageView.frame.size.width /= 2 imageView.frame.size.height /= 2 imageView.center = center isChange = false &#125; else &#123; imageView.frame.size.width *= 2 imageView.frame.size.height *= 2 imageView.center = center isChange = true &#125;&#125; UIPanGestureRecognizer1let pan = UIPanGestureRecognizer(target: self, action: #selector(ViewController.pan(pan:))) 12345678910@objc func pan(pan: UIPanGestureRecognizer) &#123; if pan.state == .began || pan.state == .changed &#123; // 移动后的变化（变化值类似向量） let translation = pan.translation(in: imageView.superview) print(translation) imageView.center = CGPoint(x: imageView.center.x + translation.x, y: imageView.center.y + translation.y) // view移动后，把上一步的移动值变为0，否则移动值为递增 pan.setTranslation(CGPoint.zero, in: imageView.superview) &#125;&#125; UIRotationGestureRecognizerlet rotation = UIRotationGestureRecognizer(target: self, action: #selector(ViewController.rotation(rotation:))) 12345@objc func rotation(rotation: UIRotationGestureRecognizer) &#123; if rotation.state == .began || rotation.state == .changed &#123; imageView.transform = CGAffineTransform(rotationAngle: rotation.rotation) &#125;&#125; UISwipeGestureRecognizerlet swipe = UISwipeGestureRecognizer(target: self, action: #selector(ViewController.swipe(swipe:))) swipe.direction = .up swipe.numberOfTouchesRequired = 3 123@objc func swipe(swipe: UISwipeGestureRecognizer) &#123; print(&quot;扫的方向：\(swipe.direction),扫的手指数：\(swipe.numberOfTouchesRequired)&quot;)&#125; UILongPressGestureRecognizernumberOfTouchesRequired 长按的指头数minimumPressDuratio 长按最小时间（秒） let long = UILongPressGestureRecognizer(target: self, action: #selector(ViewController.long(long:))) long.numberOfTouchesRequired = 2 long.minimumPressDuration = 1 123@objc func long(long: UILongPressGestureRecognizer) &#123; print(&quot;长按手势，长按字头数为\(long.numberOfTouchesRequired)&quot;)&#125; UIScreenEdgePanGestureRecognizerlet screenEdge = UIScreenEdgePanGestureRecognizer(target: self, action: #selector(ViewController.screenEdage(screenEdage:))) screenEdge.edges = .left 123@objc func screenEdage(screenEdage: UIScreenEdgePanGestureRecognizer) &#123; print(&quot;屏幕边缘滑动手势：\(screenEdage.edges)&quot;)&#125; 详细代码： GestureDemo 本文作者: AndyRon]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>手势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 12：视频背景]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-12%EF%BC%9A%E8%A7%86%E9%A2%91%E8%83%8C%E6%99%AF%2F</url>
    <content type="text"><![CDATA[参考：BackgroundVideoiOS 新建项目 BackgroundVideoDemo 新建BackgroundVideo.swift文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import Foundationimport AVKitimport AVFoundationenum BackgroundVideoErrors: Error &#123; case invalidVideo&#125;class BackgroundVideo &#123; var isMuted = true private var player : AVPlayer? private var videoURL: URL? private var viewController: UIViewController? private var hasBeenUsed: Bool = false init (on viewController: UIViewController, withVideoURL URL: String) &#123; self.viewController = viewController // parse the video string to split it into name and extension let videoNameAndExtension:[String]? = URL.characters.split&#123;$0 == &quot;.&quot;&#125;.map(String.init) if videoNameAndExtension!.count == 2 &#123; if let videoName = videoNameAndExtension?[0] , let videoExtension = videoNameAndExtension?[1] &#123; if let url = Bundle.main.url(forResource: videoName, withExtension: videoExtension) &#123; self.videoURL = url // initialize our player with our fetched video url self.player = AVPlayer(url: self.videoURL!) &#125; else &#123; print(BackgroundVideoErrors.invalidVideo) &#125; &#125; &#125; else &#123; print(&quot;Wrong video name format&quot;) &#125; &#125; deinit&#123; if self.hasBeenUsed &#123; NotificationCenter.default.removeObserver(self, name: .AVPlayerItemDidPlayToEndTime, object: nil) NotificationCenter.default.removeObserver(self, name: .UIApplicationWillEnterForeground, object: nil) &#125; &#125; public func setUpBackground()&#123; self.player?.actionAtItemEnd = .none self.player?.isMuted = isMuted //add the video to your view .. let loginView: UIView = self.viewController!.view//get our view controllers view let playerLayer = AVPlayerLayer(player: self.player) playerLayer.videoGravity = AVLayerVideoGravityResizeAspectFill // preserve aspect ratio and resize to fill screen playerLayer.zPosition = -1 // set it&apos;s possition behined anything in our view playerLayer.frame = loginView.frame // set our player frame to our view&apos;s frame loginView.layer.addSublayer(playerLayer) // prevent video from disturbing audio services from other apps do &#123; try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryAmbient) &#125; catch &#123; print(&quot;failed setting AVAudioSession Category to AVAudioSessionCategoryAmbient&quot;) &#125; self.player?.play() // start the video /// 向通知中心发送视频结束后再次从头播放 NotificationCenter.default.addObserver(self, selector: #selector(self.loopVideo), name: .AVPlayerItemDidPlayToEndTime, object: nil) // 视频进入Foreground后从头播放 NotificationCenter.default.addObserver(self, selector: #selector(self.loopVideo), name: .UIApplicationWillEnterForeground, object: nil) self.hasBeenUsed = true &#125; // 循环播放视频 @objc private func loopVideo() &#123; self.player?.seek(to: kCMTimeZero) self.player?.play() &#125; &#125; 在所需要的视图控制器中定义变量var backgroundPlayer : BackgroundVideo?，然后再在viewDidLoad中定义： 12345678910 override func viewDidLoad() &#123; super.viewDidLoad() let backgroundPlayer = BackgroundVideo(on: self, withVideoURL: &quot;test.mp4&quot;) //是否打开静音// backgroundPlayer?.isMuted = false backgroundPlayer.setUpBackground() &#125; 详细代码： BackgroundVideoDemo 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 9：本地视频播放]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-9%EF%BC%9A%E6%9C%AC%E5%9C%B0%E8%A7%86%E9%A2%91%E6%92%AD%E6%94%BE%2F</url>
    <content type="text"><![CDATA[参考： 30DaysofSwift 新建项目PlayLocalVideo 在IB中使View ControllerEmbed In &gt; Navigation Controller,并在View Controller**中添加UITableView和UITableViewCell。 在上面的UITableViewCell的中添加一个UIImageView作为视频的预览图、一个UIButton作为开始播放、两个UILabel分别用于显示视频的名称和来源。并修改一定样式和添加一定约束 添加几张图片和一个视频 添加一个cell的类，并添加三个接口。12345class VideoCell: UITableViewCell &#123; @IBOutlet var previewImageView: UIImageView! @IBOutlet var nameLabel: UILabel! @IBOutlet var sourceLabel: UILabel! 添加一个video枚举，用来存储视频信息。 12345struct video &#123; let image: String let title: String let source: String&#125; 使ViewController符合table view代理和数据的协议，并实现所需方法： 12345678910111213141516171819202122232425func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; return 220 &#125; func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123; return 2 &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return data.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! VideoCell let video = data[indexPath.row] cell.previewImageView.image = UIImage(named: video.image) cell.nameLabel.text = video.title cell.sourceLabel.text = video.source return cell &#125; 引入播放视频所需框架，并定义相关变量。 1234567import AVFoundationimport AVKit... var playViewController : AVPlayerViewController? var playerView : AVPlayer? 实现视频播放按钮方法。 12345678910111213@IBAction func playVideo(_ sender: UIButton) &#123; let path = Bundle.main.path(forResource: &quot;KL&quot;, ofType: &quot;mp4&quot;) playerView = AVPlayer(url: URL(fileURLWithPath: path!)) playViewController = AVPlayerViewController() playViewController?.player = playerView present(playViewController!, animated: true, completion: &#123; self.playViewController?.player?.play() &#125;) &#125; 详细代码： PlayLocalVideo 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 10：UIScrollView滚动视图]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-10%EF%BC%9AUIScrollView%E6%BB%9A%E5%8A%A8%E8%A7%86%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[参考：Scroll View Tutorial in iOS8 with Swift知识点: UIScrollView 当视图超过屏幕大小时，可通过把视图放在UIScrollView中让视图可以上下滚动的功能。以一张大图片为例。 新建项目 ScrollViewTutorial 代码：12345678910111213141516171819202122class ViewController: UIViewController &#123; var imageView: UIImageView! var scrollView: UIScrollView! override func viewDidLoad() &#123; super.viewDidLoad() imageView = UIImageView(image: UIImage(named: &quot;strandvagen.jpg&quot;)) scrollView = UIScrollView(frame: view.bounds) scrollView.backgroundColor = UIColor.black scrollView.contentSize = imageView.bounds.size scrollView.addSubview(imageView) view.addSubview(scrollView) &#125; &#125; 详细代码：ScrollViewTutorial 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 11：照片横屏滑动]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-11%EF%BC%9A%E7%85%A7%E7%89%87%E6%A8%AA%E5%B1%8F%E6%BB%91%E5%8A%A8%2F</url>
    <content type="text"><![CDATA[参考：30DaysofSwift知识点： UICollectionView UIVisualEffectView UICollectionViewDataSource 新建项目Carousel Effect 在IB构建UI。Collection View 里的 Scroll Direction 设置成水平滚动。UIVisualEffectView是用来添加模糊效果的，也可以使用类似如下的代码构建： 1234let blurEffect = UIBlurEffect(style: .dark)let blurEffectView = UIVisualEffectView(effect: blurEffect)blurEffectView.frame = view.boundsbackgroundImageView.addSubview(blurEffectView) 创建数据类Interest 创建UICollectionViewCell 实现UICollectionViewDataSource的方法（有点类似UITableViewDataSource）。12345678910111213141516171819202122232425262728293031323334353637class ViewController: UIViewController, UICollectionViewDataSource &#123; @IBOutlet weak var backgroundImageView: UIImageView! @IBOutlet weak var collectionView: UICollectionView! var interests = Interest.createInterests() override func viewDidLoad() &#123; super.viewDidLoad() collectionView.dataSource = self collectionView.dataSource = self &#125; override var preferredStatusBarStyle : UIStatusBarStyle &#123; return UIStatusBarStyle.lightContent &#125; func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123; return 1 &#125; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return interests.count &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let CellIdentifier = &quot;InterestCell&quot; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CellIdentifier, for: indexPath) as! InterestCollectionViewCell cell.interest = self.interests[indexPath.item] return cell &#125;&#125; 详细代码： Carousel Effect 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Alamofire：Swift的HTTP 网络库]]></title>
    <url>%2F2017%2FAlamofire%EF%BC%9ASwift%E7%9A%84HTTP-%E7%BD%91%E7%BB%9C%E5%BA%93%2F</url>
    <content type="text"><![CDATA[安装 CocoaPods和Carthage都很方便安装安装完，如果出现加载不到Alamofire，可以查看Cannot load underlying module for ‘Alamofire’ #441，问题应该可以解决。 手动安装 下载Alamofire 将Alamofire.xcodeproj拖进到项目中 在“Embedded Binaries中添加 command + B 编译后就可以使用 关于 https://httpbin.org/ 网站 https://httpbin.org/ 网站可用来做http的各种请求测试使用，不过遗憾的是没有POST等提交类型请求的测试 基本使用一个简单的请求： 123import AlamofireAlamofire.request(&quot;https://httpbin.org/get&quot;) http中有请求(Request) 和 响应(Response)两个重要概念。大部分http框架，都会使用request和response作为方法名。看看Alamofire的request方法的详细参数： 12345678public func request( _ url: URLConvertible, method: HTTPMethod = .get, parameters: Parameters? = nil, encoding: ParameterEncoding = URLEncoding.default, headers: HTTPHeaders? = nil) -&gt; DataRequest&#123; 有url,method,parameters,encoding,headers五个参数，与http是相互对应的。其中只有url是必须的，其它都有默认值。 请求后的响应处理向http发送请求后，就需对响应结果进行处理。 Alamofire采用链式调用的方式处理响应，这种链式调用的方式最初应该是起源jQuery。响应处理的一般形式如下，response就是响应结果。 123Alamofire.request(&quot;https://httpbin.org/get&quot;).responseJSON &#123; response in&#125; Alamofire 提供了五种不同的响应处理： 123456789101112131415161718192021222324252627282930// Response Handler - Unserialized Responsefunc response( queue: DispatchQueue?, completionHandler: @escaping (DefaultDataResponse) -&gt; Void) -&gt; Self// Response Data Handler - Serialized into Datafunc responseData( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Data&gt;) -&gt; Void) -&gt; Self// Response String Handler - Serialized into Stringfunc responseString( queue: DispatchQueue?, encoding: String.Encoding?, completionHandler: @escaping (DataResponse&lt;String&gt;) -&gt; Void) -&gt; Self// Response JSON Handler - Serialized into Anyfunc responseJSON( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void) -&gt; Self// Response PropertyList (plist) Handler - Serialized into Anyfunc responsePropertyList( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void)) -&gt; Self 五种方法的参数不同，但最后一参数都是一个回调的闭包，都可以写成尾随闭包形式。除了response方法的回调参数是DefaultDataResponse，其它都是DataResponse: 1234567891011121314151617181920212223public struct DataResponse&lt;Value&gt; &#123; /// The URL request sent to the server. public let request: URLRequest? /// The server&apos;s response to the URL request. public let response: HTTPURLResponse? /// The data returned by the server. public let data: Data? /// The result of response serialization. public let result: Result&lt;Value&gt; /// The timeline of the complete lifecycle of the request. public let timeline: Timeline /// Returns the associated value of the result if it is a success, `nil` otherwise. public var value: Value? &#123; return result.value &#125; /// Returns the associated error value if the result if it is a failure, `nil` otherwise. public var error: Error? &#123; return result.error &#125; var _metrics: AnyObject? DataResponse与DefaultDataResponse最大的不同就是多了两个属性result和value，value值就是格式化的不同类型。 响应处理的一些例子 response 123456789Alamofire.request(&quot;https://httpbin.org/get&quot;).response &#123; response in print(&quot;Request: \(response.request)&quot;) print(&quot;Response: \(response.response)&quot;) print(&quot;Error: \(response.error)&quot;) if let data = response.data, let utf8Text = String(data: data, encoding: .utf8) &#123; print(&quot;Data: \(utf8Text)&quot;) &#125;&#125; response方法的响应结果response是DefaultDataResponse，没有进行过格式化处理。 responseData 12345678910 Alamofire.request(&quot;https://httpbin.org/get&quot;).responseData &#123; response in debugPrint(&quot;All Response Info: \(response)&quot;) if let data = response.result.value, let utf8Text = String(data: data, encoding: .utf8) &#123; print(&quot;Data: \(utf8Text)&quot;) &#125; &#125; ``` `responseData`方法对响应结果进行了处理，`response.result.value`就是我们属性的`Data`类型。+ 链式调用 Alamofire.request(&quot;https://httpbin.org/get&quot;) .responseString { response in print(&quot;Response String: \(response.result.value)&quot;) } .responseJSON { response in print(&quot;Response JSON: \(response.result.value)&quot;) } 1234### 响应验证http响应结果中的不同状态码(`100..&lt;600`)表示不同结果。- 手动验证 Alamofire.request(“https://httpbin.org/get“).validate(statusCode: 200..&lt;300).validate(contentType: [“application/json”]).responseData { response in switch response.result { case .success: print(&quot;Validation Successful&quot;) case .failure(let error): print(error) } } 12- 自动验证状态码在`200..&lt;300`的为正确，其它为错误。 Alamofire.request(“https://httpbin.org/get&quot;).validate().responseJSON { response inswitch response.result {case .success: print(&quot;Validation Successful&quot;) case .failure(let error): print(error) }} 123### HTTP不同请求方式`request`方法的`method`参数表示不同的方法。 Alamofire.request(“https://httpbin.org/get“) // method defaults to .get Alamofire.request(“https://httpbin.org/post“, method: .post)Alamofire.request(“https://httpbin.org/put“, method: .put)Alamofire.request(“https://httpbin.org/delete“, method: .delete)12345### 请求参数编码`GET`的参数按照固定格式写到URL中，其他类型则按照不同格式写到请求body中。- GET参数编码 let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;] // All three of these calls are equivalent Alamofire.request(&quot;https://httpbin.org/get&quot;, parameters: parameters) // encoding defaults to `URLEncoding.default` Alamofire.request(&quot;https://httpbin.org/get&quot;, parameters: parameters, encoding: URLEncoding.default) Alamofire.request(&quot;https://httpbin.org/get&quot;, parameters: parameters, encoding: URLEncoding(destination: .methodDependent)) // https://httpbin.org/get?foo=bar 1- POST参数编码 let parameters: Parameters = [ &quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: [&quot;a&quot;, 1], &quot;qux&quot;: [ &quot;x&quot;: 1, &quot;y&quot;: 2, &quot;z&quot;: 3 ] ] // All three of these calls are equivalent Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters) Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: URLEncoding.default) Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: URLEncoding.httpBody) // HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3 12- JSON编码 let parameters: Parameters = [ &quot;foo&quot;: [1,2,3], &quot;bar&quot;: [ &quot;baz&quot;: &quot;qux&quot; ] ] // Both calls are equivalent Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: JSONEncoding.default) Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: JSONEncoding(options: [])) // HTTP body: {&quot;foo&quot;: [1, 2, 3], &quot;bar&quot;: {&quot;baz&quot;: &quot;qux&quot;}} 12### 添加请求HTTP头部 let headers: HTTPHeaders = [ “Authorization”: “Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==”, “Accept”: “application/json”] Alamofire.request(“https://httpbin.org/headers“, headers: headers).responseJSON { response in debugPrint(response)} 12### HTTP认证 let user = &quot;user&quot; let password = &quot;password&quot; Alamofire.request(&quot;https://httpbin.org/basic-auth/\(user)/\(password)&quot;) .authenticate(user: user, password: password) .responseJSON { response in debugPrint(response) } 12### 下载文件 Alamofire.download(&quot;https://httpbin.org/image/png&quot;).responseData { response in if let data = response.result.value { let image = UIImage(data: data) } } 1另外可以下文件保存在本地： let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(&quot;pig.png&quot;) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(&quot;https://httpbin.org/image/png&quot;, to: destination).response { response in print(response) if response.error == nil, let imagePath = response.destinationURL?.path { let image = UIImage(contentsOfFile: imagePath) self.imageView.image = image self.tableView.reloadData() } } 123### 上传- 上传 `Data` let imageData = UIImagePNGRepresentation(image!)! Alamofire.upload(imageData, to: &quot;https://httpbin.org/post&quot;).responseJSON { response in debugPrint(response) } 1- 上传文件 let fileURL = Bundle.main.url(forResource: &quot;video&quot;, withExtension: &quot;mov&quot;) Alamofire.upload(fileURL!, to: &quot;https://httpbin.org/post&quot;).responseJSON { response in debugPrint(response) } 1- 上传Multipart Form Data（表单提交） Alamofire.upload( multipartFormData: { multipartFormData in multipartFormData.append(unicornImageURL, withName: &quot;unicorn&quot;) multipartFormData.append(rainbowImageURL, withName: &quot;rainbow&quot;) }, to: &quot;https://httpbin.org/post&quot;, encodingCompletion: { encodingResult in switch encodingResult { case .success(let upload, _, _): upload.responseJSON { response in debugPrint(response) } case .failure(let encodingError): print(encodingError) } } ) 12### 请求中花费的各种时间 Alamofire.request(“https://httpbin.org/get&quot;).responseJSON { response in print(response.timeline)}1结果： Timeline: { “Latency”: 1.527 secs, “Request Duration”: 1.528 secs, “Serialization Duration”: 0.001 secs, “Total Duration”: 1.529 secs }``` 本文作者：AndyRon]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 8：使用IBInspectable 和 IBDesignable定制UI]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-8%EF%BC%9A%E4%BD%BF%E7%94%A8IBInspectable%20%E5%92%8C%20IBDesignable%E5%AE%9A%E5%88%B6UI%2F</url>
    <content type="text"><![CDATA[参考：appcode网站的书《Intermediate iOS Programming with Swift》 的Chapter 36 例子代码：https://github.com/andyRon/LearniOSByProject/tree/master/77 理解IBInspectable 和 IBDesignable简单地说，IBInspectable 就是允许开发者在IB的属性检查器中添加额外的选项。IBDesignable 能够让 IBInspectable 添加的额外选项产生的变化在IB中实时显示。以Button的圆角为例说明。 正常情况下，Button的圆角需要代码：12button.layer.cornerRadius = 10.0button.layer.masksToBounds = true 或者直接在IB的Identity检查器的 user defined runtime attributes中添加： 注意到，这种修改不是实时，在IB中Button还是直角，只有运行后才是圆角。 以IBInspectable的方式。定义个继承至UIButton的类。12345678class RoundedCornerButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125;&#125; 然后把button的class属性修改成RoundedCornerButton: 发现这个button的属性检查器中多了Corner Radius。 注意： cornerRadius属性变成了Corner Radius，RoundedCornerButton类变成了 Rounded Corner Button，这是Xcode自动转变的，开发者只需要依照swift的命名规范就可以了（类名是大写开头的驼峰命名规则，属性名是小写开头的驼峰命名规则） cornerRadius的类型是CGFloat，在属性检查器中就对应数字的选择。当然不是所有类型都可以添加属性检查器中的，IBInspectable支持如下类型：12345678910IntCGFloat Double String Bool CGPoint CGSize CGRect UIColor UIImage 如果在类RoundedCornerButton前添加@IBDesignable，那在属性检查器中自定义的属性变化就可以在IB中实时显示了。12345678@IBDesignable class RoundedCornerButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125;&#125; 创建Fancy Button创建Fancy Button来更加深入的了解IBInspectable 和 IBDesignable 创建新项目FancyButton 下载图标，也可以随意图标，拖进asset catalog 新建类FancyButton，继承至UIButton 圆角，边宽，边的颜色。 更新FancyButton：1234567891011121314151617181920@IBDesignableclass FancyButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125; @IBInspectable var borderWidth: CGFloat = 0.0 &#123; didSet &#123; layer.borderWidth = borderWidth &#125; &#125; @IBInspectable var borderColor: UIColor = .black &#123; didSet &#123; layer.borderColor = borderColor.cgColor &#125; &#125;&#125; Title在FancyButton继续添加属性：1234567891011121314151617181920@IBInspectable var titleLeftPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.left = titleLeftPadding &#125;&#125;@IBInspectable var titleRightPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.right = titleRightPadding &#125;&#125;@IBInspectable var titleTopPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.top = titleTopPadding &#125;&#125;@IBInspectable var titleBottomPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.bottom = titleBottomPadding &#125;&#125; 通过圆角可创建圆形button Image Padding添加图片边距的属性：123456789101112131415161718192021@IBInspectable var imageLeftPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.left = imageLeftPadding &#125;&#125;@IBInspectable var imageRightPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.right = imageRightPadding &#125;&#125;@IBInspectable var imageTopPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.top = imageTopPadding &#125;&#125;@IBInspectable var imageBottomPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.bottom = imageBottomPadding &#125;&#125; 图片靠右对齐根据下图关系，应有imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding。 在FancyButton中添加如下代码： 123456789@IBInspectable var enableImageRightAligned: Bool = falseoverride func layoutSubviews() &#123; super.layoutSubviews() if enableImageRightAligned, let imageView = imageView &#123; imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding &#125;&#125; + `enableImageRightAligned`属性又来自动计算 `imageEdgeInsets.left` 颜色渐变添加三个@IBInspectable属性，并更新layoutSubviews:1234567891011121314151617181920@IBInspectable var enableGradientBackground: Bool = false@IBInspectable var gradientColor1: UIColor = UIColor.black@IBInspectable var gradientColor2: UIColor = UIColor.whiteoverride func layoutSubviews() &#123; super.layoutSubviews() if enableImageRightAligned, let imageView = imageView &#123; imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding &#125; if enableGradientBackground &#123; let gradientLayer = CAGradientLayer() gradientLayer.frame = self.bounds gradientLayer.colors = [gradientColor1.cgColor, gradientColor2.cgColor] gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5) gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5) self.layer.insertSublayer(gradientLayer, at: 0) &#125;&#125; 渐变色需要运行后才能看到 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DownGit：怎么下载github中某个文件夹？]]></title>
    <url>%2F2017%2FDownGit%EF%BC%9A%E6%80%8E%E4%B9%88%E4%B8%8B%E8%BD%BDgithub%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[怎么下载github中某个文件夹？ github只提供了整个项目。下载一个项目中的某个文件夹的内容，这种需求在使用github时，还是经常使用的。比如：在一些大的项目下，只想看某个文件的内容时。又比如，像我这种andyRon/LearniOSByProject，就是我一些学习iOS的小项目或者Demo的集合，如果只想查看某个小项目，而不下载整个项目时。 方法很简单，早就有前辈想到了，DownGit这个网站就提供这个功能，只要把目录链接（比如：https://github.com/andyRon/LearniOSByProject/tree/master/76）拷贝，然后点击download就可以下载目录的压缩文件。 本文作者：AndyRon]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS本地化(swift)]]></title>
    <url>%2F2017%2FiOS%E6%9C%AC%E5%9C%B0%E5%8C%96-swift%2F</url>
    <content type="text"><![CDATA[参考：【iOS】浅谈多语言本地化(国际化)3分钟实现iOS语言本地化/国际化（图文详解）What’s NSLocalizedString equivalent in Swift?Ask 示例代码在github上localizationsDemo 1 项目中需要配置的语言这就是项目中其他不同形式本地化可以添加的语种设置。 如下图为项目添加不同语种 弹框中显示要为两个Storyboard文件添加语种信息 添加完多语种后，相关需要本地化的文件会产生一组文件 实际在目录结构中是根据不同语言生成不同的*.lproj目录，再在*.lproj目录中生成了不同的.strings文件。 2 应用名称本地化App的名称在不同语种下显示不同。 新建一个.strings文件，名为InfoPlist.strings。 选中InfoPlist.strings，在右侧的文件检查器中点击Localize，在弹框中可以选择语种，对应项目中需要配置的语言中配置的语种。 可选中需要本地化的应用名称的语种： 在InfoPlist.strings的不同语种文件中添加字段CFBundleDisplayName，表示应用的名称。CFBundleDisplayName = &quot;简体中文名称&quot;; 在模拟器中，可通过Edit Scheme...编辑语种： 3 代码中的字符串的本地化类似应用名称本地化，代码中的字符串的本地也是利用.strings文件存储翻译信息。然后再在代码中利用NSLocalizedString（翻译信息默认在Localizable.strings文件）或NSLocalizedString(_:tableName:bundle:value:comment:)（翻译信息在tableName对应的.strings文件）文件标注。 NSLocalizedString(_:tableName:bundle:value:comment:)这种方式可根据需要把翻译信息保存在自定义的文件中，在多人开发时可以很好的防止冲突。 新建一个名为Localizable.strings的.strings文件。 类似InfoPlist.strings文件的配置方式，配置不同语种。 在代码中需要本地化的字符串修改为类似NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)或NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;) 4 图片的本地化这边所说的图片的本地化就是指，同一个名称图片，在不同语种下显示不同图片。 随意添加一张图片到项目，比如Swift_Logo.png 选中上面的图片，在右侧的文件检查器中点击Localize，类似之前的做法，添加所需的不同语种。 在Finder中的不同语种的*.lproj目录中添加，相同名字但不同的图片 在代码中添加类似的代码： self.imageView.image = UIImage(named: NSLocalizedString(&quot;Swift_Logo&quot;, comment: &quot;&quot;)) 最后的英文中的状态结果为： 5 优化本地化代码书写方式本地化时，NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)或NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;)这两种方法代码写法有点繁琐，参考stackoverflow中一个问题What’s NSLocalizedString equivalent in Swift?Ask的一个答案，扩展一下String：12345678910111213extension String &#123; var localized: String &#123; return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;&quot;) &#125; func localized(withComment:String) -&gt; String &#123; return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: &quot;&quot;, comment: withComment) &#125; func localized(tableName: String) -&gt; String&#123; return NSLocalizedString(self, tableName: tableName, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;&quot;) &#125;&#125; 然后，原本下面的写法：123self.label.text = NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)self.label2.text = NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;)self.imageView.image = UIImage(named: NSLocalizedString(&quot;Swift_Logo&quot;, comment: &quot;&quot;)) 就可以写成：123self.label.text = &quot;labelName&quot;.localizedself.label2.text = &quot;labelName&quot;.localized(tableName: &quot;andy&quot;)self.imageView.image = UIImage(named: &quot;Swift_Logo&quot;.localized) 本文作者：AndyRon]]></content>
  </entry>
  <entry>
    <title><![CDATA[Carthage的使用]]></title>
    <url>%2F2017%2FCarthage%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考：Carthage的安装和使用【译】Carthage的使用Carthage 初探：四大优势与四大劣势Carthage官方地址 Carthage与CocoaPods的简单比较 CocoaPods 的优势： 使用方便，除编写 Podfile 以外其他几乎都是自动完成； 软件包数量多，主流支持； CocoaPods 的缺点： 每次更新环境都需要连接到中心仓库，比较耗时； 开发者使用比较简单，但是如果创建兼容 CocoaPods 的库，就会相对繁琐一些（尽管有了命令行）； 每次干净编译都会把所有第三方库都重新编译一次（看似很正确，直到我遇见 Carthage…） Carthage 的优势 第三方库不是每一次都重新编译，节省时间； 去中心化，没有中心服务器，这意味着每次配置和更新环境，只会去更新具体的库，而不会有一个向中心服务器获取最新库的索引这么个过程，节省时间； 与 CocoaPods 无缝集成； 结构标准的项目天然就是 Carthage 库； 安装Carthagebrew install carthage 使用Carthage 进入项目文件夹，比如建立新项目 carthageDemo 创建空文件Cartfile，命令：touch Cartfile 编辑Cartfile文件(xcode，或其它文本编辑器)，以SVProgressHUD为例，Cartfile文件内容大致如下： 1github &quot;SVProgressHUD/SVProgressHUD&quot; ~&gt; 1.0 Cartfile文件格式说明: 依赖源有两种，github和git，就是告诉 Carthage到哪里下载第三方库，例子如下：1234567891011121314151617181920212223# Require version 2.3.1 or latergithub &quot;ReactiveCocoa/ReactiveCocoa&quot; &gt;= 2.3.1# Require version 1.xgithub &quot;Mantle/Mantle&quot; ~&gt; 1.0 # (1.0 or later, but less than 2.0)# Require exactly version 0.4.1github &quot;jspahrsummers/libextobjc&quot; == 0.4.1# Use the latest versiongithub &quot;jspahrsummers/xcconfigs&quot;# Use the branchgithub &quot;jspahrsummers/xcconfigs&quot; &quot;branch&quot;# Use a project from GitHub Enterprisegithub &quot;https://enterprise.local/ghe/desktop/git-error-translations&quot;# Use a project from any arbitrary server, on the &quot;development&quot; branchgit &quot;https://enterprise.local/desktop/git-error-translations2.git&quot; &quot;development&quot;# Use a local projectgit &quot;file:///directory/to/project&quot; &quot;branch&quot; 从上面的例子中有很详细的版本号例子： == 1.0 使用1.0版本 &gt;= 1.0 使用1.0或更高的版本 ~&gt; 1.0 使用高于1.0但低于2.0的最新版本 没有的是使用最新版本 branch名称/tag名称/commit名称 使用特定分支/标签/提交版本 运行Carthage carthage update [--platform iOS]--platform iOS是针对iOS的，可选项。在项目根目录下会生成一个Cartfile.resolved文件和Carthage文件夹，Carthage文件夹中的Build目录下有编译好的framework文件，Checkouts目录第三库的源文件。 把库添加到项目中 把编译好的framework文件拖动到Linked Frameworks and Libraries或者点击+选择。 在Build Phases中添加一个Run Script。命令为 /usr/local/bin/carthage copy-frameworks。Input Files下的条目为$(SRCROOT)/Carthage/Build/iOS/SVProgressHUD.framework。具体操作如下图： 编译就可以使用第三方库了 其他 新加库时在Cartfile文件中添加后，然后操作类似上面的 更新指定库：carthage update SVProgressHUD --platform iOS 本文作者：AndyRon]]></content>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习7：内存管理]]></title>
    <url>%2F2017%2FObjective-C%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A07%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[1 对象生命周期 诞生（通过alloc或new方法实现） -&gt; 生存（接收消息并执行操作） -&gt; 交友（通过复合以及向方法传递参数） -&gt; 死去（被释放掉） 引用计数(reference counting) / 保留计数(retain counting) alloc, new, copy: 创建对象，保留计数被设置为1 retain: 保留计数加1。如[[car retain] setTire: tire atIndex:2];表示要求car对象将其保留计数的值加1并执行setTire操作。 release: 保留计数减1 dealloc: 保留计数归0时自动调用 retainCount: 获得对象保留计数当前值1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &lt;Foundation/Foundation.h&gt;@interface RetainTracker : NSObject@end@implementation RetainTracker- (id) init&#123; if (self = [super init]) &#123; NSLog(@&quot;init: Retain count of %lu .&quot;, [self retainCount]); &#125; return self;&#125; // init- (void)dealloc&#123; NSLog(@&quot;dealloc called. Bye Bye.&quot;); [super dealloc];&#125; // dealloc@end // RetainTrackerint main(int argc, const char * argv[]) &#123; RetainTracker *a = [RetainTracker new]; [a retain]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a retain]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a release]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a release]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a release]; NSLog(@&quot;%lu&quot;, [a retainCount]); // 为什么此处是 1 不是 0吗？ return 0;&#125; 对象所有权(object ownership)如果一个对象内有指向其他对象的实例变量，则称 该对象拥有这些对象。 访问方法中的保留和释放所有对象放入池中 @autoreleasepool/NSAutoreleasePool： 自动释放池 NSObject提供autorelease方法：- (id) autorelease; 2 Cocoa的内存管理规则 3 异常与异常有关的关键字 @try @catch @finally @throw 捕捉不同类型的异常123456@try &#123;&#125; @catch (MyCustomException *custom) &#123;&#125; @catch (NSException *exception) &#123;&#125; @catch (id value) &#123;&#125; @finally &#123;&#125; 抛出异常抛出异常的两种方式： @throw异常名 向某个NSException对象发送raise消息1234NSException *theException = [NSException exceptionWithName: ...];@throw theException;[theException raise]; 区别：raise只对NSException对象有效，@throw异常名可用在其他对象上。 异常也需要内存管理异常和自动释放池 本文作者：AndyRon]]></content>
  </entry>
  <entry>
    <title><![CDATA[iOS-tutorial-7：解析XML(swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-7%EF%BC%9A%E8%A7%A3%E6%9E%90XML(swift)%2F</url>
    <content type="text"><![CDATA[参考：Parsing XML Tutorial 使用XMLParser解析XML文件，然后用table展示数据。 以Single View Application模板新建项目XMLParserTutorial。 删除SB中的View Controller，拖进一个Navigation Controller。选择新的View Controller为 “Is Initial View Controller”。设置Navigation Bar的title为Books。 新建一个继承至UITableViewController，名为TableViewController的控制器文件，并与SB的控制器关联。 新建一个xml文件Books.xml，用于之后解析，文件内容为: 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot;?&gt;&lt;catalog&gt; &lt;book id=&quot;1&quot;&gt; &lt;title&gt;To Kill a Mockingbird&lt;/title&gt; &lt;author&gt;Harper Lee&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;2&quot;&gt; &lt;title&gt;1984&lt;/title&gt; &lt;author&gt;George Orwell&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;3&quot;&gt; &lt;title&gt;The Lord of the Rings&lt;/title&gt; &lt;author&gt;J.R.R Tolkien&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;4&quot;&gt; &lt;title&gt;The Catcher in the Rye&lt;/title&gt; &lt;author&gt;J.D. Salinger&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;5&quot;&gt; &lt;title&gt;The Great Gatsby&lt;/title&gt; &lt;author&gt;F. Scott Fitzgerald&lt;/author&gt; &lt;/book&gt;&lt;/catalog&gt; 新建一个文件 Book.swift： 123456import Foundationclass Book &#123; var bookTitle: String = &quot;&quot; var bookAuthor: String = &quot;&quot;&#125; 在TableViewController中添加几个变量： 1234var books: [Book] = []var eName: String = &quot;&quot;var bookTitle = &quot;&quot;var bookAuthor = &quot;&quot; 在viewDidLoad方法中，添加读取XMl文件代码： 123456789override func viewDidLoad() &#123; super.viewDidLoad() if let path = Bundle.main.url(forResource: &quot;Books&quot;, withExtension: &quot;xml&quot;) &#123; if let parser = XMLParser(contentsOf: path) &#123; parser.delegate = self parser.parse() &#125; &#125; 添加Table View的数据源代理方法： 1234567891011121314151617override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return books.count&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) let book = books[indexPath.row] cell.textLabel?.text = book.bookTitle cell.detailTextLabel?.text = book.bookAuthor return cell&#125; 让TableViewController采纳XMLParserDelegate协议： class TableViewController: UITableViewController, XMLParserDelegate 实现XMLParserDelegate中的三个方法： 12345678910111213141516171819202122232425262728293031323334// 解析XMl元素开始时func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String] = [:]) &#123; print(&quot;开始 \(elementName)&quot;) eName = elementName if elementName == &quot;book&quot; &#123; bookTitle = &quot;&quot; bookAuthor = &quot;&quot; &#125;&#125;// 正在解析XMl元素func parser(_ parser: XMLParser, foundCharacters string: String) &#123; print(&quot;ing \(eName)&quot;) let data = string.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines) if (!data.isEmpty) &#123; if eName == &quot;title&quot; &#123; bookTitle += data &#125; else if eName == &quot;author&quot; &#123; bookAuthor += data &#125; &#125;&#125;// 结束解析XMl元素func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) &#123; print(&quot;结束 \(elementName)&quot;) if elementName == &quot;book&quot; &#123; let book = Book() book.bookTitle = bookTitle book.bookAuthor = bookAuthor books.append(book) &#125;&#125; 三个方法分别在XMl元素开始解析、正在解析、结束解析时调用，也就是说有很多元素时就不停在调用这三个方法。 代码XMLParserTutorial]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习6：Fondation-Kit介绍]]></title>
    <url>%2F2017%2FObjective-C%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A06%EF%BC%9AFondation-Kit%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[12macOS -&gt; Cocoa -&gt; Foundation, AppKitiOS -&gt; Cocoa Touch -&gt; Foundation, UIKit(UIView, UIController) Foundation框架的基础是CoreFoundation（C语言），如果函数或变量是以CF开头，就是CoreFoundation框架中的。 Foundation中一些有用的数据类型范围： NSRange1234typedef struct _NSRange &#123; NSUInteger location; NSUInteger length;&#125; NSRange; 表示相关事务的范围。有三种方式初始化： 直接给字段赋值： 123NSRange range;range.location = 12;range.length = 5; 应用C语言的聚合结构赋值：NSRange range = {17, 4} 函数NSMakeRange()：NSRange range3 = NSMakeRange(12, 5);这个方法的好处是可以在任何能够使用函数的地方直接使用：[anObject flarbulateWithRange: NSMakeRange(13, 15)]; 几何数据类型CG前缀，表示Core Graphics框架（C语言），用来进行2D渲染。 CGPoint表示坐标 12345struct CGPoint&#123; float x; float y;&#125; CGSize表示大小，用来存储长度和宽度 12345struct CGSize&#123; float width; float height;&#125; CGRect 表示矩形，由坐标和大小复合而成 12345struct CGRect&#123; CGPoint origin; CGSize size;&#125; 对应创建函数： CGPointMake(), CGSizeMake(), CGRectMake() 集合数据类型是C语言结构体而不是类，是考虑性能的原因。 字符串字符串类： NSString。 通过格式字符串和参数创建NSString： 12NSString *height;height = [NSString stringWithFormat:@&quot;%d, %d&quot;, 4, 3]; 类方法： 以+为起始符的。 字符长度，实例方法length： - (NSUInteger) length; 字符串比较 (BOOL)isEqualToString:(NSString *)aString;，表示字符串内容是否相同，返回BooL；==判断字符串的指针是否相同，也就是是否是同一个事务。 12345678910NSString *thing1 = @&quot;hello 5&quot;;NSString *thing2 = [NSString stringWithFormat:@&quot;hello %d&quot;, 5]; if ([thing1 isEqualToString:thing2]) &#123; NSLog(@&quot;两个字符串内容相同&quot;);&#125;if (thing1 == thing2) &#123; NSLog(@&quot;两个字符串是同一个对象&quot;);&#125; - (NSComparisonResult)compare:(NSNumber *)decimalNumber;，逐个比较字符串的每个字符，判断大小。返回一个枚举类型NSComparisonResult，三个枚举值分别表示左小于右，左等于右，左大于右。 - (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;，根据options的不同值有不同的功能。 字符串内是否还包含别的字符串检测字符串是否以另一个字符开头或结尾： 12- (BOOL)hasPrefix:(NSString *)str;- (BOOL)hasSuffix:(NSString *)str; 一个字符串在另一个字符串内的返回：- (NSRange)rangeOfString:(NSString *)searchString; 可变性NSString是不可变的。也就是一旦被创建，就不能以删除字符或添加字符的方式改变它。NSMutableString是NSString的子类，可以改变。 可通过类方法stringWithCapacity:来创建，表示分配一块内存用于存储字符串，+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;。NSMutableString *string = [NSMutableString stringWithCapacity:1]; appendString:和appendFormat: 添加字符串： 123NSMutableString *string = [NSMutableString stringWithCapacity:50];[string appendString:@&quot;Hello there &quot;];[string appendFormat:@&quot;human %d!&quot;, 39]; // Hello there human 39! deleteCharactersInRange: 删除字符串，经常和rangeOfString:一起使用。 12345NSMutableString *friends = [NSMutableString stringWithCapacity:50]; [friends appendString:@&quot;James BethLynn Jack Evan&quot;]; NSRange jackRange = [friends rangeOfString:@&quot;Jack&quot;]; jackRange.length++; [friends deleteCharactersInRange:jackRange]; // James BethLynn Evan 集合 NSArray两个限制：只能存储OC对象；不能存储nil。 创建类方法arrayWithObjects:(nil表示结束)：NSArray *array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;, nil];直接字面量：NSArray *array2 = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; 数组对象个数： [array count]; 按索引获取对象： 12[array objectAtIndex:1];array[1]; 字符串切分成数组，数组合并成字符串。 123NSMutableString *string2 = @&quot;oop:ack:bork:greeble:ponies&quot;; NSArray *chunks = [string2 componentsSeparatedByString:@&quot;:&quot;]; string2 = [chunks componentsJoinedByString:@&quot;:-)&quot;]; // oop:-)ack:-)bork:-)greeble:-)ponies NSMutableArrayNSArray包含的对象个数是不能变化的（包含的对象是可以变化的）。NSMutableArray是可以变化数目。 创建: + (instancetype)arrayWithCapacity:(NSUInteger)numItems; 末尾添加 - (void) addObject: (id) anObject; 删除特定索引的对象 - (void)removeObjectAtIndex:(NSIndexSet *)index; 枚举：对数组进行遍历。NSEnumerator 1234NSEnumerator *emumerator = [array objectEnumerator];while (id thingie = [emumerator nextObject]) &#123; &#125; 快速枚举 123for (NSString *string in array) &#123; NSLog()&#125; NSDictionary同样也有对应的NSMutableDictionary。 123456789101112131415161718 // 创建 NSDictionary Tire *t1 = [Tire new]; Tire *t2 = [Tire new]; Tire *t3 = [Tire new]; Tire *t4 = [Tire new]; NSDictionary *tires = [NSDictionary dictionaryWithObjectsAndKeys:t1, @&quot;front-left&quot;, t2, @&quot;front-right&quot;, t3, @&quot;back-left&quot;, t4, @&quot;back-right&quot;, nil];// NSDictionary *tires = @&#123;@&quot;front-left&quot;: t1, @&quot;front-right&quot;: t2, @&quot;back-left&quot;: t3,@&quot;back-right&quot;: t4,&#125;; // 访问特定key的对象 Tire *tire = [tires objectForKey:@&quot;back-right&quot;];// Tire *tire = tires[@&quot;back-right&quot;]; // 创建NSMutableDictionary NSMutableDictionary *tires_m = [NSMutableDictionary dictionaryWithCapacity:10];// NSMutableDictionary *tires_m = [NSMutableDictionary dictionary]; // 为NSMutableDictionary添加元素 [tires_m setObject:t1 forKey:@&quot;front-left&quot;]; // 从NSMutableDictionary中删除元素 [tires_m removeObjectForKey:@&quot;front-left&quot;]; 其他数据类型NSArray和NSDictionary只能存储对象，不能直接存储任何基本类型的数据，如int、float、和struct。 NSNumber NSValue NSNull]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习4：复合（composition）]]></title>
    <url>%2F2017%2FObjective-C%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A04%EF%BC%9A%E5%A4%8D%E5%90%88%EF%BC%88composition%EF%BC%89%2F</url>
    <content type="text"><![CDATA[复合: 对象间的组合（类中中包括类）composition在音乐中翻译为作曲：将多个组件组合在一起，配合使用，从而得到完整的作品。在OC中，复合是通过包含作为实例变量的对象指针实现的。1234567@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;* (void)print;@end //Car 自定义NSLog()NSLog()使用%@格式说明符表示输出对象，也就是NSLog()会给这个对象发送了description消息，然后对象的description方法生成一个NSString并将其返回。**在类中提供description方法就可以自定义NSLog()如何输出对象。123456789101112131415@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@&quot;I am a tire.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; Tire *tire = [Tire new]; NSLog(@&quot;%@&quot;, tire); // 输出 &quot;I am a tire.&quot; return 0;&#125; 存取方法 存取(accessor) 方法是用来读取或改变某个对象属性的方法。分为 getter方法 和 setter方法。 应该尽量使用对象提供的存取方法，不要直接改变对象里面的值。存取方法总是成对出现的。命名方式：setter方法在要更改属性的加上前缀set；getter方法直接是属性名称。 1234567891011@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 在OC中所有对象间的交互都是通过指针实现的。 复合还是继承继承的关系：“Is a”（是一个）。如三角形是一个形状，Slant6是一个发动机……复合的关系：“has a”（有一个）。如形状有个填充颜色，汽车有个发动机和四个轮胎…… 详细代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@&quot;I am a tire.&quot;);&#125;@end@interface Engine : NSObject@end //Engine@implementation Engine- (NSString *)description &#123; return (@&quot;I am a Engine.&quot;);&#125; //description@end@interface Slant6 : Engine@end //slant-6型号的发动机@implementation Slant6- (NSString *)description &#123; return (@&quot;I am a slant-6型号的发动机.VROOM!&quot;);&#125;@end@interface AllWeatherRadial : Tire@end // 新型轮胎@implementation AllWeatherRadial-(NSString *)description&#123; return (@&quot;I am a tire for rain or shine.&quot;);&#125;@end@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car@implementation Car- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@&quot;%@&quot;, engine); NSLog(@&quot;%@&quot;, tires[0]); NSLog(@&quot;%@&quot;, tires[1]); NSLog(@&quot;%@&quot;, tires[2]); NSLog(@&quot;%@&quot;, tires[3]);&#125;@endint main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习3：继承(inheritance)]]></title>
    <url>%2F2017%2FObjective-C%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A03%EF%BC%9A%E7%BB%A7%E6%89%BF(inheritance)%2F</url>
    <content type="text"><![CDATA[为何使用继承 UML(Unified Modeling Language, 统一建模语言) 是一种用图表来表示类、类的内容以及它们之间关系。 将重复的代码合并到一处。 继承的语法格式 只能继承一个 只有代码精简，bug才无处藏身 没有声明实例变量时可以省略花括号 相关术语 refactoring (重构) superclass parent class subclass child class override 继承的工作机制OOP一个强大之处：可以对一个程序做一些重大改变，程序仍然可以正常运行。 方法调度：当代码发送信息时，将在当前的类中搜索相应方法，如果无法在接收消息的对象的类文件中找到相应的文件，就会在该对象的超类中进行查找。 实例变量 在创建一个新类时，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。 polymorphism(多态性) self：指向接收消息的对象的指针 重写方法 super 调用继承的方法可以确保获得方法实现的所有特性]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习2：面向对象编程的基础知识]]></title>
    <url>%2F2017%2FObjective-C%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A02%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[间接(indirection) “只要再多添加一层间接，计算机科学中就没有解决不了的问题。” 例子 电话薄 让他人代替你自己去完成工作 编写一段代码来查询其他代码，并通过它继续访问另一层代码。 推诿 变量与间接 使用文件名的间接 在面向对象编程中使用间接 使用间接来调用代码，不是直接调用某个函数，而是间接调用。 过程式编程(Procedual Programming) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kCircle, kRectangle, kEgg,&#125; ShapeType;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//图形结构typedef struct &#123; ShapeType type; ShapeColor fillColor; ShapeRect bounds;&#125; Shape;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @&quot;red&quot;; break; case kGreenColor: return @&quot;green&quot;; break; case kBlueColor: return @&quot;blue&quot;; break; &#125; return @&quot;no clue&quot;;&#125;//绘制图形void drawCircle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawRectangle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Rectangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawEgg(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Egg at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawShapes(Shape shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; switch (shapes[i].type) &#123; case kCircle: drawCircle(shapes[i].bounds, shapes[i].fillColor); break; case kRectangle: drawRectangle(shapes[i].bounds, shapes[i].fillColor); break; case kEgg: drawEgg(shapes[i].bounds, shapes[i].fillColor); break; default: break; &#125; &#125;&#125;int main(int argc, const char * argv[]) &#123; Shape shapes[3]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0].type = kCircle; shapes[0].fillColor = kRedColor; shapes[0].bounds = rect0; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1].type = kRectangle; shapes[1].fillColor = kGreenColor; shapes[1].bounds = rect1; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2].type = kEgg; shapes[2].fillColor = kBlueColor; shapes[2].bounds = rect2; drawShapes(shapes, 3); return 0;&#125; 修改过去正常工作的代码很可能会引入新的错误。建立在函数之上，数据为函数服务。代码例子 3.2.1 Shapes-Procedural 面向对象编程 以数据为中心，函数为数据服务 代码例子 3.2.2 Shapes-Object id是一种泛型，可以用来引用任何类型的对象(id实际上是一个指向结构体的指针)。 方括号在OC中其他意义：用于通知某个对象该去做什么。[shape draw];表示通知shape对象执行draw操作 发送消息（调用方法）：通知对象执行某种操作。 类是一种能够实例化成对象的结构体。 如果在运行时改变某个类，则该类的所有对象自动继承这些变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @&quot;red&quot;; break; case kGreenColor: return @&quot;green&quot;; break; case kBlueColor: return @&quot;blue&quot;; break; &#125; return @&quot;no clue&quot;;&#125;@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Rectangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Rectangle@implementation Rectangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Rectangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Egg : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Egg@implementation Egg- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Egg at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end// 补充一个三角形@interface Triangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Triangle@implementation Triangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Triangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@endvoid drawShapes(id shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; id shape = shapes[i]; [shape draw]; &#125;&#125;int main(int argc, const char * argv[]) &#123; id shapes[4]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0] = [Circle new]; [shapes[0] setBounds:rect0]; [shapes[0] setFillColor:kRedColor]; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1] = [Rectangle new]; [shapes[1] setBounds:rect1]; [shapes[1] setFillColor:kGreenColor]; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2] = [Egg new]; [shapes[2] setBounds:rect2]; [shapes[2] setFillColor:kBlueColor]; ShapeRect rect3 = &#123;3, 4, 5, 0&#125;; shapes[3] = [Triangle new]; [shapes[3] setBounds:rect3]; [shapes[3] setFillColor:kBlueColor]; drawShapes(shapes, 4); return 0;&#125; 有关术语 class object instance message method method dispatcher interface implementation OC中的OOP12345678910111213141516171819202122232425262728293031@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end``` 1. `@interface` OC编译器需要一些有关类的信息 + `@` 可以看成是对C语言的扩展 + **instance variable**(实例变量) ： `@interface`下的花括号的内容： { @private ShapeColor fillColor; ShapeRect bounds;} 1+ **method declaration**(方法声明)。有点像C语言中的函数原型。`-`表示对象方法，`+`表示类方法。`(void)`表示返回类型。 - (void) setFillColor: (ShapeColor) fillColor; - (void) setBounds: (ShapeRect) bounds; - (void) draw; ``` + **infix notation**(中缀符) ： *方法的名称及其参数都是合在一起的* `[circle setFillColor: kRedColor]` 表示调用带一个参数的方法 + 如果方法使用参数，则需要冒号，否则不需要冒号 + 提倡@end语言后添加注释来注明类的名称 @implementation @implementation中可以定义在@interface中声明过和没有声明过的方法 OC中不存在真正的私有方法 实例化对象 instantiation（实例化） [Circle new] 发送new消息 软件实体应该对扩展开放，而对修改关闭。 —- 开放/关闭原则(Bertrand Meyer)]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习5：源文件组织]]></title>
    <url>%2F2017%2FObjective-C%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A05%EF%BC%9A%E6%BA%90%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87%2F</url>
    <content type="text"><![CDATA[将程序拆分为多个小文件有助于更快地找到重要的代码，而且其他人在查看项目时也能有个大致的了解。 拆分接口和实现根据@interface和@implementation，OC的代码通常放在两种文件里： 接口部分(.h)：类的@interface指令、公共struct定义、enum常量、#defines和extern全局变量等。 实现部分(.m): 类的@implementation指令、全局变量的定义、私有struct等。 另外，复杂的项目可以拥有多个目标，它们源文件的配置各不相同，构建规则也不同。群组关系仅仅是有Xcode负责管理的一项奇妙的功能。 拆分Car程序 #import 带尖号的是导入系统头文件(只读)，如#import &lt;Foundation/Foundation.h&gt;；双引号是项目本地的代码文件，如#import &quot;Engine.h&quot;。 拆分上一篇中的Car程序首先拆分继承自NSObject的类：Tire和Engine。 1234567// Tire.h#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end 1234567891011// Tire.m#import &quot;Tire.h&quot;@implementation Tire//#pragma mark -- (NSString *)description &#123; return (@&quot;I am a Tire.&quot;);&#125; //description@end 1234567// Engine.h#import &lt;Foundation/Foundation.h&gt;@interface Engine : NSObject@end 12345678// Engine.m#import &quot;Engine.h&quot;@implementation Engine- (NSString *)description &#123; return (@&quot;I am a Engine.&quot;);&#125; //description@end 使用跨文件依赖关系 @class 是告诉编译器：“这是一个类，只会通过指针来引用它，不需要关注此类的更多信息”。可减少必须导入的头文件的数量，从而缩短编译时间。拆分Car类： 1234567891011121314// Car.h#import &lt;Foundation/Foundation.h&gt;@class Engine;@class Tire;@interface Car : NSObject- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Car.m#import &quot;Car.h&quot;#import &quot;Tire.h&quot;#import &quot;Engine.h&quot;@implementation Car&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@&quot;%@&quot;, engine); NSLog(@&quot;%@&quot;, tires[0]); NSLog(@&quot;%@&quot;, tires[1]); NSLog(@&quot;%@&quot;, tires[2]); NSLog(@&quot;%@&quot;, tires[3]);&#125;@end //Car 编译器需要先知道所有关于超类的信息才能成功地为其子类编译@interface部分。拆分Slant6和AllWeatherRadial： 1234567// Slant6.h#import &quot;Engine.h&quot;@interface Slant6 : Engine@end 123456789// Slant6.m#import &quot;Slant6.h&quot;@implementation Slant6- (NSString *)description &#123; return (@&quot;I am a slant-6.VROOM!&quot;);&#125;@end 1234567// AllWeatherRadial.h#import &quot;Tire.h&quot;@interface AllWeatherRadial : Tire@end 12345678910// AllWeatherRadial.m#import &quot;AllWeatherRadial.h&quot;@implementation AllWeatherRadial-(NSString *)description&#123; return (@&quot;I am a tire for rain or shine.&quot;);&#125;@end 最后是main.m文件：123456789101112131415161718192021222324// main.m#import &lt;Foundation/Foundation.h&gt;#import &quot;Car.h&quot;#import &quot;Tire.h&quot;#import &quot;Engine.h&quot;#import &quot;Slant6.h&quot;#import &quot;AllWeatherRadial.h&quot;int main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习1：对C的扩展]]></title>
    <url>%2F2017%2FObjective-C%2FOC%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01%EF%BC%9A%E5%AF%B9C%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[分析最简单的Hello Objective-C程序1234567#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;Hello, World!&quot;); return 0;&#125; // main OC本质上就是C语言，它用来声明main()和返回数值的语法和C语言是一样的。 扩展名.m代表message 与C类似，OC使用头文件来包含结构体、符号常量和函数原型等元素的声明。 #import类似于C的#include，但#import可保证头文件只被包含一次。 #import &lt;Foundation/Foundation.h&gt;语句告诉编译器查找Foundation框架中的Foundation.h头文件。 int argc, const char * argv[]中 argc是指命令行参数个数，argv[0]是指可执行文件的路径，argv[1]是指命令行第一个参数，argv[2]是指命令行第二个参数，以此类推。 框架 ：一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。 如Cocoa,Carbon,QuickTime,OpenGL Cocoa包括Foundation和Application Kit(AppKit) 每一个框架都有一个主头文件，它包含了框架内所有的头文件。 Foundation的头文件 1MB 14000行 100多文件 。通过#import &lt;Foundation/Foundation.h&gt; 就获得了整个集合 Xcode使用预编译头文件（一种经过压缩的，摘要形式的头文件）来加快读取速度。 NSLog()和@”字符串” NS前缀是NextSTEP（很早之前苹果公司收购的公司） NSLog()类似于C的printf() @符号是Objective-C在标准C语言基础上添加的特性，意味着引号内的字符串应作为Cocoa的NSString元素来处理 @符号可以看成之后是对C语言的扩展 布尔类型OC中的布尔值YES是1， NO是0，是与C语言中不同的。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 6：使用Quick Look框架预览文件(Swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-6%EF%BC%9A%E4%BD%BF%E7%94%A8Quick-Look%E6%A1%86%E6%9E%B6%E9%A2%84%E8%A7%88%E6%96%87%E4%BB%B6-Swift%2F</url>
    <content type="text"><![CDATA[参考 Using Quick Look Framework for Previewing Documents iOS SDK中有很多不常见，却非常好用的库，Quick Look框架就是一个非常好的例子。Quick Look框架提供了预览很多不同类型文件的功能，而不需要打开不同的APP查看，有点像Mac中的空格键功能。 Quick Look框架可以预览的文件类型： iWork documents (Pages, Numbers and Keynote) Microsoft Office documents (as long as they’ve been created with Office 97 or any other newer version) PDF files Images Text files Rich-Text Format documents Comma-Separated Value files (csv) 开始项目到开始项目处下载开始项目，这是原文提供了一个开始项目，代码是老版本的，需要转换一下。这个开始项目中包括了六种不同的类型的文件，一个navigation controller，一个table view controller（FileListViewController），另外还做了一些初始化工作。之后代码就在FileListViewController中完成。 文件和文件的URLS 在FileListViewController中定义一个文件名字的数组变量：let fileNames = [&quot;AppCoda-PDF.pdf&quot;, &quot;AppCoda-Pages.pages&quot;, &quot;AppCoda-Word.docx&quot;, &quot;AppCoda-Keynote.key&quot;, &quot;AppCoda-Text.txt&quot;, &quot;AppCoda-Image.jpeg&quot;] 继续定义一个数组变量，用户存储不同的文件的URL：var fileURLs = [NSURL]() 创建一个方法prepareFileURLs()，用于为fileURLs添加值： 123456789101112func prepareFileURLs() &#123; for file in fileNames &#123; // 1 let fileParts = file.components(separatedBy: &quot;.&quot;) if let fileURL = Bundle.main.url(forResource: fileParts[0], withExtension: fileParts[1]) &#123; // 2 if FileManager.default.fileExists(atPath: fileURL.path) &#123; fileURLs.append(fileURL as NSURL) &#125; &#125; &#125;&#125; 1 components(separatedBy:)方法用于把String按照给定的分隔符，分解成[String]。 2 判断文件地址是否真实存在。 在 viewDidLoad()中实现上面的函数： 12345override func viewDidLoad() &#123; ... prepareFileURLs()&#125; 展示文件用table view展示不同的文件： 根据文件的URL，获得文件名和文件后缀（文件类型），添加函数extractAndBreakFilenameInComponents(:)。 12345678910func extractAndBreakFilenameInComponents(fileURL: NSURL) -&gt; (fileName: String, fileExtension: String) &#123; let fileURLParts = fileURL.path!.components(separatedBy: &quot;/&quot;) let fileName = fileURLParts.last let filenameParts = fileName?.components(separatedBy: &quot;.&quot;) return (filenameParts![0], filenameParts![1])&#125; 修改 tableView(tableView:cellForRowAtIndexPath)： 123456789func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCellWithIdentifier(&quot;idCellFile&quot;, forIndexPath: indexPath) let currentFileParts = extractAndBreakFilenameInComponents(fileURLs[indexPath.row]) cell.textLabel?.text = currentFileParts.fileName return cell&#125; 根据不同的后缀名，定义不同的文件类型名称，添加函数getFileTypeFromFileExtension(:)： 12345678910111213141516171819202122232425func getFileTypeFromFileExtension(fileExtension: String) -&gt; String &#123; var fileType = &quot;&quot; switch fileExtension &#123; case &quot;docx&quot;: fileType = &quot;Microsoft Word document&quot; case &quot;pages&quot;: fileType = &quot;Pages document&quot; case &quot;jpeg&quot;: fileType = &quot;Image document&quot; case &quot;key&quot;: fileType = &quot;Keynote document&quot; case &quot;pdf&quot;: fileType = &quot;PDF document&quot; default: fileType = &quot;Text document&quot; &#125; return fileType&#125; 回到tableView(tableView:cellForRowAtIndexPath)，添加一段cell配置： cell.detailTextLabel?.text = getFileTypeFromFileExtension(fileExtension: currentFileParts.fileExtension) 修改每个section中row的数目为文件数目： 123func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return fileNames.count&#125; QLPreviewControllerDataSource 引入框架Quick Look import QuickLook 定义QLPreviewController let quickLookController = QLPreviewController() 让FileListViewController实现QLPreviewControllerDataSource协议 实现QLPreviewControllerDataSource协议的必须要实现的方法。第一方法表示有多少个文件需要预览： 123func numberOfPreviewItems(in controller: QLPreviewController) -&gt; Int &#123; return fileURLs.count&#125; 第二个方法：123func previewController(_ controller: QLPreviewController, previewItemAt index: Int) -&gt; QLPreviewItem &#123; return fileURLs[index]&#125; 在viewDidLoad()中添加：quickLookController.dataSource = self 预览文件在table view中选中文件，就要跳转的预览页面。实现方法tableView(_:didSelectRowAt:)：123456func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; if QLPreviewController.canPreview(fileURLs[indexPath.row]) &#123; quickLookController.currentPreviewItemIndex = indexPath.row navigationController?.pushViewController(quickLookController, animated: true) &#125; &#125; navigationController?.pushViewController(quickLookController, animated: true)可用presentViewController(quickLookController, animated: true, completion: nil)代替。 运行可预览文件： 观察上图，可发现 Quick Look Preview Controller自带了toolbar，左边一个是分享按钮(通过UIActivityViewController实现的)，右边一个是类似目录功能，当有很多预览文件时，来跳转到不同预览文件。 代码QuickLookDemo 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 4：CALayer介绍(swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-4%EF%BC%9ACALayer%E4%BB%8B%E7%BB%8D-swift%2F</url>
    <content type="text"><![CDATA[参考 A Beginner’s Guide to CALayer Layers是Core Animation Framework的一部分。Core Animation Framework在iOS架构的位置： 访问CALayer凡是继承至UIView的都将有一个属性layer来表示CALayer。myView.layer 初始化项目 新建CALayerDemo，single View Application模板 新建一个UIView和一个UILabel 圆角CALayer的cornerRadius属性大小表示UIView圆角处圆的半径大小。类似于box.layer.cornerRadius = 20，就形成了圆角，数字越大圆角效果越大，当cornerRadius等于box半径时，box就会变成一个园。 阴影效果1234box.layer.shadowOffset = CGSize(width: 5, height: 5)box.layer.shadowOpacity = 0.7box.layer.shadowRadius = 10box.layer.shadowColor = UIColor.blue.cgColor shadowOffset表示阴影偏移大小，也就是阴影向box的下放偏移5和向右方偏移5距离。 shadowOpacity是阴影透明度 shadowRadius是阴影涉及的半径，并且这个半径越大，阴影的颜色深浅就会越来越小。shadowRadius与shadowOffset是共同作用的 设置边的宽度和颜色12box.layer.borderColor = UIColor.black.cgColorbox.layer.borderWidth = 3 展示图片123box.layer.contents = UIImage(named: &quot;tree.jpg&quot;)?.cgImagebox.layer.contentsGravity = kCAGravityResizebox.layer.masksToBounds = true CALayer的contents属性是open var contents: Any?，可以设置为图片 contentsGravity设置成kCAGravityResize，表示contents的内容会调整大小以适应layer。如果设置成其他值可能出现大小不适的形象，比如kCAGravityBottomRight，将是： masksToBounds为true表示按照layer的边框范围显示内容；如果是false，将会是如下结果 背景颜色和透明度12box.layer.backgroundColor = UIColor.green.cgColorbox.layer.opacity = 0.5 代码CALayerDemo 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 5：关于地理定位和特定区域(Swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-5%EF%BC%9A%E5%85%B3%E4%BA%8E%E5%9C%B0%E7%90%86%E5%AE%9A%E4%BD%8D%E5%92%8C%E7%89%B9%E5%AE%9A%E5%8C%BA%E5%9F%9F-Swift%2F</url>
    <content type="text"><![CDATA[参考 Building a Geo Targeting iOS App in Swift 用户带着iPhone进入某个区域，并在某些区域待多久在开发肯能会有很大用处。 初始化项目 创建新的项目GeoTargeting，使用Single View Appliction模板 添加一个Map View，大小为整个页面 添加相关outlet 实现两个协议 123class ViewController: UIViewController, MKMapViewDelegate, CLLocationManagerDelegate &#123; @IBOutlet weak var mapView: MKMapView! 设置CLLocationManager和MKMapView。 1234567891011121314151617// 1let locationManager = CLLocationManager()override func viewDidLoad() &#123; super.viewDidLoad() // 2 locationManager.delegate = self locationManager.distanceFilter = kCLLocationAccuracyNearestTenMeters locationManager.desiredAccuracy = kCLLocationAccuracyBest // 3 mapView.delegate = self mapView.showsUserLocation = true mapView.userTrackingMode = .follow setupData() &#125; 1 创建一个CLLocationManager的实例，用于检测用户的位置变化 2 设置locationManager一些参数，确定精确性 在viewDidAppear中核查用户授权状态1234567891011121314151617override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) let authorizationStatus = CLLocationManager.authorizationStatus() // 1 if authorizationStatus == .notDetermined &#123; locationManager.requestAlwaysAuthorization() &#125; // 2 else if authorizationStatus == .denied &#123; showAlert(&quot;Location services &quot;) &#125; // 3 else if authorizationStatus == .authorizedAlways &#123; locationManager.startUpdatingLocation() &#125;&#125; 1 如果用户授权状态是不确定，就检查是否是一直的状态。 2 如果用户授权状态是拒绝，就用弹框显示信息给用户看。showAlert(title:)是弹框函数： 1234567891011func showAlert(_ title: String) &#123; print(title) let alertController = UIAlertController(title: title, message: nil, preferredStyle: .alert) let action = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler: nil) alertController.addAction(action) present(alertController, animated: true, completion: nil) &#125; 3 如果用户授权状态是一直，就开始更新地理位置。 另外，还需要在.plist文件中添加key为NSLocationAlwaysUsageDescription的提示信息 需要一直能获取你的位置 才可以。在调用requestAlwaysAuthorization()时这个key是必须的。允许获取当前位置。 添加函数setupData()1234567891011121314151617181920212223242526272829303132333435func setupData() &#123; // 1 if CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) &#123; // 2 let title = &quot;全季酒店&quot; let coordinate = CLLocationCoordinate2DMake(31.1849700000,121.6303200000) let regionRadius = 300.0 // 3 let region = CLCircularRegion(center: CLLocationCoordinate2D(latitude: coordinate.latitude, longitude: coordinate.longitude), radius: regionRadius, identifier: title) locationManager.startMonitoring(for: region) // 4 let restaurantAnnotation = MKPointAnnotation() restaurantAnnotation.coordinate = coordinate restaurantAnnotation.title = title mapView.addAnnotation(restaurantAnnotation) // 5 let circle = MKCircle(center: coordinate, radius: regionRadius) mapView.add(circle) &#125; else &#123; print(&quot;不能追踪区域&quot;) &#125;&#125;// 6func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123; let circleRenderer = MKCircleRenderer(overlay: overlay) circleRenderer.strokeColor = UIColor.red circleRenderer.lineWidth = 1.0 return circleRenderer&#125; 1 判断是否监控区域功能是否可用。当用户拒绝状态，或用户不让app背景下刷新，或飞行模式时这个功能不可用 2 随意构建一个位置（如全季酒店），经纬度可通过经纬度查询查询，并设置区域半径regionRadius，单位是米。 3 初始化CLCircularRegion。 4 添加一个注解，类似大头针形状。 5 添加区域圆圈标志。 6 这是MKMapViewDelegate的方法，用户画圆 CLRegionCLRegion就是上面标定的圆形区域。下面添加两个CLLocationManagerDelegate的回调方法，分别在是设备的定位位置进和出标定的区域时调用。12345678// MARK:- CLLocationManagerDelegatefunc locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;)&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;)&#125; Xcode中的位置调试上面设备的位置，不可能拿着手机到处跑，Xcode提高了方便的调式方式。可以建立位置文件.GPX: xcode也提供世界上一些常用的位置文件：点击上图调试栏最后的位置标志就可以调式了。 复杂逻辑下的位置处理如果位置不停变化，在监控区域停留时间比较短，或者监控区域比较多是，处理位置问题就比较复杂了。更新部分代码：123456789101112131415161718// 1var monitoredRegions: Dictionary&lt;String, NSDate&gt; = [:] func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;) // 2 monitoredRegions[region.identifier] = NSDate()&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;) // 3 monitoredRegions.removeValue(forKey: region.identifier)&#125;// 4func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; updateRegions()&#125; 1 定义以字典用于存储用户进入监控区的时间。 2 记录进入时间。 3 删除进入时间。 4 用户位置变化后调用 加入函数updateRegions()代码：1234567891011121314151617181920func updateRegions() &#123; // 1 let regionMaxVisiting = 10.0 var regionsToDelete: [String] = [] // 2 for regionIdentifier in monitoredRegions.keys &#123; // 3 if NSDate().timeIntervalSince(monitoredRegions[regionIdentifier]! as Date) &gt; regionMaxVisiting &#123; showAlert(&quot;谢谢访问&quot;) regionsToDelete.append(regionIdentifier) &#125; &#125; // 4 for regionIdentifier in regionsToDelete &#123; monitoredRegions.removeValue(forKey: regionIdentifier) &#125;&#125; 1 加的用户到某个区域10s，就确定用户已经到访问过这个区域。regionsToDelete用来存储即将删除的区域的identifier，也就用户待过超过10s的区域。 2 遍历所有监控区域 3 timeIntervalSince用来计算某个时间到当前时间的差值，单位为秒。 4 删除用户待过超过regionMaxVisiting的区域。 代码GeoTargeting 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 3：Speech Framework的简单使用]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-3%EF%BC%9ASpeech-Framework%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[参考： Building a Speech-to-Text App Using Speech Framework in iOS 10 在WWDC 2016时，Apple介绍了Speech framework，这是一个很有用的声音识别框架。实际上这是利用Siri进行声音识别。 初始化项目 新建SpeechToTextDemo，模板是Single View Application。 添加简单的UI 分别定义UITextView和UIButton的两个outlet，为textView和microphoneButton。 再为UIButton添加一个action：123@IBAction func microphoneTapped(_ sender: AnyObject) &#123;&#125; 使用Speech Framework import Speech 实现SFSpeechRecognizerDelegate协议 用户授权获取声音数据是要获得用户的授权的。 在ViewController类中定义一个变量，作为语音识别器。参数identifier是识别的语种，可参考这个列表，中文是“ zh_Hans_CN”。private let speechRecognizer = SFSpeechRecognizer(locale: Locale.init(identifier: &quot;zh_Hans_CN&quot;)) 在viewDidLoad()中： 1234567891011121314151617181920212223242526272829override func viewDidLoad() &#123; super.viewDidLoad() // 1 microphoneButton.isEnabled = false speechRecognizer?.delegate = self // 2 SFSpeechRecognizer.requestAuthorization&#123; (authStatus) in var isButtionEnabled = false switch authStatus &#123; case .authorized: isButtionEnabled = true case .denied: isButtionEnabled = false print(&quot;用户拒绝接受语音识别&quot;) case .notDetermined: isButtionEnabled = false print(&quot;语音识别功能没有经过认可&quot;) case .restricted: isButtionEnabled = false print(&quot;当前设备不能语音识别&quot;) &#125; self.microphoneButton.isEnabled = isButtionEnabled &#125; startRecording()&#125; 1 默认按钮设成不可用 2 授权结果回调 Apple需要每个app如要用户授权时，都应该定制一个反馈信息（info.plist）。在info.plist中添加两个key，分别是麦克风和语音识别的授权，Privacy - Microphone Usage Description和Privacy - Speech Recognition Usage Description。 处理语音识别 在ViewController类中添加三个变量 123private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest? //识别请求private var recognitionTask: SFSpeechRecognitionTask? // 提供识别请求的结果private let audioEngine = AVAudioEngine() // SFSpeechAudioBufferRecognitionRequest对象处理语音识别的请求，代表语音进入语音识别器。 SFSpeechRecognitionTask 识别任务，用于操作识别器的停止和开始 AVAudioEngine 语音引擎，提供语音输出 创建新函数startRecording()，这个函数在点击button后调用，也就是microphoneTapped(:)中最后调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162func startRecording() &#123; // 1 if recognitionTask != nil &#123; recognitionTask?.cancel() recognitionTask = nil &#125; // 2 let audioSession = AVAudioSession.sharedInstance() do &#123; try audioSession.setCategory(AVAudioSessionCategoryRecord) try audioSession.setMode(AVAudioSessionModeMeasurement) try audioSession.setActive(true, with: .notifyOthersOnDeactivation) &#125; catch &#123; print(&quot;audioSession的属性设置失败&quot;) &#125; // 3 recognitionRequest = SFSpeechAudioBufferRecognitionRequest() // 4 guard let inputNode = audioEngine.inputNode else &#123; fatalError(&quot;Audio engine has no input node&quot;) &#125; // 5 guard let recognitionRequest = recognitionRequest else &#123; fatalError(&quot;Unable to create an SFSpeechAudioBufferRecognitionRequest object&quot;) &#125; // 6 recognitionRequest.shouldReportPartialResults = true // 7 recognitionTask = speechRecognizer?.recognitionTask(with: recognitionRequest, resultHandler: &#123; (result, error) in var isFinal = false if result != nil &#123; self.textView.text = result?.bestTranscription.formattedString isFinal = (result?.isFinal)! &#125; if error != nil || isFinal &#123; self.audioEngine.stop() inputNode.removeTap(onBus: 0) self.recognitionRequest = nil self.recognitionTask = nil self.microphoneButton.isEnabled = true &#125; &#125;) let recordingFormat = inputNode.outputFormat(forBus: 0) inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) &#123; (buffer, when) in self.recognitionRequest?.append(buffer) &#125; audioEngine.prepare() do &#123; try audioEngine.start() &#125; catch &#123; print(&quot;audioEngine couldn&apos;t start beacause of an error.&quot;) &#125; textView.text = &quot;Say something, I&apos;m listening!&quot;&#125; 1 开始录音时的初始化 2 AVAudioSession提供语音录音，设置一些参数 3 初始化SFSpeechAudioBufferRecognitionRequest 4 核查audioEngine是否可用 5 核查recognitionRequest 7 检测的音频后的回调方法，也就是开始录音后，有音频进入后都调用 语音识别的开关 实现代理方法speechRecognizer(_:availabilityDidChange:)。这个方法在语音识别器可用性发生变化时被调用。 1234567func speechRecognizer(_ speechRecognizer: SFSpeechRecognizer, availabilityDidChange available: Bool) &#123; if available &#123; microphoneButton.isEnabled = true &#125; else &#123; microphoneButton.isEnabled = false &#125;&#125; 点击button时的操作： 1234567891011@IBAction func microphoneTapped(_ sender: AnyObject) &#123; if audioEngine.isRunning &#123; audioEngine.stop() recognitionRequest?.endAudio() microphoneButton.isEnabled = false microphoneButton.setTitle(&quot;Start Recording&quot;, for: .normal) &#125; else &#123; startRecording() microphoneButton.setTitle(&quot;Stop Recording&quot;, for: .normal) &#125; &#125; 总结语音识别在iPhone的自带键盘中有这个功能，中文识别率很高，如果不高兴或不方便打字，很方便使用。 代码SpeechToTextDemo 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[swift的文档注释]]></title>
    <url>%2F2017%2Fswift%E7%9A%84%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%2F</url>
    <content type="text"><![CDATA[在Xcode中Quick Help 为开发者提供方便快捷的简洁文档查看方式。option+点击查看弹框，option+command+2在检查器中查看。swift的中有两种注释方式，让Xcode在Quick Help中显示。这种注释可以认为是将文档以某种规范的格式嵌入在实际代码的上方，这样就可以通过某些工具自动生成漂亮的文档文件。这种内嵌式的文档在现代编程中是很普遍的。在swift中，这两种注释方式是： /** */ ///这些注释中还可以有其他一些规范 可以支持markdown 关键词 三个关键词：parameter， returns， throws。这三个关键词会在最左边显示。 还有一些关键词会被提取到description中作为一些特殊字段显示，其他都会在description正常显示：author, authors, copyright, date；since, version；attention, important, note, remark, warning；bug, TODO, experiment； complexity； precondition, postcondition, requires, invariant see* 参考http://swifter.tips/documentation/http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/ 本文作者：AndyRon本文链接：http://andyron.com/2017/swift的文档注释/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 2：用Core Image进行面部识别(Swift)]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-2%EF%BC%9A%E7%94%A8Core-Image%E8%BF%9B%E8%A1%8C%E9%9D%A2%E9%83%A8%E8%AF%86%E5%88%AB-Swift%2F</url>
    <content type="text"><![CDATA[参考：Face Detection in iOS Using Core Image 面部识别API不仅可以是识别面部，也可识别面部的特殊细节，例如微笑甚至眨眼睛。 建立初始项目原文建好了初始项目，我自己新建了初始项目 新建项目Detector 删除IB中原本View Controller Scene。 拖动UITabBarController到IB中，得到三个Scene。选择UITabBarController的Is Initial View Controller，使其作为初始控制器。 修改Item 1的title和其Bar Item都为Photo，修改其Class为ViewController。 向Assets中添加几张人物图片 想Photo Scene中添加一个Image View，Content Mode改为Aspect Fit，选择一个图片。在ViewController添加图片对应@IBOutlet：@IBOutlet var personPic: UIImageView! 选中Item 2，点击菜单栏EDitor &gt; Embed In &gt; Navigation Controller，新生成一个与之关联的Scene。 新建CameraViewController类，继承至UIViewController。修改上面生成的Scene的Class属性为CameraViewController。 拖动一个UIBarButtonItem到Camera View Controller Scene的UINavigationItem的右边，并选择System Item为Camera 在CameraViewController中建立outlet和Action 识别照片的面部 在 ViewController.swift中引入CoreImage:import CoreImage 在 ViewController.swift中添加函数detect(): 12345678910111213141516171819202122232425262728293031func detect() &#123; // 1 guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; // 2 let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // 3 for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) let faceBox = UIView(frame: face.bounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) // 4 if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 1 根据UIImage获取CoreImage中图片对象。guard与if功能类似，区别可查看以撸代码的形式学习Swift-5：Control Flow的6 guard 与 if。 2 初始化检测器CIDetector， accuray是检查器配置选项，表示精确度；因为CIDetector可以进行几种类型的检测，所以CIDetectorTypeFace用来表示面部检测；features方法返回具体的检测结果 3 给每个检测到的脸添加红色框 4 检测是否有左眼位置 在viewDidLoad中添加 detect()，运行结果类似： 打印结果，显示检测到的面部位置是不对的：Found bounds are (177.0, 416.0, 380.0, 380.0)这是因为UIKit的坐标系统与Core Image的坐标系统是不同的： 把Core Image的坐标系统转换为UIKit的坐标系统，修改detect()为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func detect() &#123; guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // let ciImageSize = personciImage.extent.size var transform = CGAffineTransform(scaleX: 1, y: -1) transform = transform.translatedBy(x: 0, y: -ciImageSize.height) for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) // Apply the transform to convert the coordinates var faceViewBounds = face.bounds.applying(transform) // Calculate the actual position and size of the rectangle in the image view let viewSize = personPic.bounds.size let scale = min(viewSize.width / ciImageSize.width, viewSize.height / ciImageSize.height) let offsetX = (viewSize.width - ciImageSize.width * scale) / 2 let offsetY = (viewSize.height - ciImageSize.height * scale) / 2 faceViewBounds = faceViewBounds.applying(CGAffineTransform(scaleX: scale, y: scale)) faceViewBounds.origin.x += offsetX faceViewBounds.origin.y += offsetY let faceBox = UIView(frame: faceViewBounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 运行可看到正确识别位置： 相机拍照后的脸部识别之前是项目中照片识别，现在是拍完照再识别，原理是相同的，就是多一个拍完照，取照片的过程。 更新CameraViewController类的代码 1234567891011121314151617181920212223242526272829303132333435363738// 1class CameraViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate &#123; @IBOutlet var imageView: UIImageView! // 2 let imagePicker = UIImagePickerController() override func viewDidLoad() &#123; super.viewDidLoad() imagePicker.delegate = self &#125; @IBAction func takePhoto(_ sender: AnyObject) &#123; // 3 if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; imagePicker.allowsEditing = false imagePicker.sourceType = .camera present(imagePicker, animated: true, completion: nil) &#125; // 4 //MARK: -UIImagePickerControllerDelegate func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage &#123; imageView.contentMode = .scaleAspectFit imageView.image = pickedImage &#125; dismiss(animated: true, completion: nil) self.detect() &#125; // 5 func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil) &#125;&#125; 1 实现UIImagePickerControllerDelegate协议，用于拍照相关代理。 2 初始化UIImagePickerController。UIImagePickerController是照相或摄影界面和功能管理的类。 3 判断设备照相机是否可用。 4 实现一个UIImagePickerControllerDelegate中的代理方法，当拍摄完备确实使用照片时调用。 5 也是UIImagePickerControllerDelegate中的代理方法，取消拍摄时调用。 添加detect()代码，与ViewController中不同的是，不用红色框框处识别出的面部，而是识别出面部的细节，并用UIAlertController弹出显示。 1234567891011121314151617181920212223242526272829303132333435363738394041func detect() &#123; let imageOptions = NSDictionary(object: NSNumber(value: 5) as NSNumber, forKey: CIDetectorImageOrientation as NSString) let personciImage = CIImage(cgImage: imageView.image!.cgImage!) let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage, options: imageOptions as? [String : AnyObject]) if let face = faces?.first as? CIFaceFeature &#123; print(&quot;found bounds are \(face.bounds)&quot;) var message = &quot;有个脸&quot; if face.hasSmile &#123; print(&quot;脸是笑的&quot;) message += &quot;,脸是笑的&quot; &#125; if face.hasMouthPosition &#123; print(&quot;有嘴唇&quot;) message += &quot;,有嘴唇&quot; &#125; if face.hasLeftEyePosition &#123; print(&quot;左眼镜的位置是 \(face.leftEyePosition)&quot;) message += &quot;,左眼镜的位置是 \(face.leftEyePosition)&quot; &#125; if face.hasRightEyePosition &#123; print(&quot;右眼镜的位置是 \(face.rightEyePosition)&quot;) message += &quot;,右眼镜的位置是 \(face.rightEyePosition)&quot; &#125; let alert = UIAlertController(title: &quot;嘿嘿&quot;, message: message, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; else &#123; let alert = UIAlertController(title: &quot;没脸了&quot;, message: &quot;没有检测到脸&quot;, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; &#125; 运行就可以识别照片的面部具体细节CIFaceFeature还提供了其他很多面部细节：1234567891011121314151617181920212223242526272829open var hasLeftEyePosition: Bool &#123; get &#125;open var leftEyePosition: CGPoint &#123; get &#125;open var hasRightEyePosition: Bool &#123; get &#125;open var rightEyePosition: CGPoint &#123; get &#125;open var hasMouthPosition: Bool &#123; get &#125;open var mouthPosition: CGPoint &#123; get &#125;open var hasTrackingID: Bool &#123; get &#125;open var trackingID: Int32 &#123; get &#125;open var hasTrackingFrameCount: Bool &#123; get &#125;open var trackingFrameCount: Int32 &#123; get &#125;open var hasFaceAngle: Bool &#123; get &#125;open var faceAngle: Float &#123; get &#125;open var hasSmile: Bool &#123; get &#125;open var leftEyeClosed: Bool &#123; get &#125;open var rightEyeClosed: Bool &#123; get &#125; 代码Detector 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode中Scene里的名称]]></title>
    <url>%2F2017%2FXcode%E4%B8%ADScene%E9%87%8C%E7%9A%84%E5%90%8D%E7%A7%B0%2F</url>
    <content type="text"><![CDATA[默认的Scene名称 Xcode中新建一个控制器对象后会产生一个Scene，而Scene的名称就与其关联的控制器名称相关，比如默认的View Controller的对象的Scene的名称就是View Controller Scene。 如果把控制器改成SFSafariViewController，那么Scene的名字就会变成Safari View Scene。 如果把控制器改成自建的，Scene名字也会随着变化，比如ASAndyViewController对应的Scene名字是 Andy View Scene 总的来说，apple在程序中代码命名规范，一般是前面连续大写的是框架名称，然后后面使用驼峰命名法。要显示时就把框架前缀去掉，然后根据驼峰命名规则分隔显示。 自定义Scene的名称Scene的名称也是可以自定义的，在其属性检查器中，修改title即可，当然这种修改只是停留在IB中，为了开发时便于查看，不影响代码中的名称。 本文作者：AndyRon本文链接：http://andyron.com/2017/Xcode中Scene里的名称/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 1： 识别二维码（swift3）]]></title>
    <url>%2F2017%2FiOS-tutorial%2FiOS-tutorial-1%EF%BC%9A%E8%AF%86%E5%88%AB%E4%BA%8C%E7%BB%B4%E7%A0%81%EF%BC%88swift3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[这是一篇使用AVFoundation框架识别二维码的文章，原文提供了初始化项目QRCodeReaderStarter，我重新建立项目，图片是从原文提供的初始化项目中copy的。 初始化项目 新建一个名为QRCodeReader的单页项目 删除ViewController.swift文件，在项目目录处右击新建文件，新建一个QRCodeViewController类继承自UIViewController。 点击Main.storyboard，选中View Controller，修改其属性Class为QRCodeViewController，使两者关联。 向Main.storyboard中拖动一个View Controller对象，以1的方法新建一个继承自UIViewController的类QRScannerController，然后与Main.storyboard中新建的View Controller关联。 下载图片。从原文的初始化项目QRCodeReaderStarter复制。 修改Code View Controller Scene的view背景颜色做修改；添加一个label，名称改为Quick Scan，字体，和字体大小也做修改；添加button，删除文本，大小为150150，Type为System，image为focus*，Tint为黄色；添加一些约束。 Scanner Controller Scene： 在顶部添加一个View，在这个View中添加以label和button，button的image为cross；在顶部添加一个label；添加一些约束。 构建 segue 用control-drag从Code View Controller Scene中的button到Scanner Controller Scene，选择Present Modally 在QRCodeViewController中添加代码： 1234@IBAction func unwindToHomeScreen(segue: UIStoryboardSegue) &#123; //去除模态视图 dismiss(animated: true, completion: nil) &#125; 在Scanner Controller Scene 中，用control-drag从button到Exit，选择unwindToHomeScreenWithSegue: 6和7中样式和约束，合适即可。 加载 AVFoundation 框架 在QRScannerController.swift文件中引入AVFoundation Framework：import AVFoundation QRScannerController实现AVCaptureMetadataOutputObjectsDelegate协议：class QRScannerController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {表示当捕获的元数据产生时，需要一些回调方法。 QRScannerController中添加三个变量：123var captureSession: AVCaptureSession?var videoPreviewLayer: AVCaptureVideoPreviewLayer?var qrCodeFrameView: UIView? 实现视频捕获 在QRScannerController的viewDidLoad中添加代码： 123456789101112131415161718192021222324252627// 1let captureDevice = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)do &#123; // 2 let input = try AVCaptureDeviceInput(device: captureDevice) // 3 captureSession = AVCaptureSession() // 4 captureSession?.addInput(input) // 5 let captureMetadataOutput = AVCaptureMetadataOutput() captureSession?.addOutput(captureMetadataOutput) // 6 captureMetadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main) captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode] videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession) videoPreviewLayer?.videoGravity = AVLayerVideoGravityResizeAspectFill videoPreviewLayer?.frame = view.layer.bounds view.layer.addSublayer(videoPreviewLayer!) captureSession?.startRunning()&#125; catch &#123; print(error) return&#125; 1 初始化AVCaptureDevice，它表示物理捕获设备；AVMediaTypeVideo是Media types，表示视频类型，还有AVMediaTypeAudio，AVMediaTypeText等其他类型 2 根据AVCaptureDevice初始化捕获设备的输入数据对象AVCaptureDeviceInput。这边的try是swift中错误处理的标识，对应public init(device: AVCaptureDevice!) throws。 3 AVCaptureSession 用于协调输入与输出之间的数据流。 4 为AVCaptureSession 添加输入数据 5 定义输出数据对象AVCaptureMetaDataOutput，并把它添加给AVCaptureSession 6 设置self为输出数据对象的代理，这就对应了QRScannerController类实现AVCaptureMetadataOutputObjectsDelegate协议。metadataObjectTypes是识别的元数据类型，AVMetadataObjectTypeQRCode表示二维码类型。 在Info.plist中添加key为NSCameraUsageDescription或”Privacy – Camera Usage Description”，值为 为了扫描二维码，需要使用你的相机。 运行应用时，点击scan button后，使用了相机，但messageLabel和tapbar没有了，因为被AVCaptureVideoPreviewLayer覆盖了，加入两行代码就可以显示了：12view.bringSubview(toFront: messageLabel)view.bringSubview(toFront: topbar) 实现二维码读取当检测到二维码时，用绿色框高亮；然后二维码被解码成文本信息展示在messagelabel中。 初始化绿色框。继续在上述代码后添加:12345678qrCodeFrameView = UIView() if let qrCodeFrameView = qrCodeFrameView &#123; qrCodeFrameView.layer.borderColor = UIColor.green.cgColor qrCodeFrameView.layer.borderWidth = 2 view.addSubview(qrCodeFrameView) view.bringSubview(toFront: qrCodeFrameView)&#125; 由于qrCodeFrameView没有设置大小，默认是0，所以不会显示，当之后发现二维码时再让它显示。 解码二维码当AVCaptureMetadataOutput识别出二维码时，AVCaptureMetadataOutputObjectsDelegate中的代理方法将被调用：optional public func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) 回调方法定义： func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) { if metadataObjects == nil || metadataObjects.count == 0 { qrCodeFrameView?.frame = CGRect.zero messageLabel.text = &quot;没有二维码/条形码&quot; return } let metadataObj = metadataObjects[0] as! AVMetadataMachineReadableCodeObject if metadataObj.type == AVMetadataObjectTypeQRCode { // 1 let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil { // 2 messageLabel.text = metadataObj.stringValue } } } 第二个参数metadataObjects是个数组，就是所有被识别出来的元数据对象。如果这个参数为nil或数组为空数组，就表示没有识别出对象。 1 通过transformedMetadataObject方法获得AVMetadataObject对象，更加这个对象可以获得二维码的位置，然后显示绿框。 2 把二维码信息显示在messagelabel上。 识别条形码除了识别二维码以外，还可以识别条形码。只要在captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode]添加更多的元数据类型。，然后回调方法中修改检测类型就可以。 123456789101112131415161718192021222324let supportedCodeTypes = [AVMetadataObjectTypeUPCECode, AVMetadataObjectTypeCode39Code, AVMetadataObjectTypeCode39Mod43Code, AVMetadataObjectTypeCode93Code, AVMetadataObjectTypeCode128Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeAztecCode, AVMetadataObjectTypePDF417Code, AVMetadataObjectTypeQRCode ]captureMetadataOutput.metadataObjectTypes = supportedCodeTypes// ....if supportedCodeTypes.contains(metadataObj.type) &#123; let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil &#123; messageLabel.text = metadataObj.stringValue &#125;&#125; 代码QRCodeReader 本文作者：AndyRon]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS应用程序的状态]]></title>
    <url>%2F2017%2FiOS%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[iOS应用程序一共有五种状态： Not Running 程序还没运行 Inactive 程序运行在foreground但没有接收事件 Active 程序运行在foreground接收事件 Background 程序运行在background正在执行代码 Suspended 程序运行在background没有执行代码 iOS应用程序状态变化会回调APPDelegate中的方法，但不是每一种状态变化都会有对应的方法(上图的红框的两个变化就没有对应的方法) application:didFinishLaunchingWithOptions: Not Running -&gt; Inactive applicationDidBecomeActive: Inactive -&gt; Active applicationWillResignActive: Active -&gt; Inactive applicationDidEnterBackground: Background -&gt; Suspended applicationWillEnterForeground: Background -&gt; Inactive applicationWillTerminate: Suspended -&gt; Not Running 常见的应用状态变化场景 程序第一次启动（或者被杀掉以后启动）： Not Running -&gt; Inactive -&gt; Active 点击Home键（没有在Inof.plist中设置Application does not run in background）： Active -&gt; Inactive -&gt; Background -&gt; Suspended 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 挂起重新运行 Suspended -&gt; Background -&gt; Inactive -&gt; Active 内存清除（杀掉应用或删除应用） Suspended -&gt; Not Running 应用之间的切换 Active -&gt; Inactive Inactive -&gt; Active 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 可通过在APPDelegate的回调方法中打印数据，来查看应用状态变化 123456789101112131415161718192021222324252627282930func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; print(&quot;`application:didFinishLaunchingWithOptions:` Not Running -&gt; Inactive&quot;) return true&#125;func applicationWillResignActive(_ application: UIApplication) &#123; print(&quot;`applicationWillResignActive:` Active -&gt; Inactive&quot;)&#125;func applicationDidEnterBackground(_ application: UIApplication) &#123; print(&quot;`applicationDidEnterBackground:` Background -&gt; Suspended&quot;)&#125;func applicationWillEnterForeground(_ application: UIApplication) &#123; print(&quot;`applicationWillEnterForeground:` Background -&gt; Inactive&quot;)&#125;func applicationDidBecomeActive(_ application: UIApplication) &#123; print(&quot;`applicationDidBecomeActive:` Inactive -&gt; Active&quot;)&#125;func applicationWillTerminate(_ application: UIApplication) &#123; print(&quot;`applicationWillTerminate:` Suspended -&gt; Not Running&quot;)&#125; 本文作者：AndyRon本文链接：http://andyron.com/2017/iOS应用程序的状态/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
</search>