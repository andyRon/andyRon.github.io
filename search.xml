<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[1]]></title>
    <url>%2F2017%2F1.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[iOS与JS(一)：使用URL拦截的方式进行JS与OC互相调用]]></title>
    <url>%2F2017%2Fios-js-1.html</url>
    <content type="text"><![CDATA[关于WKWebView与UIWebView之间的区别，本文就不在说明，本文只使用WKWebView。效果图如下： html代码：12345678910111213141516171819202122232425262728293031323334353637&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf8&quot;&gt; &lt;script language=&quot;javascript&quot;&gt; function loadURL(url) &#123; window.location.href = url &#125; function locationClick() &#123; loadURL(&quot;scheme://getLocation&quot;); &#125; function shake() &#123; loadURL(&quot;scheme://shake&quot;); &#125; function setLocation(location) &#123; alert(location) document.getElementById(&quot;returnValue&quot;).value = location; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是按钮调用&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;获取定位&quot; onclick=&quot;locationClick()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;震动一下&quot; onclick=&quot;shake()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是文件上传&lt;/h1&gt; &lt;input type=&quot;file&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是回调结果展示区&lt;/h1&gt; &lt;textarea id =&quot;returnValue&quot; type=&quot;value&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; 以获取定位这个按钮为例说明OC和JS互相调用代码执行流程： 初始化WKWebView加载本地html文件。 点击web中的按钮，web发起URL请求。 URL请求被WKNavigationDelegate中的代理方法拦截。根据自定义的URL识别使用不同的处理方式。如：在- (void)getLocation方法中调用JS的setLocation函数。 JS的setLocation函数执行JS的alert()函数，被WKUIDelegate中的代理方法捕获，调用iOS原生的弹框。 详细代码说明 初始化WKWebView加载本地html文件 123456789101112131415161718192021- (void)initWKWebView&#123; // 1 WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init]; configuration.userContentController = [WKUserContentController new]; WKPreferences *preferences = [WKPreferences new]; preferences.javaScriptCanOpenWindowsAutomatically = YES; preferences.minimumFontSize = 40.0; configuration.preferences = preferences; self.webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration]; // 2 NSString *urlStr = [[NSBundle mainBundle] pathForResource:@&quot;index.html&quot; ofType:nil]; NSURL *fileURL = [NSURL fileURLWithPath:urlStr]; [self.webView loadFileURL:fileURL allowingReadAccessToURL:fileURL]; self.webView.navigationDelegate = self; self.webView.UIDelegate = self; [self.view addSubview:self.webView];&#125; 1 WKWebView的一些参数配置 2 加载本html URL请求被WKNavigationDelegate中的代理方法拦截。也就是JS调用了OC 1234567891011121314#pragma mark - WKNavigationDelegate- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler&#123; NSURL *URL = navigationAction.request.URL; NSString *scheme = [URL scheme]; if ([scheme isEqualToString:@&quot;scheme&quot;]) &#123; [self handleCustomAction:URL]; decisionHandler(WKNavigationActionPolicyCancel); return; &#125; decisionHandler(WKNavigationActionPolicyAllow);&#125; OC 调用 JS 12345678- (void)getLocation&#123; // 将结果返回给js NSString *jsStr = [NSString stringWithFormat:@&quot;setLocation(&apos;%@&apos;)&quot;,@&quot;上海市浦东新区&quot;]; [self.webView evaluateJavaScript:jsStr completionHandler:^(id _Nullable result, NSError * _Nullable error) &#123; NSLog(@&quot;%@----%@&quot;,result, error); &#125;];&#125; JS代码被当成字符串调用 completionHandler是JS代码被调用后回调 JS中alert弹窗被WKUIDelegate中的代理方法捕获，调用iOS原生的弹框。 1234567891011#pragma mark - WKUIDelegate- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提醒&quot; message:message preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@&quot;知道了&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(); &#125;]]; [self presentViewController:alert animated:YES completion:nil];&#125; 最后，html中的文件input可以直接调用iOS的图片库，相机和文件。 代码： 90-iOSJS/OCJS1 参考： iOS下JS与OC互相调用（二）–WKWebView 拦截URL iOS下JS与原生OC互相调用(总结)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS与JS(二)：MessageHandler(OC&Swift)]]></title>
    <url>%2F2017%2Fios-js-2.html</url>
    <content type="text"><![CDATA[iOS与JS的相互调用除了URL拦截（iOS与JS(一)：使用URL拦截的方式进行JS与OC互相调用）外，还可以使用WKWebView的中的MessageHandler来实现。 MessageHandler是什么呢？以代码来说明，比较好理解。在OC中初始化WKWebView是，添加如下代码:[self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Location&quot;];那么在JS中就可以使用：window.webkit.messageHandlers.Location.postMessage(null);JS中的Location就对应OC中的name，postMessage后的参数就是JS传给OC的参数，类型可以是 NSNumber, NSString, NSDate, NSArray, NSDictionary, and NSNull。JS回调OC时，就回调WKScriptMessageHandler的- (void)userContentController:([WKUserContentController](apple-reference-documentation://hcracoR5p2) *)userContentController didReceiveScriptMessage:([WKScriptMessage](apple-reference-documentation://hcD3KQdcJY) *)message;方法，这边的message是WKScriptMessage， message.name就是“Location”，message.body就是postMessage后的参数。 下面看完整的🌰： html的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf8&quot;&gt; &lt;script language=&quot;javascript&quot;&gt; var ctuapp_share_img=&quot;www.baidu.com&quot;; function locationClick() &#123; window.webkit.messageHandlers.Location.postMessage(null); &#125; function shake() &#123; window.webkit.messageHandlers.Shake.postMessage(null); &#125; function payClick()&#123; window.webkit.messageHandlers.Pay.postMessage(&#123;order_no:&apos;201511120981234&apos;,channel:&apos;wx&apos;,amount:1,subject:&apos;粉色外套&apos;&#125;); &#125; function setLocation(location) &#123; alert(location) document.getElementById(&quot;returnValue&quot;).value = location; &#125; function payResult(str) &#123; alert(str); document.getElementById(&quot;returnValue&quot;).value = str; &#125; &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是按钮调用&lt;/h1&gt; &lt;input type=&quot;button&quot; value=&quot;获取定位&quot; onclick=&quot;locationClick()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;震动一下&quot; onclick=&quot;shake()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;input type=&quot;button&quot; value=&quot;支付&quot; onclick=&quot;payClick()&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是文件上传&lt;/h1&gt; &lt;input type=&quot;file&quot; /&gt;&lt;br&gt;&lt;br&gt; &lt;h1&gt;这是回调结果展示区&lt;/h1&gt; &lt;textarea id =&quot;returnValue&quot; type=&quot;value&quot; rows=&quot;5&quot; cols=&quot;50&quot;&gt;&lt;/textarea&gt; &lt;/body&gt;&lt;/html&gt; 初始化WKWebView12345678910111213141516171819- (void)initWKWebView&#123; WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init]; WKPreferences *preferences = [WKPreferences new]; preferences.javaScriptCanOpenWindowsAutomatically = YES; preferences.minimumFontSize = 40.0; configuration.preferences = preferences; self.webView = [[WKWebView alloc] initWithFrame:self.view.frame configuration:configuration]; NSString *urlStr = [[NSBundle mainBundle] pathForResource:@&quot;index.html&quot; ofType:nil]; NSURL *fileURL = [NSURL fileURLWithPath:urlStr]; [self.webView loadFileURL:fileURL allowingReadAccessToURL:fileURL]; self.webView.UIDelegate = self; [self.view addSubview:self.webView];&#125; 添加 MessageHandler为了防止循环引用，结束时释放。123456789101112131415161718- (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; // addScriptMessageHandler 很容易导致循环引用 // 控制器 强引用了WKWebView,WKWebView copy(强引用了）configuration， configuration copy （强引用了）userContentController [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Location&quot;]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Shake&quot;]; [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;Pay&quot;];&#125;- (void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;Location&quot;]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;Shake&quot;]; [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;Pay&quot;];&#125; 实现WKUIDelegate和WKScriptMessageHandler协议方法12345678910111213141516171819202122232425#pragma mark - WKUIDelegate- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler&#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提醒&quot; message:message preferredStyle:UIAlertControllerStyleAlert]; [alert addAction:[UIAlertAction actionWithTitle:@&quot;知道了&quot; style:UIAlertActionStyleCancel handler:^(UIAlertAction * _Nonnull action) &#123; completionHandler(); &#125;]]; [self presentViewController:alert animated:YES completion:nil];&#125;#pragma mark - WKScriptMessageHandler- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message&#123; // message.body -- Allowed types are NSNumber, NSString, NSDate, NSArray,NSDictionary, and NSNull. NSLog(@&quot;body:%@&quot;,message.body); if ([message.name isEqualToString:@&quot;Location&quot;]) &#123; [self getLocation]; &#125; else if ([message.name isEqualToString:@&quot;Shake&quot;]) &#123; [self shakeAction]; &#125; else if ([message.name isEqualToString:@&quot;Pay&quot;]) &#123; [self payWithParams:message.body]; &#125;&#125; 效果： Swift的和OC类型，代码我也一起写了 代码： 90-iOSJS 中的 OCJSMessageHandler 和 SwiftJSMessageHandler 参考：iOS下JS与OC互相调用（三）–MessageHandler]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS动画(三)：核心动画中缩放和旋转(Swift)]]></title>
    <url>%2F2017%2Fios-animation-3.html</url>
    <content type="text"><![CDATA[原理和上一篇是相同的，不同之处是keyPath属性，缩放时是keyPath是 transform.scale，旋转时keyPath是transform.rotation。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113class ScaleRotationViewController: UIViewController &#123; // 用于缩放的layer lazy var redLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 150), backgroundColor: UIColor.red) &#125;() lazy var greenLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 250), backgroundColor: UIColor.green) &#125;() lazy var cyanLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 350), backgroundColor: UIColor.cyan) &#125;() lazy var blueLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 125, y: 450), backgroundColor: UIColor.blue) &#125;() // 用于旋转的Layer lazy var redRotationLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 300, y: 150), backgroundColor: UIColor.red) &#125;() lazy var greenRotationLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 300, y: 250), backgroundColor: UIColor.green) &#125;() lazy var cyanRotationLayer: CALayer = &#123; return self.createLayer(position: CGPoint(x: 300, y: 350), backgroundColor: UIColor.cyan) &#125;() override func viewDidLoad() &#123; super.viewDidLoad() // 添加缩放的动画 redLayer.add(createAnimation(keyPath: &quot;transform.scale.x&quot;, toValue: 0.5), forKey: nil) greenLayer.add(createAnimation(keyPath: &quot;transform.scale.y&quot;, toValue: 0.5), forKey: nil) cyanLayer.add(createAnimation(keyPath: &quot;transform.scale.z&quot;, toValue: 0.5), forKey: nil) blueLayer.add(createAnimation(keyPath: &quot;transform.scale&quot;, toValue: 0.5), forKey: nil) // 添加旋转的动画 redRotationLayer.add(createAnimation(keyPath: &quot;transform.rotation.x&quot;, toValue: CGFloat(Double.pi / 4)), forKey: nil) greenRotationLayer.add(createAnimation(keyPath: &quot;transform.rotation.y&quot;, toValue: CGFloat(Double.pi / 4)), forKey: nil) cyanRotationLayer.add(createAnimation(keyPath: &quot;transform.rotation.z&quot;, toValue: CGFloat(Double.pi / 4)), forKey: nil) self.creatLabel(title: &quot;缩放&quot;, frame: CGRect(x: 100, y: 80, width: 50, height: 20)) self.creatLabel(title: &quot;旋转&quot;, frame: CGRect(x: 250, y: 80, width: 50, height: 20)) self.creatLabel(title: &quot;X轴&quot;, frame: CGRect(x: 20, y: 125, width: 50, height: 20)) self.creatLabel(title: &quot;Y轴&quot;, frame: CGRect(x: 20, y: 225, width: 50, height: 20)) self.creatLabel(title: &quot;Z轴&quot;, frame: CGRect(x: 20, y: 325, width: 50, height: 20)) self.creatLabel(title: &quot;XYZ轴&quot;, frame: CGRect(x: 20, y: 425, width: 50, height: 20)) &#125; // 创建calayer func createLayer (position: CGPoint, backgroundColor: UIColor) -&gt; CALayer &#123; //创建calayer let layer = CALayer() //设置位置和大小 layer.position = position layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100) //设置背景颜色 layer.backgroundColor = backgroundColor.cgColor //把layer添加到UIView的layer上 self.view.layer.addSublayer(layer) return layer &#125; // 创建基础Animation func createAnimation (keyPath: String, toValue: CGFloat) -&gt; CABasicAnimation &#123; //创建动画对象 let scaleAni = CABasicAnimation() //设置动画属性 scaleAni.keyPath = keyPath //设置动画的起始位置。也就是动画从哪里到哪里。不指定起点，默认就从positoin开始 scaleAni.toValue = toValue //动画持续时间 scaleAni.duration = 2; //动画重复次数 scaleAni.repeatCount = Float(CGFloat.greatestFiniteMagnitude) return scaleAni; &#125; //创建Label fileprivate func creatLabel (title: String, frame: CGRect) -&gt; ()&#123; let label = UILabel() label.text = title label.frame = frame label.textColor = UIColor.darkGray label.font = UIFont.systemFont(ofSize: 12) self.view.addSubview(label) &#125;&#125; 代码： 89-Animation/CABasic Animation 参考：第五篇：CABasic Animation。iOS动画系列之五：基础动画之缩放篇&amp;旋转篇]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画(二)：核心动画中的基础移动(Swift)]]></title>
    <url>%2F2017%2Fios-animation-2.html</url>
    <content type="text"><![CDATA[简单的移动 新建一个CALayer。 12345678910lazy var redLayer: CALayer = &#123; return self.createLayer()&#125;()func createLayer() -&gt; CALayer &#123; let redLayer = CALayer() redLayer.position = CGPoint(x: 200, y: 200) redLayer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100) redLayer.backgroundColor = UIColor.red.cgColor return redLayer&#125; 把新建的CALayer添加的view的layer中。 1view.layer.addSublayer(redLayer) 遵守协议CAAnimationDelegate class BasicPostionViewController: UIViewController, CAAnimationDelegate { 创建动画CABasicAnimation,并添加的CALayer中。 12345678910111213141516171819func createCABasicAnimation() -&gt; CABasicAnimation &#123; let basicAni = CABasicAnimation() // 设置动画属性 basicAni.keyPath = &quot;position&quot; basicAni.fromValue = NSValue.init(cgPoint: CGPoint(x: 0, y: 0)) basicAni.toValue = NSValue.init(cgPoint: CGPoint(x: 300, y: 300)) basicAni.duration = 2 basicAni.fillMode = kCAFillModeForwards basicAni.isRemovedOnCompletion = false basicAni.delegate = self return basicAni&#125; 12let basicAni = createCABasicAnimation()self.redLayer.add(basicAni, forKey: &quot;basicPosition&quot;) forKey 是动画对象的名字，只是用来标识，没有特殊意义。 稍微复杂的移动 原理和上面相同，都是先创建CALayer，然后添加CABasicAnimation。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class BasicPostion2ViewController: UIViewController, CAAnimationDelegate&#123; lazy var redLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 150), backgroundColor: UIColor.red) &#125;() lazy var greenLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 250), backgroundColor: UIColor.green) &#125;() lazy var cyanLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 350), backgroundColor: UIColor.cyan) &#125;() lazy var blueLayer: CALayer = &#123; return self.createLayer(postion: CGPoint(x: 0, y: 450), backgroundColor: UIColor.blue) &#125;() override func viewDidLoad() &#123; super.viewDidLoad() redLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 150), toValue: CGPoint(x: 300, y: 150), timingFunction: kCAMediaTimingFunctionLinear), forKey: &quot;basicAnimation&quot;) view.layer.addSublayer(redLayer) greenLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 250), toValue: CGPoint(x: 300, y: 250), timingFunction: kCAMediaTimingFunctionEaseIn), forKey: &quot;basicAnimation&quot;) view.layer.addSublayer(greenLayer) cyanLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 350), toValue: CGPoint(x: 300, y: 350), timingFunction: kCAMediaTimingFunctionEaseOut), forKey: &quot;basicAnimation&quot;) view.layer.addSublayer(cyanLayer) blueLayer.add(createBasicAnimation(fromValue: CGPoint(x: 0, y: 450), toValue: CGPoint(x: 300, y: 450), timingFunction: kCAMediaTimingFunctionEaseInEaseOut), forKey: &quot;basicAnimation&quot;) view.layer.addSublayer(blueLayer) &#125; func createLayer(postion: CGPoint, backgroundColor: UIColor) -&gt; CALayer &#123; let layer = CALayer() layer.position = postion layer.bounds = CGRect(x: 0, y: 0, width: 100, height: 100) layer.backgroundColor = backgroundColor.cgColor return layer &#125; func createBasicAnimation (fromValue: CGPoint, toValue: CGPoint, timingFunction: String) -&gt; CABasicAnimation &#123; let basicAni = CABasicAnimation() basicAni.keyPath = &quot;position&quot; basicAni.fromValue = fromValue basicAni.toValue = toValue basicAni.duration = 2 // basicAni.fillMode = kCAFillModeForwards // basicAni.isRemovedOnCompletion = false // 1 basicAni.timingFunction = CAMediaTimingFunction(name: timingFunction) basicAni.delegate = self return basicAni &#125;&#125; 1 timingFunction代表移动模式： kCAMediaTimingFunctionLinear（线性）：匀速，给你一个相对静态的感觉 kCAMediaTimingFunctionEaseIn（渐进）：动画缓慢进入，然后加速离开 kCAMediaTimingFunctionEaseOut（渐出）：动画全速进入，然后减速的到达目的地 kCAMediaTimingFunctionEaseInEaseOut（渐进渐出）：动画缓慢的进入，中间加速，然后减速的到达目的地。 代码： 89-Animation/CABasic Animation 参考： 第三篇：iOS动画系列之三：Core Animation。介绍了Core Animation的常用属性和方法。 第四篇：CABasic Animation。iOS动画系列之四：基础动画之平移篇]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS动画(一)：时钟动画(Swift)]]></title>
    <url>%2F2017%2Fios-animation-1-clock.html</url>
    <content type="text"><![CDATA[一、直接做动画 新建项目clock 加载表盘图片。在viewDidLoad中添加： 123456let dialLayer = CALayer()dialLayer.bounds = CGRect(x: 0, y: 0, width: 150, height: 150)dialLayer.position = self.view.centerdialLayer.contents = UIImage(named: &quot;clock&quot;)?.cgImageview.layer.addSublayer(dialLayer) 懒加载秒针、分针、时针视图。懒加载机制是Swift中一种存储属性：延迟存储属性，具体可擦看 以撸代码的形式学习Swift-10：Properties 1234567891011121314151617181920212223242526272829303132// 秒针lazy var secondHandView: UIView = &#123; let secondHandView = UIView() secondHandView.backgroundColor = UIColor.red secondHandView.bounds = CGRect(x: 0, y: 0, width: 1, height: 60) secondHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1) return secondHandView&#125;()// 分针lazy var minuteHandView: UIView = &#123; let minuteHandView = UIView() minuteHandView.backgroundColor = UIColor.darkGray minuteHandView.bounds = CGRect(x: 0, y: 0, width: 3, height: 60) minuteHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1) return minuteHandView&#125;()// 时针lazy var hourHandView: UIView = &#123; let hourHandView = UIView() hourHandView.backgroundColor = UIColor.darkGray hourHandView.bounds = CGRect(x: 0, y: 0, width: 3, height: 45) hourHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1) return hourHandView&#125;() 把秒针、分针、时针添加到view中。在viewDidLoad中添加： 123456secondHandView.center = view.centerself.view.addSubview(secondHandView)minuteHandView.center = view.centerself.view.addSubview(minuteHandView)hourHandView.center = view.centerself.view.addSubview(hourHandView) 创建CADisplayLink，并将其添加到主线程中。在viewDidLoad中添加： 12let link = CADisplayLink(target: self, selector: #selector(ViewController.clockRunning))link.add(to: RunLoop.main, forMode: .defaultRunLoopMode) 添加方法clockRunning: 123456789101112131415161718func clockRunning() &#123; let tZone = TimeZone.current var calendar = Calendar.current let currentDate = Date() calendar.timeZone = tZone let currentTime = calendar.dateComponents([Calendar.Component.hour, Calendar.Component.minute, Calendar.Component.second], from: currentDate) // 根据当前秒、分、时数分别计算秒针、分针、时针偏转弧度 let secondAngle = CGFloat ( Double(currentTime.second!) * (Double.pi * 2.0 / 60) ) secondHandView.transform = CGAffineTransform(rotationAngle: secondAngle) let minuteAngle = CGFloat ( Double(currentTime.minute!) * (Double.pi * 2.0 / 60) ) minuteHandView.transform = CGAffineTransform(rotationAngle: minuteAngle) let hourAngle = CGFloat ( Double(currentTime.hour!) * (Double.pi * 2.0 / 12) ) hourHandView.transform = CGAffineTransform(rotationAngle: hourAngle)&#125; 现在就完成了文章开头的效果。 二、代码说明 关于anchorPoint（锚点）如果注释掉分针和时针视图，并且关掉动画效果和锚点设置：123456789// secondHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1)// minuteHandView.center = view.center// self.view.addSubview(minuteHandView)// hourHandView.center = view.center// self.view.addSubview(hourHandView) // 创建CADisplayLink，并将其添加到主线程中// let link = CADisplayLink(target: self, selector: #selector(ViewController.clockRunning))// link.add(to: RunLoop.main, forMode: .defaultRunLoopMode) 加上secondHandView.layer.anchorPoint = CGPoint(x: 0.5, y: 1)后： anchorPoint的官方描述： Defines the anchor point of the layer’s bounds rectangle. Animatable.You specify the value for this property using the unit coordinate space. The default value of this property is (0.5, 0.5), which represents the center of the layer’s bounds rectangle. All geometric manipulations to the view occur about the specified point. For example, applying a rotation transform to a layer with the default anchor point causes the layer to rotate around its center. Changing the anchor point to a different location would cause the layer to rotate around that new point. anchorPoint的值在 (0,0) 和 (1,1)之间。默认是 (0.5, 0.5),代表锚点在中心位置。 (0,0) 和 (1,1)分别代表左上角和右上角。 关于CALayer的属性position和anchorPoint position类似UIView 的center position决定了layer在父视图上的位置 anchorPoint决定了position在自身的位置。All geometric manipulations to the view occur about the specified point. CADisplayLink 与 NSTimer CADisplayLink精确度高 NSTimer占用系统资源较多 代码和图片位置： 89-Animation/clock 参考： iOS动画系列之一：通过实战学习CALayer和透视的原理。做一个带时分秒指针的时钟动画(上) iOS动画系列之二：通过实战学习CALayer和透视的原理。做一个带时分秒指针的时钟动画。包含了OC和Swift两种源代码(下)]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识Core ML：建立一个简单的图片内容识别应用]]></title>
    <url>%2F2017%2Fintroducing-coreml.html</url>
    <content type="text"><![CDATA[Xcode 9 beta &amp; iOS11 beta &amp; Swift4 Core ML是一个能集成机器学习模型到app中的框架。 一、新建初始项目 新建项目CoreMLDemo，以single-view application template模板 建立如下如下UI 二、实现照相和获取图片库功能 遵守两个协议：class ViewController: UIViewController, UINavigationControllerDelegate, UIImagePickerControllerDelegate { 添加两个接口，并关联。 12@IBOutlet var imageView: UIImageView!@IBOutlet var classifier: UILabel! 实现两个Action 1234567891011121314151617181920@IBAction func camera(_ sender: Any) &#123; if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; let cameraPicker = UIImagePickerController() cameraPicker.delegate = self cameraPicker.sourceType = .camera cameraPicker.allowsEditing = false present(cameraPicker, animated: true, completion: nil)&#125;@IBAction func openLibrary(_ sender: Any) &#123; let picker = UIImagePickerController() picker.allowsEditing = false picker.delegate = self picker.sourceType = .photoLibrary present(picker, animated: true)&#125; 实现协议UIImagePickerControllerDelegate中的方法： 123func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil)&#125; 在Info.plist中添加📷使用请求，Privacy – Camera Usage Description and Privacy 三、集成Core ML Data Model 到Apple机器学习官网 Machine Learning下载Core ML models，目前有6个Model，识别图片的使用Inception v3。下载得到一个mlmodel结尾的文件，直接拖到项目中，会自动生成对应model名的swift的类文件，可以直接在代码中使用。 在ViewController.swift中引入Core ML:import CoreML 初始Inceptionv3: 12345var model: Inceptionv3!override func viewWillAppear(_ animated: Bool) &#123; model = Inceptionv3()&#125; 实现UIImagePickerControllerDelegate协议的imagePickerController(_:didFinishPickingMediaWithInfo)方法： 12345678910111213141516171819202122232425262728293031323334func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; picker.dismiss(animated: true) classifier.text = &quot;Analyzing Image...&quot; guard let image = info[&quot;UIImagePickerControllerOriginalImage&quot;] as? UIImage else &#123; return &#125; UIGraphicsBeginImageContextWithOptions(CGSize(width: 299, height: 299), true, 2.0) image.draw(in: CGRect(x: 0, y: 0, width: 299, height: 299)) let newImage = UIGraphicsGetImageFromCurrentImageContext()! UIGraphicsEndImageContext() let attrs = [kCVPixelBufferCGImageCompatibilityKey: kCFBooleanTrue, kCVPixelBufferCGBitmapContextCompatibilityKey: kCFBooleanTrue] as CFDictionary var pixelBuffer : CVPixelBuffer? let status = CVPixelBufferCreate(kCFAllocatorDefault, Int(newImage.size.width), Int(newImage.size.height), kCVPixelFormatType_32ARGB, attrs, &amp;pixelBuffer) guard (status == kCVReturnSuccess) else &#123; return &#125; CVPixelBufferLockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) let pixelData = CVPixelBufferGetBaseAddress(pixelBuffer!) let rgbColorSpace = CGColorSpaceCreateDeviceRGB() let context = CGContext(data: pixelData, width: Int(newImage.size.width), height: Int(newImage.size.height), bitsPerComponent: 8, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer!), space: rgbColorSpace, bitmapInfo: CGImageAlphaInfo.noneSkipFirst.rawValue) //3 context?.translateBy(x: 0, y: newImage.size.height) context?.scaleBy(x: 1.0, y: -1.0) UIGraphicsPushContext(context!) newImage.draw(in: CGRect(x: 0, y: 0, width: newImage.size.width, height: newImage.size.height)) UIGraphicsPopContext() CVPixelBufferUnlockBaseAddress(pixelBuffer!, CVPixelBufferLockFlags(rawValue: 0)) imageView.image = newImage 使用Core ML在上面imagePickerController(_:didFinishPickingMediaWithInfo)方法最后添加： 1234guard let prediction = try? model.prediction(image: pixelBuffer!) else &#123; return&#125;classifier.text = &quot;I think this is a \(prediction.classLabel).&quot; 现在就可运行识别图片内容了，我已几个简单的做了实验，效果还可以： 能识别🐶的种类，哈巴狗pug 🍌应该相对而言简单： 朋友家的猫，我也不知道猫的种类，识别为波斯猫(Persian cat): 这个我就不知道是怎么识别为浓咖啡(espresso)的了🤔 当然识别相差比较奇怪的。小米手环识别成听诊器（stethoscope）😢 kindle识别不出😢😢😢 四、Core ML学习资源官方文档 official Core ML documentation WWDC 2017： Introducing Core ML Core ML in Depth 代码 CoreMLDemo （由于Inceptionv3.mlmodel比较大，我就没有上传到github上，直接到 Machine Learning然后拖到项目中即可） 参考：Introduction to Core ML: Building a Simple Image Recognition App]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>Core ML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用github和hexo创建免费的静态个人博客网站]]></title>
    <url>%2F2017%2Fgithub-hexo.html</url>
    <content type="text"><![CDATA[之前刚学编程，接触PHP时，出于学习的目的，兴致勃勃地买了域名、主机、学了Wordpress，找了主题，折腾了好久建了个网站，也写了一些文章，然后就没有然后了，这是从入门到放弃系列的典型案例。前段时间收到主机要到期的通知，正好我也接触到了简书，支持markdown，感觉蛮好，平常也习惯使用markdown格式记录笔记。就觉得不再续费主机了，就主要使用简书，个人博客就使用github和hexo这种支持markdown生成静态网页形式就行了。 已经有很多小伙伴这样搭建自己的个人博客，并写了相关文章，这边我就做一个搭建过程中的简单记录。开始之前需要安装git和nodejs，有github账号，程序员小伙伴一般都会有了，我就不啰嗦了。 关于GitHub PagesGitHub Pages原本是为托管在github上的项目提供介绍页面的一个功能，非常适合托管一些功能简单或者是静态页面的网站。考虑到访问速度，可以考虑国内的coding。 按照GitHub Pages步骤建立自己的GitHub Pages库。 hexohexo文档很详细，也有中文，很方便。 安装 hexonpm install hexo-cli -g 建站 123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 新生成的目录结构为： 123456789101112131415161718 . ├── _config.yml ├── node_modules ├── package.json ├── scaffolds ├── source └── themes ``` + `_config.yml` 是网站的[站点配置文件](https://hexo.io/zh-cn/docs/configuration.html) + `node_modules` 是nodejs库文件目录，就是`npm install`命令安装的文件位置 + `package.json`是程序信息 + `scaffolds` 新建文章的模板 + `source` 存放用户资源的地方，404、favicon、CNAME 等堵在此处，这是我们主要工作的地方。其中，`_posts`文件是写文章地方，除` _posts`文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹（之后生成），而其他文件会被拷贝过去。 + `themes` 是主题存储地方。- 配置网站信息`_config.yml` 文件提供了很多配置，详细可看官网[配置信息](https://hexo.io/zh-cn/docs/configuration.html)。先配置两方面的，之后需要再配置。 + 网站基本信息 Sitetitle: 欣欣向戎subtitle: AndyRon’s Blogdescription: Just for fun.author: AndyRonlanguage: zh-Hanstimezone: Asia/Shanghai 1+ 部署，注意字段，`repo`就是个人GitHub Pages的地址库。 DeploymentDocs: https://hexo.io/docs/deployment.htmldeploy:type: gitrepo: https://github.com/andyRon/andyRon.github.io.gitbranch: master 1234567891011121314151617181920212223242526272829303132333435- 新建文章 `hexo new [layout] &lt;title&gt;` ： 也就是在`source/_posts/`下按照模板新建了一个markdown文件，layout就是指`scaffolds`文件夹中的模板，也可以直接在`_posts`中新建markdown文件。- 在本地服务器测试`hexo server` ：在浏览器打开http://localhost:4000/ ，就可以查看- 生成静态文件`hexo generate`（`hexo g`） ：这个命令会新建一个`public`文件夹，在其中生成静态文件，这个目录相当于网站的根目录。- 发布到github`hexo deploy`（`hexo d`）：把`public`文件夹内的内容上传到github上。现在访问https://yourname.github.io (我的是https://andyron.github.io )就能访问刚建立的网站了。如果出现[**ERROR Deployer not found**](https://github.com/hexojs/hexo/issues/1040)的问题，可通过`npm install hexo-deployer-git --save`解决。- 其他hexo命令`hexo clean` ：删除public文件夹内容，和清理一些缓存。调试网站可以使用。### 域名绑定（如有必要）- 在`source/`下添加文件`CNAME`，内容只为如`andyron.com`（没有http和www）- 部署到github上：`hexo generate`，`hexo deploy`- 域名解析。不同的域名服务商大同小异，我的是阿里云，为了防止解析出问题，我把其他默认一些邮件解析等都删了，就添加两个：![](http://upload-images.jianshu.io/upload_images/1678135-248c8a30a3115f53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)可能需要等一短时间（10分钟以上），就可以用 http://andyron.com 访问了。### hexo主题hexo有很多主题，很多网友为hexo贡献了很多主题，可到[主题](https://hexo.io/themes/)上寻找。我选择的是[next](https://github.com/iissnan/hexo-theme-next)主题，这个使用主题用的人比较多，[文档](http://theme-next.iissnan.com/getting-started.html)很全，也比较简洁。主题的使用非常简单： - 将主题文件拷贝至站点目录的`themes` 目录下 - 修改**站点配置文件**： `theme: 主题名`主题的一些设置：- 设置RSS + 安装 [hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed)插件，在`hexo init`初始化的目录下执行`npm install hexo-generator-feed --save` + 在**站点配置文件**添加： feed:type: atompath: atom.xmllimit: 20hub:content: 123456 + `hexo generate`- 设置搜索有很多搜索方式，这只是一种简单方式 + 安装`hexo-generator-searchdb`，在`hexo`的根目录下：`$ npm install hexo-generator-searchdb --save` + 在**站点配置文件**添加： search: path: search.xml field: post format: html limit: 10000 12+ 在**主题配置文件**（`themes/next/_config.yml`）修改： local_search: enable: true ``` 添加标签页面 $hexo new page tags：结果生成新文件夹source/tags/，并在其中有一个index.md。 在主题配置文件的menu中打开标签 添加分类页面 $hexo new page categories：结果生成新文件夹source/categories，并在其中有一个index.md。 在主题配置文件的menu中打开分类。 添加关于我页面 $hexo new page about：结果生成新文件夹source/about，并在其中有一个index.md，在index.md中直接编写关于我的内容。 在主题配置文件的menu中打开分类。 添加百度分析 注册 百度统计，并添加自己的网站 复制 hm.js? 后面那串统计脚本 id 在主题配置文件中添加字段baidu_analytics`，职位上面的脚本id 参考http://blog.csdn.net/zuoziji416/article/details/53204478]]></content>
      <tags>
        <tag>github</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS 传感器(一)：总的介绍和距离传感器]]></title>
    <url>%2F2017%2Fios-sensor-1.html</url>
    <content type="text"><![CDATA[关于传感器（Sensor），Apple官方好像并没有专门列出来介绍过，我只能从前辈的文章寻找，很多文章中都给iOS传感器进行过很详细的分类介绍，但有的传感器只是有过介绍，没有介绍使用方法或API，当然也有可能是我没搜索到，比如湿度传感器很多文章都提到，但详细使用方式就未曾看到过，还有这边的湿度传感器是指iPhone内部的？还是指iPhone所在外部环境的？ iPhone的传感器是经过长时间不停的变化和改进的，因为传感器一听名字就知道这种变化和改进十之八九是要与硬件有关系的。知乎中有一遍文章介绍的很详细，iPhone这十年在传感器上的演进- 知乎专栏。 iOS中传感器分类我姑且按照我查看的资料对iOS传感器进行一个不精确分类。 传感器类型 说明 加速计 Core Motion，感应设备的运动（摇一摇、计步器） 陀螺仪 Core Motion，感应设备的持握方式（赛车类游戏） 步数计 Core Motion 气压计 Core Motion 磁力计 Core Motion 距离传感器 感应是否有其他物体靠近设备屏幕（打电话自动屏） 环境光线传感器 感应周边环境光线的强弱（自动调节屏幕亮度） 内部温度传感器 感应设备内部的温度（提醒用户降温，防止损伤设备） 湿度传感器 感应设备是否进水（方便维修人员） 距离传感器和光线传感器知乎知友 Hi-iD 的答案介绍过这两个传感器的关系，本人简单总结如下： iPhone 5/5s/6之后光线/距离感应器就是iPhone顶部中心一个孔 光线传感器和距离传感器是两个独立的传感器，但两者都是对光作出反应。 距离传感器是基于红外光，距离传感器自身发射出的红外光，经外界反射后折回的红外光被距离传感器进行识别判断，所以距离传感器会有两个单元（反射和接收） 距离传感器的使用距离传感器的使用的使用相对简单：1234567891011121314override func viewDidLoad() &#123; super.viewDidLoad() UIDevice.current.isProximityMonitoringEnabled = true NotificationCenter.default.addObserver(self, selector: #selector(ViewController.sensorStateChange(notification:)), name: Notification.Name.UIDeviceProximityStateDidChange, object: nil) &#125; @objc func sensorStateChange(notification: NotificationCenter) &#123; if UIDevice.current.proximityState == true &#123; print(&quot;接近&quot;) &#125; else &#123; print(&quot;远离&quot;) &#125; &#125; 现在对iPhone顶部中心一个孔进行遮挡，就能感受的距离传感器。 Core MotionCore Motion是关于accelerometers(加速计), gyroscopes(陀螺仪), pedometers(步数计), magnetometers( 磁力计), and barometers(气压计)等5个传感器使用的框架， 暂时就按照字面意思翻译成核心运动框架。官方文档的介绍： Core Motion reports motion- and environment-related data from the onboard hardware of iOS devices, including from the accelerometers(加速计), gyroscopes(陀螺仪), pedometers(步数计), magnetometers( 磁力计), and barometers(气压计). You use this framework to access hardware-generated data so that you can use it in your app. For example, a game might use accelerometer and gyroscope data to control onscreen game behavior. 之后的文章就学习Core Motion的使用。😋 参考：1 https://www.zhihu.com/question/25526443/answer/310408872 iPhone这十年在传感器上的演进- 知乎专栏3 iOS开发之传感器4 扒一扒iPhone6的手机传感器5 非典型技术宅 的传感器系列文章 iOS传感器：实现一个随屏幕旋转的图片]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 13：手势处理]]></title>
    <url>%2F2017%2Fios-tutorial-13.html</url>
    <content type="text"><![CDATA[iOS手势处理由UIGestureRecognizer控制，不同手势有这个类的不同子类处理，不同手势处理有不同的相关属性。 子类 描述 UITapGestureRecognizer 点击手势 UIPanGestureRecognizer 跟着手移动手势 UIPinchGestureRecognizer 缩放手势 UIRotationGestureRecognizer 旋转手势 UISwipeGestureRecognizer 轻扫手势 UILongPressGestureRecognizer 长按手势 UIScreenEdgePanGestureRecognizer 屏幕边缘滑动手势 手势处理的步骤一般： 初始化手势，并添加到需要手势的View中 添加手势回调方法 UITapGestureRecognizer属性numberOfTapsRequired表示点击次数，属性numberOfTouchesRequired表示点击手指数。12345678910111213141516171819202122var isChange = false...let tap = UITapGestureRecognizer(target: self, action: #selector(ViewController.tap(tap:)))tap.numberOfTapsRequired = 2...imageView.addGestureRecognizer(tap)...@objc func tap(tap: UITapGestureRecognizer) &#123; let center = imageView.center if isChange &#123; imageView.frame.size.width /= 2 imageView.frame.size.height /= 2 imageView.center = center isChange = false &#125; else &#123; imageView.frame.size.width *= 2 imageView.frame.size.height *= 2 imageView.center = center isChange = true &#125;&#125; UIPanGestureRecognizer1let pan = UIPanGestureRecognizer(target: self, action: #selector(ViewController.pan(pan:))) 12345678910@objc func pan(pan: UIPanGestureRecognizer) &#123; if pan.state == .began || pan.state == .changed &#123; // 移动后的变化（变化值类似向量） let translation = pan.translation(in: imageView.superview) print(translation) imageView.center = CGPoint(x: imageView.center.x + translation.x, y: imageView.center.y + translation.y) // view移动后，把上一步的移动值变为0，否则移动值为递增 pan.setTranslation(CGPoint.zero, in: imageView.superview) &#125;&#125; UIRotationGestureRecognizerlet rotation = UIRotationGestureRecognizer(target: self, action: #selector(ViewController.rotation(rotation:))) 12345@objc func rotation(rotation: UIRotationGestureRecognizer) &#123; if rotation.state == .began || rotation.state == .changed &#123; imageView.transform = CGAffineTransform(rotationAngle: rotation.rotation) &#125;&#125; UISwipeGestureRecognizerlet swipe = UISwipeGestureRecognizer(target: self, action: #selector(ViewController.swipe(swipe:))) swipe.direction = .up swipe.numberOfTouchesRequired = 3 123@objc func swipe(swipe: UISwipeGestureRecognizer) &#123; print(&quot;扫的方向：\(swipe.direction),扫的手指数：\(swipe.numberOfTouchesRequired)&quot;)&#125; UILongPressGestureRecognizernumberOfTouchesRequired 长按的指头数minimumPressDuratio 长按最小时间（秒） let long = UILongPressGestureRecognizer(target: self, action: #selector(ViewController.long(long:))) long.numberOfTouchesRequired = 2 long.minimumPressDuration = 1 123@objc func long(long: UILongPressGestureRecognizer) &#123; print(&quot;长按手势，长按字头数为\(long.numberOfTouchesRequired)&quot;)&#125; UIScreenEdgePanGestureRecognizerlet screenEdge = UIScreenEdgePanGestureRecognizer(target: self, action: #selector(ViewController.screenEdage(screenEdage:))) screenEdge.edges = .left 123@objc func screenEdage(screenEdage: UIScreenEdgePanGestureRecognizer) &#123; print(&quot;屏幕边缘滑动手势：\(screenEdage.edges)&quot;)&#125; 详细代码： GestureDemo]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>手势</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 12：视频背景]]></title>
    <url>%2F2017%2Fios-tutorial-12.html</url>
    <content type="text"><![CDATA[新建项目 BackgroundVideoDemo 新建BackgroundVideo.swift文件： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990import Foundationimport AVKitimport AVFoundationenum BackgroundVideoErrors: Error &#123; case invalidVideo&#125;class BackgroundVideo &#123; var isMuted = true private var player : AVPlayer? private var videoURL: URL? private var viewController: UIViewController? private var hasBeenUsed: Bool = false init (on viewController: UIViewController, withVideoURL URL: String) &#123; self.viewController = viewController // parse the video string to split it into name and extension let videoNameAndExtension:[String]? = URL.characters.split&#123;$0 == &quot;.&quot;&#125;.map(String.init) if videoNameAndExtension!.count == 2 &#123; if let videoName = videoNameAndExtension?[0] , let videoExtension = videoNameAndExtension?[1] &#123; if let url = Bundle.main.url(forResource: videoName, withExtension: videoExtension) &#123; self.videoURL = url // initialize our player with our fetched video url self.player = AVPlayer(url: self.videoURL!) &#125; else &#123; print(BackgroundVideoErrors.invalidVideo) &#125; &#125; &#125; else &#123; print(&quot;Wrong video name format&quot;) &#125; &#125; deinit&#123; if self.hasBeenUsed &#123; NotificationCenter.default.removeObserver(self, name: .AVPlayerItemDidPlayToEndTime, object: nil) NotificationCenter.default.removeObserver(self, name: .UIApplicationWillEnterForeground, object: nil) &#125; &#125; public func setUpBackground()&#123; self.player?.actionAtItemEnd = .none self.player?.isMuted = isMuted //add the video to your view .. let loginView: UIView = self.viewController!.view//get our view controllers view let playerLayer = AVPlayerLayer(player: self.player) playerLayer.videoGravity = AVLayerVideoGravityResizeAspectFill // preserve aspect ratio and resize to fill screen playerLayer.zPosition = -1 // set it&apos;s possition behined anything in our view playerLayer.frame = loginView.frame // set our player frame to our view&apos;s frame loginView.layer.addSublayer(playerLayer) // prevent video from disturbing audio services from other apps do &#123; try AVAudioSession.sharedInstance().setCategory(AVAudioSessionCategoryAmbient) &#125; catch &#123; print(&quot;failed setting AVAudioSession Category to AVAudioSessionCategoryAmbient&quot;) &#125; self.player?.play() // start the video /// 向通知中心发送视频结束后再次从头播放 NotificationCenter.default.addObserver(self, selector: #selector(self.loopVideo), name: .AVPlayerItemDidPlayToEndTime, object: nil) // 视频进入Foreground后从头播放 NotificationCenter.default.addObserver(self, selector: #selector(self.loopVideo), name: .UIApplicationWillEnterForeground, object: nil) self.hasBeenUsed = true &#125; // 循环播放视频 @objc private func loopVideo() &#123; self.player?.seek(to: kCMTimeZero) self.player?.play() &#125; &#125; 在所需要的视图控制器中定义变量var backgroundPlayer : BackgroundVideo?，然后再在viewDidLoad中定义： 12345678910 override func viewDidLoad() &#123; super.viewDidLoad() let backgroundPlayer = BackgroundVideo(on: self, withVideoURL: &quot;test.mp4&quot;) //是否打开静音// backgroundPlayer?.isMuted = false backgroundPlayer.setUpBackground() &#125; 详细代码： BackgroundVideoDemo 参考：BackgroundVideoiOS]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 10：UIScrollView滚动视图]]></title>
    <url>%2F2017%2Fios-tutorial-10-uiscrolview.html</url>
    <content type="text"><![CDATA[知识点: UIScrollView 当视图超过屏幕大小时，可通过把视图放在UIScrollView中让视图可以上下滚动的功能。以一张大图片为例。 新建项目 ScrollViewTutorial 代码：12345678910111213141516171819202122class ViewController: UIViewController &#123; var imageView: UIImageView! var scrollView: UIScrollView! override func viewDidLoad() &#123; super.viewDidLoad() imageView = UIImageView(image: UIImage(named: &quot;strandvagen.jpg&quot;)) scrollView = UIScrollView(frame: view.bounds) scrollView.backgroundColor = UIColor.black scrollView.contentSize = imageView.bounds.size scrollView.addSubview(imageView) view.addSubview(scrollView) &#125; &#125; 详细代码：ScrollViewTutorial 参考：Scroll View Tutorial in iOS8 with Swift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 11：照片横屏滑动]]></title>
    <url>%2F2017%2Fios-tutorial-11.html</url>
    <content type="text"><![CDATA[知识点： UICollectionView UIVisualEffectView UICollectionViewDataSource 新建项目Carousel Effect 在IB构建UI。Collection View 里的 Scroll Direction 设置成水平滚动。UIVisualEffectView是用来添加模糊效果的，也可以使用类似如下的代码构建： 1234let blurEffect = UIBlurEffect(style: .dark)let blurEffectView = UIVisualEffectView(effect: blurEffect)blurEffectView.frame = view.boundsbackgroundImageView.addSubview(blurEffectView) 创建数据类Interest 创建UICollectionViewCell 实现UICollectionViewDataSource的方法（有点类似UITableViewDataSource）。12345678910111213141516171819202122232425262728293031323334353637class ViewController: UIViewController, UICollectionViewDataSource &#123; @IBOutlet weak var backgroundImageView: UIImageView! @IBOutlet weak var collectionView: UICollectionView! var interests = Interest.createInterests() override func viewDidLoad() &#123; super.viewDidLoad() collectionView.dataSource = self collectionView.dataSource = self &#125; override var preferredStatusBarStyle : UIStatusBarStyle &#123; return UIStatusBarStyle.lightContent &#125; func numberOfSections(in collectionView: UICollectionView) -&gt; Int &#123; return 1 &#125; func collectionView(_ collectionView: UICollectionView, numberOfItemsInSection section: Int) -&gt; Int &#123; return interests.count &#125; func collectionView(_ collectionView: UICollectionView, cellForItemAt indexPath: IndexPath) -&gt; UICollectionViewCell &#123; let CellIdentifier = &quot;InterestCell&quot; let cell = collectionView.dequeueReusableCell(withReuseIdentifier: CellIdentifier, for: indexPath) as! InterestCollectionViewCell cell.interest = self.interests[indexPath.item] return cell &#125;&#125; 详细代码： Carousel Effect 参考：30DaysofSwift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 9：本地视频播放]]></title>
    <url>%2F2017%2Fios-tutorial-9.html</url>
    <content type="text"><![CDATA[新建项目PlayLocalVideo 在IB中使View ControllerEmbed In &gt; Navigation Controller,并在View Controller**中添加UITableView和UITableViewCell。 在上面的UITableViewCell的中添加一个UIImageView作为视频的预览图、一个UIButton作为开始播放、两个UILabel分别用于显示视频的名称和来源。并修改一定样式和添加一定约束 添加几张图片和一个视频 添加一个cell的类，并添加三个接口。 12345class VideoCell: UITableViewCell &#123; @IBOutlet var previewImageView: UIImageView! @IBOutlet var nameLabel: UILabel! @IBOutlet var sourceLabel: UILabel! 添加一个video枚举，用来存储视频信息。 12345struct video &#123; let image: String let title: String let source: String&#125; 使ViewController符合table view代理和数据的协议，并实现所需方法： 12345678910111213141516171819202122232425func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -&gt; CGFloat &#123; return 220 &#125; func numberOfSectionsInTableView(tableView: UITableView) -&gt; Int &#123; return 2 &#125; func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return data.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! VideoCell let video = data[indexPath.row] cell.previewImageView.image = UIImage(named: video.image) cell.nameLabel.text = video.title cell.sourceLabel.text = video.source return cell &#125; 引入播放视频所需框架，并定义相关变量。 1234567import AVFoundationimport AVKit... var playViewController : AVPlayerViewController? var playerView : AVPlayer? 实现视频播放按钮方法。 12345678910111213@IBAction func playVideo(_ sender: UIButton) &#123; let path = Bundle.main.path(forResource: &quot;KL&quot;, ofType: &quot;mp4&quot;) playerView = AVPlayer(url: URL(fileURLWithPath: path!)) playViewController = AVPlayerViewController() playViewController?.player = playerView present(playViewController!, animated: true, completion: &#123; self.playViewController?.player?.play() &#125;) &#125; 详细代码： PlayLocalVideo 参考： 30DaysofSwift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Alamofire：Swift的HTTP 网络库]]></title>
    <url>%2F2017%2Falamofire-introduce.html</url>
    <content type="text"><![CDATA[安装 CocoaPods和Carthage都很方便安装安装完，如果出现加载不到Alamofire，可以查看Cannot load underlying module for ‘Alamofire’ #441，问题应该可以解决。 手动安装 下载Alamofire 将Alamofire.xcodeproj拖进到项目中 在“Embedded Binaries中添加 command + B 编译后就可以使用 关于 https://httpbin.org/ 网站 https://httpbin.org/ 网站可用来做http的各种请求测试使用，不过遗憾的是没有POST等提交类型请求的测试 基本使用一个简单的请求： 123import AlamofireAlamofire.request(&quot;https://httpbin.org/get&quot;) http中有请求(Request) 和 响应(Response)两个重要概念。大部分http框架，都会使用request和response作为方法名。看看Alamofire的request方法的详细参数： 12345678public func request( _ url: URLConvertible, method: HTTPMethod = .get, parameters: Parameters? = nil, encoding: ParameterEncoding = URLEncoding.default, headers: HTTPHeaders? = nil) -&gt; DataRequest&#123; 有url,method,parameters,encoding,headers五个参数，与http是相互对应的。其中只有url是必须的，其它都有默认值。 请求后的响应处理向http发送请求后，就需对响应结果进行处理。 Alamofire采用链式调用的方式处理响应，这种链式调用的方式最初应该是起源jQuery。响应处理的一般形式如下，response就是响应结果。 123Alamofire.request(&quot;https://httpbin.org/get&quot;).responseJSON &#123; response in&#125; Alamofire 提供了五种不同的响应处理： 123456789101112131415161718192021222324252627282930// Response Handler - Unserialized Responsefunc response( queue: DispatchQueue?, completionHandler: @escaping (DefaultDataResponse) -&gt; Void) -&gt; Self// Response Data Handler - Serialized into Datafunc responseData( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Data&gt;) -&gt; Void) -&gt; Self// Response String Handler - Serialized into Stringfunc responseString( queue: DispatchQueue?, encoding: String.Encoding?, completionHandler: @escaping (DataResponse&lt;String&gt;) -&gt; Void) -&gt; Self// Response JSON Handler - Serialized into Anyfunc responseJSON( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void) -&gt; Self// Response PropertyList (plist) Handler - Serialized into Anyfunc responsePropertyList( queue: DispatchQueue?, completionHandler: @escaping (DataResponse&lt;Any&gt;) -&gt; Void)) -&gt; Self 五种方法的参数不同，但最后一参数都是一个回调的闭包，都可以写成尾随闭包形式。除了response方法的回调参数是DefaultDataResponse，其它都是DataResponse: 1234567891011121314151617181920212223public struct DataResponse&lt;Value&gt; &#123; /// The URL request sent to the server. public let request: URLRequest? /// The server&apos;s response to the URL request. public let response: HTTPURLResponse? /// The data returned by the server. public let data: Data? /// The result of response serialization. public let result: Result&lt;Value&gt; /// The timeline of the complete lifecycle of the request. public let timeline: Timeline /// Returns the associated value of the result if it is a success, `nil` otherwise. public var value: Value? &#123; return result.value &#125; /// Returns the associated error value if the result if it is a failure, `nil` otherwise. public var error: Error? &#123; return result.error &#125; var _metrics: AnyObject? DataResponse与DefaultDataResponse最大的不同就是多了两个属性result和value，value值就是格式化的不同类型。 响应处理的一些例子 response 123456789Alamofire.request(&quot;https://httpbin.org/get&quot;).response &#123; response in print(&quot;Request: \(response.request)&quot;) print(&quot;Response: \(response.response)&quot;) print(&quot;Error: \(response.error)&quot;) if let data = response.data, let utf8Text = String(data: data, encoding: .utf8) &#123; print(&quot;Data: \(utf8Text)&quot;) &#125;&#125; response方法的响应结果response是DefaultDataResponse，没有进行过格式化处理。 responseData 12345678910 Alamofire.request(&quot;https://httpbin.org/get&quot;).responseData &#123; response in debugPrint(&quot;All Response Info: \(response)&quot;) if let data = response.result.value, let utf8Text = String(data: data, encoding: .utf8) &#123; print(&quot;Data: \(utf8Text)&quot;) &#125; &#125; ``` `responseData`方法对响应结果进行了处理，`response.result.value`就是我们属性的`Data`类型。+ 链式调用 Alamofire.request(&quot;https://httpbin.org/get&quot;) .responseString { response in print(&quot;Response String: \(response.result.value)&quot;) } .responseJSON { response in print(&quot;Response JSON: \(response.result.value)&quot;) } 1234### 响应验证http响应结果中的不同状态码(`100..&lt;600`)表示不同结果。- 手动验证 Alamofire.request(“https://httpbin.org/get“).validate(statusCode: 200..&lt;300).validate(contentType: [“application/json”]).responseData { response in switch response.result { case .success: print(&quot;Validation Successful&quot;) case .failure(let error): print(error) } } 12- 自动验证状态码在`200..&lt;300`的为正确，其它为错误。 Alamofire.request(“https://httpbin.org/get&quot;).validate().responseJSON { response inswitch response.result {case .success: print(&quot;Validation Successful&quot;) case .failure(let error): print(error) }} 123### HTTP不同请求方式`request`方法的`method`参数表示不同的方法。 Alamofire.request(“https://httpbin.org/get“) // method defaults to .get Alamofire.request(“https://httpbin.org/post“, method: .post)Alamofire.request(“https://httpbin.org/put“, method: .put)Alamofire.request(“https://httpbin.org/delete“, method: .delete)12345### 请求参数编码`GET`的参数按照固定格式写到URL中，其他类型则按照不同格式写到请求body中。- GET参数编码 let parameters: Parameters = [&quot;foo&quot;: &quot;bar&quot;] // All three of these calls are equivalent Alamofire.request(&quot;https://httpbin.org/get&quot;, parameters: parameters) // encoding defaults to `URLEncoding.default` Alamofire.request(&quot;https://httpbin.org/get&quot;, parameters: parameters, encoding: URLEncoding.default) Alamofire.request(&quot;https://httpbin.org/get&quot;, parameters: parameters, encoding: URLEncoding(destination: .methodDependent)) // https://httpbin.org/get?foo=bar 1- POST参数编码 let parameters: Parameters = [ &quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: [&quot;a&quot;, 1], &quot;qux&quot;: [ &quot;x&quot;: 1, &quot;y&quot;: 2, &quot;z&quot;: 3 ] ] // All three of these calls are equivalent Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters) Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: URLEncoding.default) Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: URLEncoding.httpBody) // HTTP body: foo=bar&amp;baz[]=a&amp;baz[]=1&amp;qux[x]=1&amp;qux[y]=2&amp;qux[z]=3 12- JSON编码 let parameters: Parameters = [ &quot;foo&quot;: [1,2,3], &quot;bar&quot;: [ &quot;baz&quot;: &quot;qux&quot; ] ] // Both calls are equivalent Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: JSONEncoding.default) Alamofire.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: parameters, encoding: JSONEncoding(options: [])) // HTTP body: {&quot;foo&quot;: [1, 2, 3], &quot;bar&quot;: {&quot;baz&quot;: &quot;qux&quot;}} 12### 添加请求HTTP头部 let headers: HTTPHeaders = [ “Authorization”: “Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==”, “Accept”: “application/json”] Alamofire.request(“https://httpbin.org/headers“, headers: headers).responseJSON { response in debugPrint(response)} 12### HTTP认证 let user = &quot;user&quot; let password = &quot;password&quot; Alamofire.request(&quot;https://httpbin.org/basic-auth/\(user)/\(password)&quot;) .authenticate(user: user, password: password) .responseJSON { response in debugPrint(response) } 12### 下载文件 Alamofire.download(&quot;https://httpbin.org/image/png&quot;).responseData { response in if let data = response.result.value { let image = UIImage(data: data) } } 1另外可以下文件保存在本地： let destination: DownloadRequest.DownloadFileDestination = { _, _ in let documentsURL = FileManager.default.urls(for: .documentDirectory, in: .userDomainMask)[0] let fileURL = documentsURL.appendingPathComponent(&quot;pig.png&quot;) return (fileURL, [.removePreviousFile, .createIntermediateDirectories]) } Alamofire.download(&quot;https://httpbin.org/image/png&quot;, to: destination).response { response in print(response) if response.error == nil, let imagePath = response.destinationURL?.path { let image = UIImage(contentsOfFile: imagePath) self.imageView.image = image self.tableView.reloadData() } } 123### 上传- 上传 `Data` let imageData = UIImagePNGRepresentation(image!)! Alamofire.upload(imageData, to: &quot;https://httpbin.org/post&quot;).responseJSON { response in debugPrint(response) } 1- 上传文件 let fileURL = Bundle.main.url(forResource: &quot;video&quot;, withExtension: &quot;mov&quot;) Alamofire.upload(fileURL!, to: &quot;https://httpbin.org/post&quot;).responseJSON { response in debugPrint(response) } 1- 上传Multipart Form Data（表单提交） Alamofire.upload( multipartFormData: { multipartFormData in multipartFormData.append(unicornImageURL, withName: &quot;unicorn&quot;) multipartFormData.append(rainbowImageURL, withName: &quot;rainbow&quot;) }, to: &quot;https://httpbin.org/post&quot;, encodingCompletion: { encodingResult in switch encodingResult { case .success(let upload, _, _): upload.responseJSON { response in debugPrint(response) } case .failure(let encodingError): print(encodingError) } } ) 12### 请求中花费的各种时间 Alamofire.request(“https://httpbin.org/get&quot;).responseJSON { response in print(response.timeline)}1结果： Timeline: { “Latency”: 1.527 secs, “Request Duration”: 1.528 secs, “Serialization Duration”: 0.001 secs, “Total Duration”: 1.529 secs }```]]></content>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 1 前言和目录]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-1.html</url>
    <content type="text"><![CDATA[这是我学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的记录，章节和原书不同。 开发环境是Xcode 8，Swift 3，iOS 10。 我的代码在github上，andyRon/Beginning-iOS-Programming-with-Swift 目录 开始用Swift开发iOS 10 - 1 前言和目录 开始用Swift开发iOS 10 - 2 Hello World！第一个Swift APP 开始用Swift开发iOS 10 - 3 介绍Auto Layout 开始用Swift开发iOS 10 - 4 用Stack View设计UI 开始用Swift开发iOS 10 - 5 原型的介绍 开始用Swift开发iOS 10 - 6 创建简单的Table Based App 开始用Swift开发iOS 10 - 7 定制Table Views 开始用Swift开发iOS 10 - 8 Table View和UIAlertController的交互 开始用Swift开发iOS 10 - 9 Table Row的删除, UITableViewRowAction和UIActivityViewController的使用 开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue 开始用Swift开发iOS 10 - 11 面向对象编程介绍 开始用Swift开发iOS 10 - 12 丰富Detail View和定制化Navigation Bar 开始用Swift开发iOS 10 - 13 Self Sizing Cells and Dynamic Type 开始用Swift开发iOS 10 - 14 基础动画，模糊效果和Unwind Segue 开始用Swift开发iOS 10 - 15 使用地图 开始用Swift开发iOS 10 - 16 介绍静态Table Views，UIImagePickerController和NSLayoutConstraint 开始用Swift开发iOS 10 - 17 使用Core Data 开始用Swift开发iOS 10 - 18 Search Bar 和 UISearchController 开始用Swift开发iOS 10 - 19 使用UIPageViewController构建介绍页面 开始用Swift开发iOS 10 - 20 使用Tab Bar Controller 和 拆分Storyboard 开始用Swift开发iOS 10 - 21 使用WKWebView和SFSafariViewController 开始用Swift开发iOS 10 - 22 使用CloudKit [开始用Swift开发iOS 10 - 24 使用TestFlight进行Beta测试]http://andyron.com/2017/beginning-ios-swift-24.html) 开始用Swift开发iOS 10 - 25 使用3D Touch 开始用Swift开发iOS 10 - 26 使用本地用户通知]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 8：使用IBInspectable 和 IBDesignable定制UI]]></title>
    <url>%2F2017%2Fios-tutorial-8-ibinspectable-ibdesignable.html</url>
    <content type="text"><![CDATA[例子代码：https://github.com/andyRon/LearniOSByProject/tree/master/77 理解IBInspectable 和 IBDesignable简单地说，IBInspectable 就是允许开发者在IB的属性检查器中添加额外的选项。IBDesignable 能够让 IBInspectable 添加的额外选项产生的变化在IB中实时显示。以Button的圆角为例说明。 正常情况下，Button的圆角需要代码：12button.layer.cornerRadius = 10.0button.layer.masksToBounds = true 或者直接在IB的Identity检查器的 user defined runtime attributes中添加： 注意到，这种修改不是实时，在IB中Button还是直角，只有运行后才是圆角。 以IBInspectable的方式。定义个继承至UIButton的类。12345678class RoundedCornerButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125;&#125; 然后把button的class属性修改成RoundedCornerButton: 发现这个button的属性检查器中多了Corner Radius。 注意： cornerRadius属性变成了Corner Radius，RoundedCornerButton类变成了 Rounded Corner Button，这是Xcode自动转变的，开发者只需要依照swift的命名规范就可以了（类名是大写开头的驼峰命名规则，属性名是小写开头的驼峰命名规则） cornerRadius的类型是CGFloat，在属性检查器中就对应数字的选择。当然不是所有类型都可以添加属性检查器中的，IBInspectable支持如下类型：12345678910IntCGFloat Double String Bool CGPoint CGSize CGRect UIColor UIImage 如果在类RoundedCornerButton前添加@IBDesignable，那在属性检查器中自定义的属性变化就可以在IB中实时显示了。12345678@IBDesignable class RoundedCornerButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125;&#125; 创建Fancy Button创建Fancy Button来更加深入的了解IBInspectable 和 IBDesignable 创建新项目FancyButton 下载图标，也可以随意图标，拖进asset catalog 新建类FancyButton，继承至UIButton 圆角，边宽，边的颜色。 更新FancyButton：12345678910111213141516171819@IBDesignableclass FancyButton: UIButton &#123; @IBInspectable var cornerRadius: CGFloat = 0.0 &#123; didSet &#123; layer.cornerRadius = cornerRadius layer.masksToBounds = cornerRadius &gt; 0 &#125; &#125; @IBInspectable var borderWidth: CGFloat = 0.0 &#123; didSet &#123; layer.borderWidth = borderWidth &#125; &#125; @IBInspectable var borderColor: UIColor = .black &#123; didSet &#123; layer.borderColor = borderColor.cgColor &#125; &#125;&#125; Title在FancyButton继续添加属性：1234567891011121314151617181920@IBInspectable var titleLeftPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.left = titleLeftPadding &#125;&#125;@IBInspectable var titleRightPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.right = titleRightPadding &#125;&#125;@IBInspectable var titleTopPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.top = titleTopPadding &#125;&#125;@IBInspectable var titleBottomPadding: CGFloat = 0.0 &#123; didSet &#123; titleEdgeInsets.bottom = titleBottomPadding &#125;&#125; 通过圆角可创建圆形button Image Padding添加图片边距的属性：123456789101112131415161718192021@IBInspectable var imageLeftPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.left = imageLeftPadding &#125;&#125;@IBInspectable var imageRightPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.right = imageRightPadding &#125;&#125;@IBInspectable var imageTopPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.top = imageTopPadding &#125;&#125;@IBInspectable var imageBottomPadding: CGFloat = 0.0 &#123; didSet &#123; imageEdgeInsets.bottom = imageBottomPadding &#125;&#125; 图片靠右对齐根据下图关系，应有imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding。 在FancyButton中添加如下代码： 123456789@IBInspectable var enableImageRightAligned: Bool = falseoverride func layoutSubviews() &#123; super.layoutSubviews() if enableImageRightAligned, let imageView = imageView &#123; imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding &#125;&#125; + `enableImageRightAligned`属性又来自动计算 `imageEdgeInsets.left` 颜色渐变添加三个@IBInspectable属性，并更新layoutSubviews:1234567891011121314151617181920@IBInspectable var enableGradientBackground: Bool = false@IBInspectable var gradientColor1: UIColor = UIColor.black@IBInspectable var gradientColor2: UIColor = UIColor.whiteoverride func layoutSubviews() &#123; super.layoutSubviews() if enableImageRightAligned, let imageView = imageView &#123; imageEdgeInsets.left = self.bounds.width - imageView.bounds.width - imageRightPadding &#125; if enableGradientBackground &#123; let gradientLayer = CAGradientLayer() gradientLayer.frame = self.bounds gradientLayer.colors = [gradientColor1.cgColor, gradientColor2.cgColor] gradientLayer.startPoint = CGPoint(x: 0.0, y: 0.5) gradientLayer.endPoint = CGPoint(x: 1.0, y: 0.5) self.layer.insertSublayer(gradientLayer, at: 0) &#125;&#125; 渐变色需要运行后才能看到 参考：appcode网站的书《Intermediate iOS Programming with Swift》 的Chapter 36]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[DownGit：怎么下载github中某个文件夹？]]></title>
    <url>%2F2017%2Fdowngit.html</url>
    <content type="text"><![CDATA[怎么下载github中某个文件夹？ github只提供了整个项目下载。下载一个项目中的某个文件夹的内容，这种需求在使用github时，还是经常使用的。 比如：在一些大的项目下，只想看某个文件的内容时。又比如，像我这种andyRon/LearniOSByProject，就是我一些学习iOS的小项目或者Demo的集合，如果只想查看某个小项目，而不下载整个项目时。 方法很简单，早就有前辈想到了，DownGit这个网站就提供这个功能，只要把目录链接（比如：https://github.com/andyRon/LearniOSByProject/tree/master/76）拷贝，然后点击download就可以下载目录的压缩文件。]]></content>
      <tags>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS本地化(swift)]]></title>
    <url>%2F2017%2Fios-localize.html</url>
    <content type="text"><![CDATA[示例代码在github上localizationsDemo 1 项目中需要配置的语言这就是项目中其他不同形式本地化可以添加的语种设置。 如下图为项目添加不同语种 弹框中显示要为两个Storyboard文件添加语种信息 添加完多语种后，相关需要本地化的文件会产生一组文件 实际在目录结构中是根据不同语言生成不同的*.lproj目录，再在*.lproj目录中生成了不同的.strings文件。 2 应用名称本地化App的名称在不同语种下显示不同。 新建一个.strings文件，名为InfoPlist.strings。 选中InfoPlist.strings，在右侧的文件检查器中点击Localize，在弹框中可以选择语种，对应项目中需要配置的语言中配置的语种。 可选中需要本地化的应用名称的语种： 在InfoPlist.strings的不同语种文件中添加字段CFBundleDisplayName，表示应用的名称。CFBundleDisplayName = &quot;简体中文名称&quot;; 在模拟器中，可通过Edit Scheme...编辑语种： 3 代码中的字符串的本地化类似应用名称本地化，代码中的字符串的本地也是利用.strings文件存储翻译信息。然后再在代码中利用NSLocalizedString（翻译信息默认在Localizable.strings文件）或NSLocalizedString(_:tableName:bundle:value:comment:)（翻译信息在tableName对应的.strings文件）文件标注。 NSLocalizedString(_:tableName:bundle:value:comment:)这种方式可根据需要把翻译信息保存在自定义的文件中，在多人开发时可以很好的防止冲突。 新建一个名为Localizable.strings的.strings文件。 类似InfoPlist.strings文件的配置方式，配置不同语种。 在代码中需要本地化的字符串修改为类似NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)或NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;) 4 图片的本地化这边所说的图片的本地化就是指，同一个名称图片，在不同语种下显示不同图片。 随意添加一张图片到项目，比如Swift_Logo.png 选中上面的图片，在右侧的文件检查器中点击Localize，类似之前的做法，添加所需的不同语种。 在Finder中的不同语种的*.lproj目录中添加，相同名字但不同的图片 在代码中添加类似的代码： self.imageView.image = UIImage(named: NSLocalizedString(&quot;Swift_Logo&quot;, comment: &quot;&quot;)) 最后的英文中的状态结果为： 5 优化本地化代码书写方式本地化时，NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)或NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;)这两种方法代码写法有点繁琐，参考stackoverflow中一个问题What’s NSLocalizedString equivalent in Swift?Ask的一个答案，扩展一下String：12345678910111213extension String &#123; var localized: String &#123; return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;&quot;) &#125; func localized(withComment:String) -&gt; String &#123; return NSLocalizedString(self, tableName: nil, bundle: Bundle.main, value: &quot;&quot;, comment: withComment) &#125; func localized(tableName: String) -&gt; String&#123; return NSLocalizedString(self, tableName: tableName, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;&quot;) &#125;&#125; 然后，原本下面的写法：123self.label.text = NSLocalizedString(&quot;labelName&quot;, comment: &quot;Label&quot;)self.label2.text = NSLocalizedString(&quot;labelName&quot;, tableName: &quot;andy&quot;, bundle: Bundle.main, value: &quot;&quot;, comment: &quot;Label&quot;)self.imageView.image = UIImage(named: NSLocalizedString(&quot;Swift_Logo&quot;, comment: &quot;&quot;)) 就可以写成：123self.label.text = &quot;labelName&quot;.localizedself.label2.text = &quot;labelName&quot;.localized(tableName: &quot;andy&quot;)self.imageView.image = UIImage(named: &quot;Swift_Logo&quot;.localized) 参考：【iOS】浅谈多语言本地化(国际化)3分钟实现iOS语言本地化/国际化（图文详解）What’s NSLocalizedString equivalent in Swift?Ask]]></content>
  </entry>
  <entry>
    <title><![CDATA[Carthage的使用]]></title>
    <url>%2F2017%2Fcarthage-introduce.html</url>
    <content type="text"><![CDATA[Carthage与CocoaPods的简单比较 CocoaPods 的优势： 使用方便，除编写 Podfile 以外其他几乎都是自动完成； 软件包数量多，主流支持； CocoaPods 的缺点： 每次更新环境都需要连接到中心仓库，比较耗时； 开发者使用比较简单，但是如果创建兼容 CocoaPods 的库，就会相对繁琐一些（尽管有了命令行）； 每次干净编译都会把所有第三方库都重新编译一次（看似很正确，直到我遇见 Carthage…） Carthage 的优势 第三方库不是每一次都重新编译，节省时间； 去中心化，没有中心服务器，这意味着每次配置和更新环境，只会去更新具体的库，而不会有一个向中心服务器获取最新库的索引这么个过程，节省时间； 与 CocoaPods 无缝集成； 结构标准的项目天然就是 Carthage 库； 安装Carthagebrew install carthage 使用Carthage 进入项目文件夹，比如建立新项目 carthageDemo 创建空文件Cartfile，命令：touch Cartfile 编辑Cartfile文件(xcode，或其它文本编辑器)，以SVProgressHUD为例，Cartfile文件内容大致如下： 1github &quot;SVProgressHUD/SVProgressHUD&quot; ~&gt; 1.0 Cartfile文件格式说明: 依赖源有两种，github和git，就是告诉 Carthage到哪里下载第三方库，例子如下：1234567891011121314151617181920212223# Require version 2.3.1 or latergithub &quot;ReactiveCocoa/ReactiveCocoa&quot; &gt;= 2.3.1# Require version 1.xgithub &quot;Mantle/Mantle&quot; ~&gt; 1.0 # (1.0 or later, but less than 2.0)# Require exactly version 0.4.1github &quot;jspahrsummers/libextobjc&quot; == 0.4.1# Use the latest versiongithub &quot;jspahrsummers/xcconfigs&quot;# Use the branchgithub &quot;jspahrsummers/xcconfigs&quot; &quot;branch&quot;# Use a project from GitHub Enterprisegithub &quot;https://enterprise.local/ghe/desktop/git-error-translations&quot;# Use a project from any arbitrary server, on the &quot;development&quot; branchgit &quot;https://enterprise.local/desktop/git-error-translations2.git&quot; &quot;development&quot;# Use a local projectgit &quot;file:///directory/to/project&quot; &quot;branch&quot; 从上面的例子中有很详细的版本号例子： == 1.0 使用1.0版本 &gt;= 1.0 使用1.0或更高的版本 ~&gt; 1.0 使用高于1.0但低于2.0的最新版本 没有的是使用最新版本 branch名称/tag名称/commit名称 使用特定分支/标签/提交版本 运行Carthage carthage update [--platform iOS]--platform iOS是针对iOS的，可选项。在项目根目录下会生成一个Cartfile.resolved文件和Carthage文件夹，Carthage文件夹中的Build目录下有编译好的framework文件，Checkouts目录第三库的源文件。 把库添加到项目中 把编译好的framework文件拖动到Linked Frameworks and Libraries或者点击+选择。 在Build Phases中添加一个Run Script。命令为 /usr/local/bin/carthage copy-frameworks。Input Files下的条目为$(SRCROOT)/Carthage/Build/iOS/SVProgressHUD.framework。具体操作如下图： 编译就可以使用第三方库了 其他 新加库时在Cartfile文件中添加后，然后操作类似上面的 更新指定库：carthage update SVProgressHUD --platform iOS 参考：Carthage的安装和使用【译】Carthage的使用Carthage 初探：四大优势与四大劣势Carthage官方地址]]></content>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习7：内存管理]]></title>
    <url>%2F2017%2Foc-basic-7.html</url>
    <content type="text"><![CDATA[1 对象生命周期 诞生（通过alloc或new方法实现） -&gt; 生存（接收消息并执行操作） -&gt; 交友（通过复合以及向方法传递参数） -&gt; 死去（被释放掉） 引用计数(reference counting) / 保留计数(retain counting) alloc, new, copy: 创建对象，保留计数被设置为1 retain: 保留计数加1。如[[car retain] setTire: tire atIndex:2];表示要求car对象将其保留计数的值加1并执行setTire操作。 release: 保留计数减1 dealloc: 保留计数归0时自动调用 retainCount: 获得对象保留计数当前值1234567891011121314151617181920212223242526272829303132333435363738394041424344#import &lt;Foundation/Foundation.h&gt;@interface RetainTracker : NSObject@end@implementation RetainTracker- (id) init&#123; if (self = [super init]) &#123; NSLog(@&quot;init: Retain count of %lu .&quot;, [self retainCount]); &#125; return self;&#125; // init- (void)dealloc&#123; NSLog(@&quot;dealloc called. Bye Bye.&quot;); [super dealloc];&#125; // dealloc@end // RetainTrackerint main(int argc, const char * argv[]) &#123; RetainTracker *a = [RetainTracker new]; [a retain]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a retain]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a release]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a release]; NSLog(@&quot;%lu&quot;, [a retainCount]); [a release]; NSLog(@&quot;%lu&quot;, [a retainCount]); // 为什么此处是 1 不是 0吗？ return 0;&#125; 对象所有权(object ownership)如果一个对象内有指向其他对象的实例变量，则称 该对象拥有这些对象。 访问方法中的保留和释放所有对象放入池中 @autoreleasepool/NSAutoreleasePool： 自动释放池 NSObject提供autorelease方法：- (id) autorelease; 2 Cocoa的内存管理规则 3 异常与异常有关的关键字 @try @catch @finally @throw 捕捉不同类型的异常123456@try &#123;&#125; @catch (MyCustomException *custom) &#123;&#125; @catch (NSException *exception) &#123;&#125; @catch (id value) &#123;&#125; @finally &#123;&#125; 抛出异常抛出异常的两种方式： @throw异常名 向某个NSException对象发送raise消息1234NSException *theException = [NSException exceptionWithName: ...];@throw theException;[theException raise]; 区别：raise只对NSException对象有效，@throw异常名可用在其他对象上。 异常也需要内存管理异常和自动释放池]]></content>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 26 使用本地用户通知]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-26.html</url>
    <content type="text"><![CDATA[iOS 10 之前用户通知相对而言是简单的，iOS 10让用户通知更加丰富了，可以有静态图片，动态gif，视频，音频等。 用户通知可以出现在通知中心，主屏，锁屏时，当用户错过了用户通知时，可以在通知中心查看。 用户通知分为两类： 本地通知。 是通过应用本身和用户设备本身触发的。比如：基于用户位置的app，在用户进入某个特殊区域发送通知；to-do list的app在某些特定时间发送通知。 远程通知。 是远程服务器端首先向苹果推送服务器（Apple Push Notification Service ，APNS）发送，然后再经过APNS推送通知到用户设备。 这一篇只讨论本地通知。 三种不同触发的本地通知： 特定数量的时间。 比如是10分钟后。 特定日期和时间点。 特定位置。 询问用户授权向用户发送通知是要得到用户允许的。 在AppDelegate.swift中添加 import UserNotifications 在application(_:didFinishLaunchingWithOptions:)方法中添加授权12345678UNUserNotificationCenter.current().requestAuthorization(options: [.alert, .sound, .badge], completionHandler: &#123; (granted, error) in if granted &#123; print(&quot;User notifications are allowed.&quot;) &#125; else &#123; print(&quot;User notifications are not allowed.&quot;) &#125;&#125;) 创建通知通知的一般结构： 通知用UNMutableNotificationContent类来表示。 在RestaurantTableViewController中添加一个方法 12345678910111213141516171819202122func prepareNotification() &#123; // Make sure the restaurant array is not empty if restaurants.count &lt;= 0 &#123; return &#125; // 1 let randomNum = Int(arc4random_uniform(UInt32(restaurants.count))) let suggestedRestaurant = restaurants[randomNum] // 2 let content = UNMutableNotificationContent() content.title = &quot;Restaurant Recommendation&quot; content.subtitle = &quot;Try new food today&quot; content.body = &quot;I recommend you to check out \(suggestedRestaurant.name!).The restaurant is one of your favorites. It is located at \(suggestedRestaurant.location!). Would you like to give it a try?&quot; content.sound = UNNotificationSound.default() // 3 let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 10, repeats: false) let request = UNNotificationRequest(identifier: &quot;foodpin.restaurantSuggestion&quot;, content: content, trigger: trigger) // Schedule the notification UNUserNotificationCenter.current().add(request, withCompletionHandler: nil) &#125; 1 获得一个随机的restaurant 2 通过UNMutableNotificationContent获得一个通知，配置参数，sound表示需要通知声音。 3 UNTimeIntervalNotificationTrigger是一个时间触发，为了好测试，表示10s后通知一次。 在viewDidLoad中实现上面函数。prepareNotification() 现在运行，注意在应用内是不能接受本应用通知，所以运行后立即进入主屏或锁屏。通知本身有高度限制，内容过长会不显示，只要向下滑动就可以显示完整。 向通知中添加图片图片等富文本内容通过UNMutableNotificationContent的attachments属性添加，attachments属性是UNNotificationAttachment的数组。UNNotificationAttachment可以是图片、音频、音效、视频文件。 在prepareNotification中的触发之前添加代码： 123456789101112// 1let tempDirURL = URL(fileURLWithPath: NSTemporaryDirectory(), isDirectory: true)let tempFileURL = tempDirURL.appendingPathComponent(&quot;suggested-restaurant.jpg&quot;)if let image = UIImage(data: suggestedRestaurant.image! as Data) &#123; // 2 try? UIImageJPEGRepresentation(image, 1.0)?.write(to: tempFileURL) if let restaurantImage = try? UNNotificationAttachment(identifier: &quot;restaurantImage&quot;, url: tempFileURL, options: nil) &#123; content.attachments = [restaurantImage] &#125;&#125; 1 由于使用Core Data，图片以NSData形式存储了，所以使用NSTemporaryDirectory来生成临时目录存储临时图片文件 2 UIImageJPEGRepresentation用来生成jpg图片文件 运行查看，同样向下滑动可查看完整。 和通知的交互之前只要点击通知进入应用的交互，这是默认的交互。 在prepareNotification中的触发之前添加代码： 123456789101112 // 1let categoryIdentifer = &quot;foodpin.restaurantaction&quot;// 3let makeReservationAction = UNNotificationAction(identifier: &quot;foodpin.makeReservation&quot;, title: &quot;Reserve a table&quot;, options: [.foreground])let cancelAction = UNNotificationAction(identifier: &quot;foodpin.cancel&quot;, title: &quot;Later&quot;, options: [])// 4let category = UNNotificationCategory(identifier: categoryIdentifer, actions:[makeReservationAction, cancelAction], intentIdentifiers: [], options: [])// 5UNUserNotificationCenter.current().setNotificationCategories([category])// 2 content.categoryIdentifier = categoryIdentifer 1,2 categoryIdentifier是让通知和category关联起来 3 UNNotificationAction有点类似UIAlertAction，options: [.foreground]表示让应用到前台，就是启动应用 4 UNNotificationCategory有点类似UIAlertController 5 把UNNotificationCategory注册到用户中心 处理Actions上面的options: [.foreground]只是启动了应用，没有实现具体操作。UNUserNotificationCenterDelegate中的userNotificationCenter(_:didReceive:withCompletionHandler:)方法在UNNotificationAction被选择时调用，在这个方法内部可实现具体操作。 让AppDelegate符合协议UNUserNotificationCenterDelegate 实现userNotificationCenter(_:didReceive:withCompletionHandler:) 123456789101112131415161718func userNotificationCenter(_ center: UNUserNotificationCenter, didReceive response: UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -&gt; Void) &#123; // 1 if response.actionIdentifier == &quot;foodpin.makeReservation&quot; &#123; print(&quot;Make reservation...&quot;) // 2 if let phone = response.notification.request.content.userInfo[&quot;phone&quot;] &#123; let telURL = &quot;tel://\(phone)&quot; if let url = URL(string: telURL) &#123; if UIApplication.shared.canOpenURL(url) &#123; print(&quot;calling \(telURL)&quot;) // 3 UIApplication.shared.open(url) &#125; &#125; &#125; &#125; completionHandler()&#125; 1 对应之前创建UNNotificationAction时的identifier。 2 response.notification.request.content对应之前创建通知prepareNotification函数中的UNMutableNotificationContent，userInfo属性可用来存储通知想传递的数据。比如在prepareNotification函数中添加content.userInfo = [&quot;phone&quot;: suggestedRestaurant.phone!]，这边就可获得。 3 拨打电话。 在content.userInfo = [&quot;phone&quot;: suggestedRestaurant.phone!]中添加UNUserNotificationCenter.current().delegate = self。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 25 使用3D Touch]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-25.html</url>
    <content type="text"><![CDATA[接着上一篇 开始用Swift开发iOS 10 - 24 使用TestFlight进行Beta测试 ，这一篇学习使用3D Touch。 自从iPhone 6s和iPhone 6s Plus开始，Apple介绍了一种新的交互方式就是3D Touch。这新的特性需要硬件的支持，是iPhone屏幕不仅能感应到触摸，还能感应到压力。 现在3D Touch主要有三类交互方式： Quick Action ：点击应用图标后的快捷操作。👇是例子： Peek(preview) 和 Pop(commit)一般是一起的 ：主要应用于app中快速查看详细内容。自带的Photos app是很好的例子： 微信公众号也是不错的例子： Home Screen Quick Action Quick Action分两种： 静态的：在Info.plist中编写，固定不变的。 动态的：在代码中创建和更新。以自带的News app为例： 不同的频道是随着时间而变化的。 静态的Quick Action 静态的Quick Action只需要在Info.plist中配置UIApplicationShortcutItems数组就可以了，数组的每一项（字典）就是一个Action，每一个Action有6个类型的字段配置： UIApplicationShortcutItemType(必须) UIApplicationShortcutItemTitle(必须) UIApplicationShortcutItemSubtitle(可选) UIApplicationShortcutItemIconType(可选) UIApplicationShortcutItemIconFile(可选) UIApplicationShortcutItemUserInfo(可选)如果是下面配置： 结果就是： 动态的Quick Action动态的的Quick Action配置只要在AppDelegate.swift的application(:didFinishLaunchingWithOptions)中添加如下代码即可： 12let shortcutItem = UIApplicationShortcutItem(type: &quot;com.andyron.NewRestaurant&quot;, localizedTitle: &quot;New Restaurant&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(type: .add), userInfo: nil)UIApplication.shared.shortcutItems = [shortcutItem] 使用动态的Quick Action配置我的FoodPin应用由于我之前使用UIPageViewController创建了开始结束页面，如果在在AppDelegate.swift的application(:didFinishLaunchingWithOptions)中添加动态的Quick Action就会出现直接跳过介绍页面的情况，所以要在看完结束也之后再添加Quick Action。 下载图标，拖进Assets.xcassets 在WalkthroughContentViewController的nextButtonTapped方法的case 2: 里添加3个Action： 123456789101112// 1if traitCollection.forceTouchCapability == UIForceTouchCapability.available &#123; let bundleIdentifier = Bundle.main.bundleIdentifier // 2 let shortcutItem1 = UIApplicationShortcutItem(type: &quot;\(bundleIdentifier).OpenFavorites&quot;, localizedTitle: &quot;Show Favorites&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(templateImageName: &quot;favortie-shortcut&quot;), userInfo: nil) let shortcutItem2 = UIApplicationShortcutItem(type: &quot;\(bundleIdentifier).OpenDiscover&quot;, localizedTitle: &quot;Discover restaurants&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(templateImageName: &quot;discover-shortcut&quot;), userInfo: nil) let shortcutItem3 = UIApplicationShortcutItem(type: &quot;\(bundleIdentifier).NewRestaurant&quot;, localizedTitle: &quot;New Restaurant&quot;, localizedSubtitle: nil, icon: UIApplicationShortcutIcon(type: .add), userInfo: nil) // 3 UIApplication.shared.shortcutItems = [shortcutItem1, shortcutItem2, shortcutItem3]&#125; 1 判断设备是否支持3D Touch 2 UIApplicationShortcutIcon可以使用系统的图标，也可以使用外部图标 3 shortcutItems数组顺序对应从靠近图标开始向上或向下显示 实现Quick Action的具体跳转动作UIApplicationDelegate协议中的application(_:performActionFor:completionHandler:)方法会在Quick Action被点击后调用。 在AppDelegate.swift文件中定义一个QuickAction枚举。列举出quick action相关动作。 123456789101112enum QuickAction: String &#123; case OpenFavorites = &quot;OpenFavorites&quot; case OpenDiscover = &quot;OpenDiscover&quot; case NewRestaurant = &quot;NewRestaurant&quot; init?(fullIdentifier: String) &#123; guard let shortcutIdentifier = fullIdentifier.components(separatedBy: &quot;.&quot;).last else &#123; return nil &#125; self.init(rawValue: shortcutIdentifier) &#125;&#125; 在AppDelegate中实现application(_:performActionFor:completionHandler:)方法： 12345678910111213141516171819202122232425262728func application(_ application: UIApplication, performActionFor shortcutItem: UIApplicationShortcutItem, completionHandler: @escaping (Bool) -&gt; Void) &#123; completionHandler(handleQuickAction(shortcutItem: shortcutItem))&#125;private func handleQuickAction(shortcutItem: UIApplicationShortcutItem) -&gt; Bool &#123; let shortcutType = shortcutItem.type guard let shortcutIdentifier = QuickAction(fullIdentifier: shortcutType) else &#123; return false &#125; guard let tabBarController = window?.rootViewController as? UITabBarController else &#123; return false &#125; switch shortcutIdentifier &#123; case .OpenFavorites: tabBarController.selectedIndex = 0 case .OpenDiscover: tabBarController.selectedIndex = 1 case .NewRestaurant: if let navController = tabBarController.viewControllers?[0] &#123; let restaurantTableViewController = navController.childViewControllers[0] restaurantTableViewController.performSegue(withIdentifier: &quot;addRestaurant&quot;, sender: restaurantTableViewController) &#125; else &#123; return false &#125; &#125; return false&#125; Peek 和 Pop 在RestaurantTableViewController的viewDidLoad方法中添加如下代码。使用UIViewController中的registerForPreviewing方法注册使用peek和pop。 1234// 如果3D Touch可以用，就注册本控制器可以peek和popif traitCollection.forceTouchCapability == .available &#123; registerForPreviewing(with: self as! UIViewControllerPreviewingDelegate, sourceView: view)&#125; 让RestaurantTableViewController符合UIViewControllerPreviewingDelegate协议： class RestaurantTableViewController: UITableViewController, NSFetchedResultsControllerDelegate, UISearchResultsUpdating, UIViewControllerPreviewingDelegate { 实现UIViewControllerPreviewingDelegate协议的方法： 1234567891011121314151617181920212223242526272829// 当按压时调用（peek）func previewingContext(_ previewingContext: UIViewControllerPreviewing, viewControllerForLocation location: CGPoint) -&gt; UIViewController? &#123; // 1 guard let indexPath = tableView.indexPathForRow(at: location) else &#123; return nil &#125; // 2 guard let cell = tableView.cellForRow(at: indexPath) else &#123; return nil &#125; // 3 guard let restaurantDetailViewController = storyboard?.instantiateViewController(withIdentifier: &quot;RestaurantDetailViewController&quot;) as? RestaurantDetailViewController else &#123; return nil &#125; let selectedRestaurant = restaurants[indexPath.row] restaurantDetailViewController.restaurant = selectedRestaurant // 4 restaurantDetailViewController.preferredContentSize = CGSize(width: 0.0, height: 450.0) previewingContext.sourceRect = cell.frame return restaurantDetailViewController&#125;// pop时调用func previewingContext(_ previewingContext: UIViewControllerPreviewing, commit viewControllerToCommit: UIViewController) &#123; show(viewControllerToCommit, sender: self)&#125; 1 通过按压的位置获得indexPath 2 通过indexPath获得cell 3 通过控制器的Storyboard ID获得控制器，之前如果没有填写Storyboard ID，现在也可填写合适Storyboard ID。 4 给peek的预览页面一个高度限制，非必须。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 24 使用TestFlight进行Beta测试]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-24.html</url>
    <content type="text"><![CDATA[Beta测试是在产品发布之前所进行的软件测试活动，它是技术测试的最后一个阶段，通过了验收测试，产品就会进入发布阶段。 在iOS 8 时，Apple发布TestFlight用于Beta测试。之前TestFlight一直是独立用户mobile app测试的mobile平台，在2014年2月，Apple收购的TestFlight母公司Burstly。现在TestFlight已经集成到iTunes Connect中，允许开发只通过邮件地址邀请Beta测试用户。 在iTunes Connect中创建一个App Record iTunes Connect 是为iOS开发者提供在App Store管理销售他们apps的Web应用工具。 在上传app之前，必须要在 iTunes Connect中有App Record。 需要提供下列信息： Platform App name Primary language Bundle ID SKU 创建成果后会跳到下一个页面 App信息这一步主要选择一下App分类的类别。 价格与销售范围 准备提交这一步主要添加截图、app描述、app图标、联系信息等信息 预览图和截图提高至少一张5.5 英寸的截图(1242x2208 pixels) ，iTunes Connect会自动生成其他屏幕尺寸的图片。详细可参考iTunes Connect Developer Guide 或 iTunes Connect 开发人员帮助（中文） app描述填写一些相关描述，关键词（以逗号分隔），URL等 App 综合信息 这边的App Store 图标要求是1024x1024 pixels，不能包含隐藏元素。 App 审核信息 版本发布 更新Build string回到Xcode，确认版本数字与iTunes Connect中一致。 准备App Icon和启动页图片 利用类似图标工场这种移动应用图标生成工具，可生成一些大小的图标。 可以在Finder中直接复制AppIcon.appiconset目录替代即可。 在默人的启动开始页面LaunchScreen.storyboard中，添加一个图片。 打包和验证App在上传app到iTunes Connect之前，如要创建app包，这在Xcode 8之后已经非常容易了。 在主菜单中选择Product &gt; Scheme &gt; Edit Scheme：确认Build Configuration是Release： 在主菜单中选择Product &gt; Archive，可能需要等待一段时间。 打包成功后，在主菜单中打开Window &gt; Organizer，出现如下界面： 选择Validate…，然后选择自己的开发者账号： 点击Validate，之后可能需要一段时间： 上传应用到iTunes Connect 上面的验证成功后，点击Upload to App Store…，然后在点击Upload，这个过程可能也需要比较长的时间。 管理内部测试用户 内部用户也就是 iTunes Connect 用户，最多可添加25个。可在用户和职能中添加。 添加iTunes Connect 用户 添加内部测试用户后，内部测试用户会收到邮件，内面有验证码。 下载 TestFlight 应用然后在 Redeem中输入验证码，即可下载安装应用测试。 管理外部测试用户（Beta测试用户）以前是最大限制2000，现在可以邀请10000名外部测试人员。外部测试用户不需要事先添加。 填写完整测试信息 新建群组，比如就叫外部测试员： 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 22 使用CloudKit]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-22.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 21 使用WKWebView和SFSafariViewController 学习打开网页，这一篇学习使用CloudKit。 iCloud最初乔布斯在WWDC2011是发布的，只为了给Apps、游戏能够在云端数据保存，让Mac和iOS之间数据自动同步所用。最近几年才渐渐成长为云服务。如果想创建社交类型的，可以分享用户之间数据的app，就可考虑使用iCloud，这样就不需要自己再去构建一个后端APIs了。虽然可能由于国内的网络环境，iCloud实际应用效果并不好，不过还是有必要学一下的🙂。 如果开发了Web应用，同样也可以访问iOS应用的iCloud中数据。Apple分别提供了CloudKit JS和CloudKit库。 CloudKit默认给我们的app提供一些免费的空间： 当app的用户的活跃数提高，免费空间也会随之提高，详细可查看官网介绍。 理解CloudKit框架CloudKit框架不仅提供了存储功能，还提供了开发者与iCloud之间的各种交互。Containers和database是CloudKit框架的基础元素。 默认，一个app就是一个container，代码中就是CKContainer，一个container中包括三个database(CKDatabase)： 一个public database： app中所有用户都能查看 一个shared database：app中一组用户能查看（iOS 10） 一个private database：app中单个用户查看 为应用添加CloudKit 首先需要开发者账号。 然后在Capabilities中打开iCloud。 在CloudKit Dashboard中管理 Record 点击上图中的CloudKit Dashboard，或者直接访问https://icloud.developer.apple.com/dashboard/。最新的CloudKit Dashboard的页面有了一些变化。首先进去的是应用列表（也就是container列表），点击一个就进入如下页面： 点击Development的data，类似下面 选择Record Types（有点像关系数据中的表），创建新的类型Restaurant，并添加几个Field的。 选择Records（类型表中的数据），添加几条数据，注意选择public database。 使用 Convenience API获取public DatabaseCloudKit提供两种APIs让开发与iCloud交互：the convenience API 和 the operational API。 Convenience API的通常调用方式： 12345678let cloudContainer = CKContainer.default()let publicDatabase = cloudContainer.publicCloudDatabaselet predicate = NSPredicate(value: true)let query = CKQuery(recordType: &quot;Restaurant&quot;, predicate: predicate)publicDatabase.perform(query, inZoneWith: nil, completionHandler: &#123; (results, error) -&gt; Void in// Process the records&#125;) CKContainer.default()获取应用的Container。 publicCloudDatabase表示默认的public database。 NSPredicate和CKQuery是搜索条件 新建DiscoverTableViewController，继承至UITableViewController，关联discover.storyboard中的table view的控制器； 并修改其prototype cell的identifier为Cell。 在DiscoverTableViewController.swift中加入import CloudKit，并定义一个CKRecord的数组变量： var restaurants:[CKRecord] = [] 添加获取Records的函数： 12345678910111213141516171819202122232425func fetchRecordsFromCloud() &#123; let cloudContainer = CKContainer.default() let publicDatabase = cloudContainer.publicCloudDatabase let predicate = NSPredicate(value: true) let query = CKQuery(recordType: &quot;Restaurant&quot;, predicate: predicate) publicDatabase.perform(query, inZoneWith: nil, completionHandler: &#123; (results, error) -&gt; Void in if error != nil &#123; print(error) return &#125; if let results = results &#123; print(&quot;Completed the download of Restaurant data&quot;) self.restaurants = results OperationQueue.main.addOperation &#123; self.spinner.stopAnimating() self.tableView.reloadData() &#125; &#125; &#125;)&#125; 在perform中，当确定获取到了数据后，赋值给restaurants，并刷新table。 在viewDidLoad中添加： fetchRecordsFromCloud()。 添加table view相关代理方法： 12345678910111213141516171819202122override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return restaurants.count&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for:indexPath) // Configure the cell... let restaurant = restaurants[indexPath.row] cell.textLabel?.text = restaurant.object(forKey: &quot;name&quot;) as? String if let image = restaurant.object(forKey: &quot;image&quot;) &#123; let imageAsset = image as! CKAsset if let imageData = try? Data.init(contentsOf: imageAsset.fileURL) &#123; cell.imageView?.image = UIImage(data: imageData) &#125; &#125; return cell&#125; object(forKey:)是CKRecord中获取Record Field值的方法。 图片对象转换为CKAsset。 为什么慢？测试以上代码，发现fetchRecordsFromCloud函数中的打印信息”Completed the download of Restaurant data”已经显示在控制台了，但是还需要过一段时间App中才能显示，也就是说向iCloud中获取完数据后才开始准备table view加载。 这边就需要使用到多线程的概念。在iOS中，UI更新（像table重新加载）必须在主线程执行。这样获取iCloud数据的线程在进行时，UI更新也在同步进行。 123OperationQueue.main.addOperation &#123; self.tableView.reloadData()&#125; 使用operational API获取public Database Convenience API只适合简单和少量的查询。 更新fetchRecordsFromCloud方法： 123456789101112131415161718192021222324252627func fetchRecordsFromCloud() &#123; let cloudContainer = CKContainer.default() let publicDatabase = cloudContainer.publicCloudDatabase let predicate = NSPredicate(value: true) let query = CKQuery(recordType: &quot;Restaurant&quot;, predicate: predicate) // Create the query operation with the query let queryOperation = CKQueryOperation(query: query) queryOperation.desiredKeys = [&quot;name&quot;, &quot;image&quot;] queryOperation.queuePriority = .veryHigh queryOperation.resultsLimit = 50 queryOperation.recordFetchedBlock = &#123; (record) -&gt; Void in self.restaurants.append(record) &#125; queryOperation.queryCompletionBlock = &#123; (cursor, error) -&gt; Void in if let error = error &#123; print(&quot;Failed to get data from iCloud - \(error.localizedDescription)&quot;) return &#125; print(&quot;Successfully retrieve the data from iCloud&quot;) OperationQueue.main.addOperation &#123; self.tableView.reloadData() &#125; &#125; // Execute the query publicDatabase.add(queryOperation)&#125; 通过CKQueryOperation代替perform方法,它提供了许多查询选项。 desiredKeys代表需要查询的字段。 resultsLimit代表依次查询最大Record数目 加载指示（菊花转） 可以在viewDidLoad中添加类型如下代码： 123456let spinner:UIActivityIndicatorView = UIActivityIndicatorView()spinner.activityIndicatorViewStyle = .grayspinner.center = view.centerspinner.hidesWhenStopped = trueview.addSubview(spinner)spinner.startAnimating() 也可以通过在discover.storyboard中添加： 添加完发现 activity indicator view在控制器上面，这在Xcode中叫The Extra Views 在DiscoverTableViewController中添加接口，并关联。 @IBOutlet var spinner: UIActivityIndicatorView! 在viewDidLoad中添加代码： 1234spinner.hidesWhenStopped = truespinner.center = view.centertableView.addSubview(spinner)spinner.startAnimating() 数据加载完要隐藏加载提示：1234OperationQueue.main.addOperation &#123; self.spinner.stopAnimating() self.tableView.reloadData() &#125; 懒加载图片懒加载图片就是先加载一个本地默认图片，暂时不加载远程图片，当图片准备好在去更新图片视图。 修改请求字段desireKeys，让开始时不加图片: queryOperation.desiredKeys = [&quot;name&quot;] 更新 tableView(_:cellForRowAt:)： 1234567891011121314151617181920212223242526272829303132333435override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) let restaurant = restaurants[indexPath.row] cell.textLabel?.text = restaurant.object(forKey: &quot;name&quot;) as? String // Set the default image cell.imageView?.image = UIImage(named: &quot;photoalbum&quot;) // Fetch Image from Cloud in background let publicDatabase = CKContainer.default().publicCloudDatabase let fetchRecordsImageOperation = CKFetchRecordsOperation(recordIDs:[restaurant.recordID]) fetchRecordsImageOperation.desiredKeys = [&quot;image&quot;] fetchRecordsImageOperation.queuePriority = .veryHigh fetchRecordsImageOperation.perRecordCompletionBlock = &#123; (record, recordID, error) -&gt; Void in if let error = error &#123; print(&quot;Failed to get restaurant image: \(error.localizedDescription)&quot;) return &#125; if let restaurantRecord = record &#123; OperationQueue.main.addOperation() &#123; if let image = restaurantRecord.object(forKey: &quot;image&quot;) &#123; let imageAsset = image as! CKAsset print(imageAsset.fileURL) if let imageData = try? Data.init(contentsOf: imageAsset.fileURL) &#123; cell.imageView?.image = UIImage(data: imageData) &#125; &#125; &#125; &#125; &#125; publicDatabase.add(fetchRecordsImageOperation) return cell&#125; CKFetchRecordsOperation通过recordID获得特定的Record。 CKFetchRecordsOperation一些方法类似CKQueryOperation。 懒加载后发现，图片在其它视图显示后慢慢先后加载显示。 下拉刷新UIRefreshControl提供了标准的下拉刷新特性。 在DiscoverTableViewController的viewDidLoad中添加：12345// Pull To Refresh ControlrefreshControl = UIRefreshControl()refreshControl?.backgroundColor = UIColor.whiterefreshControl?.tintColor = UIColor.grayrefreshControl?.addTarget(self, action: #selector(fetchRecordsFromCloud), for: UIControlEvents.valueChanged) 每一次下拉是显示菊花转，并且调用fetchRecordsFromCloud方法。 在fetchRecordsFromCloud方法的queryCompletionBlock添加数据加载完成后去除菊花转代码： 12345if let refreshControl = self.refreshControl &#123; if refreshControl.isRefreshing &#123; refreshControl.endRefreshing() &#125;&#125; 刷新会出现重复数据，要在fetchRecordsFromCloud方法开始时，清理数据： 12restaurants.removeAll()tableView.reloadData() 使用CloudKit保存数据到iCloudCKDatabase的save(_:completionHandler:)的方法可用来保存数据到iCloud。实现用户新加数据时，既保存在本地的Core Data，有保存在iCloud中。 在AddRestaurantController中添加：import CloudKit。 在AddRestaurantController添加方法： 12345678910111213141516171819202122232425262728// 保存到Core Data的同时也保存的iCloud中func saveRecordToCloud(restaurant:RestaurantMO!) -&gt; Void &#123; // Prepare the record to save let record = CKRecord(recordType: &quot;Restaurant&quot;) record.setValue(restaurant.name, forKey: &quot;name&quot;) record.setValue(restaurant.type, forKey: &quot;type&quot;) record.setValue(restaurant.location, forKey: &quot;location&quot;) record.setValue(restaurant.phone, forKey: &quot;phone&quot;) let imageData = restaurant.image as! Data // Resize the image let originalImage = UIImage(data: imageData)! let scalingFactor = (originalImage.size.width &gt; 1024) ? 1024 / originalImage.size.width : 1.0 let scaledImage = UIImage(data: imageData, scale: scalingFactor)! // Write the image to local file for temporary use let imageFilePath = NSTemporaryDirectory() + restaurant.name! let imageFileURL = URL(fileURLWithPath: imageFilePath) try? UIImageJPEGRepresentation(scaledImage, 0.8)?.write(to: imageFileURL) // Create image asset for upload let imageAsset = CKAsset(fileURL: imageFileURL) record.setValue(imageAsset, forKey: &quot;image&quot;) // Get the Public iCloud Database let publicDatabase = CKContainer.default().publicCloudDatabase // Save the record to iCloud publicDatabase.save(record, completionHandler: &#123; (record, error) -&gt; Void in try? FileManager.default.removeItem(at: imageFileURL) &#125;)&#125; 在save方法的dismiss(animated:completion:)的前面添加： saveRecordToCloud(restaurant: restaurant) 排序CKQuery有属性sortDescriptors可用来排序。在DiscoverTableViewController的fetchRecordsFromCloud方法，query定义后添加： query.sortDescriptors = [NSSortDescriptor(key: &quot;creationDate&quot;, ascending: false)] creationDate是默认的创建时间字段。 Exercise：修改Discover样式 新建一个DiscoverTableViewCell，继承至UITableViewCell，并关联Discover的cell。 修改cell合适的样式，比如下面 在DiscoverTableViewCell中新建四个接口，并关联。 1234@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!@IBOutlet var thumbnailImageView: UIImageView! 更新tableView(_:cellForRowAt:)和fetchRecordsFromCloud相关代码 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 21 使用WKWebView和SFSafariViewController]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-21.html</url>
    <content type="text"><![CDATA[上一篇开始用Swift开发iOS 10 - 20 使用Tab Bar Controller 和 拆分Storyboard学习了工具栏和Storyboard的拆分，这一篇学习怎么在app中显示网页内容。由于原书中使用了的网站在国内不好访问，我就用了我的简书、博客、Github代替🙂。 设计about view 下载图片拖进Assets.xcasset。 打开about.storyboard，拖进一个Image View到table view header，height为190，image为about-logo，content mode为Aspect fit。选择table view cell，identifier为Cell，style为Basic。 新建AboutTableViewController继承至UITableViewController，关联about中的table view controller。 在AboutTableViewController，添加：123var sectionTitles = [&quot;Leave Feedback&quot;, &quot;Follow Us&quot;]var sectionContent = [[&quot;Rate us on App Store&quot;, &quot;Tell us your feedback&quot;], [&quot;Jianshu&quot;, &quot;Blog&quot;, &quot;Github&quot;]]var links = [&quot;http://www.jianshu.com/u/efce1a2a95ab&quot;, &quot;http://andyron.com&quot;, &quot;https://github.com/andyRon&quot;] table view的相关代理协议方法实现，这次使用俩个section，tableView(_:titleForHeaderInSection:)是获取section的title方法。1234567891011121314151617181920override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return sectionTitles.count&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // #warning Incomplete implementation, return the number of rows return sectionContent[section].count&#125;override func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? &#123; return sectionTitles[section]&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) cell.textLabel?.text = sectionContent[indexPath.section][indexPath.row] return cell&#125; 移除Tableview下面分割线，在viewDidLoad中添加： tableView.tableFooterView = UIView(frame: CGRect.zero) 用Mobile Safari打开Web可直接给出网址，通过Mobile Safari打开网站，UIApplication.shared.open(_:options:completionHandler:)。 123456789101112131415override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; switch indexPath.section &#123; case 0: if indexPath.row == 0 &#123; if let url = URL(string: &quot;http://www.apple.com/itunes/charts/paid-apps/&quot;) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125; &#125; default: break &#125; // 取消被选中状态 tableView.deselectRow(at: indexPath, animated: false)&#125; 使用WKWebView载入Web使用使用WKWebView载入Web的例子1234if let url = URL(string: &quot;http://andyron.com&quot;) &#123; let request = URLRequest(url: url) webView.load(request)&#125; 直接载入本地html文件的例子：123let url = URL(fileURLWithPath: &quot;about.html&quot;)let request = URLRequest(url: url)webView.load(request) 在about.storyboard中拖进一个新的View Controller，用来展示Web内容。使用ctrl-drag建立Show类型的segue，identifier为 showWebView。 新建WebViewController继承至UIViewController，关联上面的用来显示Web内容的View Controller。 在WebViewController.swift中添加import WebKit，变量var webView: WKWebView!。 更新 viewDidLoad： 123456789override func viewDidLoad() &#123; super.viewDidLoad() if let url = URL(string: &quot;http://andyron.com&quot;) &#123; let request = URLRequest(url: url) webView.load(request) &#125;&#125; 添加loadView，这个方法会在viewDidLoad之前调用创建WKWebView。 1234override func loadView() &#123; webView = WKWebView() view = webView&#125; 更新AboutTableViewController中的tableView(_didSelectRowAtIndexPath:)： 123456789101112131415161718override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; switch indexPath.section &#123; case 0: if indexPath.row == 0 &#123; if let url = URL(string: &quot;http://www.apple.com/itunes/charts/paid-apps/&quot;) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125; &#125; else if indexPath.row == 1 &#123; performSegue(withIdentifier: &quot;showWebView&quot;, sender: self) &#125; default: break &#125; // 取消被选中状态 tableView.deselectRow(at: indexPath, animated: false)&#125; 由于自从iOS 9之后，出于安全考虑，默认只能访问HTTPS的网站，如果需要访问HTTP的网站，就需要在plist文件中添加许可： 使用SFSafariViewController载入Web在AboutTableViewController.swift中加入import SafariServices，然后更新tableView(_didSelectRowAtIndexPath:)，只用通过url创建一个SFSafariViewController对象，然后使用present方法展示就可以了。1234567891011121314151617181920212223override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; switch indexPath.section &#123; case 0: if indexPath.row == 0 &#123; if let url = URL(string: &quot;http://www.apple.com/itunes/charts/paid-apps/&quot;) &#123; UIApplication.shared.open(url, options: [:], completionHandler: nil) &#125; &#125; else if indexPath.row == 1 &#123; performSegue(withIdentifier: &quot;showWebView&quot;, sender: self) &#125; case 1: if let url = URL(string: links[indexPath.row]) &#123; let safariController = SFSafariViewController(url: url) present(safariController, animated: true, completion: nil) &#125; default: break &#125; // 取消被选中状态 tableView.deselectRow(at: indexPath, animated: false)&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 20 使用Tab Bar Controller 和 拆分Storyboard]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-20.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 19 使用UIPageViewController构建介绍页面构建了开始介绍页面，这一篇学习使用Tab Bar Controller和拆分Storyboard。 创建 Tab Bar Controller 选择开始的Navigation Controller，Editor &gt; Embed in &gt; Tab Bar Controller，然后自动添加一个新的Tab Bar Controller 作为初始的控制器，之前Navigation Controller变成Tab Bar Controller的一部分了。 在Navigation Controller中选择 tab item，修改System Item为Favorites。 隐藏 Tab Bar工具栏在其他页面隐藏，选择Detail View，勾选Hide Bottom Bar on Push就可以。 也可以用代码形式，在RestaurantTableViewController中的prepare(for:)中添加： destinationController.hidesBottomBarWhenPushed = true 添加新的Tabs 添加一个新的Navigation Controller， 选中tab item，修改System Item为Recents；table view的navigation item的title为Discover 把新加的Navigation Controller加入到 Tab Bar Controller。用ctrl+drag从Tab Bar Controller到新的Navigation Controller，选择Relationship Segue - View Controllers。 改变新的Navigation Controller的tab bar的title为Recent，修改system item为Recents 同样的方式添加一个新的Navigation Controller， 选中tab item，修改System Item为More；table view的navigation item的title为About。也用ctrl+drag与Tab Bar Controller建立关系。 最终创建有三个Tab Bar Item的Tab Bar。 定制Tab Bar的样式修改Tab Bar的样式在application(_:didFinishLaunchingWithOptions:)中进行，类似下面的代码，详细的API可参考官方文档：123UITabBar.appearance().tintColor = UIColor(red: 235.0/255.0, green: 75.0/255.0,blue: 27.0/255.0, alpha: 1.0)UITabBar.appearance().barTintColor = UIColor.black 改变 Tab Bar Item的图片 从图片下载图片到Assets.xcasset。 在SB中修改三个Tab Bar Item的System Item都为Custom，修改Title和Image为想要的值，类似下图 在application(_:didFinishLaunchingWithOptions:)中修改样式：12UITabBar.appearance().tintColor = UIColor(red: 235.0/255.0, green: 75.0/255.0, blue: 27.0/255.0, alpha: 1.0)UITabBar.appearance().barTintColor = UIColor(red: 236/255.0, green: 240.0/255.0, blue: 241.0/255.0, alpha: 1.0) 改变选择指示图片（Selection Indicator Image）Selection Indicator Image就是指tab bar item被选中后与其它tab bar item不同的样式,在代码中和SB中都可以修改。 UITabBar.appearance().selectionIndicatorImage = UIImage(named: &quot;tabitem-selected&quot;) 最终效果： 拆分Storyboard当项目变大时，一个Storyboard就会很大，如果是项目中有很多人合作的话，一个Storyboard也很难管理。从Xcode7之后，新功能storyboard references解决了这个问题。 在Main.storyboard中选择，about相关的两个view controller，然后Editor &gt; Refactor to Storyboard…，新建名为about.storyboard的storyboard文件，就把这个两个独立出去了。 把about相关的view controller拆分出去后，在Main.storyboard里有一个关联图标，双击就可以跳转到about.storyboard中。 同样的方法，独立出discover相关view controller，生成discover.storyboard文件。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS-tutorial-7：解析XML(swift)]]></title>
    <url>%2F2017%2Fios-tutorial-7-xml.html</url>
    <content type="text"><![CDATA[使用XMLParser解析XML文件，然后用table展示数据。 以Single View Application模板新建项目XMLParserTutorial。 删除SB中的View Controller，拖进一个Navigation Controller。选择新的View Controller为 “Is Initial View Controller”。设置Navigation Bar的title为Books。 新建一个继承至UITableViewController，名为TableViewController的控制器文件，并与SB的控制器关联。 新建一个xml文件Books.xml，用于之后解析，文件内容为: 1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot;?&gt;&lt;catalog&gt; &lt;book id=&quot;1&quot;&gt; &lt;title&gt;To Kill a Mockingbird&lt;/title&gt; &lt;author&gt;Harper Lee&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;2&quot;&gt; &lt;title&gt;1984&lt;/title&gt; &lt;author&gt;George Orwell&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;3&quot;&gt; &lt;title&gt;The Lord of the Rings&lt;/title&gt; &lt;author&gt;J.R.R Tolkien&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;4&quot;&gt; &lt;title&gt;The Catcher in the Rye&lt;/title&gt; &lt;author&gt;J.D. Salinger&lt;/author&gt; &lt;/book&gt; &lt;book id=&quot;5&quot;&gt; &lt;title&gt;The Great Gatsby&lt;/title&gt; &lt;author&gt;F. Scott Fitzgerald&lt;/author&gt; &lt;/book&gt;&lt;/catalog&gt; 新建一个文件 Book.swift： 123456import Foundationclass Book &#123; var bookTitle: String = &quot;&quot; var bookAuthor: String = &quot;&quot;&#125; 在TableViewController中添加几个变量： 1234var books: [Book] = []var eName: String = &quot;&quot;var bookTitle = &quot;&quot;var bookAuthor = &quot;&quot; 在viewDidLoad方法中，添加读取XMl文件代码： 123456789override func viewDidLoad() &#123; super.viewDidLoad() if let path = Bundle.main.url(forResource: &quot;Books&quot;, withExtension: &quot;xml&quot;) &#123; if let parser = XMLParser(contentsOf: path) &#123; parser.delegate = self parser.parse() &#125; &#125; 添加Table View的数据源代理方法： 1234567891011121314151617override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1&#125;override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return books.count&#125;override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) let book = books[indexPath.row] cell.textLabel?.text = book.bookTitle cell.detailTextLabel?.text = book.bookAuthor return cell&#125; 让TableViewController采纳XMLParserDelegate协议： class TableViewController: UITableViewController, XMLParserDelegate 实现XMLParserDelegate中的三个方法： 12345678910111213141516171819202122232425262728293031323334// 解析XMl元素开始时func parser(_ parser: XMLParser, didStartElement elementName: String, namespaceURI: String?, qualifiedName qName: String?, attributes attributeDict: [String : String] = [:]) &#123; print(&quot;开始 \(elementName)&quot;) eName = elementName if elementName == &quot;book&quot; &#123; bookTitle = &quot;&quot; bookAuthor = &quot;&quot; &#125;&#125;// 正在解析XMl元素func parser(_ parser: XMLParser, foundCharacters string: String) &#123; print(&quot;ing \(eName)&quot;) let data = string.trimmingCharacters(in: NSCharacterSet.whitespacesAndNewlines) if (!data.isEmpty) &#123; if eName == &quot;title&quot; &#123; bookTitle += data &#125; else if eName == &quot;author&quot; &#123; bookAuthor += data &#125; &#125;&#125;// 结束解析XMl元素func parser(_ parser: XMLParser, didEndElement elementName: String, namespaceURI: String?, qualifiedName qName: String?) &#123; print(&quot;结束 \(elementName)&quot;) if elementName == &quot;book&quot; &#123; let book = Book() book.bookTitle = bookTitle book.bookAuthor = bookAuthor books.append(book) &#125;&#125; 三个方法分别在XMl元素开始解析、正在解析、结束解析时调用，也就是说有很多元素时就不停在调用这三个方法。 代码XMLParserTutorial 参考：Parsing XML Tutorial]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 19 使用UIPageViewController构建介绍页面]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-19.html</url>
    <content type="text"><![CDATA[继续上一篇 开始用Swift开发iOS 10 - 18 Search Bar 和 UISearchController ，这一篇使用UIPageViewController构建介绍页面，与使用LaunchScreen.storyboard的启动页不同。 向Storyboard中添加UIPageViewController 在Storyboard拖进一个UIPageViewController。修改相关属性。 修改UIPageViewController的 storyboard ID 为 WalkthroughController。 类似UINavigationController，UIPageViewController也是一种容器类型的控制器。这种容器类型的控制器是用来管理其它多个控制器的。 如果容器内的控制器页面元素类似（上图就是这种情况），可以通过一个控制器重复利用。 设计介绍页 下载介绍页所需的图片，拖到Assets.xcasset。 拖动一个新的View Controller到SB中（作为重复使用的控制器），做一些UI设计： 设置背景为红色 添加一个Label名为Personalize，选择合适的字体和大小，居中。 添加一个Image View，300*232，居中。 添加另一个Label名为Pin your favorite restaurants and create your own food guide，282*64，行数为0，居中，选择合适的字体和大小。 添加一些约束 设置新的View Controller的 storyboard ID 为 WalkthroughContentViewController。最后大概如下： 创建WalkthroughContentViewController 创建WalkthroughContentViewController类文件，继承至UIViewController，并关联上面添加的新View Controller。 添加三个接口，关联两个Label和一个image view；添加四个变量，其中index是指多个介绍页的索引。 12345678@IBOutlet var headingLabel: UILabel!@IBOutlet var contentLabel: UILabel!@IBOutlet var contentImageView: UIImageView!var index = 0var heading = &quot;&quot;var imageFile = &quot;&quot;var content = &quot;&quot; 修改viewDidLoad为： 1234567override func viewDidLoad() &#123; super.viewDidLoad() headingLabel.text = heading contentLabel.text = content contentImageView.image = UIImage(named: imageFile)&#125; 实现 UIPageViewController 新建类WalkthroughPageViewController，继承至UIPageViewController。 让WalkthroughPageViewControlle符合UIPageViewControllerDataSource协议。 class WalkthroughPageViewController: UIPageViewController, UIPageViewControllerDataSource 新建几个变量，用于显示介绍页中的内容。 123var pageHeadings = [&quot;Personalize&quot;, &quot;Locate&quot;, &quot;Discover&quot;]var pageImages = [&quot;foodpin-intro-1&quot;, &quot;foodpin-intro-2&quot;, &quot;foodpin-intro-3&quot;]var pageContent = [&quot;Pin your favorite restaurants and create your own foodguide&quot;, &quot;Search and locate your favourite restaurant on Maps&quot;, &quot;Find restaurants pinned by your friends and other foodies around the world&quot;] 实现UIPageViewControllerDataSource协议的两个方法，分别在介绍页翻到下一个和翻到上一个时调用。contentViewController函数的作用是根据介绍页的索引获取不同的数据。instantiateViewController方法根据storyboard的中storyboard ID生成视图控制器。 1234567891011121314151617181920212223242526272829303132func pageViewController(_ pageViewController: UIPageViewController, viewControllerBefore viewController: UIViewController) -&gt; UIViewController? &#123; var index = (viewController as! WalkthroughContentViewController).index index -= 1 return contentViewController(at: index)&#125;func pageViewController(_ pageViewController: UIPageViewController, viewControllerAfter viewController: UIViewController) -&gt; UIViewController? &#123; var index = (viewController as! WalkthroughContentViewController).index index += 1 return contentViewController(at: index)&#125;func contentViewController(at index: Int) -&gt; WalkthroughContentViewController? &#123; if index &lt; 0 || index &gt;= pageHeadings.count &#123; return nil &#125; if let pageContentViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughContentViewController&quot;) as? WalkthroughContentViewController &#123; pageContentViewController.imageFile = pageImages[index] pageContentViewController.heading = pageHeadings[index] pageContentViewController.content = pageContent[index] pageContentViewController.index = index return pageContentViewController &#125; return nil&#125; 修改viewDidLoad： 12345678override func viewDidLoad() &#123; super.viewDidLoad() dataSource = self if let startingViewController = contentViewController(at: 0) &#123; setViewControllers([startingViewController], direction: .forward, animated: true, completion: nil) &#125;&#125; setViewControllers方法是设置UIPageViewController管理的视图控制器。 让介绍页在首页显示后跳出。 在RestaurantTableViewControlle中添加：123456override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) if let pageViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughController&quot;) as? WalkthroughPageViewController &#123; present(pageViewController, animated: true, completion: nil) &#125;&#125; 添加默认页面指示页面指示就是一般在页面下用于分辨当前是第一个页面的几个小点。实现UIPageViewControllerDataSource协议的两个方法：presentationCount(for:)表示总共有几个小点（页面）。presentationIndex(for:)表示当前页面的索引。12345678910func presentationCount(for pageViewController: UIPageViewController) -&gt; Int &#123; return pageHeadings.count&#125;func presentationIndex(for pageViewController: UIPageViewController) -&gt; Int &#123; if let pageContentViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughContentViewController&quot;) as? WalkthroughContentViewController &#123; return pageContentViewController.index &#125; return 0&#125; 修改页面指示的样式不用默认的页面指示，就要把上面两个方法删除，然后使用UIPageControl。 删除上面实现的两个方法。从对象库中拖一个Page Control到walkthrough content view controller底部，在属性检查器中修改适当属性，并添加约束。 在WalkthroughContentViewController中添加接口@IBOutlet var pageControl: UIPageControl!并与Page Control关联。在viewDidLoad中添加pageControl.currentPage = index 添加NEXT/DONE按钮 在walkthrough content view controller右下角添加一个按钮名为NEXT。 在WalkthroughContentViewController中添加接口，并按钮关联。 @IBOutlet var forwardButton: UIButton! 在viewDidLoad中添加根据索引判断按钮名的代码： 12345switch index &#123;case 0...1: forwardButton.setTitle(&quot;NEXT&quot;, for: .normal)case 2: forwardButton.setTitle(&quot;DONE&quot;, for: .normal)default: break&#125; 添加点击按钮的action，并与按钮关联 12345678910@IBAction func nextButtonTapped(sender: UIButton) &#123; switch index &#123; case 0...1: let pageViewController = parent as! WalkthroughPageViewController pageViewController.forward(index: index) case 2: dismiss(animated: true, completion: nil) default: break &#125;&#125; 在WalkthroughPageViewController中添加方法： 12345func forward(index: Int) &#123; if let nextViewController = contentViewController(at: index + 1) &#123; setViewControllers([nextViewController], direction: .forward, animated: true, completion: nil) &#125;&#125; 完成类似下面： 但因为之前是利用RestaurantTableViewController的viewDidAppear方法显示介绍页的，而viewDidAppear方法是页面显示后就调用一下，这样就出现不停进入介绍页。实际上只需要第一次打开app的时显示介绍页就可以了。 UserDefaults的使用UserDefaults是用来管理应用和用户相关的设置的。也就是可以用UserDefaults存储一些用户相关的少量数据，比如上面的是否看过介绍页，也就是是否点击过DONE按钮了。UserDefaults也是通过单例模式进行操作的，通过类属性standard获取单例。 nextButtonTapped中点击DONE按钮时设置一个值标志： 1234567891011@IBAction func nextButtonTapped(sender: UIButton) &#123; switch index &#123; case 0...1: let pageViewController = parent as! WalkthroughPageViewController pageViewController.forward(index: index) case 2: UserDefaults.standard.set(true, forKey: &quot;hasViewedWalkthrough&quot;) dismiss(animated: true, completion: nil) default: break &#125;&#125; 再到RestaurantTableViewController的viewDidAppear判断对应key值。 123456789override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) if UserDefaults.standard.bool(forKey: &quot;hasViewedWalkthrough&quot;) &#123; return &#125; if let pageViewController = storyboard?.instantiateViewController(withIdentifier: &quot;WalkthroughController&quot;) as? WalkthroughPageViewController &#123; present(pageViewController, animated: true, completion: nil) &#125;&#125; 完成介绍页。学习了UIPageViewController和UserDefaults。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 18 Search Bar 和 UISearchController]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-18.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 17 使用Core Data 是使用Core Data存储数据，这一篇是添加搜索功能。 使用 UISearchControllerUISearchController是一个简洁的创建搜索条和管理搜索结果的API。通常情况下，为以table为基础的app添加搜索条只需要下面三行代码就可以了，searchResultsController为nil时搜索结果显示就在当前搜索的页面以当前的样式显示。123searchController = UISearchController(searchResultsController: nil)searchController.searchResultsUpdater = selftableView.tableHeaderView = searchController.searchBar 为我的FoodPin应用添加搜索条: 在RestaurantTableViewController中添加一个变量： var searchController: UISearchController! 在viewDidLoad中初始化： searchController = UISearchController(searchResultsController: nil) tableView.tableHeaderView = searchController.searchBar 这样就添加了搜索条，但还每天添加搜索逻辑，搜索没效。 筛选内容 在RestaurantTableViewController中继续添加一个变量，用户存储筛选结果： var searchResults: [RestaurantMO] = [] 添加筛选方法： 1234567891011func filterContent(for searchText: String) &#123; searchResults = restaurants.filter(&#123; (restaurant) -&gt; Bool in if let name = restaurant.name &#123; let isMatch = name.localizedCaseInsensitiveContains(searchText) return isMatch &#125; return false &#125;)&#125; filter是数组的一个方法，它遍历数组的每一项进行闭包中的操作，根据结果判断是否删除对应项，最后得到一个筛选的数组。localizedCaseInsensitiveContains方法用来判断name中是否包含searchText（忽略大小写） 更新搜索结果 让RestaurantTableViewController “符合” UISearchResultsUpdating协议： class RestaurantTableViewController: UITableViewController, NSFetchedResultsControllerDelegate, UISearchResultsUpdating 实现UISearchResultsUpdating协议：中的updateSearchResults(for:)方法，这个方法在搜索条被选则和输入搜索字时调用： 123456func updateSearchResults(for searchController: UISearchController) &#123; if let searchText = searchController.searchBar.text &#123; filterContent(for: searchText) tableView.reloadData() &#125;&#125; 更新tableView(_:numberOfRowsInSection:)。UISearchController有一个isActive属性用来判断搜索控制器当前活跃状态。 1234567override func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; if searchController.isActive &#123; return searchResults.count &#125; else &#123; return restaurants.count &#125;&#125; 更新tableView(_:cellForRowAt:)。根据UISearchController的状态判断是从restaurants中获取数据还是searchResults。 1234567891011121314151617override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell let restaurant = (searchController.isActive) ? searchResults[indexPath.row] : restaurants[indexPath.row] cell.nameLabel.text = restaurant.name cell.thumbnailImageView.image = UIImage(data: restaurant.image! as Data) cell.thumbnailImageView.layer.cornerRadius = 30.0 cell.thumbnailImageView.clipsToBounds = true cell.locationLabel.text = restaurant.location cell.typeLabel.text = restaurant.type cell.accessoryType = restaurant.isVisited ? .checkmark: .none return cell&#125; 实现一个新的方法，让table在搜索状态下不可以滑动编辑。 1234567override func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool &#123; if searchController.isActive &#123; return false &#125; else &#123; return true &#125;&#125; 更新prepare(for:)，让segue在传输数据到detail view时的数据也相对应。 destinationController.restaurant = searchController.isActive ? searchResults[indexPath.row] : restaurants[indexPath.row 在viewDidLoad中添加两行代码： 12searchController.searchResultsUpdater = selfsearchController.dimsBackgroundDuringPresentation = false 现在就完成了搜索功能。 定制搜索条的样式UISearchBar提供一些属性用来定制。在viewDidLoad中添加：1234searchController.searchBar.placeholder = &quot;Search restaurants...&quot;searchController.searchBar.tintColor = UIColor.whitesearchController.searchBar.barTintColor = UIColor(red: 218.0/255.0, green:100.0/255.0, blue: 70.0/255.0, alpha: 1.0) Exercise：添加地址搜索只需要更改搜索函数filterContent：12345678910111213searchResults = restaurants.filter(&#123; (restaurant) -&gt; Bool in if let name = restaurant.name, let location = restaurant.location &#123; let isMatchName = name.localizedCaseInsensitiveContains(searchText) let isMatchLocation = location.localizedCaseInsensitiveContains(searchText) if isMatchName || isMatchLocation &#123; return true &#125; &#125; return false &#125;) 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 17 使用Core Data]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-17.html</url>
    <content type="text"><![CDATA[上一篇 开始用Swift开发iOS 10 - 16 介绍静态Table Views，UIImagePickerController和NSLayoutConstraint 中添加新建restaurant页面，但最后数据并没有保存下来，这一篇使用Core Data方式来持久化保存数据。 数据持久化一般是指数据库保存。在Web开发中，常用Oracle或MySQL等关系数据库来保存数据，通过SQL语句查询。在iOS中对应的数据库是SQLite。Core Data不是数据库，它是让开发者通过面向对象方式与数据库进行交互的库。 使用Core Data的例子新建一个使用Core Data的项目，在AppDelegate类中会比平常多了一个变量和一方法，另外还多了一个文件CoreDataDemo.xcdatamodeld。 123456789101112131415161718192021222324252627282930313233343536373839404142lazy var persistentContainer: NSPersistentContainer = &#123; /* The persistent container for the application. This implementation creates and returns a container, having loaded the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail. */ let container = NSPersistentContainer(name: &quot;CoreDataDemo&quot;) container.loadPersistentStores(completionHandler: &#123; (storeDescription, error) in if let error = error as NSError? &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. /* Typical reasons for an error here include: * The parent directory does not exist, cannot be created, or disallows writing. * The persistent store is not accessible, due to permissions or data protection when the device is locked. * The device is out of space. * The store could not be migrated to the current model version. Check the error message to determine what the actual problem was. */ fatalError(&quot;Unresolved error \(error), \(error.userInfo)&quot;) &#125; &#125;) return container&#125;()// MARK: - Core Data Saving supportfunc saveContext () &#123; let context = persistentContainer.viewContext if context.hasChanges &#123; do &#123; try context.save() &#125; catch &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nserror = error as NSError fatalError(&quot;Unresolved error \(nserror), \(nserror.userInfo)&quot;) &#125; &#125;&#125; 变量persistentContainer是NSPersistentContainer的实例，let container = NSPersistentContainer(name: &quot;CoreDataDemo&quot;)对应CoreDataDemo.xcdatamodeld文件，如果是自己添加时名字需要对应。 当数据变化(insert/update/delete)时 ，调用saveContext方法保存数据。 向项目中添加Data Model 右击FoodPin文件夹，选择新建Data Model文件，文件名为FoodPin。 选中新生成的FoodPin.xcdatamodeld，添加一个Restaurant Entity，然后再在此Entity下添加一些属性。 选中特定属性后可在右侧检查器中设置相关特性，比如是否强制需要。 创建Managed ObjectsCore Data框架中的 Managed Objects与Entity之间的关系，有点像代码中 接口变量 和 UI objects之间的关系。xcode可自动生成Managed Objects。 选中Restaurant Entity，在检查器中修改class的name为RestaurantMO，Codegen 为 Class Definition。 command-R 或 comman-B一下，表面上没有什么变化，在project navigator中没有多出文件。实际上已经生成RestaurantMO类，代码已经可以使用了，如果使用command+点击 RestaurantMO，就可以看到RestaurantMO的代码： 修改相关受影响的代码 RestaurantTableViewController.swift重新定义restaurants: var restaurants:[RestaurantMO] = []由于CoreData中存储图片是二进制，引用时不能用文件名: 12cell.thumbnailImageView.image = UIImage(data: restaurants[indexPath.row].imageas! Data) 12 if let imageToShare = UIImage(data: self.restaurants[indexPath.row].image as!Data) &#123; 由于RestaurantMO的属性值是可选值，使用时需要解包： 1let defaultText = &quot;Just checking in at &quot; + self.restaurants[indexPath.row].name! RestaurantDetailViewController.swift 1var restaurant:RestaurantMO! 1restaurantImageView.image = UIImage(data: restaurant.image as! Data) 12 geoCoder.geocodeAddressString(restaurant.location!, completionHandler: &#123;placemarks, error in MapViewController.swift 1var restaurant:RestaurantMO! 1leftIconView.image = UIImage(data: restaurant.image as! Data) ReviewViewController.swift 1var restaurant:RestaurantMO! 1restaurantImageView.image = UIImage(data: restaurant.image as! Data) 现在能成功运行，发现是没有数据的。 保存新数据到数据库 在AddTableViewController.swift中引入Core Data：import CoreData。添加变量var restaurant:RestaurantMO!。 在AppDelegate中加入上面例子一个变量和一方法。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// MARK: - Core Data stack lazy var persistentContainer: NSPersistentContainer = &#123; /* The persistent container for the application. This implementation creates and returns a container, having loaded the store for the application to it. This property is optional since there are legitimate error conditions that could cause the creation of the store to fail. */ let container = NSPersistentContainer(name: &quot;FoodPin&quot;) container.loadPersistentStores(completionHandler: &#123; (storeDescription, error) in if let error = error as NSError? &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. /* Typical reasons for an error here include: * The parent directory does not exist, cannot be created, or disallows writing. * The persistent store is not accessible, due to permissions or data protection when the device is locked. * The device is out of space. * The store could not be migrated to the current model version. Check the error message to determine what the actual problem was. */ fatalError(&quot;Unresolved error \(error), \(error.userInfo)&quot;) &#125; &#125;) return container &#125;() // MARK: - Core Data Saving support func saveContext () &#123; let context = persistentContainer.viewContext if context.hasChanges &#123; do &#123; try context.save() &#125; catch &#123; // Replace this implementation with code to handle the error appropriately. // fatalError() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. let nserror = error as NSError fatalError(&quot;Unresolved error \(nserror), \(nserror.userInfo)&quot;) &#125; &#125; &#125; 在AddTableViewController的save方法的dismiss之前插入： 123456789101112131415161718// 1if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; restaurant = RestaurantMO(context: appDelegate.persistentContainer.viewContext) restaurant.name = nameTextField.text restaurant.type = typeTextField.text restaurant.location = locationTextField.text restaurant.isVisited = isVisited if let restaurantImage = photoImageView.image &#123; // 2 if let imageData = UIImagePNGRepresentation(restaurantImage) &#123; restaurant.image = NSData(data: imageData) &#125; &#125; print(&quot;Saving data to context ...&quot;) appDelegate.saveContext()&#125; UIApplication.shared这种形式是iOS SDK中比较常用单例模式，就是通过一个类属性shared获取整个app运行过程只需要一个实例的方法。UIApplication.shared.delegate as? AppDelegate就获取了AppDelegate对象。 获取图片的二进制数据对象。 运行，添加新的restaurant后并没有在Food Pin中显示，实际已经添加到数据库中，在RestaurantTableViewController里没有向数据库获取。 通过CoreData获取数据 在RestaurantTableViewController.swift中添加import CoreData。实现协议NSFetchedResultsControllerDelegate，这个协议中有方法，任何时候当获取来的数据有变化时立即通知代理。class RestaurantTableViewController: UITableViewController, NSFetchedResultsControllerDelegate 定义一个变量var fetchResultController: NSFetchedResultsController&lt;RestaurantMO&gt;! 在viewDidLoad中添加 123456789101112131415161718192021// 1 let fetchRequest: NSFetchRequest&lt;RestaurantMO&gt; = RestaurantMO.fetchRequest()// 2let sortDescriptor = NSSortDescriptor(key: &quot;name&quot;, ascending: true)fetchRequest.sortDescriptors = [sortDescriptor]if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; let context = appDelegate.persistentContainer.viewContext fetchResultController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: context, sectionNameKeyPath: nil, cacheName: nil) fetchResultController.delegate = self&#125;do &#123; // 3 try fetchResultController.performFetch() if let fetchedObjects = fetchResultController.fetchedObjects &#123; // 4 restaurants = fetchedObjects &#125;&#125; catch &#123; print(error)&#125; 1 从RestaurantMO对象获得数据请求对象NSFetchRequest。 2 通过NSSortDescriptor来设置获取结果的排序方式。 3 performFetch方法执行从数据库中获取数据请求。 4 把请求结果复制给变量restaurants。 数据库中数据变化，将调用来自NSFetchedResultsControllerDelegate三个方法，调用三个方法的时间可以简单的理解分别为数据将要改变、数据正在改变、数据改变后：controllerWillChangeContent(_:)controller(_:didChange:at:for:newIndexPath:)controllerDidChangeContent(_:) 方法的实现，也分别对table view有不同处理： 123456789101112131415161718192021222324252627282930func controllerWillChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) &#123; tableView.beginUpdates()&#125;func controller(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;, didChange anObject: Any, at indexPath: IndexPath?, for type: NSFetchedResultsChangeType, newIndexPath: IndexPath?) &#123; switch type &#123; case .insert: if let newIndexPath = newIndexPath &#123; tableView.insertRows(at: [newIndexPath], with: .fade) &#125; case .delete: if let indexPath = indexPath &#123; tableView.deleteRows(at: [indexPath], with: .fade) &#125; case .update: if let indexPath = indexPath &#123; tableView.reloadRows(at: [indexPath], with: .fade) &#125; default: tableView.reloadData() &#125; if let fetchedObjects = controller.fetchedObjects &#123; restaurants = fetchedObjects as! [RestaurantMO] &#125;&#125;func controllerDidChangeContent(_ controller: NSFetchedResultsController&lt;NSFetchRequestResult&gt;) &#123; tableView.endUpdates()&#125; 现在运行程序，添加新的Restaurant就能同步显示了。 通过CoreData删除数据更新RestaurantTableViewController的tableView(_:editActionsForRowAt:_)方法中的 deleteAction。1234567891011let deleteAction = UITableViewRowAction(style: .default, title: &quot;Delete&quot;, handler: &#123; (action, indexPath) -&gt; Void in if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; let context = appDelegate.persistentContainer.viewContext let restaurantToDelete = self.fetchResultController.object(at: indexPath) context.delete(restaurantToDelete) appDelegate.saveContext() &#125; &#125;) 现在删除一项后，重新启动后，数据消失。 更新数据更新RestaurantDetailViewController的中的ActionratingButtonTapped: ：12345678910111213141516171819202122@IBAction func ratingButtonTapped(segue: UIStoryboardSegue) &#123; if let rating = segue.identifier &#123; restaurant.isVisited = true switch rating &#123; case &quot;great&quot;: restaurant.rating = &quot;Absolutely love it! Must try.&quot; case &quot;good&quot;: restaurant.rating = &quot;Pretty good.&quot; case &quot;dislike&quot;: restaurant.rating = &quot;I don&apos;t like it.&quot; default: break &#125; &#125; if let appDelegate = (UIApplication.shared.delegate as? AppDelegate) &#123; appDelegate.saveContext() &#125; tableView.reloadData()&#125; 现在评价一项后，重新启动后评价就会保留。 Exercise：添加新字段之前新建Restaurant页面没有Phone字段，现在添加 在SB的New Restaurant添加新Cell，在AddRestaurantController中添加相关接口并关联。 更新AddRestaurantController中的save:Action相关代码。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 15 使用地图]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-15.html</url>
    <content type="text"><![CDATA[继续上一盘开始用Swift开发iOS 10 - 14 基础动画，模糊效果和Unwind Segue，这一篇使用地图。添加MapKit框架： 添加Map到应用中效果图如下： 在Detail view的table view底部添加一个Map View。高度设置为135，取消一些属性zooming, scrolling, rotating等，使地图没有交互功能。 删除之前去掉table view底部的代码，让底部显示。tableView.tableFooterView = UIView(frame: CGRect.zero) 添加新的视图控制器，并在其中添加Map View，调整大小为全屏。 control-drag从detail视图控制器到新的地图视图控制器，选择show。因为table view的头部和底部是不能选择的，所有不能从table view的底部control-drag到地图视图控制器。 为了能检测的table view底部map的是否被接触，需要为地图添加UITapGestureRecognizer 。在RestaurantDetailViewController.swift中引入 import MapKit;定义地图接口@IBOutlet var mapView: MKMapView!，并关联;在viewDidLoad中添加：12let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(showMap))mapView.addGestureRecognizer(tapGestureRecognizer) 另外添加方法：123func showMap() &#123; performSegue(withIdentifier: &quot;showMap&quot;, sender: self)&#125; 用Geocoder转换地址到经纬度类似下面：1234567let geoCoder = CLGeocoder()geoCoder.geocodeAddressString(&quot;上海东方明珠&quot;, completionHandler: &#123; placemarks, error in for p in placemarks! &#123; print(p.location?.coordinate) &#125;&#125;) placemarks是CLPlacemark的数组。 地图标注（annotation）介绍通过地址文本获得经纬度后就可在地图上标注指示，类似下面的样子： 地图标注的代码一般如下，先通过地址文本生成的经纬度，规定MKPointAnnotation的经纬度，然后把MKPointAnnotation添加到地图视图中即可。12345let annotation = MKPointAnnotation()if let location = placemark.location &#123; annotation.coordinate = location.coordinate mapView.addAnnotation(annotation)&#125; 为没有交互的地图添加标注在RestaurantDetailViewController.swift的viewDidLoad中添加：123456789101112131415161718192021222324252627let geoCoder = CLGeocoder()geoCoder.geocodeAddressString(restaurant.location, completionHandler: &#123; placemarks, error in if error != nil &#123; print(error) return &#125; if let placemarks = placemarks &#123; let placemark = placemarks[0] let annotation = MKPointAnnotation() if let location = placemark.location &#123; annotation.coordinate = location.coordinate self.mapView.addAnnotation(annotation) // 规定地图显示半径 250米 let region = MKCoordinateRegionMakeWithDistance(annotation.coordinate, 250, 250) self.mapView.setRegion(region, animated: false) &#125; &#125;&#125;)``` ### 为全屏的地图添加标注- 新建一个视图控制器`MapViewController`，关联全屏地图控制器，引入地图框架 `import MapKit`。- 第一个地图接口和`restaurant`变量 @IBOutlet var mapView: MKMapView!var restaurant:Restaurant!1- 更新`viewDidLoad`： override func viewDidLoad() { super.viewDidLoad() let geoCoder = CLGeocoder() geoCoder.geocodeAddressString(restaurant.location, completionHandler: { placemarks, error in if error != nil { print(error) return } if let placemarks = placemarks { // Get the first placemark let placemark = placemarks[0] // 1 let annotation = MKPointAnnotation() annotation.title = self.restaurant.name annotation.subtitle = self.restaurant.type if let location = placemark.location { annotation.coordinate = location.coordinate // 2 self.mapView.showAnnotations([annotation], animated: true) self.mapView.selectAnnotation(annotation, animated: true) } } }) } 123456 + 1 设置`MKPointAnnotation`一些属性 + 2 在地图展示标注。地图上课展示很多标注。`selectAnnotation:`方法是标注显示被选中的样式。### 在标注中添加图片- 让`MapViewController`实现`MKMapViewDelegate`协议，并在`viewDidLoad`中设置`mapView.delegate = self`- 添加`mapView(_:viewFor:)`方法，当地图每次需要annotation时调用： func mapView(_ mapView: MKMapView, viewFor annotation: MKAnnotation) -&gt; MKAnnotationView? { let identifier = &quot;MyPin&quot; // 1 if annotation.isKind(of: MKUserLocation.self) { return nil } // 2 var annotationView: MKPinAnnotationView? = mapView.dequeueReusableAnnotationView(withIdentifier: identifier) as? MKPinAnnotationView if annotationView == nil { annotationView = MKPinAnnotationView(annotation: annotation, reuseIdentifier: identifier) annotationView?.canShowCallout = true } // 3 let leftIconView = UIImageView(frame: CGRect(x: 0, y: 0, width: 53, height: 53)) leftIconView.image = UIImage(named: restaurant.image) annotationView?.leftCalloutAccessoryView = leftIconView // 4 annotationView?.pinTintColor = UIColor.orange return annotationView } ``` 1 判断是否用户当前位置。用户当前位置算是一种特殊的标注，是当前位置，就不需要另外添加标注了。 2 创建MKPinAnnotationView。有点类似创建table view cell。 3 在MKPinAnnotationView上添加图片。 4 改变标注针的颜色。 地图定制mapView.showsCompass = true mapView.showsScale = true mapView.showsTraffic = true showsCompass表示在右上角显示罗盘。showsScale 表示在左上角显示缩放比例尺。 showsTraffic表示显示交通信息。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 16 介绍静态Table Views，UIImagePickerController和NSLayoutConstraint]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-16.html</url>
    <content type="text"><![CDATA[继续上一篇开始用Swift开发iOS 10 - 15 使用地图，这一篇通过添加一个新建Restaurant页面来介绍静态Table Views，UIImagePickerController，NSLayoutConstraint。静态Table Views就是固定cell数目的Table Views；UIImagePickerController用来从设备图片库中获取图片；NSLayoutConstraint就是约束类，用来用代码形式添加约束。 添加新的Table View Controller 拖动一个Table View Controller到SB中。 修改成Table View的content为static cells。 选中Table View Section，修改Rows成5。 下载 [图片] (http://www.appcoda.com/resources/swift3/photoicons.zip)，拖进`Assets` 修改第一个Cell高度为250。添加Image View， image为photoalbum，大小64*64，水平和垂直居中。 第二个cell高度为72。添加一个Label文本NAME。添加一个Text Field,placeholder为Restaurant Name，border style为 none，宽度为339。添加适当约束。 第三个和第四个Cell与第二个类似，Label文本分别为TYPE LOCATION，Text Field的 placeholder 分别为Restaurant Type，Restaurant Location。 第五个 高度为72。 添加一个Label文本Have You Been Here 。添加两个Button，title分别为YES、NO，字体颜色都为white，背景颜色分别为red，gray。 添加segue 在Food Pin Controller的Navigation bar的右边添加一个bar button item，System Item为Add。 把上面新建是我table view controller内嵌在一个Navigation controller中，选中table view controller，在菜单栏中选择Editor &gt; Embed in &gt; Navigation Controller，设置其navigation bar的title为New Restaurant。 关联Add按钮和New Restaurant Controller的Navigation controller，segue类型present modally，identifier为addRestaurant。 在New Restaurant Controller的Navigation bar的左边添加一个bar button item，System Item为 Cancel，tint为white。 在RestaurantTableViewController中添加unwind segue的action。用control-drag关联。 12@IBAction func unwindToHomeScreen(segue:UIStoryboardSegue) &#123;&#125; 使用UIImagePickerController调用相册 新建AddRestaurantController，继承至UITableViewController。关联New Restaurant Controller。 删除除了viewDidLoad方法的其他方法，静态类型不需要了。 添加tableView(_:didSelectRowAt:)：1234567891011override func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; if indexPath.row == 0 &#123; if UIImagePickerController.isSourceTypeAvailable(.photoLibrary) &#123; let imagePicker = UIImagePickerController() imagePicker.allowsEditing = false imagePicker.sourceType = .photoLibrary present(imagePicker, animated: true, completion: nil) &#125; &#125;&#125; 选择第一个cell，也就是图片，通过isSourceTypeAvailable方法判断是否有图库可用。 在Info.plist中添加使用图库的请求描述， Privacy - Photo Library Usage Description -&gt; You need to grant the app access to your photo library so you can pick your favorite restaurant photo. 。 实现UIImagePickerControllerDelegate协议 添加UIImagePickerControllerDelegate 和UINavigationControllerDelegate class AddRestaurantController: UITableViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate { 添加接口@IBOutlet var photoImageView: UIImageView!，并关联。 添加函数imagePickerController(_:didFinishPickingMediaWithInfo:)，当用户从图库中选择图片时调用。 12345678910func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let selectedImage = info[UIImagePickerControllerOriginalImage] as? UIImage &#123; photoImageView.image = selectedImage photoImageView.contentMode = .scaleAspectFill photoImageView.clipsToBounds = true &#125; dismiss(animated: TUREAD, completion: nil)&#125; 在tableView(_:didSelectRowAt:)中的imagePicker定义后添加： imagePicker.delegate = self 用代码的方式定义约束之前都是通过storyboard设置约束，其实也可以通过代码的形式设置。 之前的地图的约束例子，storyboard 中的Map View.leading = leading等价于： let leadingConstraint = NSLayoutConstraint(item: mapView, attribute: NSLayoutAttribute.leading, relatedBy: .equal, toItem: mapView.superview, attribute: .leading, multiplier: 1, constant: 0) leadingConstraint.isActive = true 在添加imagePickerController(_:didFinishPickingMediaWithInfo:)的dismiss(animated: true, completion: nil)之前添加4个约束代码。 123456789let leadingConstraint = NSLayoutConstraint(item: photoImageView, attribute: .leading, relatedBy: .equal, toItem: photoImageView.superview, attribute: .leading, multiplier: 1, constant: 0) leadingConstraint.isActive = true let trailingConstrain = NSLayoutConstraint(item: photoImageView, attribute: .trailing, relatedBy: .equal, toItem: photoImageView.superview, attribute: .trailing, multiplier: 1, constant: 0) trailingConstrain.isActive = true let topConstraint = NSLayoutConstraint(item: photoImageView, attribute: .top, relatedBy: .equal, toItem: photoImageView.superview, attribute: .top, multiplier: 1, constant: 0) let buttomConstraint = NSLayoutConstraint(item: photoImageView, attribute: .bottom, relatedBy: .equal, toItem: photoImageView.superview, attribute: .bottom, multiplier: 1, constant: 0) 添加约束前后对比： Exercise：验证添加数据 在New Restaurant Controller的Navigation controller的有右上角添加Save按钮。 在AddRestaurantController中添加五个接口和一个变量，并关联。 123456@IBOutlet var nameTextField:UITextField!@IBOutlet var typeTextField:UITextField!@IBOutlet var locationTextField:UITextField!@IBOutlet var yesButton:UIButton!@IBOutlet var noButton:UIButton! var isVisited: Bool = true 添加一个Action，关联save按钮。 1234567891011121314@IBAction func save(_ sender: Any) &#123; if (nameTextField.text?.isEmpty)! || (typeTextField.text?.isEmpty)! || (locationTextField.text?.isEmpty)! &#123; let alertController = UIAlertController(title: &quot;Oops&quot;, message: &quot;We can&apos;t proceed because one of the fields is blank....&quot;, preferredStyle: .alert) let alertAction = UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil) alertController.addAction(alertAction) present(alertController, animated: true, completion: nil) &#125; else &#123; print(nameTextField.text, typeTextField.text, locationTextField.text, isVisited) dismiss(animated: true, completion: nil)// performSegue(withIdentifier: &quot;unwindToHomeScreen&quot;, sender: self) &#125;&#125; 去除 Add Restaurant view controller回到主界面有两种方法，一是dismiss(animated: true, completion: nil)，而是利用unwind segue。 添加一个Action toggleBeenHereButton:，用于yesButton和noButton的操作。1234567891011@IBAction func toggleBeenHereButton(sender: UIButton) &#123; if sender == yesButton &#123; isVisited = true yesButton.backgroundColor = UIColor.red noButton.backgroundColor = UIColor.gray &#125; else &#123; isVisited = false yesButton.backgroundColor = UIColor.gray noButton.backgroundColor = UIColor.red &#125;&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 14 基础动画，模糊效果和Unwind Segue]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-14.html</url>
    <content type="text"><![CDATA[动画是通过一系列静态图片（帧）快速显示来模拟动作和形状的变化过程。 在iOS中，创建基础动画很简单，只需要利用UIView的类型方法：animate(withDuration:animations:)。这个方法的原理就是，设置好开始状体和结束状态，然后 UIView animation 创建中间的过程效果。继续上一篇开始用Swift开发iOS 10 - 13 Self Sizing Cells and Dynamic Type。 添加评级Button 下载图片包，添加到xcassets里。 在detail view右上角添加一个Button，设置其内容为空，image为更添加的图片check（一个对勾图标），type为system，tint为white。 为Button添加四个约束，右、上两个spacing约束，宽度和高度约束。 创建Restaurant Review视图控制器 在storyboard中新建一个View Controller。 在新建视图控制器中添加Image View，并改变其大小为整个view，先设置image属性为一个随机图片，比如cafeloisl。 并设置一些约束。 按照下图设置之后是UI： 在Review的图片上添加一个UIView，x、y、宽度、高度分别是53、40、269、420。 添加Image View，宽度和高度分别为269，200，随机设置image 添加一个内容为You&#39;ve dined here. What do you think?的Label。字体风格为Light，大小为27，居中退器，行数为2。 添加三个按钮内容分别为Absolutely love it!，Good，I don&#39;t like it。背景为红色，tint为white，字体是Light和16。 设置三个按钮为一个stack view，改变distribution为Fill Equally，spaing为5。 为上面添加的UIView添加四个约束。上左右的spacing约束分别为20，37，37。高度约束为420。 为label添加左右下三个spacing约束，值都是15。 为stack view天机左右下三个spacing约束，分别为8，8，10。 创建Present modally类型的Segue在开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue中介绍过Segue类型。Present modally是新页面将以动画形式从底部出现到覆盖整个手机屏幕。 contrl-drag从对勾button到Review视图控制，选择Present modally。并设置新生成segue的identifier为showReview。 定义如何退出Review View Controller在Navigation Controller中自带了返回按钮，这边需要自己设置unwind segue。 在Review View Controller中的UIView的右上角添加一个关闭按钮，类似于对勾按钮，添加右上和宽度高度约束。 为了实现unwind segue，需要做两件事：首先，在返回的的视图控制器（RestaurantDetailViewController）中定义一个方法，定义这个方法是为了告诉xcode这个segue是可以返回的。12@IBAction func close(segue:UIStoryboardSegue) &#123;&#125; 其次在IB中关联返回。control+drag关闭按钮到Exit，选择closeWithSegue:。 为背景图片添加模糊效果UIVisualEffectView 新建ReviewViewController继承至UIViewController，关联上面新建视图控制器。 在ReviewViewController中添加背景图片结构，并关联图片。@IBOutlet var backgroundImageView: UIImageView! 在ReviewViewController的viewDidLoad中添加：1234let blurEffect = UIBlurEffect(style: .dark)let blurEffectView = UIVisualEffectView(effect: blurEffect)blurEffectView.frame = view.boundsbackgroundImageView.addSubview(blurEffectView) 模糊效果有点像在要添加的视图上面添加一个视图(UIVisualEffectView)，这图有模糊效果(UIBlurEffect)，模糊样式通过UIBlurEffectStyle控制，有三种extraLight, light, dark。 实现 UIView Animation 为准备实现动画效果的UIView添加接口，并关联。@IBOutlet var containerView: UIView! 定义初始状态：在ReviewViewController的viewDidLoad中添加:containerView.transform = CGAffineTransform.init(scaleX: 0, y: 0) 定义介绍状态：在ReviewViewController的viewDidAppear中添加：12345override func viewDidAppear(_ animated: Bool) &#123; UIView.animate(withDuration: 0.3, animations: &#123; self.containerView.transform = CGAffineTransform.identity &#125;)&#125; CGAffineTransform.identity表示原本设置的大小和位置状态。 Spring 动画只要修改一下结束状态就可以了：123UIView.animate(withDuration: 0.4, delay: 0.0, usingSpringWithDamping: 0.3, initialSpringVelocity: 0.2, options: .curveEaseInOut, animations: &#123; self.containerView.transform = CGAffineTransform.identity&#125;, completion: nil) 从上向下的动画只要修改一下初始状态，把初始位置设置在上面即可：1containerView.transform = CGAffineTransform.init(translationX: 0, y: -1000) 组合两种变化把containerView.transform = CGAffineTransform.init(translationX: 0, y: -1000)修改成：1234let scaleTransform = CGAffineTransform.init(scaleX: 0, y: 0)let translateTransform = CGAffineTransform.init(translationX: 0, y: -1000)let combineTransform = scaleTransform.concatenating(translateTransform)containerView.transform = combineTransform Unwind Segues 和数据传输在Review View中点击三个不同评价按钮也通过Unwind Segues返回并传输数据。 在RestaurantDetailViewController在添加另外一个unwind action方法。 12@IBAction func ratingButtonTapped(segue: UIStoryboardSegue) &#123;&#125; 分别对三个按钮control+drag到Exit，选择ratingButtonTappedWithSegue:，并分别把三个unwind segue的identifier改成 great good dislike。 在Restaurant中添加rating属性： var rating = &quot;&quot; 更新 ratingButtonTapped(segue:)： 1234567891011121314151617@IBAction func ratingButtonTapped(segue: UIStoryboardSegue) &#123; if let rating = segue.identifier &#123; restaurant.isVisited = true switch rating &#123; case &quot;greate&quot;: restaurant.rating = &quot;Absolutely love it! Must try.&quot; case &quot;good&quot;: restaurant.rating = &quot;Pretty good.&quot; case &quot;dislike&quot;: restaurant.rating = &quot;I don&apos;t like it.&quot; default: break &#125; &#125; tableView.reloadData()&#125; 更新RestaurantDetailViewController的tableView(_:cellForRowAt:)中当fieldLabel为“Been here”的valueLabel的值： cell.valueLabel.text = (restaurant.isVisited) ? &quot;Yes, I&apos;ve been herebefore. \(restaurant.rating)&quot; : &quot;No&quot; 修改ReviewViewController中的图片为相应的图片 在ReviewViewController中添加一个属性：var restaurant: Restaurant! 在RestaurantDetailViewController中添加prepare(for:sender:)方法，作为RestaurantDetailViewController到ReviewViewController的segue时调用，用于传输数据。 123456override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showReview&quot; &#123; let destinationController = segue.destination as! ReviewViewController destinationController.restaurant = self.restaurant &#125;&#125; 在ReviewViewController 中添加图片接口。@IBOutlet var topImageView: UIImageView! 在ReviewViewController的viewDidLoad中显示图片：123let image = UIImage(named: self.restaurant.image)backgroundImageView.image = imagetopImageView.image = image 为closeButton添加动画效果 添加接口@IBOutlet var closeButton: UIButton! 在viewDieLoad中添加：closeButton.transform = CGAffineTransform.init(scaleX: 1000, y: 0) 在 viewDidAppear:添加：12345UIView.animate(withDuration: 0.5, delay: 0.5, usingSpringWithDamping: 0.7, initialSpringVelocity: 0.3, options: .curveEaseInOut, animations: &#123; self.closeButton.transform = CGAffineTransform.identity &#125;, completion: nil) 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习6：Fondation-Kit介绍]]></title>
    <url>%2F2017%2Foc-basic-6.html</url>
    <content type="text"><![CDATA[12macOS -&gt; Cocoa -&gt; Foundation, AppKitiOS -&gt; Cocoa Touch -&gt; Foundation, UIKit(UIView, UIController) Foundation框架的基础是CoreFoundation（C语言），如果函数或变量是以CF开头，就是CoreFoundation框架中的。 Foundation中一些有用的数据类型范围： NSRange1234typedef struct _NSRange &#123; NSUInteger location; NSUInteger length;&#125; NSRange; 表示相关事务的范围。有三种方式初始化： 直接给字段赋值： 123NSRange range;range.location = 12;range.length = 5; 应用C语言的聚合结构赋值：NSRange range = {17, 4} 函数NSMakeRange()：NSRange range3 = NSMakeRange(12, 5);这个方法的好处是可以在任何能够使用函数的地方直接使用：[anObject flarbulateWithRange: NSMakeRange(13, 15)]; 几何数据类型CG前缀，表示Core Graphics框架（C语言），用来进行2D渲染。 CGPoint表示坐标 12345struct CGPoint&#123; float x; float y;&#125; CGSize表示大小，用来存储长度和宽度 12345struct CGSize&#123; float width; float height;&#125; CGRect 表示矩形，由坐标和大小复合而成 12345struct CGRect&#123; CGPoint origin; CGSize size;&#125; 对应创建函数： CGPointMake(), CGSizeMake(), CGRectMake() 集合数据类型是C语言结构体而不是类，是考虑性能的原因。 字符串字符串类： NSString。 通过格式字符串和参数创建NSString： 12NSString *height;height = [NSString stringWithFormat:@&quot;%d, %d&quot;, 4, 3]; 类方法： 以+为起始符的。 字符长度，实例方法length： - (NSUInteger) length; 字符串比较 (BOOL)isEqualToString:(NSString *)aString;，表示字符串内容是否相同，返回BooL；==判断字符串的指针是否相同，也就是是否是同一个事务。 12345678910NSString *thing1 = @&quot;hello 5&quot;;NSString *thing2 = [NSString stringWithFormat:@&quot;hello %d&quot;, 5]; if ([thing1 isEqualToString:thing2]) &#123; NSLog(@&quot;两个字符串内容相同&quot;);&#125;if (thing1 == thing2) &#123; NSLog(@&quot;两个字符串是同一个对象&quot;);&#125; - (NSComparisonResult)compare:(NSNumber *)decimalNumber;，逐个比较字符串的每个字符，判断大小。返回一个枚举类型NSComparisonResult，三个枚举值分别表示左小于右，左等于右，左大于右。 - (NSComparisonResult)compare:(NSString *)string options:(NSStringCompareOptions)mask;，根据options的不同值有不同的功能。 字符串内是否还包含别的字符串检测字符串是否以另一个字符开头或结尾： 12- (BOOL)hasPrefix:(NSString *)str;- (BOOL)hasSuffix:(NSString *)str; 一个字符串在另一个字符串内的返回：- (NSRange)rangeOfString:(NSString *)searchString; 可变性NSString是不可变的。也就是一旦被创建，就不能以删除字符或添加字符的方式改变它。NSMutableString是NSString的子类，可以改变。 可通过类方法stringWithCapacity:来创建，表示分配一块内存用于存储字符串，+ (NSMutableString *)stringWithCapacity:(NSUInteger)capacity;。NSMutableString *string = [NSMutableString stringWithCapacity:1]; appendString:和appendFormat: 添加字符串： 123NSMutableString *string = [NSMutableString stringWithCapacity:50];[string appendString:@&quot;Hello there &quot;];[string appendFormat:@&quot;human %d!&quot;, 39]; // Hello there human 39! deleteCharactersInRange: 删除字符串，经常和rangeOfString:一起使用。 12345NSMutableString *friends = [NSMutableString stringWithCapacity:50]; [friends appendString:@&quot;James BethLynn Jack Evan&quot;]; NSRange jackRange = [friends rangeOfString:@&quot;Jack&quot;]; jackRange.length++; [friends deleteCharactersInRange:jackRange]; // James BethLynn Evan 集合 NSArray两个限制：只能存储OC对象；不能存储nil。 创建类方法arrayWithObjects:(nil表示结束)：NSArray *array = [NSArray arrayWithObjects:@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;, nil];直接字面量：NSArray *array2 = @[@&quot;one&quot;, @&quot;two&quot;, @&quot;three&quot;]; 数组对象个数： [array count]; 按索引获取对象： 12[array objectAtIndex:1];array[1]; 字符串切分成数组，数组合并成字符串。 123NSMutableString *string2 = @&quot;oop:ack:bork:greeble:ponies&quot;; NSArray *chunks = [string2 componentsSeparatedByString:@&quot;:&quot;]; string2 = [chunks componentsJoinedByString:@&quot;:-)&quot;]; // oop:-)ack:-)bork:-)greeble:-)ponies NSMutableArrayNSArray包含的对象个数是不能变化的（包含的对象是可以变化的）。NSMutableArray是可以变化数目。 创建: + (instancetype)arrayWithCapacity:(NSUInteger)numItems; 末尾添加 - (void) addObject: (id) anObject; 删除特定索引的对象 - (void)removeObjectAtIndex:(NSIndexSet *)index; 枚举：对数组进行遍历。NSEnumerator 1234NSEnumerator *emumerator = [array objectEnumerator];while (id thingie = [emumerator nextObject]) &#123; &#125; 快速枚举 123for (NSString *string in array) &#123; NSLog()&#125; NSDictionary同样也有对应的NSMutableDictionary。 123456789101112131415161718 // 创建 NSDictionary Tire *t1 = [Tire new]; Tire *t2 = [Tire new]; Tire *t3 = [Tire new]; Tire *t4 = [Tire new]; NSDictionary *tires = [NSDictionary dictionaryWithObjectsAndKeys:t1, @&quot;front-left&quot;, t2, @&quot;front-right&quot;, t3, @&quot;back-left&quot;, t4, @&quot;back-right&quot;, nil];// NSDictionary *tires = @&#123;@&quot;front-left&quot;: t1, @&quot;front-right&quot;: t2, @&quot;back-left&quot;: t3,@&quot;back-right&quot;: t4,&#125;; // 访问特定key的对象 Tire *tire = [tires objectForKey:@&quot;back-right&quot;];// Tire *tire = tires[@&quot;back-right&quot;]; // 创建NSMutableDictionary NSMutableDictionary *tires_m = [NSMutableDictionary dictionaryWithCapacity:10];// NSMutableDictionary *tires_m = [NSMutableDictionary dictionary]; // 为NSMutableDictionary添加元素 [tires_m setObject:t1 forKey:@&quot;front-left&quot;]; // 从NSMutableDictionary中删除元素 [tires_m removeObjectForKey:@&quot;front-left&quot;]; 其他数据类型NSArray和NSDictionary只能存储对象，不能直接存储任何基本类型的数据，如int、float、和struct。 NSNumber NSValue NSNull]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 13 Self Sizing Cells and Dynamic Type]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-13.html</url>
    <content type="text"><![CDATA[接着上一遍开始用Swift开发iOS 10 - 12 丰富Detail View和定制化Navigation Bar的代码稍作修改，为Restaurant多加一个phone属性,修改过location的长度。 修改RestaurantTableViewController中的restaurants变量（添加字段phone，location字段内容增多）： 1234567891011121314151617181920212223var restaurants:[Restaurant] = [ Restaurant(name: &quot;Cafe Deadend&quot;, type: &quot;Coffee &amp; Tea Shop&quot;,location: &quot;G/F, 72 Po Hing Fong, Sheung Wan, Hong Kong&quot;, phone: &quot;232-923423&quot;,image: &quot;cafedeadend.jpg&quot;, isVisited: false), Restaurant(name: &quot;Homei&quot;, type: &quot;Cafe&quot;, location: &quot;Shop B, G/F, 22-24A Tai Ping San Street SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;348-233423&quot;, image:&quot;homei.jpg&quot;, isVisited: false), Restaurant(name: &quot;Teakha&quot;, type: &quot;Tea House&quot;, location: &quot;Shop B, 18 Tai Ping Shan Road SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;354-243523&quot;, image: &quot;teakha.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe loisl&quot;, type: &quot;Austrian / Causual Drink&quot;, location: &quot;Shop B, 20 Tai Ping Shan Road SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;453-333423&quot;, image: &quot;cafeloisl.jpg&quot;, isVisited: false), Restaurant(name: &quot;Petite Oyster&quot;, type: &quot;French&quot;, location: &quot;24 Tai Ping Shan Road SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;983-284334&quot;, image: &quot;petiteoyster.jpg&quot;, isVisited: false), Restaurant(name: &quot;For Kee Restaurant&quot;, type: &quot;Bakery&quot;, location: &quot;Shop J-K., 200 Hollywood Road, SOHO, Sheung Wan, Hong Kong&quot;, phone: &quot;232-434222&quot;, image: &quot;forkeerestaurant.jpg&quot;, isVisited: false), Restaurant(name: &quot;Po&apos;s Atelier&quot;, type: &quot;Bakery&quot;, location: &quot;G/F, 62 Po Hing Fong, Sheung Wan, Hong Kong&quot;, phone: &quot;234-834322&quot;, image: &quot;posatelier.jpg&quot;, isVisited: false), Restaurant(name: &quot;Bourke Street Backery&quot;, type: &quot;Chocolate&quot;, location: &quot;633 Bourke St Sydney New South Wales 2010 Surry Hills&quot;, phone: &quot;982-434343&quot;, image:&quot;bourkestreetbakery.jpg&quot;, isVisited: false), Restaurant(name: &quot;Haigh&apos;s Chocolate&quot;, type: &quot;Cafe&quot;, location: &quot;412-414 George St Sydney New South Wales&quot;, phone: &quot;734-232323&quot;, image: &quot;haighschocolate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Palomino Espresso&quot;, type: &quot;American / Seafood&quot;, location: &quot;Shop 1 61 York St Sydney New South Wales&quot;, phone: &quot;872-734343&quot;, image: &quot;palominoespresso.jpg&quot;, isVisited: false), Restaurant(name: &quot;Upstate&quot;, type: &quot;American&quot;, location: &quot;95 1st Ave New York, NY 10003&quot;, phone: &quot;343-233221&quot;, image: &quot;upstate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Traif&quot;, type: &quot;American&quot;, location: &quot;229 S 4th St Brooklyn, NY 11211&quot;, phone: &quot;985-723623&quot;, image: &quot;traif.jpg&quot;, isVisited: false), Restaurant(name: &quot;Graham Avenue Meats&quot;, type: &quot;Breakfast &amp; Brunch&quot;, location: &quot;445 Graham Ave Brooklyn, NY 11211&quot;, phone: &quot;455-232345&quot;, image: &quot;grahamavenuemeats.jpg&quot;, isVisited: false), Restaurant(name: &quot;Waffle &amp; Wolf&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;413 Graham Ave Brooklyn, NY 11211&quot;, phone: &quot;434-232322&quot;, image: &quot;wafflewolf.jpg&quot;, isVisited: false), Restaurant(name: &quot;Five Leaves&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;18 Bedford Ave Brooklyn, NY 11222&quot;, phone: &quot;343-234553&quot;, image: &quot;fiveleaves.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe Lore&quot;, type: &quot;Latin American&quot;, location: &quot;Sunset Park 4601 4th Ave Brooklyn, NY 11220&quot;, phone: &quot;342-455433&quot;, image: &quot;cafelore.jpg&quot;, isVisited: false), Restaurant(name: &quot;Confessional&quot;, type: &quot;Spanish&quot;, location: &quot;308 E 6th St New York, NY 10003&quot;, phone: &quot;643-332323&quot;, image: &quot;confessional.jpg&quot;, isVisited: false), Restaurant(name: &quot;Barrafina&quot;, type: &quot;Spanish&quot;, location: &quot;54 Frith Street London W1D 4SL United Kingdom&quot;, phone: &quot;542-343434&quot;, image: &quot;barrafina.jpg&quot;, isVisited: false), Restaurant(name: &quot;Donostia&quot;, type: &quot;Spanish&quot;, location: &quot;10 Seymour Place London W1H 7ND United Kingdom&quot;, phone: &quot;722-232323&quot;, image: &quot;donostia.jpg&quot;, isVisited: false), Restaurant(name: &quot;Royal Oak&quot;, type: &quot;British&quot;, location: &quot;2 Regency Street London SW1P 4BZ United Kingdom&quot;, phone: &quot;343-988834&quot;, image: &quot;royaloak.jpg&quot;, isVisited: false), Restaurant(name: &quot;CASK Pub and Kitchen&quot;, type: &quot;Thai&quot;, location: &quot;22 Charlwood Street London SW1V 2DY Pimlico&quot;, phone: &quot;432-344050&quot;, image: &quot;caskpubkitchen.jpg&quot;, isVisited: false)] 为Restaurant添加属性phone。 修改RestaurantDetailViewController中两个table view方法：123456789101112131415161718192021222324252627282930313233func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 5&#125;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! RestaurantDetailTableViewCell // Configure the cell... switch indexPath.row &#123; case 0: cell.fieldLabel.text = &quot;Name&quot; cell.valueLabel.text = restaurant.name case 1: cell.fieldLabel.text = &quot;Type&quot; cell.valueLabel.text = restaurant.type case 2: cell.fieldLabel.text = &quot;Location&quot; cell.valueLabel.text = restaurant.location case 3: cell.fieldLabel.text = &quot;Phone&quot; cell.valueLabel.text = restaurant.phone case 4: cell.fieldLabel.text = &quot;Been here&quot; cell.valueLabel.text = (restaurant.isVisited) ? &quot;Yes, I&apos;ve been herebefore&quot; : &quot;No&quot; default: cell.fieldLabel.text = &quot;&quot; cell.valueLabel.text = &quot;&quot; &#125; cell.backgroundColor = UIColor.clear return cell&#125; 使Cell自适应 在RestaurantDetailViewController中的viewDidLoad中添加： 12tableView.estimatedRowHeight = 36.0 tableView.rowHeight = UITableViewAutomaticDimension estimatedRowHeight是cell的预计高度，这边就设置成原本prototype cell的高度。 UITableViewAutomaticDimension表示超过预计高度后自动适应高度。 修改Value label的numberOfLines属性为0，就是不限制行数。 添加spacing约束当value label超过两行，文本显示出问题： 这是因为虽然value label的高度自适应了合适的高度，但是stack view的高度没有约束，不能计算的出来，因此要给stack view添加两个上下的相等spcing约束。 这样不管value label是多少行，高度都会自适应了。 Dynamic TypeDynamic Type当在手机设置 &gt;通用 &gt; 辅助功能 &gt; 更大字体设置字体大小时，app中的应用也相应的变化。只要把字体设置成text style - Headline就会有Dynamic Type功能。目前只有name label的字体设置成了text style - Headline，其他设置成固定大小的字体，不会随着在手机设置 &gt;通用 &gt; 辅助功能 &gt; 更大字体设置字体大小时而变化。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习2：面向对象编程的基础知识]]></title>
    <url>%2F2017%2Foc-basic-2.html</url>
    <content type="text"><![CDATA[间接(indirection) “只要再多添加一层间接，计算机科学中就没有解决不了的问题。” 例子 电话薄 让他人代替你自己去完成工作 编写一段代码来查询其他代码，并通过它继续访问另一层代码。 推诿 变量与间接 使用文件名的间接 在面向对象编程中使用间接 使用间接来调用代码，不是直接调用某个函数，而是间接调用。 过程式编程(Procedual Programming) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kCircle, kRectangle, kEgg,&#125; ShapeType;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//图形结构typedef struct &#123; ShapeType type; ShapeColor fillColor; ShapeRect bounds;&#125; Shape;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @&quot;red&quot;; break; case kGreenColor: return @&quot;green&quot;; break; case kBlueColor: return @&quot;blue&quot;; break; &#125; return @&quot;no clue&quot;;&#125;//绘制图形void drawCircle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawRectangle(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Rectangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawEgg(ShapeRect bounds, ShapeColor fillColor)&#123; NSLog(@&quot;drawing a Egg at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;void drawShapes(Shape shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; switch (shapes[i].type) &#123; case kCircle: drawCircle(shapes[i].bounds, shapes[i].fillColor); break; case kRectangle: drawRectangle(shapes[i].bounds, shapes[i].fillColor); break; case kEgg: drawEgg(shapes[i].bounds, shapes[i].fillColor); break; default: break; &#125; &#125;&#125;int main(int argc, const char * argv[]) &#123; Shape shapes[3]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0].type = kCircle; shapes[0].fillColor = kRedColor; shapes[0].bounds = rect0; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1].type = kRectangle; shapes[1].fillColor = kGreenColor; shapes[1].bounds = rect1; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2].type = kEgg; shapes[2].fillColor = kBlueColor; shapes[2].bounds = rect2; drawShapes(shapes, 3); return 0;&#125; 修改过去正常工作的代码很可能会引入新的错误。建立在函数之上，数据为函数服务。代码例子 3.2.1 Shapes-Procedural 面向对象编程 以数据为中心，函数为数据服务 代码例子 3.2.2 Shapes-Object id是一种泛型，可以用来引用任何类型的对象(id实际上是一个指向结构体的指针)。 方括号在OC中其他意义：用于通知某个对象该去做什么。[shape draw];表示通知shape对象执行draw操作 发送消息（调用方法）：通知对象执行某种操作。 类是一种能够实例化成对象的结构体。 如果在运行时改变某个类，则该类的所有对象自动继承这些变化。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184#import &lt;Foundation/Foundation.h&gt;typedef enum &#123; kRedColor, kGreenColor, kBlueColor&#125; ShapeColor;//不同图形元素typedef struct &#123; int x, y, width, height;&#125; ShapeRect;//颜色函数NSString *colorName(ShapeColor fillColor)&#123; switch (fillColor) &#123; case kRedColor: return @&quot;red&quot;; break; case kGreenColor: return @&quot;green&quot;; break; case kBlueColor: return @&quot;blue&quot;; break; &#125; return @&quot;no clue&quot;;&#125;@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Rectangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Rectangle@implementation Rectangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Rectangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end@interface Egg : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Egg@implementation Egg- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Egg at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end// 补充一个三角形@interface Triangle : NSObject&#123;@private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Triangle@implementation Triangle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Triangle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@endvoid drawShapes(id shapes[], int count)&#123; for (int i=0; i&lt;count; i++) &#123; id shape = shapes[i]; [shape draw]; &#125;&#125;int main(int argc, const char * argv[]) &#123; id shapes[4]; ShapeRect rect0 = &#123;0, 0, 10, 30&#125;; shapes[0] = [Circle new]; [shapes[0] setBounds:rect0]; [shapes[0] setFillColor:kRedColor]; ShapeRect rect1 = &#123;30, 40, 50, 60&#125;; shapes[1] = [Rectangle new]; [shapes[1] setBounds:rect1]; [shapes[1] setFillColor:kGreenColor]; ShapeRect rect2 = &#123;15, 18, 37, 29&#125;; shapes[2] = [Egg new]; [shapes[2] setBounds:rect2]; [shapes[2] setFillColor:kBlueColor]; ShapeRect rect3 = &#123;3, 4, 5, 0&#125;; shapes[3] = [Triangle new]; [shapes[3] setBounds:rect3]; [shapes[3] setFillColor:kBlueColor]; drawShapes(shapes, 4); return 0;&#125; 有关术语 class object instance message method method dispatcher interface implementation OC中的OOP12345678910111213141516171819202122232425262728293031@interface Circle : NSObject&#123; @private ShapeColor fillColor; ShapeRect bounds;&#125;- (void) setFillColor: (ShapeColor) fillColor;- (void) setBounds: (ShapeRect) bounds;- (void) draw;@end //Circle@implementation Circle- (void) setFillColor:(ShapeColor) c&#123; fillColor = c;&#125;- (void) setBounds:(ShapeRect) b&#123; bounds = b;&#125;- (void) draw&#123; NSLog(@&quot;drawing a Circle at (%d %d %d %d) in %@&quot;, bounds.x, bounds.y, bounds.width, bounds.height, colorName(fillColor));&#125;@end``` 1. `@interface` OC编译器需要一些有关类的信息 + `@` 可以看成是对C语言的扩展 + **instance variable**(实例变量) ： `@interface`下的花括号的内容： { @private ShapeColor fillColor; ShapeRect bounds;} 1+ **method declaration**(方法声明)。有点像C语言中的函数原型。`-`表示对象方法，`+`表示类方法。`(void)`表示返回类型。 - (void) setFillColor: (ShapeColor) fillColor; - (void) setBounds: (ShapeRect) bounds; - (void) draw; ``` + **infix notation**(中缀符) ： *方法的名称及其参数都是合在一起的* `[circle setFillColor: kRedColor]` 表示调用带一个参数的方法 + 如果方法使用参数，则需要冒号，否则不需要冒号 + 提倡@end语言后添加注释来注明类的名称 @implementation @implementation中可以定义在@interface中声明过和没有声明过的方法 OC中不存在真正的私有方法 实例化对象 instantiation（实例化） [Circle new] 发送new消息 软件实体应该对扩展开放，而对修改关闭。 —- 开放/关闭原则(Bertrand Meyer)]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习5：源文件组织]]></title>
    <url>%2F2017%2Foc-basic-5.html</url>
    <content type="text"><![CDATA[将程序拆分为多个小文件有助于更快地找到重要的代码，而且其他人在查看项目时也能有个大致的了解。 拆分接口和实现根据@interface和@implementation，OC的代码通常放在两种文件里： 接口部分(.h)：类的@interface指令、公共struct定义、enum常量、#defines和extern全局变量等。 实现部分(.m): 类的@implementation指令、全局变量的定义、私有struct等。 另外，复杂的项目可以拥有多个目标，它们源文件的配置各不相同，构建规则也不同。群组关系仅仅是有Xcode负责管理的一项奇妙的功能。 拆分Car程序 #import 带尖号的是导入系统头文件(只读)，如#import &lt;Foundation/Foundation.h&gt;；双引号是项目本地的代码文件，如#import &quot;Engine.h&quot;。 拆分上一篇中的Car程序首先拆分继承自NSObject的类：Tire和Engine。 1234567// Tire.h#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end 1234567891011// Tire.m#import &quot;Tire.h&quot;@implementation Tire//#pragma mark -- (NSString *)description &#123; return (@&quot;I am a Tire.&quot;);&#125; //description@end 1234567// Engine.h#import &lt;Foundation/Foundation.h&gt;@interface Engine : NSObject@end 12345678// Engine.m#import &quot;Engine.h&quot;@implementation Engine- (NSString *)description &#123; return (@&quot;I am a Engine.&quot;);&#125; //description@end 使用跨文件依赖关系 @class 是告诉编译器：“这是一个类，只会通过指针来引用它，不需要关注此类的更多信息”。可减少必须导入的头文件的数量，从而缩短编译时间。拆分Car类： 1234567891011121314// Car.h#import &lt;Foundation/Foundation.h&gt;@class Engine;@class Tire;@interface Car : NSObject- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// Car.m#import &quot;Car.h&quot;#import &quot;Tire.h&quot;#import &quot;Engine.h&quot;@implementation Car&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@&quot;%@&quot;, engine); NSLog(@&quot;%@&quot;, tires[0]); NSLog(@&quot;%@&quot;, tires[1]); NSLog(@&quot;%@&quot;, tires[2]); NSLog(@&quot;%@&quot;, tires[3]);&#125;@end //Car 编译器需要先知道所有关于超类的信息才能成功地为其子类编译@interface部分。拆分Slant6和AllWeatherRadial： 1234567// Slant6.h#import &quot;Engine.h&quot;@interface Slant6 : Engine@end 123456789// Slant6.m#import &quot;Slant6.h&quot;@implementation Slant6- (NSString *)description &#123; return (@&quot;I am a slant-6.VROOM!&quot;);&#125;@end 1234567// AllWeatherRadial.h#import &quot;Tire.h&quot;@interface AllWeatherRadial : Tire@end 12345678910// AllWeatherRadial.m#import &quot;AllWeatherRadial.h&quot;@implementation AllWeatherRadial-(NSString *)description&#123; return (@&quot;I am a tire for rain or shine.&quot;);&#125;@end 最后是main.m文件：123456789101112131415161718192021222324// main.m#import &lt;Foundation/Foundation.h&gt;#import &quot;Car.h&quot;#import &quot;Tire.h&quot;#import &quot;Engine.h&quot;#import &quot;Slant6.h&quot;#import &quot;AllWeatherRadial.h&quot;int main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习3：继承(inheritance)]]></title>
    <url>%2F2017%2Foc-basic-3-inheritance.html</url>
    <content type="text"><![CDATA[为何使用继承 UML(Unified Modeling Language, 统一建模语言) 是一种用图表来表示类、类的内容以及它们之间关系。 将重复的代码合并到一处。 继承的语法格式 只能继承一个 只有代码精简，bug才无处藏身 没有声明实例变量时可以省略花括号 相关术语 refactoring (重构) superclass parent class subclass child class override 继承的工作机制OOP一个强大之处：可以对一个程序做一些重大改变，程序仍然可以正常运行。 方法调度：当代码发送信息时，将在当前的类中搜索相应方法，如果无法在接收消息的对象的类文件中找到相应的文件，就会在该对象的超类中进行查找。 实例变量 在创建一个新类时，其对象首先会从它的超类继承实例变量，然后根据自身情况添加自己的实例变量。 polymorphism(多态性) self：指向接收消息的对象的指针 重写方法 super 调用继承的方法可以确保获得方法实现的所有特性]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习4：复合（composition）]]></title>
    <url>%2F2017%2Foc-basic-4-composition.html</url>
    <content type="text"><![CDATA[复合: 对象间的组合（类中中包括类）composition在音乐中翻译为作曲：将多个组件组合在一起，配合使用，从而得到完整的作品。在OC中，复合是通过包含作为实例变量的对象指针实现的。1234567@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;* (void)print;@end //Car 自定义NSLog()NSLog()使用%@格式说明符表示输出对象，也就是NSLog()会给这个对象发送了description消息，然后对象的description方法生成一个NSString并将其返回。**在类中提供description方法就可以自定义NSLog()如何输出对象。123456789101112131415@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@&quot;I am a tire.&quot;);&#125;@endint main(int argc, const char * argv[]) &#123; Tire *tire = [Tire new]; NSLog(@&quot;%@&quot;, tire); // 输出 &quot;I am a tire.&quot; return 0;&#125; 存取方法 存取(accessor) 方法是用来读取或改变某个对象属性的方法。分为 getter方法 和 setter方法。 应该尽量使用对象提供的存取方法，不要直接改变对象里面的值。存取方法总是成对出现的。命名方式：setter方法在要更改属性的加上前缀set；getter方法直接是属性名称。 1234567891011@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car 在OC中所有对象间的交互都是通过指针实现的。 复合还是继承继承的关系：“Is a”（是一个）。如三角形是一个形状，Slant6是一个发动机……复合的关系：“has a”（有一个）。如形状有个填充颜色，汽车有个发动机和四个轮胎…… 详细代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#import &lt;Foundation/Foundation.h&gt;@interface Tire : NSObject@end //Tire 轮胎@implementation Tire- (NSString *)description &#123; return (@&quot;I am a tire.&quot;);&#125;@end@interface Engine : NSObject@end //Engine@implementation Engine- (NSString *)description &#123; return (@&quot;I am a Engine.&quot;);&#125; //description@end@interface Slant6 : Engine@end //slant-6型号的发动机@implementation Slant6- (NSString *)description &#123; return (@&quot;I am a slant-6型号的发动机.VROOM!&quot;);&#125;@end@interface AllWeatherRadial : Tire@end // 新型轮胎@implementation AllWeatherRadial-(NSString *)description&#123; return (@&quot;I am a tire for rain or shine.&quot;);&#125;@end@interface Car : NSObject&#123; Engine *engine; Tire *tires[4];&#125;- (Engine *) engine;- (void) setEngine: (Engine *) newEngine;- (Tire *) tireAtIndex: (int) index;- (void) setTire: (Tire *) tire atIndex: (int) index;- (void)print;@end //Car@implementation Car- (Engine *) engine&#123; return (engine);&#125; //engine- (void) setEngine:(Engine *)newEngine&#123; engine = newEngine;&#125; //setEngine- (void) setTire:(Tire *)tire atIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; tires[index] = tire;&#125; // setTire- (Tire *) tireAtIndex:(int)index&#123; if (index&lt;0 || index&gt;3) &#123; NSLog(@&quot;bad index (%d) in setTire:atIndex&quot;, index); exit(1); &#125; return tires[index];&#125; // tireAtIndex- (id)init&#123; if (self = [super init]) &#123; //? engine = [Engine new]; tires[0] = [Tire new]; tires[1] = [Tire new]; tires[2] = [Tire new]; tires[3] = [Tire new]; &#125; return (self);&#125;- (void)print&#123; NSLog(@&quot;%@&quot;, engine); NSLog(@&quot;%@&quot;, tires[0]); NSLog(@&quot;%@&quot;, tires[1]); NSLog(@&quot;%@&quot;, tires[2]); NSLog(@&quot;%@&quot;, tires[3]);&#125;@endint main(int argc, const char * argv[]) &#123; Car *car = [Car new]; Engine *engine = [Slant6 new]; [car setEngine:engine]; for (int i=0; i&lt;4; i++) &#123; Tire *tire = [AllWeatherRadial new]; [car setTire:tire atIndex:i]; &#125; [car print]; return 0;&#125;]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[OC基础学习1：对C的扩展]]></title>
    <url>%2F2017%2Foc-basic-1-c.html</url>
    <content type="text"><![CDATA[分析最简单的Hello Objective-C程序1234567#import &lt;Foundation/Foundation.h&gt;int main(int argc, const char * argv[]) &#123; NSLog(@&quot;Hello, World!&quot;); return 0;&#125; // main OC本质上就是C语言，它用来声明main()和返回数值的语法和C语言是一样的。 扩展名.m代表message 与C类似，OC使用头文件来包含结构体、符号常量和函数原型等元素的声明。 #import类似于C的#include，但#import可保证头文件只被包含一次。 #import &lt;Foundation/Foundation.h&gt;语句告诉编译器查找Foundation框架中的Foundation.h头文件。 int argc, const char * argv[]中 argc是指命令行参数个数，argv[0]是指可执行文件的路径，argv[1]是指命令行第一个参数，argv[2]是指命令行第二个参数，以此类推。 框架 ：一种把头文件、库、图片、声音等内容聚集在一个独立单元中的集合体。 如Cocoa,Carbon,QuickTime,OpenGL Cocoa包括Foundation和Application Kit(AppKit) 每一个框架都有一个主头文件，它包含了框架内所有的头文件。 Foundation的头文件 1MB 14000行 100多文件 。通过#import &lt;Foundation/Foundation.h&gt; 就获得了整个集合 Xcode使用预编译头文件（一种经过压缩的，摘要形式的头文件）来加快读取速度。 NSLog()和@”字符串” NS前缀是NextSTEP（很早之前苹果公司收购的公司） NSLog()类似于C的printf() @符号是Objective-C在标准C语言基础上添加的特性，意味着引号内的字符串应作为Cocoa的NSString元素来处理 @符号可以看成之后是对C语言的扩展 布尔类型OC中的布尔值YES是1， NO是0，是与C语言中不同的。]]></content>
      <categories>
        <category>Objective-C</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 12 丰富Detail View和定制化Navigation Bar]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-12.html</url>
    <content type="text"><![CDATA[上一篇开始用Swift开发iOS 10 - 11 面向对象编程介绍对代码做了一点修改，这一篇来丰富一下详情页和定制化Navigation Bar。 重新设计详细页面 选中Main.storyboard，删除Image View和三个Label。 添加Table View，修改其大小为整个View，并且添加一些约束。设置prototype cells为1；table view cell的identifier为Cell，row height为36。 在table view的头部添加一个image view，给变其高度为300，宽度为View的宽度。 连接image view和RestaurantDetailViewController中的restaurantImageView接口。 修改Image View的content mode为 Aspect Fit，并勾选Clip to Bounds 定制 Prototype Cell 增加两个label，分别命名为Field，Value ，字体修改成自己想要的。把它们组成一个Stack View。 为Stack View添加一些约束。在cell中垂直居中；Trailing Space 和 Leading Space都为零。 用Ctrl-drag从FieldLabel到ValueLabel，选择Equal Widths，生成一个FieldLabel与ValueLabel宽度相同的约束。修改Multiplier值为0.5，就是FieldLabel的宽度是ValueLabel的一半。 新建RestaurantDetailTableViewCell类文件，继承至UITableViewCell。添加两个接口，并关联上面的两个Label。12@IBOutlet var fieldLabel:UILabel!@IBOutlet var valueLabel:UILabel! 更新 RestaurantDetailViewController 实现UITableViewDataSource和UITableViewDelegate: class RestaurantDetailViewController: UIViewController, UITableViewDataSource, UITableViewDelegate { 实现UITableViewDataSource的相关方法： 123456789101112131415161718192021222324252627282930func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return 4&#125;func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCell(withIdentifier: &quot;Cell&quot;, for: indexPath) as! RestaurantDetailTableViewCell // Configure the cell... switch indexPath.row &#123; case 0: cell.fieldLabel.text = &quot;Name&quot; cell.valueLabel.text = restaurant.name case 1: cell.fieldLabel.text = &quot;Type&quot; cell.valueLabel.text = restaurant.type case 2: cell.fieldLabel.text = &quot;Location&quot; cell.valueLabel.text = restaurant.location case 3: cell.fieldLabel.text = &quot;Been here&quot; cell.valueLabel.text = (restaurant.isVisited) ? &quot;Yes, I&apos;ve been herebefore&quot; : &quot;No&quot; default: cell.fieldLabel.text = &quot;&quot; cell.valueLabel.text = &quot;&quot; &#125; cell.backgroundColor = UIColor.clear return cell&#125; 把table view的delegate和dataSource接口设置成Restaurant Detail View Controller 。 定制table view 的样式 在RestaurantDetailViewController中添加一个接口变量，并关联storyboard中的table view。@IBOutlet var tableView:UITableView! 设置table view的背景颜色，在viewDidLoad中添加:tableView.backgroundColor = UIColor(red: 240.0/255.0, green: 240.0/255.0, blue: 240.0/255.0, alpha: 0.2)新加的颜色是亮灰色（和白色相近，可以设置成其他深颜色做对比），运行后不是整个table view都变色。这是因为，每一个cell都是重新添加的，cell的背景颜色还是默认的白色，覆盖了table view的背景颜色，要在tableView(_:cellForRowAt:)的return之前添加：cell.backgroundColor = UIColor.clear 移除table view中空cell的分割线，在viewDidLoad中添加: tableView.tableFooterView = UIView(frame: CGRect.zero) 改变分割线的颜色， 在viewDidLoad中添加:tableView.separatorColor = UIColor(red: 240.0/255.0, green: 240.0/255.0, blue: 240.0/255.0, alpha: 0.8) 定制Navigation Bar的样式通过UINavigationBar.appearance()修改Navigation Bar的样式。 Navigation Bar的样式修改是整体修改的，所以修改Navigation Bar的样式代码要写在application(_:didFinishLaunchingWithOptions:)方法中。 修改navigation bar的背景颜色：UINavigationBar.appearance().barTintColor = UIColor(red: 216.0/255.0, green: 74.0/255.0, blue: 32.0/255.0, alpha: 1.0) 修改title样式：123if let barFont = UIFont(name: &quot;Avenir-Light&quot;, size: 24.0) &#123; UINavigationBar.appearance().titleTextAttributes = [NSForegroundColorAttributeName:UIColor.white, NSFontAttributeName:barFont]&#125; Avenir-Light是字体名称，详细的iOS字体可查 http://iosfonts.com 。 tintColor控制Navigation items和bar button items的颜色UINavigationBar.appearance().tintColor = UIColor.white 目前，Navigation bar的返回按钮是一个&lt;和Food Pin，想删除Food Pin，需要修改RestaurantTableViewController的backBarButtonItem属性。 在 RestaurantTableViewController的viewDidLoad中添加： navigationItem.backBarButtonItem = UIBarButtonItem(title: &quot;&quot;, style: .plain, target: nil, action: nil) 为 detail view 的 Navigation bar 添加title，在 RestaurantDetailViewController的viewDidLoad中添加：title = restaurant.name 隐藏Navigation Bar 自从iOS 8后，Navigation Bar可以在不同情况下隐藏，在storyboard中选择Navigation Controller修改。（On Swipe是向上滑） 但这种设置整个app的Navigation Bar都会隐藏。如果只想在restaurant table view controller中隐藏，在detail view中不隐藏，就需要在两个控制器的viewDidLoad分别设置：navigationController?.hidesBarsOnSwipe = true 和 navigationController?.hidesBarsOnSwipe = false 。 运行反复测试后发现两个问题： 当从detail view返回后，restaurant table view controller的 Navigation Bar不能隐藏。 当restaurant table view controller的 Navigation Bar隐藏后进入detail view后， Navigation Bar消失不能再显示。 首先明确两个控制器中的navigationController属性指的是同一个Navigation Controller ，viewDidLoad方法是view第一次加载时调用，之后就不再调用了。 也就是说当从detail view返回，hidesBarsOnSwipe已经被设置为false，而到restaurant table view controller的viewDidLoad不再调用，所以Navigation Bar不能再隐藏。 解决办法是使用viewWillAppear，这个方法是在视图每一次显示时调用。在RestaurantTableViewController中添加：1234override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) navigationController?.hidesBarsOnSwipe = true&#125; 在RestaurantDetailViewController中添加：12345override func viewWillAppear(_ animated: Bool) &#123; super.viewWillAppear(animated) navigationController?.hidesBarsOnSwipe = false navigationController?.setNavigationBarHidden(false, animated: true)&#125; 修改Status Bar样式app中Status Bar的默认样式是黑色。 在Info.plist中添加一个key为View controller-based status bar appearance，值为NO。然后application(_:didFinishLaunchingWithOptions:)中添加：UIApplication.shared.statusBarStyle = .lightContent。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 6：使用Quick Look框架预览文件(Swift)]]></title>
    <url>%2F2017%2Fios-tutorial-6-quicklook.html</url>
    <content type="text"><![CDATA[iOS SDK中有很多不常见，却非常好用的库，Quick Look框架就是一个非常好的例子。Quick Look框架提供了预览很多不同类型文件的功能，而不需要打开不同的APP查看，有点像Mac中的空格键功能。 Quick Look框架可以预览的文件类型： iWork documents (Pages, Numbers and Keynote) Microsoft Office documents (as long as they’ve been created with Office 97 or any other newer version) PDF files Images Text files Rich-Text Format documents Comma-Separated Value files (csv) 开始项目到开始项目处下载开始项目，这是原文提供了一个开始项目，代码是老版本的，需要转换一下。这个开始项目中包括了六种不同的类型的文件，一个navigation controller，一个table view controller（FileListViewController），另外还做了一些初始化工作。之后代码就在FileListViewController中完成。 文件和文件的URLS 在FileListViewController中定义一个文件名字的数组变量：let fileNames = [&quot;AppCoda-PDF.pdf&quot;, &quot;AppCoda-Pages.pages&quot;, &quot;AppCoda-Word.docx&quot;, &quot;AppCoda-Keynote.key&quot;, &quot;AppCoda-Text.txt&quot;, &quot;AppCoda-Image.jpeg&quot;] 继续定义一个数组变量，用户存储不同的文件的URL：var fileURLs = [NSURL]() 创建一个方法prepareFileURLs()，用于为fileURLs添加值： 123456789101112func prepareFileURLs() &#123; for file in fileNames &#123; // 1 let fileParts = file.components(separatedBy: &quot;.&quot;) if let fileURL = Bundle.main.url(forResource: fileParts[0], withExtension: fileParts[1]) &#123; // 2 if FileManager.default.fileExists(atPath: fileURL.path) &#123; fileURLs.append(fileURL as NSURL) &#125; &#125; &#125;&#125; 1 components(separatedBy:)方法用于把String按照给定的分隔符，分解成[String]。 2 判断文件地址是否真实存在。 在 viewDidLoad()中实现上面的函数： 12345override func viewDidLoad() &#123; ... prepareFileURLs()&#125; 展示文件用table view展示不同的文件： 根据文件的URL，获得文件名和文件后缀（文件类型），添加函数extractAndBreakFilenameInComponents(:)。 12345678910func extractAndBreakFilenameInComponents(fileURL: NSURL) -&gt; (fileName: String, fileExtension: String) &#123; let fileURLParts = fileURL.path!.components(separatedBy: &quot;/&quot;) let fileName = fileURLParts.last let filenameParts = fileName?.components(separatedBy: &quot;.&quot;) return (filenameParts![0], filenameParts![1])&#125; 修改 tableView(tableView:cellForRowAtIndexPath)： 123456789func tableView(tableView: UITableView, cellForRowAtIndexPath indexPath: NSIndexPath) -&gt; UITableViewCell &#123; let cell = tableView.dequeueReusableCellWithIdentifier(&quot;idCellFile&quot;, forIndexPath: indexPath) let currentFileParts = extractAndBreakFilenameInComponents(fileURLs[indexPath.row]) cell.textLabel?.text = currentFileParts.fileName return cell&#125; 根据不同的后缀名，定义不同的文件类型名称，添加函数getFileTypeFromFileExtension(:)： 12345678910111213141516171819202122232425func getFileTypeFromFileExtension(fileExtension: String) -&gt; String &#123; var fileType = &quot;&quot; switch fileExtension &#123; case &quot;docx&quot;: fileType = &quot;Microsoft Word document&quot; case &quot;pages&quot;: fileType = &quot;Pages document&quot; case &quot;jpeg&quot;: fileType = &quot;Image document&quot; case &quot;key&quot;: fileType = &quot;Keynote document&quot; case &quot;pdf&quot;: fileType = &quot;PDF document&quot; default: fileType = &quot;Text document&quot; &#125; return fileType&#125; 回到tableView(tableView:cellForRowAtIndexPath)，添加一段cell配置： cell.detailTextLabel?.text = getFileTypeFromFileExtension(fileExtension: currentFileParts.fileExtension) 修改每个section中row的数目为文件数目： 123func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; return fileNames.count&#125; QLPreviewControllerDataSource 引入框架Quick Look import QuickLook 定义QLPreviewController let quickLookController = QLPreviewController() 让FileListViewController实现QLPreviewControllerDataSource协议 实现QLPreviewControllerDataSource协议的必须要实现的方法。第一方法表示有多少个文件需要预览： 123func numberOfPreviewItems(in controller: QLPreviewController) -&gt; Int &#123; return fileURLs.count&#125; 第二个方法：123func previewController(_ controller: QLPreviewController, previewItemAt index: Int) -&gt; QLPreviewItem &#123; return fileURLs[index]&#125; 在viewDidLoad()中添加：quickLookController.dataSource = self 预览文件在table view中选中文件，就要跳转的预览页面。实现方法tableView(_:didSelectRowAt:)：123456func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) &#123; if QLPreviewController.canPreview(fileURLs[indexPath.row]) &#123; quickLookController.currentPreviewItemIndex = indexPath.row navigationController?.pushViewController(quickLookController, animated: true) &#125; &#125; navigationController?.pushViewController(quickLookController, animated: true)可用presentViewController(quickLookController, animated: true, completion: nil)代替。 运行可预览文件： 观察上图，可发现 Quick Look Preview Controller自带了toolbar，左边一个是分享按钮(通过UIActivityViewController实现的)，右边一个是类似目录功能，当有很多预览文件时，来跳转到不同预览文件。 代码QuickLookDemo 参考 Using Quick Look Framework for Previewing Documents]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-10.html</url>
    <content type="text"><![CDATA[接着上一篇开始用Swift开发iOS 10 - 9 Table Row的删除, UITableViewRowAction和UIActivityViewController的使用的代码，继续学习Navigation Controller和Segue。 创造Navigation Controller 选中Restaurant Table View Controller然后点击菜单栏中的Editor &gt; Embed in &gt; Navigation Controller；生成了新的一Scene（Navigation Controller Scene）。 选中之前Scene中的Navigation bar，修改其title为Food Pin。 添加 Detail View Controller之前添加导航栏，现在添加另一个view controller，用来显restaurant的详细内容。 拖动一个新的View Controller。 拖动一个image View，调整合适大小，并添加相关约束。Content Mode属性修改为 Aspect Fill。 用segue连接prototype cell和detail scene。 Ctrl-drag从prototype cell到detail scene。如果不方便选择prototype cell，可以在document outline中拖动。选择Show连接风格。 iOS 10中有几种sugue类型： Show：新的view controller将被添加view controller栈的顶部。跳转的页面有Navigation bar，并且有返回原来页面的返回按钮。这是非常常用的的类型。 Show detail：在view controller栈中，新的view controller将被替代原来的view controller。跳转的页面没有Navigation bar，也没有返回原来页面的返回按钮。 Present modally：新页面将以动画形式从底部出现到覆盖整个手机屏幕。这种形式最常见的列子是iOS自带的日历应用： Present as popover：以带有箭头锚点的弹框显示。通常使用的iPad应用中 不再需要action sheet，去除tableView(_:didSelectRowAt:)方法 创建新类文件RestaurantDetailViewController，继承至UIViewController。是新建scene与RestaurantDetailViewController的联系。 在RestaurantDetailViewController中加入一个outlet和一个变量，outlet关联Image View，restaurantImage用与接受table view传来的图像名称数据。 12345678@IBOutlet var restaurantImageView:UIImageView!var restaurantImage = &quot;&quot;override func viewDidLoad() &#123; super.viewDidLoad() restaurantImageView.image = UIImage(named: restaurantImage)&#125; 通过segues传递数据segue管理view controller之间的过渡。当segue触发时，storyboard会通知源view controller（如RestaurantTableViewController）调用方法prepare(for:sender:)，可以通过此方法传递数据。 当storyboard中结构复杂时，segue可能会有很多，同一个view controller可能与各级view controller之间有segue，这种情况最好给segue一个唯一identifier。设置segue的identifier为 showRestaurantDetail。 在RestaurantTableViewController中添加prepareForSegue: 12345678override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showRestaurantDetail&quot; &#123; if let indexPath = tableView.indexPathForSelectedRow &#123; let destinationController = segue.destination as! RestaurantDetailViewController destinationController.restaurantImage = restaurantImages[indexPath.row] &#125; &#125;&#125; 为详情页面添加三个标签 添加三个标签，Text分别为Name，Location，Type（注意：虽然Text会被替代，但不要开始留空，因为留空会使之后生成stack view时，大小不确定）；三个label生成一个stack view，调整字体和大小，添加适当的约束。 添加三个outlet，和三个与之对应的变量。 12345678910111213141516@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!var nameText = &quot;&quot;var locationText = &quot;&quot;var typeText = &quot;&quot;override func viewDidLoad() &#123; super.viewDidLoad() restaurantImageView.image = UIImage(named: restaurantImage) nameLabel.text = nameText locationLabel.text = locationText typeLabel.text = typeText&#125; 修改RestaurantTableViewController中的prepareForSegue方法： 1234567891011override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showRestaurantDetail&quot; &#123; if let indexPath = tableView.indexPathForSelectedRow &#123; let destinationController = segue.destination as! RestaurantDetailViewController destinationController.restaurantImage = restaurantImages[indexPath.row] destinationController.nameText = restaurantNames[indexPath.row] destinationController.locationText = restaurantLocations[indexPath.row] destinationController.typeText = restaurantTypes[indexPath.row] &#125; &#125;&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 11 面向对象编程介绍]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-11.html</url>
    <content type="text"><![CDATA[关于面向对象编程（Object Oriented Programming ，OOP）的知识就不多介绍了，这不是一门编程语言中的概念，而是编程方法。OOP最好的一地方是，它让复杂的软件分解成一个个小的部分，方便程序员开放和管理。这一篇文章就把上一篇文章开始用Swift开发iOS 10 - 10 Navigation Controller的介绍和Segue的代码整理成OOP形式。 重新修改FoodPin项目 之前在RestaurantTableViewController类中，定义了restaurantNames,restaurantImages, restaurantLocations,restaurantTypes四个数组变量，分别表示restaurant的名字，图片名称，位置，类型。每个restaurant的信息分散在四个数组中，而且数组的内容顺序要对应，现在把四个信息组成在一个类中Restaurant。 添加类文件Restaurant.swift 123456789101112131415161718import Foundationclass Restaurant &#123; var name = &quot;&quot; var type = &quot;&quot; var location = &quot;&quot; var image = &quot;&quot; var isVisited = false // 1 init(name: String, type: String, location: String, image: String, isVisited: Bool) &#123; self.name = name self.type = type self.location = location self.image = image self.isVisited = isVisited &#125;&#125; 1 自定义的初始化方法。在Swift中，类的所有变量都需要被初始化，或者声明为可选值。 用Restaurant对象数组代替RestaurantTableViewController中的几个数组变量。 var restaurants:[Restaurant] = [ Restaurant(name: &quot;Cafe Deadend&quot;, type: &quot;Coffee &amp; Tea Shop&quot;, location: &quot;HongKong&quot;, image: &quot;cafedeadend.jpg&quot;, isVisited: false), Restaurant(name: &quot;Homei&quot;, type: &quot;Cafe&quot;, location: &quot;Hong Kong&quot;, image:&quot;homei.jpg&quot;, isVisited: false), Restaurant(name: &quot;Teakha&quot;, type: &quot;Tea House&quot;, location: &quot;Hong Kong&quot;, image:&quot;teakha.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe loisl&quot;, type: &quot;Austrian / Causual Drink&quot;, location: &quot;Hong Kong&quot;, image: &quot;cafeloisl.jpg&quot;, isVisited: false), Restaurant(name: &quot;Petite Oyster&quot;, type: &quot;French&quot;, location: &quot;Hong Kong&quot;, image: &quot;petiteoyster.jpg&quot;, isVisited: false), Restaurant(name: &quot;For Kee Restaurant&quot;, type: &quot;Bakery&quot;, location: &quot;HongKong&quot;, image: &quot;forkeerestaurant.jpg&quot;, isVisited: false), Restaurant(name: &quot;Po&apos;s Atelier&quot;, type: &quot;Bakery&quot;, location: &quot;Hong Kong&quot;, image: &quot;posatelier.jpg&quot;, isVisited: false), Restaurant(name: &quot;Bourke Street Backery&quot;, type: &quot;Chocolate&quot;, location: &quot;Sydney&quot;, image: &quot;bourkestreetbakery.jpg&quot;, isVisited: false), Restaurant(name: &quot;Haigh&apos;s Chocolate&quot;, type: &quot;Cafe&quot;, location: &quot;Sydney&quot;, image: &quot;haighschocolate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Palomino Espresso&quot;, type: &quot;American / Seafood&quot;, location: &quot;Sydney&quot;, image: &quot;palominoespresso.jpg&quot;, isVisited: false), Restaurant(name: &quot;Upstate&quot;, type: &quot;American&quot;, location: &quot;New York&quot;, image: &quot;upstate.jpg&quot;, isVisited: false), Restaurant(name: &quot;Traif&quot;, type: &quot;American&quot;, location: &quot;New York&quot;, image: &quot;traif.jpg&quot;, isVisited: false), Restaurant(name: &quot;Graham Avenue Meats&quot;, type: &quot;Breakfast &amp; Brunch&quot;, location: &quot;New York&quot;, image: &quot;grahamavenuemeats.jpg&quot;, isVisited: false), Restaurant(name: &quot;Waffle &amp; Wolf&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;NewYork&quot;, image: &quot;wafflewolf.jpg&quot;, isVisited: false), Restaurant(name: &quot;Five Leaves&quot;, type: &quot;Coffee &amp; Tea&quot;, location: &quot;New York&quot;,image: &quot;fiveleaves.jpg&quot;, isVisited: false), Restaurant(name: &quot;Cafe Lore&quot;, type: &quot;Latin American&quot;, location: &quot;New York&quot;, image: &quot;cafelore.jpg&quot;, isVisited: false), Restaurant(name: &quot;Confessional&quot;, type: &quot;Spanish&quot;, location: &quot;New York&quot;, image: &quot;confessional.jpg&quot;, isVisited: false), Restaurant(name: &quot;Barrafina&quot;, type: &quot;Spanish&quot;, location: &quot;London&quot;, image: &quot;barrafina.jpg&quot;, isVisited: false), Restaurant(name: &quot;Donostia&quot;, type: &quot;Spanish&quot;, location: &quot;London&quot;, image: &quot;donostia.jpg&quot;, isVisited: false), Restaurant(name: &quot;Royal Oak&quot;, type: &quot;British&quot;, location: &quot;London&quot;, image: &quot;royaloak.jpg&quot;, isVisited: false), Restaurant(name: &quot;CASK Pub and Kitchen&quot;, type: &quot;Thai&quot;, location: &quot;London&quot;, image: &quot;caskpubkitchen.jpg&quot;, isVisited: false) ] 更新 tableView(_:numberOfRowsInSection:) : 1234override func tableView(_ tableView: UITableView, numberOfRowsInSectionsection: Int) -&gt; Int &#123; return restaurants.count&#125; 更新 tableView(_:cellForRowAtIndexPath:) ： 12345678910111213141516override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell // Configure the cell... cell.nameLabel.text = restaurants[indexPath.row].name cell.thumbnailImageView.image = UIImage(named: restaurants[indexPath.row].image) cell.thumbnailImageView.layer.cornerRadius = 30.0 cell.thumbnailImageView.clipsToBounds = true cell.locationLabel.text = restaurants[indexPath.row].location cell.typeLabel.text = restaurants[indexPath.row].type cell.accessoryType = restaurants[indexPath.row].isVisited ? .checkmark : .none return cell&#125; 更新tableView(_:commit:forRowAt:) : 123456override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; restaurants.remove(at: indexPath.row) &#125; tableView.deleteRows(at: [indexPath], with: .fade)&#125; 更新 tableView(_:editActionsForRowAt:) ： override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? { let shareAction = UITableViewRowAction(style: .default, title: &quot;Share&quot;, handler: { (action, indexPath) -&gt; Void in let defaultText = &quot;Just checking in at &quot; + self.restaurants[indexPath.row].name if let imageToShare = UIImage(named: self.restaurants[indexPath.row].image) { let activityController = UIActivityViewController(activityItems: [defaultText, imageToShare], applicationActivities: nil) self.present(activityController, animated: true, completion: nil) } }) let deleteAction = UITableViewRowAction(style: .default, title: &quot;Delete&quot;, handler: { (action, indexPath) -&gt; Void in self.restaurants.remove(at: indexPath.row) tableView.deleteRows(at: [indexPath], with: .fade) }) shareAction.backgroundColor = UIColor(red: 48.0/255.0, green: 173.0/255.0, blue: 99.0/255.0, alpha: 1.0) deleteAction.backgroundColor = UIColor(red: 202.0/255.0, green: 202.0/255.0, blue: 203.0/255.0, alpha: 1.0) return [deleteAction,shareAction] } RestaurantDetailViewController中的四个变量： 1234var nameText = &quot;&quot;var locationText = &quot;&quot;var typeText = &quot;&quot;var restaurantImage = &quot;&quot; 更新为：var restaurant: Restaurant! 与之对应的viewDidLoad()也修改为： override func viewDidLoad() { super.viewDidLoad() restaurantImageView.image = UIImage(named: restaurant.image) nameLabel.text = restaurant.name locationLabel.text = restaurant.location typeLabel.text = restaurant.type } 最后prepare(for:sender:)方法也做对应修改： 12345678override func prepare(for segue: UIStoryboardSegue, sender: Any?) &#123; if segue.identifier == &quot;showRestaurantDetail&quot; &#123; if let indexPath = tableView.indexPathForSelectedRow &#123; let destinationController = segue.destination as! RestaurantDetailViewController destinationController.restaurant = restaurants[indexPath.row] &#125; &#125;&#125; 运行没有问题。 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 4：CALayer介绍(swift)]]></title>
    <url>%2F2017%2Fios-tutorial-4-calayer.html</url>
    <content type="text"><![CDATA[Layers是Core Animation Framework的一部分。Core Animation Framework在iOS架构的位置： 访问CALayer凡是继承至UIView的都将有一个属性layer来表示CALayer。myView.layer 初始化项目 新建CALayerDemo，single View Application模板 新建一个UIView和一个UILabel 圆角CALayer的cornerRadius属性大小表示UIView圆角处圆的半径大小。类似于box.layer.cornerRadius = 20，就形成了圆角，数字越大圆角效果越大，当cornerRadius等于box半径时，box就会变成一个园。 阴影效果1234box.layer.shadowOffset = CGSize(width: 5, height: 5)box.layer.shadowOpacity = 0.7box.layer.shadowRadius = 10box.layer.shadowColor = UIColor.blue.cgColor shadowOffset表示阴影偏移大小，也就是阴影向box的下放偏移5和向右方偏移5距离。 shadowOpacity是阴影透明度 shadowRadius是阴影涉及的半径，并且这个半径越大，阴影的颜色深浅就会越来越小。shadowRadius与shadowOffset是共同作用的 设置边的宽度和颜色12box.layer.borderColor = UIColor.black.cgColorbox.layer.borderWidth = 3 展示图片123box.layer.contents = UIImage(named: &quot;tree.jpg&quot;)?.cgImagebox.layer.contentsGravity = kCAGravityResizebox.layer.masksToBounds = true CALayer的contents属性是open var contents: Any?，可以设置为图片 contentsGravity设置成kCAGravityResize，表示contents的内容会调整大小以适应layer。如果设置成其他值可能出现大小不适的形象，比如kCAGravityBottomRight，将是： masksToBounds为true表示按照layer的边框范围显示内容；如果是false，将会是如下结果 背景颜色和透明度12box.layer.backgroundColor = UIColor.green.cgColorbox.layer.opacity = 0.5 代码CALayerDemo 参考 A Beginner’s Guide to CALayer]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 5：关于地理定位和特定区域(Swift)]]></title>
    <url>%2F2017%2Fios-tutorial-5.html</url>
    <content type="text"><![CDATA[用户带着iPhone进入某个区域，并在某些区域待多久在开发肯能会有很大用处。 初始化项目 创建新的项目GeoTargeting，使用Single View Appliction模板 添加一个Map View，大小为整个页面 添加相关outlet 实现两个协议 123class ViewController: UIViewController, MKMapViewDelegate, CLLocationManagerDelegate &#123; @IBOutlet weak var mapView: MKMapView! 设置CLLocationManager和MKMapView。 1234567891011121314151617// 1let locationManager = CLLocationManager()override func viewDidLoad() &#123; super.viewDidLoad() // 2 locationManager.delegate = self locationManager.distanceFilter = kCLLocationAccuracyNearestTenMeters locationManager.desiredAccuracy = kCLLocationAccuracyBest // 3 mapView.delegate = self mapView.showsUserLocation = true mapView.userTrackingMode = .follow setupData() &#125; 1 创建一个CLLocationManager的实例，用于检测用户的位置变化 2 设置locationManager一些参数，确定精确性 在viewDidAppear中核查用户授权状态1234567891011121314151617override func viewDidAppear(_ animated: Bool) &#123; super.viewDidAppear(animated) let authorizationStatus = CLLocationManager.authorizationStatus() // 1 if authorizationStatus == .notDetermined &#123; locationManager.requestAlwaysAuthorization() &#125; // 2 else if authorizationStatus == .denied &#123; showAlert(&quot;Location services &quot;) &#125; // 3 else if authorizationStatus == .authorizedAlways &#123; locationManager.startUpdatingLocation() &#125;&#125; 1 如果用户授权状态是不确定，就检查是否是一直的状态。 2 如果用户授权状态是拒绝，就用弹框显示信息给用户看。showAlert(title:)是弹框函数： 1234567891011func showAlert(_ title: String) &#123; print(title) let alertController = UIAlertController(title: title, message: nil, preferredStyle: .alert) let action = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler: nil) alertController.addAction(action) present(alertController, animated: true, completion: nil) &#125; 3 如果用户授权状态是一直，就开始更新地理位置。 另外，还需要在.plist文件中添加key为NSLocationAlwaysUsageDescription的提示信息 需要一直能获取你的位置 才可以。在调用requestAlwaysAuthorization()时这个key是必须的。允许获取当前位置。 添加函数setupData()1234567891011121314151617181920212223242526272829303132333435func setupData() &#123; // 1 if CLLocationManager.isMonitoringAvailable(for: CLCircularRegion.self) &#123; // 2 let title = &quot;全季酒店&quot; let coordinate = CLLocationCoordinate2DMake(31.1849700000,121.6303200000) let regionRadius = 300.0 // 3 let region = CLCircularRegion(center: CLLocationCoordinate2D(latitude: coordinate.latitude, longitude: coordinate.longitude), radius: regionRadius, identifier: title) locationManager.startMonitoring(for: region) // 4 let restaurantAnnotation = MKPointAnnotation() restaurantAnnotation.coordinate = coordinate restaurantAnnotation.title = title mapView.addAnnotation(restaurantAnnotation) // 5 let circle = MKCircle(center: coordinate, radius: regionRadius) mapView.add(circle) &#125; else &#123; print(&quot;不能追踪区域&quot;) &#125;&#125;// 6func mapView(_ mapView: MKMapView, rendererFor overlay: MKOverlay) -&gt; MKOverlayRenderer &#123; let circleRenderer = MKCircleRenderer(overlay: overlay) circleRenderer.strokeColor = UIColor.red circleRenderer.lineWidth = 1.0 return circleRenderer&#125; 1 判断是否监控区域功能是否可用。当用户拒绝状态，或用户不让app背景下刷新，或飞行模式时这个功能不可用 2 随意构建一个位置（如全季酒店），经纬度可通过经纬度查询查询，并设置区域半径regionRadius，单位是米。 3 初始化CLCircularRegion。 4 添加一个注解，类似大头针形状。 5 添加区域圆圈标志。 6 这是MKMapViewDelegate的方法，用户画圆 CLRegionCLRegion就是上面标定的圆形区域。下面添加两个CLLocationManagerDelegate的回调方法，分别在是设备的定位位置进和出标定的区域时调用。12345678// MARK:- CLLocationManagerDelegatefunc locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;)&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;)&#125; Xcode中的位置调试上面设备的位置，不可能拿着手机到处跑，Xcode提高了方便的调式方式。可以建立位置文件.GPX: xcode也提供世界上一些常用的位置文件：点击上图调试栏最后的位置标志就可以调式了。 复杂逻辑下的位置处理如果位置不停变化，在监控区域停留时间比较短，或者监控区域比较多是，处理位置问题就比较复杂了。更新部分代码：123456789101112131415161718// 1var monitoredRegions: Dictionary&lt;String, NSDate&gt; = [:] func locationManager(_ manager: CLLocationManager, didEnterRegion region: CLRegion) &#123; showAlert(&quot;enter \(region.identifier)&quot;) // 2 monitoredRegions[region.identifier] = NSDate()&#125;func locationManager(_ manager: CLLocationManager, didExitRegion region: CLRegion) &#123; showAlert(&quot;exit \(region.identifier)&quot;) // 3 monitoredRegions.removeValue(forKey: region.identifier)&#125;// 4func locationManager(_ manager: CLLocationManager, didUpdateLocations locations: [CLLocation]) &#123; updateRegions()&#125; 1 定义以字典用于存储用户进入监控区的时间。 2 记录进入时间。 3 删除进入时间。 4 用户位置变化后调用 加入函数updateRegions()代码：1234567891011121314151617181920func updateRegions() &#123; // 1 let regionMaxVisiting = 10.0 var regionsToDelete: [String] = [] // 2 for regionIdentifier in monitoredRegions.keys &#123; // 3 if NSDate().timeIntervalSince(monitoredRegions[regionIdentifier]! as Date) &gt; regionMaxVisiting &#123; showAlert(&quot;谢谢访问&quot;) regionsToDelete.append(regionIdentifier) &#125; &#125; // 4 for regionIdentifier in regionsToDelete &#123; monitoredRegions.removeValue(forKey: regionIdentifier) &#125;&#125; 1 加的用户到某个区域10s，就确定用户已经到访问过这个区域。regionsToDelete用来存储即将删除的区域的identifier，也就用户待过超过10s的区域。 2 遍历所有监控区域 3 timeIntervalSince用来计算某个时间到当前时间的差值，单位为秒。 4 删除用户待过超过regionMaxVisiting的区域。 代码GeoTargeting 参考 Building a Geo Targeting iOS App in Swift]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 3：Speech Framework的简单使用]]></title>
    <url>%2F2017%2Fios-tutorial-3-speechframework.html</url>
    <content type="text"><![CDATA[在WWDC 2016时，Apple介绍了Speech framework，这是一个很有用的声音识别框架。实际上这是利用Siri进行声音识别。 初始化项目 新建SpeechToTextDemo，模板是Single View Application。 添加简单的UI 分别定义UITextView和UIButton的两个outlet，为textView和microphoneButton。 再为UIButton添加一个action：123@IBAction func microphoneTapped(_ sender: AnyObject) &#123;&#125; 使用Speech Framework import Speech 实现SFSpeechRecognizerDelegate协议 用户授权获取声音数据是要获得用户的授权的。 在ViewController类中定义一个变量，作为语音识别器。参数identifier是识别的语种，可参考这个列表，中文是“ zh_Hans_CN”。private let speechRecognizer = SFSpeechRecognizer(locale: Locale.init(identifier: &quot;zh_Hans_CN&quot;)) 在viewDidLoad()中： 1234567891011121314151617181920212223242526272829override func viewDidLoad() &#123; super.viewDidLoad() // 1 microphoneButton.isEnabled = false speechRecognizer?.delegate = self // 2 SFSpeechRecognizer.requestAuthorization&#123; (authStatus) in var isButtionEnabled = false switch authStatus &#123; case .authorized: isButtionEnabled = true case .denied: isButtionEnabled = false print(&quot;用户拒绝接受语音识别&quot;) case .notDetermined: isButtionEnabled = false print(&quot;语音识别功能没有经过认可&quot;) case .restricted: isButtionEnabled = false print(&quot;当前设备不能语音识别&quot;) &#125; self.microphoneButton.isEnabled = isButtionEnabled &#125; startRecording()&#125; 1 默认按钮设成不可用 2 授权结果回调 Apple需要每个app如要用户授权时，都应该定制一个反馈信息（info.plist）。在info.plist中添加两个key，分别是麦克风和语音识别的授权，Privacy - Microphone Usage Description和Privacy - Speech Recognition Usage Description。 处理语音识别 在ViewController类中添加三个变量 123private var recognitionRequest: SFSpeechAudioBufferRecognitionRequest? //识别请求private var recognitionTask: SFSpeechRecognitionTask? // 提供识别请求的结果private let audioEngine = AVAudioEngine() // SFSpeechAudioBufferRecognitionRequest对象处理语音识别的请求，代表语音进入语音识别器。 SFSpeechRecognitionTask 识别任务，用于操作识别器的停止和开始 AVAudioEngine 语音引擎，提供语音输出 创建新函数startRecording()，这个函数在点击button后调用，也就是microphoneTapped(:)中最后调用 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162func startRecording() &#123; // 1 if recognitionTask != nil &#123; recognitionTask?.cancel() recognitionTask = nil &#125; // 2 let audioSession = AVAudioSession.sharedInstance() do &#123; try audioSession.setCategory(AVAudioSessionCategoryRecord) try audioSession.setMode(AVAudioSessionModeMeasurement) try audioSession.setActive(true, with: .notifyOthersOnDeactivation) &#125; catch &#123; print(&quot;audioSession的属性设置失败&quot;) &#125; // 3 recognitionRequest = SFSpeechAudioBufferRecognitionRequest() // 4 guard let inputNode = audioEngine.inputNode else &#123; fatalError(&quot;Audio engine has no input node&quot;) &#125; // 5 guard let recognitionRequest = recognitionRequest else &#123; fatalError(&quot;Unable to create an SFSpeechAudioBufferRecognitionRequest object&quot;) &#125; // 6 recognitionRequest.shouldReportPartialResults = true // 7 recognitionTask = speechRecognizer?.recognitionTask(with: recognitionRequest, resultHandler: &#123; (result, error) in var isFinal = false if result != nil &#123; self.textView.text = result?.bestTranscription.formattedString isFinal = (result?.isFinal)! &#125; if error != nil || isFinal &#123; self.audioEngine.stop() inputNode.removeTap(onBus: 0) self.recognitionRequest = nil self.recognitionTask = nil self.microphoneButton.isEnabled = true &#125; &#125;) let recordingFormat = inputNode.outputFormat(forBus: 0) inputNode.installTap(onBus: 0, bufferSize: 1024, format: recordingFormat) &#123; (buffer, when) in self.recognitionRequest?.append(buffer) &#125; audioEngine.prepare() do &#123; try audioEngine.start() &#125; catch &#123; print(&quot;audioEngine couldn&apos;t start beacause of an error.&quot;) &#125; textView.text = &quot;Say something, I&apos;m listening!&quot;&#125; 1 开始录音时的初始化 2 AVAudioSession提供语音录音，设置一些参数 3 初始化SFSpeechAudioBufferRecognitionRequest 4 核查audioEngine是否可用 5 核查recognitionRequest 7 检测的音频后的回调方法，也就是开始录音后，有音频进入后都调用 语音识别的开关 实现代理方法speechRecognizer(_:availabilityDidChange:)。这个方法在语音识别器可用性发生变化时被调用。 1234567func speechRecognizer(_ speechRecognizer: SFSpeechRecognizer, availabilityDidChange available: Bool) &#123; if available &#123; microphoneButton.isEnabled = true &#125; else &#123; microphoneButton.isEnabled = false &#125;&#125; 点击button时的操作： 1234567891011@IBAction func microphoneTapped(_ sender: AnyObject) &#123; if audioEngine.isRunning &#123; audioEngine.stop() recognitionRequest?.endAudio() microphoneButton.isEnabled = false microphoneButton.setTitle(&quot;Start Recording&quot;, for: .normal) &#125; else &#123; startRecording() microphoneButton.setTitle(&quot;Stop Recording&quot;, for: .normal) &#125; &#125; 总结语音识别在iPhone的自带键盘中有这个功能，中文识别率很高，如果不高兴或不方便打字，很方便使用。 代码SpeechToTextDemo 参考： Building a Speech-to-Text App Using Speech Framework in iOS 10]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[swift的文档注释]]></title>
    <url>%2F2017%2Fswift-document.html</url>
    <content type="text"><![CDATA[在Xcode中Quick Help 为开发者提供方便快捷的简洁文档查看方式。option+点击查看弹框，option+command+2在检查器中查看。swift的中有两种注释方式，让Xcode在Quick Help中显示。这种注释可以认为是将文档以某种规范的格式嵌入在实际代码的上方，这样就可以通过某些工具自动生成漂亮的文档文件。这种内嵌式的文档在现代编程中是很普遍的。在swift中，这两种注释方式是： /** */ /// 这些注释中还可以有其他一些规范 可以支持markdown 关键词 三个关键词：parameter， returns， throws。这三个关键词会在最左边显示。 还有一些关键词会被提取到description中作为一些特殊字段显示，其他都会在description正常显示：author, authors, copyright, date；since, version；attention, important, note, remark, warning；bug, TODO, experiment； complexity； precondition, postcondition, requires, invariant see* 参考http://swifter.tips/documentation/http://ericasadun.com/2015/06/14/swift-header-documentation-in-xcode-7/]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 2：用Core Image进行面部识别(Swift)]]></title>
    <url>%2F2017%2Fios-tutorial-2-facerecognition.html</url>
    <content type="text"><![CDATA[面部识别API不仅可以是识别面部，也可识别面部的特殊细节，例如微笑甚至眨眼睛。 建立初始项目原文建好了初始项目，我自己新建了初始项目 新建项目Detector 删除IB中原本View Controller Scene。 拖动UITabBarController到IB中，得到三个Scene。选择UITabBarController的Is Initial View Controller，使其作为初始控制器。 修改Item 1的title和其Bar Item都为Photo，修改其Class为ViewController。 向Assets中添加几张人物图片 想Photo Scene中添加一个Image View，Content Mode改为Aspect Fit，选择一个图片。在ViewController添加图片对应@IBOutlet：@IBOutlet var personPic: UIImageView! 选中Item 2，点击菜单栏EDitor &gt; Embed In &gt; Navigation Controller，新生成一个与之关联的Scene。 新建CameraViewController类，继承至UIViewController。修改上面生成的Scene的Class属性为CameraViewController。 拖动一个UIBarButtonItem到Camera View Controller Scene的UINavigationItem的右边，并选择System Item为Camera 在CameraViewController中建立outlet和Action 识别照片的面部 在 ViewController.swift中引入CoreImage:import CoreImage 在 ViewController.swift中添加函数detect(): 12345678910111213141516171819202122232425262728293031func detect() &#123; // 1 guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; // 2 let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // 3 for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) let faceBox = UIView(frame: face.bounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) // 4 if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 1 根据UIImage获取CoreImage中图片对象。guard与if功能类似，区别可查看以撸代码的形式学习Swift-5：Control Flow的6 guard 与 if。 2 初始化检测器CIDetector， accuray是检查器配置选项，表示精确度；因为CIDetector可以进行几种类型的检测，所以CIDetectorTypeFace用来表示面部检测；features方法返回具体的检测结果 3 给每个检测到的脸添加红色框 4 检测是否有左眼位置 在viewDidLoad中添加 detect()，运行结果类似： 打印结果，显示检测到的面部位置是不对的：Found bounds are (177.0, 416.0, 380.0, 380.0)这是因为UIKit的坐标系统与Core Image的坐标系统是不同的： 把Core Image的坐标系统转换为UIKit的坐标系统，修改detect()为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func detect() &#123; guard let personciImage = CIImage(image: personPic.image!) else &#123; return &#125; let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage) // let ciImageSize = personciImage.extent.size var transform = CGAffineTransform(scaleX: 1, y: -1) transform = transform.translatedBy(x: 0, y: -ciImageSize.height) for face in faces as! [CIFaceFeature] &#123; print(&quot;Found bounds are \(face.bounds)&quot;) // Apply the transform to convert the coordinates var faceViewBounds = face.bounds.applying(transform) // Calculate the actual position and size of the rectangle in the image view let viewSize = personPic.bounds.size let scale = min(viewSize.width / ciImageSize.width, viewSize.height / ciImageSize.height) let offsetX = (viewSize.width - ciImageSize.width * scale) / 2 let offsetY = (viewSize.height - ciImageSize.height * scale) / 2 faceViewBounds = faceViewBounds.applying(CGAffineTransform(scaleX: scale, y: scale)) faceViewBounds.origin.x += offsetX faceViewBounds.origin.y += offsetY let faceBox = UIView(frame: faceViewBounds) faceBox.layer.borderWidth = 3 faceBox.layer.borderColor = UIColor.red.cgColor faceBox.backgroundColor = UIColor.clear personPic.addSubview(faceBox) if face.hasLeftEyePosition &#123; print(&quot;Left eye bounds are \(face.leftEyePosition)&quot;) &#125; if face.hasRightEyePosition &#123; print(&quot;Right eye bounds are \(face.rightEyePosition)&quot;) &#125; &#125;&#125; 运行可看到正确识别位置： 相机拍照后的脸部识别之前是项目中照片识别，现在是拍完照再识别，原理是相同的，就是多一个拍完照，取照片的过程。 更新CameraViewController类的代码 1234567891011121314151617181920212223242526272829303132333435363738// 1class CameraViewController: UIViewController, UIImagePickerControllerDelegate, UINavigationControllerDelegate &#123; @IBOutlet var imageView: UIImageView! // 2 let imagePicker = UIImagePickerController() override func viewDidLoad() &#123; super.viewDidLoad() imagePicker.delegate = self &#125; @IBAction func takePhoto(_ sender: AnyObject) &#123; // 3 if !UIImagePickerController.isSourceTypeAvailable(.camera) &#123; return &#125; imagePicker.allowsEditing = false imagePicker.sourceType = .camera present(imagePicker, animated: true, completion: nil) &#125; // 4 //MARK: -UIImagePickerControllerDelegate func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [String : Any]) &#123; if let pickedImage = info[UIImagePickerControllerOriginalImage] as? UIImage &#123; imageView.contentMode = .scaleAspectFit imageView.image = pickedImage &#125; dismiss(animated: true, completion: nil) self.detect() &#125; // 5 func imagePickerControllerDidCancel(_ picker: UIImagePickerController) &#123; dismiss(animated: true, completion: nil) &#125;&#125; 1 实现UIImagePickerControllerDelegate协议，用于拍照相关代理。 2 初始化UIImagePickerController。UIImagePickerController是照相或摄影界面和功能管理的类。 3 判断设备照相机是否可用。 4 实现一个UIImagePickerControllerDelegate中的代理方法，当拍摄完备确实使用照片时调用。 5 也是UIImagePickerControllerDelegate中的代理方法，取消拍摄时调用。 添加detect()代码，与ViewController中不同的是，不用红色框框处识别出的面部，而是识别出面部的细节，并用UIAlertController弹出显示。 1234567891011121314151617181920212223242526272829303132333435363738394041func detect() &#123; let imageOptions = NSDictionary(object: NSNumber(value: 5) as NSNumber, forKey: CIDetectorImageOrientation as NSString) let personciImage = CIImage(cgImage: imageView.image!.cgImage!) let accuracy = [CIDetectorAccuracy: CIDetectorAccuracyHigh] let faceDetector = CIDetector(ofType: CIDetectorTypeFace, context: nil, options: accuracy) let faces = faceDetector?.features(in: personciImage, options: imageOptions as? [String : AnyObject]) if let face = faces?.first as? CIFaceFeature &#123; print(&quot;found bounds are \(face.bounds)&quot;) var message = &quot;有个脸&quot; if face.hasSmile &#123; print(&quot;脸是笑的&quot;) message += &quot;,脸是笑的&quot; &#125; if face.hasMouthPosition &#123; print(&quot;有嘴唇&quot;) message += &quot;,有嘴唇&quot; &#125; if face.hasLeftEyePosition &#123; print(&quot;左眼镜的位置是 \(face.leftEyePosition)&quot;) message += &quot;,左眼镜的位置是 \(face.leftEyePosition)&quot; &#125; if face.hasRightEyePosition &#123; print(&quot;右眼镜的位置是 \(face.rightEyePosition)&quot;) message += &quot;,右眼镜的位置是 \(face.rightEyePosition)&quot; &#125; let alert = UIAlertController(title: &quot;嘿嘿&quot;, message: message, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; else &#123; let alert = UIAlertController(title: &quot;没脸了&quot;, message: &quot;没有检测到脸&quot;, preferredStyle: .alert) alert.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler: nil)) self.present(alert, animated: true, completion: nil) &#125; &#125; 运行就可以识别照片的面部具体细节CIFaceFeature还提供了其他很多面部细节：1234567891011121314151617181920212223242526272829open var hasLeftEyePosition: Bool &#123; get &#125;open var leftEyePosition: CGPoint &#123; get &#125;open var hasRightEyePosition: Bool &#123; get &#125;open var rightEyePosition: CGPoint &#123; get &#125;open var hasMouthPosition: Bool &#123; get &#125;open var mouthPosition: CGPoint &#123; get &#125;open var hasTrackingID: Bool &#123; get &#125;open var trackingID: Int32 &#123; get &#125;open var hasTrackingFrameCount: Bool &#123; get &#125;open var trackingFrameCount: Int32 &#123; get &#125;open var hasFaceAngle: Bool &#123; get &#125;open var faceAngle: Float &#123; get &#125;open var hasSmile: Bool &#123; get &#125;open var leftEyeClosed: Bool &#123; get &#125;open var rightEyeClosed: Bool &#123; get &#125; 代码Detector 参考：Face Detection in iOS Using Core Image]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 9 Table Row的删除, UITableViewRowAction和UIActivityViewController的使用]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-9.html</url>
    <content type="text"><![CDATA[上一篇开始用Swift开发iOS 10 - 8 Table View和UIAlertController的交互是Table Row选择的操作，这一篇继续上一篇的代码实现删除操作。 滑动删除 实现UITableViewDataSource中相应方法：123override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; &#125; 此时滑动有删除按钮： 删除数据123456789override func tableView(_ tableView: UITableView, commit editingStyle: UITableViewCellEditingStyle, forRowAt indexPath: IndexPath) &#123; if editingStyle == .delete &#123; restaurantNames.remove(at: indexPath.row) restaurantLocations.remove(at: indexPath.row) restaurantTypes.remove(at: indexPath.row) restaurantIsVisited.remove(at: indexPath.row) restaurantImages.remove(at: indexPath.row) &#125;&#125; UITableViewCellEditingStyle有两种insert和delete。运行后发现删除动作后，相应的table view row被没有消失，因为上面的删除只是删除了相应数组中的数据，并没有在视图上显示，如要重新加载才会删除。 重新加载UITableView在tableView(_:commit:forRowAt:)后添加：tableView.reloadData()另外，更好的刷新table view的方法是使用UITableView的deleteRows(at:with:)方法，还有动画效果：tableView.deleteRows(at: [indexPath], with: .fade) 用UITableViewRowAction为滑动产生更多动作1234567891011121314151617181920212223override func tableView(_ tableView: UITableView, editActionsForRowAt indexPath: IndexPath) -&gt; [UITableViewRowAction]? &#123; // 1 let shareAction = UITableViewRowAction(style: .default, title: &quot;Share&quot;, handler: &#123; (action, indexPath) -&gt; Void in // 3 let defaultText = &quot;Just checking in at &quot; + self.restaurantNames[indexPath.row] let activityController = UIActivityViewController(activityItems: [defaultText], applicationActivities: nil) self.present(activityController, animated: true, completion: nil) &#125;) // 1 let deleteAction = UITableViewRowAction(style: .default, title: &quot;Delete&quot;, handler: &#123; (action, indexPath) -&gt; Void in self.restaurantNames.remove(at: indexPath.row) self.restaurantLocations.remove(at: indexPath.row) self.restaurantTypes.remove(at: indexPath.row) self.restaurantIsVisited.remove(at: indexPath.row) self.restaurantImages.remove(at: indexPath.row) &#125;) // 2 return [deleteAction, shareAction] &#125; 1 UITableViewRowAction的用法和UIAlertAction类似。style相同，具体功能是在回调闭包中实现的。 UIActivityViewController继承是UIViewController，提供一些服务，例如拷贝到剪贴板，分享内容到社交媒体，通过Messages发送项目等。 一旦实现了tableView(_:editActionsForRowAt:)方法，tableView(_:commit:forRowAt:)方法产生delete按钮将不再产生，所以要在tableView(_:commit:forRowAt:)中添加delete按钮。 2 返回的UITableViewRowAction的数组，action的显示顺序是，按照数组的顺序在屏幕从有到左显示。 3 defaultText是分享的内容，不仅可以是文本，也可以添加图片对象UIImage。此处代码修改一下：12345let defaultText = &quot;Just checking in at &quot; + self.restaurantNames[indexPath.row]if let imageToShare = UIImage(named: self.restaurantImages[indexPath.row]) &#123; let activityController = UIActivityViewController(activityItems: [defaultText, imageToShare], applicationActivities: nil) self.present(activityController, animated: true, completion: nil)&#125; 定制UITableViewRowAction可以修改背景颜色：1234shareAction.backgroundColor = UIColor(red: 48.0/255.0, green: 173.0/255.0, blue: 99.0/255.0, alpha: 1.0) deleteAction.backgroundColor = UIColor(red: 202.0/255.0, green: 202.0/255.0, blue: 203.0/255.0, alpha: 1.0) 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 8 Table View和UIAlertController的交互]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-8.html</url>
    <content type="text"><![CDATA[继续上一部分开始用Swift开发iOS 10 - 7 定制Table Views项目FoodPin的代码，添加两个功能： 点击cell时，产生弹框，弹框中有两个功能选项 Call 和 Check-in 当点击Check-in选项时，为cell加上对号 理解UITableViewDelegate协议代理模式在iOS编程中非常常见的。每个代理负责特定的角色或任务，维持系统的简单和干净。当一个对象需要完成特定任务时，可以依靠另一个对象完成。这在软件设计模式中通常叫做“separation of concerns”。UITableViewController就应用了代理模式。两个协议完成不同的任务。UITableViewDataSource协议负责提供和管理table的数据。UITableViewDelegate协议负责设置table的section headings 和 footers，以及操作cell selections和cell recording。 阅读文档 怎么知道UITableViewDelegate中有那些方法呢？ 阅读Apple的官方iOS开发文档(https://developer.apple.com/library/ios/))。作为iOS开发者，需要经常阅读API 文档。目前没有单个的书籍可覆盖所有iOS SDK。 Xcode中提供方便的查看文档的方法，在相关代码处option+点击，出现弹框展示文档简介，再在弹框上点击相关代码就直接进入详细文档处。文档对不同方法进行了分类，比如UITableViewDelegate的文档就有上面提到的Managing Selections：12func tableView(UITableView, willSelectRowAt: IndexPath)func tableView(UITableView, didSelectRowAt: IndexPath) 实现协议中管理列选项方法 在RestaurantTableViewController类中实现tableView(_:didSelectRowAt:)方法： 123456789101112override func tableView(_ tableView: UITableView, didSelectRowAt indexPath:IndexPath) &#123; // 1 let optionMenu = UIAlertController(title: nil, message: &quot;What do you wantto do?&quot;, preferredStyle: .actionSheet) // 2 let cancelAction = UIAlertAction(title: &quot;Cancel&quot;, style: .cancel, handler:nil) optionMenu.addAction(cancelAction) // 3 present(optionMenu, animated: true, completion: nil)&#125; 1 创建了UIAlertController。UIAlertController是从iOS8被引入，用来替代以前的UIAlertView和UIActionSheet，向用户弹出警示信息；preferredStyle参数有两个值：.actionSheet 和 .alert，表示替代的两种样式。 2 创建一个cancel样式的UIAlertAction。UIAlertController的警示弹出框一般是由最上面的title+message（都不是非必须的）和一些Action组成，cancel action在最下面。 3 present是UIViewController中的方法，用于展示。 添加Actions到ALert Controller中 Call action1234567891011let callActionHandler = &#123; (action:UIAlertAction!) -&gt; Void in let alertMessage = UIAlertController(title: &quot;Service Unavailable&quot;, message:&quot;Sorry, the call feature is not available yet. Please retry later.&quot;,preferredStyle: .alert) alertMessage.addAction(UIAlertAction(title: &quot;OK&quot;, style: .default, handler:nil)) self.present(alertMessage, animated: true, completion: nil)&#125;let callAction = UIAlertAction(title: &quot;Call &quot; + &quot;123-000-\(indexPath.row)&quot;,style: .default, handler: callActionHandler)optionMenu.addAction(callAction) callActionHandler是swift闭包结构的一种写法，关于闭包可查看以撸代码的形式学习Swift-7：Closure。这个代码块在Call action被点击是执行。 Check-in action12345678// Check-in actionlet checkInAction = UIAlertAction(title: &quot;Check in&quot;, style: .default, handler:&#123; (action:UIAlertAction!) -&gt; Void in let cell = tableView.cellForRow(at: indexPath) cell?.accessoryType = .checkmark&#125;)optionMenu.addAction(checkInAction) 当用户点击“Check in”action时，为选中的cell增加一个对号，表明是用户喜欢的。accessoryType包括disclosureIndicator, detailDisclosureButton, checkmark 和 detailButton。当cell被选中后，这个cell会一直灰色高亮。去掉：tableView.deselectRow(at: indexPath, animated: false) 解决Bug现在应用运行后，check-in某一cell时，可能会出现其他cell同时也被check-in。这个问题是因为cell重复使用导致的。当一个屏幕滚动时，新进的cell就会利用滚出的得cell，以提高效率。解决方法：为每个cell创造一个是否被check-in的标志。 在RestaurantTableViewController中创建一个Boolean类型的数组：var restaurantIsVisited = Array(repeating: false, count: 21) check-in后就把对应的标志修改为true： 1234567let checkInAction = UIAlertAction(title: &quot;Check in&quot;, style: .default, handler:&#123; (action:UIAlertAction!) -&gt; Void in let cell = tableView.cellForRow(at: indexPath) cell?.accessoryType = .checkmark self.restaurantIsVisited[indexPath.row] = true&#125; 在每一次生成cell是也要检查是否check-in，在tableView(_:cellForRowAt:)放的return cell之前加入：cell.accessoryType = restaurantIsVisited[indexPath.row] ? .checkmark : .none 练习当选中也被check-in的cell时，check-in Action的文本变成Undo Check in，点击后取消其对号。修一下check-in代码：123456789101112131415161718let cell = tableView.cellForRow(at: indexPath)if cell?.accessoryType == .checkmark &#123; let checkInAction = UIAlertAction(title: &quot;Undo Check in&quot;, style: .default, handler: &#123; (action:UIAlertAction!) -&gt; Void in cell?.accessoryType = .none self.restaurantIsVisited[indexPath.row] = false &#125;) optionMenu.addAction(checkInAction)&#125; else &#123; let checkInAction = UIAlertAction(title: &quot;Check in&quot;, style: .default, handler: &#123; (action:UIAlertAction!) -&gt; Void in cell?.accessoryType = .checkmark self.restaurantIsVisited[indexPath.row] = true &#125;) optionMenu.addAction(checkInAction)&#125; 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 7 定制Table Views]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-7.html</url>
    <content type="text"><![CDATA[开始用Swift开发iOS 10 - 6 创建简单的Table Based App是basic风格的Table，这一部分将： 使用UITableViewController 代替 UITableView 展示table view cell中不同的图片显示方式 设计定制的table view cell来替代basic的table view cell 使用UITableViewController新建一个Table View App 新建项目FoodPin，模板为”Single View application” 删除Main.storyboard中的 view controller，删除ViewController.swift 拖动一个Table View Controller到IB中，选中其Is Initial View Controller 新建类RestaurantTableViewController，继承至UITableViewController。将Table View Controller的Class属性设置为RestaurantTableViewController。 在simpletable-image1.zip和simpletable-image2.zip处下载图片，拖到asset catalog 在类RestaurantTableViewController中添加以变量 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats&quot;,&quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;, &quot;Barrafina&quot;,&quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 在类RestaurantTableViewController中添加代码： 123456789override func tableView(_ tableView: UITableView, cellForRowAt indexPath:IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier,for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;)return cell &#125; 插入代码 123456789101112131415161718 override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // Configure the cell... cell.textLabel?.text = restaurantNames[indexPath.row] cell.imageView?.image = UIImage(named: &quot;restaurant.jpg&quot;) return cell &#125; override func numberOfSections(in tableView: UITableView) -&gt; Int &#123; return 1 &#125; override func tableView(_ tableView: UITableView, numberOfRowsInSectionsection: Int) -&gt; Int &#123; return restaurantNames.count &#125; 在类RestaurantTableViewController中加入图片名称变量： 123456var restaurantImages = [&quot;cafedeadend.jpg&quot;, &quot;homei.jpg&quot;, &quot;teakha.jpg&quot;,&quot;cafeloisl.jpg&quot;, &quot;petiteoyster.jpg&quot;, &quot;forkeerestaurant.jpg&quot;, &quot;posatelier.jpg&quot;,&quot;bourkestreetbakery.jpg&quot;, &quot;haighschocolate.jpg&quot;, &quot;palominoespresso.jpg&quot;,&quot;upstate.jpg&quot;, &quot;traif.jpg&quot;, &quot;grahamavenuemeats.jpg&quot;, &quot;wafflewolf.jpg&quot;,&quot;fiveleaves.jpg&quot;, &quot;cafelore.jpg&quot;, &quot;confessional.jpg&quot;, &quot;barrafina.jpg&quot;,&quot;donostia.jpg&quot;, &quot;royaloak.jpg&quot;, &quot;caskpubkitchen.jpg&quot;] 并修改对应代码：cell.imageView?.image = UIImage(named: restaurantImages[indexPath.row]) 定制Table View Cells 修改Table View Cell的Sytle变为Custom，Identifier为Cell 修改Table View 的Row Height为80 确认Table View Cell 的Custom被选择和Row Height为80 拖动image view到Cell中 拖动三个label到Cell中，文本分别是Name，Location，Type。Name 的font为Headline；Location的font style为Light，font size为14，font color为Dark Gray；Type**font style为Light，font size**为13。 把三个label设置成一个vertical stack view，其spacing为1 把vertical stack view和Image View设置成一个horizontal stack view，其spacing为10 为vertical stack view设置上下左右边距约束；为图片设置宽和高的约束 处理约束问题 为Custom Cell创建类 创建继承至UITableViewCell的类RestaurantTableViewCell 在RestaurantTableViewCell中建立四个outlet，分别对应图片和三个label 1234@IBOutlet var nameLabel: UILabel!@IBOutlet var locationLabel: UILabel!@IBOutlet var typeLabel: UILabel!@IBOutlet var thumbnailImageView: UIImageView! 建立代码中接口与storyboard之间的联系 修改Table View Controller代码 由于已经为Custom Cell创建了类RestaurantTableViewCell，所以Table View Controller中生成Cell的待修改为： 12let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) as! RestaurantTableViewCell 由于Cell的风格不是sytle了，而是定制的，所以文本和图片代码要做出修改： 12cell.nameLabel.text = restaurantNames[indexPath.row]cell.thumbnailImageView.image = UIImage(named: restaurantImages[indexPath.row]) 图片圆角 可通过UIView的layer属性（CALayer）修改图片圆脚，cornerRadius表示圆角的半径，由于图片的尺寸是60*60，所以圆角的半径设置为30后，图片看上去是个圆。12cell.thumbnailImageView.layer.cornerRadius = 30.0cell.thumbnailImageView.clipsToBounds = true 练习 添加“Type”和“Location”。添加如下两个数组变量：1234var restaurantLocations = [&quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Hong Kong&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;Sydney&quot;, &quot;NewYork&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;New York&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;, &quot;London&quot;] var restaurantTypes = [&quot;Coffee &amp; Tea Shop&quot;, &quot;Cafe&quot;, &quot;Tea House&quot;, &quot;Austrian Causual Drink&quot;, &quot;French&quot;, &quot;Bakery&quot;, &quot;Bakery&quot;, &quot;Chocolate&quot;, &quot;Cafe&quot;, &quot;American Seafood&quot;, &quot;American&quot;, &quot;American&quot;, &quot;Breakfast &amp; Brunch&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Coffee &amp; Tea&quot;, &quot;Latin American&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;Spanish&quot;, &quot;British&quot;, &quot;Thai&quot;] 然后再在Cell时赋值即可：12cell.locationLabel.text = restaurantLocations[indexPath.row] cell.typeLabel.text = restaurantTypes[indexPath.row] 重新设计界面： 修改Table View和Table View Cell的Row Height都为300。 重新设计图片与label的之间的层次结构，并修改图片的大小和其他一些约束。 删除图片圆角 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Xcode中Scene里的名称]]></title>
    <url>%2F2017%2Fxcode-scene-name.html</url>
    <content type="text"><![CDATA[默认的Scene名称 Xcode中新建一个控制器对象后会产生一个Scene，而Scene的名称就与其关联的控制器名称相关，比如默认的View Controller的对象的Scene的名称就是View Controller Scene。 如果把控制器改成SFSafariViewController，那么Scene的名字就会变成Safari View Scene。 如果把控制器改成自建的，Scene名字也会随着变化，比如ASAndyViewController对应的Scene名字是 Andy View Scene 总的来说，apple在程序中代码命名规范，一般是前面连续大写的是框架名称，然后后面使用驼峰命名法。要显示时就把框架前缀去掉，然后根据驼峰命名规则分隔显示。 自定义Scene的名称Scene的名称也是可以自定义的，在其属性检查器中，修改title即可，当然这种修改只是停留在IB中，为了开发时便于查看，不影响代码中的名称。]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS tutorial 1： 识别二维码（swift3）]]></title>
    <url>%2F2017%2Fios-tutorial-1-arcode.html</url>
    <content type="text"><![CDATA[这是一篇使用AVFoundation框架识别二维码的文章，原文提供了初始化项目QRCodeReaderStarter，我重新建立项目，图片是从原文提供的初始化项目中copy的。 初始化项目 新建一个名为QRCodeReader的单页项目 删除ViewController.swift文件，在项目目录处右击新建文件，新建一个QRCodeViewController类继承自UIViewController。 点击Main.storyboard，选中View Controller，修改其属性Class为QRCodeViewController，使两者关联。 向Main.storyboard中拖动一个View Controller对象，以1的方法新建一个继承自UIViewController的类QRScannerController，然后与Main.storyboard中新建的View Controller关联。 下载图片。从原文的初始化项目QRCodeReaderStarter复制。 修改Code View Controller Scene的view背景颜色做修改；添加一个label，名称改为Quick Scan，字体，和字体大小也做修改；添加button，删除文本，大小为150150，Type为System，image为focus*，Tint为黄色；添加一些约束。 Scanner Controller Scene： 在顶部添加一个View，在这个View中添加以label和button，button的image为cross；在顶部添加一个label；添加一些约束。 构建 segue 用control-drag从Code View Controller Scene中的button到Scanner Controller Scene，选择Present Modally 在QRCodeViewController中添加代码： 1234@IBAction func unwindToHomeScreen(segue: UIStoryboardSegue) &#123; //去除模态视图 dismiss(animated: true, completion: nil) &#125; 在Scanner Controller Scene 中，用control-drag从button到Exit，选择unwindToHomeScreenWithSegue: 6和7中样式和约束，合适即可。 加载 AVFoundation 框架 在QRScannerController.swift文件中引入AVFoundation Framework：import AVFoundation QRScannerController实现AVCaptureMetadataOutputObjectsDelegate协议：class QRScannerController: UIViewController, AVCaptureMetadataOutputObjectsDelegate {表示当捕获的元数据产生时，需要一些回调方法。 QRScannerController中添加三个变量：123var captureSession: AVCaptureSession?var videoPreviewLayer: AVCaptureVideoPreviewLayer?var qrCodeFrameView: UIView? 实现视频捕获 在QRScannerController的viewDidLoad中添加代码： 123456789101112131415161718192021222324252627// 1let captureDevice = AVCaptureDevice.defaultDevice(withMediaType: AVMediaTypeVideo)do &#123; // 2 let input = try AVCaptureDeviceInput(device: captureDevice) // 3 captureSession = AVCaptureSession() // 4 captureSession?.addInput(input) // 5 let captureMetadataOutput = AVCaptureMetadataOutput() captureSession?.addOutput(captureMetadataOutput) // 6 captureMetadataOutput.setMetadataObjectsDelegate(self, queue: DispatchQueue.main) captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode] videoPreviewLayer = AVCaptureVideoPreviewLayer(session: captureSession) videoPreviewLayer?.videoGravity = AVLayerVideoGravityResizeAspectFill videoPreviewLayer?.frame = view.layer.bounds view.layer.addSublayer(videoPreviewLayer!) captureSession?.startRunning()&#125; catch &#123; print(error) return&#125; 1 初始化AVCaptureDevice，它表示物理捕获设备；AVMediaTypeVideo是Media types，表示视频类型，还有AVMediaTypeAudio，AVMediaTypeText等其他类型 2 根据AVCaptureDevice初始化捕获设备的输入数据对象AVCaptureDeviceInput。这边的try是swift中错误处理的标识，对应public init(device: AVCaptureDevice!) throws。 3 AVCaptureSession 用于协调输入与输出之间的数据流。 4 为AVCaptureSession 添加输入数据 5 定义输出数据对象AVCaptureMetaDataOutput，并把它添加给AVCaptureSession 6 设置self为输出数据对象的代理，这就对应了QRScannerController类实现AVCaptureMetadataOutputObjectsDelegate协议。metadataObjectTypes是识别的元数据类型，AVMetadataObjectTypeQRCode表示二维码类型。 在Info.plist中添加key为NSCameraUsageDescription或”Privacy – Camera Usage Description”，值为 为了扫描二维码，需要使用你的相机。 运行应用时，点击scan button后，使用了相机，但messageLabel和tapbar没有了，因为被AVCaptureVideoPreviewLayer覆盖了，加入两行代码就可以显示了：12view.bringSubview(toFront: messageLabel)view.bringSubview(toFront: topbar) 实现二维码读取当检测到二维码时，用绿色框高亮；然后二维码被解码成文本信息展示在messagelabel中。 初始化绿色框。继续在上述代码后添加:12345678qrCodeFrameView = UIView() if let qrCodeFrameView = qrCodeFrameView &#123; qrCodeFrameView.layer.borderColor = UIColor.green.cgColor qrCodeFrameView.layer.borderWidth = 2 view.addSubview(qrCodeFrameView) view.bringSubview(toFront: qrCodeFrameView)&#125; 由于qrCodeFrameView没有设置大小，默认是0，所以不会显示，当之后发现二维码时再让它显示。 解码二维码当AVCaptureMetadataOutput识别出二维码时，AVCaptureMetadataOutputObjectsDelegate中的代理方法将被调用：optional public func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) 回调方法定义： func captureOutput(_ captureOutput: AVCaptureOutput!, didOutputMetadataObjects metadataObjects: [Any]!, from connection: AVCaptureConnection!) { if metadataObjects == nil || metadataObjects.count == 0 { qrCodeFrameView?.frame = CGRect.zero messageLabel.text = &quot;没有二维码/条形码&quot; return } let metadataObj = metadataObjects[0] as! AVMetadataMachineReadableCodeObject if metadataObj.type == AVMetadataObjectTypeQRCode { // 1 let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil { // 2 messageLabel.text = metadataObj.stringValue } } } 第二个参数metadataObjects是个数组，就是所有被识别出来的元数据对象。如果这个参数为nil或数组为空数组，就表示没有识别出对象。 1 通过transformedMetadataObject方法获得AVMetadataObject对象，更加这个对象可以获得二维码的位置，然后显示绿框。 2 把二维码信息显示在messagelabel上。 识别条形码除了识别二维码以外，还可以识别条形码。只要在captureMetadataOutput.metadataObjectTypes = [AVMetadataObjectTypeQRCode]添加更多的元数据类型。，然后回调方法中修改检测类型就可以。 123456789101112131415161718192021222324let supportedCodeTypes = [AVMetadataObjectTypeUPCECode, AVMetadataObjectTypeCode39Code, AVMetadataObjectTypeCode39Mod43Code, AVMetadataObjectTypeCode93Code, AVMetadataObjectTypeCode128Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeAztecCode, AVMetadataObjectTypePDF417Code, AVMetadataObjectTypeQRCode ]captureMetadataOutput.metadataObjectTypes = supportedCodeTypes// ....if supportedCodeTypes.contains(metadataObj.type) &#123; let barCodeObject = videoPreviewLayer?.transformedMetadataObject(for: metadataObj) qrCodeFrameView?.frame = barCodeObject!.bounds if metadataObj.stringValue != nil &#123; messageLabel.text = metadataObj.stringValue &#125;&#125; 代码QRCodeReader]]></content>
      <categories>
        <category>iOS</category>
        <category>iOS tutorial</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS应用程序的状态]]></title>
    <url>%2F2017%2Fios-application-status.html</url>
    <content type="text"><![CDATA[iOS应用程序一共有五种状态： Not Running 程序还没运行 Inactive 程序运行在foreground但没有接收事件 Active 程序运行在foreground接收事件 Background 程序运行在background正在执行代码 Suspended 程序运行在background没有执行代码 iOS应用程序状态变化会回调APPDelegate中的方法，但不是每一种状态变化都会有对应的方法(上图的红框的两个变化就没有对应的方法) application:didFinishLaunchingWithOptions: Not Running -&gt; Inactive applicationDidBecomeActive: Inactive -&gt; Active applicationWillResignActive: Active -&gt; Inactive applicationDidEnterBackground: Background -&gt; Suspended applicationWillEnterForeground: Background -&gt; Inactive applicationWillTerminate: Suspended -&gt; Not Running 常见的应用状态变化场景 程序第一次启动（或者被杀掉以后启动）： Not Running -&gt; Inactive -&gt; Active 点击Home键（没有在Inof.plist中设置Application does not run in background）： Active -&gt; Inactive -&gt; Background -&gt; Suspended 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 挂起重新运行 Suspended -&gt; Background -&gt; Inactive -&gt; Active 内存清除（杀掉应用或删除应用） Suspended -&gt; Not Running 应用之间的切换 Active -&gt; Inactive Inactive -&gt; Active 点击Home键（在Inof.plist中设置Application does not run in background为YES，应用不能运行在后台，进入后台后会立即进入Not Running）： Active -&gt; Inactive -&gt; Background -&gt; Suspended -&gt; Not Running 可通过在APPDelegate的回调方法中打印数据，来查看应用状态变化 123456789101112131415161718192021222324252627282930func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey: Any]?) -&gt; Bool &#123; print(&quot;`application:didFinishLaunchingWithOptions:` Not Running -&gt; Inactive&quot;) return true&#125;func applicationWillResignActive(_ application: UIApplication) &#123; print(&quot;`applicationWillResignActive:` Active -&gt; Inactive&quot;)&#125;func applicationDidEnterBackground(_ application: UIApplication) &#123; print(&quot;`applicationDidEnterBackground:` Background -&gt; Suspended&quot;)&#125;func applicationWillEnterForeground(_ application: UIApplication) &#123; print(&quot;`applicationWillEnterForeground:` Background -&gt; Inactive&quot;)&#125;func applicationDidBecomeActive(_ application: UIApplication) &#123; print(&quot;`applicationDidBecomeActive:` Inactive -&gt; Active&quot;)&#125;func applicationWillTerminate(_ application: UIApplication) &#123; print(&quot;`applicationWillTerminate:` Suspended -&gt; Not Running&quot;)&#125;]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 6 创建简单的Table Based App]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-6.html</url>
    <content type="text"><![CDATA[table view应该是iOS应用中最常用的UI element。最好的例子就是iPhone自带的一些应用，如电话，邮件，设置等。TED，Google+，Airbnb，微信等等都是很好例子。 创建一个项目 项目名称为SimpleTable，模板为”Single View application” 设计UI 选中Main.storyboard，从Object library中拖动Table View进入视图 改变Table View的大小至整个view，修改属性Prototype Cells为1 选中Table View Cell，修改Style为Basic，Identifier为Cell。table view cell的标准类型有 basic、right detail、left detail 和 subtitle，当然还有定制类型custom。 选中Table View，设置四个spacing约束，上下左右的距离都设置为0 为UITableView添加两个协议 Object library中的每一UI component都是对应一个class，如 Table View就是对应UITableView。可以通过点击并悬停在UI component上查看对应的class和介绍。 在ViewController.swift文件的UIViewController后，添加代码, UITableViewDataSource, UITableViewDelegate，表示ViewController类实现了UITableViewDataSource，UITableViewDelegate两个协议。出现红色感叹号，这是xcode的问题提示，点击参看问题描述： Type ‘ViewController’ does not conform to protocol‘UITableViewDataSource’ 问题描述为ViewController不符合协议UITableViewDataSource。通过command+点击 （最新的xcode9变成了command+option+点击）到UITableViewDataSource中看看你：1234567891011121314151617181920212223242526272829303132public protocol UITableViewDataSource : NSObjectProtocol &#123; @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int // Row display. Implementers should *always* try to reuse cells by setting each cell&apos;s reuseIdentifier and querying for available reusable cells with dequeueReusableCellWithIdentifier: // Cell gets various attributes set automatically based on table (separators) and data source (accessory views, editing controls) @available(iOS 2.0, *) public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell @available(iOS 2.0, *) optional public func numberOfSections(in tableView: UITableView) -&gt; Int // Default is 1 if not implemented @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -&gt; String? // fixed font style. use custom view (UILabel) if you want something different @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, titleForFooterInSection section: Int) -&gt; String? // Editing // Individual rows can opt out of having the -editing property set for them. If not implemented, all rows are assumed to be editable. @available(iOS 2.0, *) optional public func tableView(_ tableView: UITableView, canEditRowAt indexPath: IndexPath) -&gt; Bool ... UITableViewDataSource协议中定义了很多方法，除了前两个方法没有optional其它都有，有的表示这个方法不一定要实现，没有的就一定要实现，把这个两个方法实现了，问题提示就会消失。这两个方法从名字和返回值类型也大概能知道做了什么： public func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int 一个section有几行，也就是一个section有几个UITableViewCell， section就是一组UITableViewCell的意思，Table View可以定义多个section，默认是一个。 public func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell 返回每一行的 UITableViewCell 在ViewController.swift中定义一个变量restaurantNames，类型是数组，表示一系列餐馆的名字。 1var restaurantNames = [&quot;Cafe Deadend&quot;, &quot;Homei&quot;, &quot;Teakha&quot;, &quot;Cafe Loisl&quot;, &quot;PetiteOyster&quot;, &quot;For Kee Restaurant&quot;, &quot;Po&apos;s Atelier&quot;, &quot;Bourke Street Bakery&quot;, &quot;Haigh&apos;sChocolate&quot;, &quot;Palomino Espresso&quot;, &quot;Upstate&quot;, &quot;Traif&quot;, &quot;Graham Avenue Meats AndDeli&quot;, &quot;Waffle &amp; Wolf&quot;, &quot;Five Leaves&quot;, &quot;Cafe Lore&quot;, &quot;Confessional&quot;,&quot;Barrafina&quot;, &quot;Donostia&quot;, &quot;Royal Oak&quot;, &quot;CASK Pub and Kitchen&quot;] 定义UITableViewDataSource的两个方法： 12345678910111213141516func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -&gt; Int &#123; // 1 return restaurantNames.count &#125; func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; // 2 let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // 3 cell.textLabel?.text = restaurantNames[indexPath.row] return cell &#125; 1 餐馆的数目就是section的行数 2 “Cell”与之前定义的UITableViewCell的Identifier属性是对应的。dequeueReusableCell方法是产生一个UITableViewCell。 3 UITableViewCell中有可算属性textLabel，其实就是一个UILabel，由于是可选属性，调用时也用可选链式调用cell.textLabel?.text 连接 DataSource 和 Delegate运行app，没有数据显示。尽管上面已经在代码中让ViewController继承了UITableViewDataSource, UITableViewDelegate，但storyboard并不知道。 在document outline中选择Table View，使用control-drag到View Controller，在弹出框中选择dataSource。同样的方法选择delegate 确认连接是否成功。选中Table View，在connetion检查器中查看；或者直接在document outline中右击Table View 运行app 添加图片到Table View 从simpletable-image1.zip下载图片，解压后一起拖到asset catalog 在ViewController.swift的tableView(_:cellForRowAtIndexPath:)方法的return cell前添加代码cell.imageView?.image = UIImage(named: &quot;restaurant&quot;)。使每个UITableViewCell的image都是一样的。 隐藏状态栏顶部状态来和table view 数据重叠了，只要在ViewController加一段代码就可以：123override var prefersStatusBarHidden: Bool &#123; return true&#125; prefersStatusBarHidden是父类UIViewController中的属性，所以要加 override，表示重写了。 不同的Cell对应不同的图片 从simpletable-image2.zip下载图片，解压后一起拖到asset catalog 修改ViewController.swift的tableView(_:cellForRowAtIndexPath:)为： 12345678910111213141516171819func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -&gt; UITableViewCell &#123; let cellIdentifier = &quot;Cell&quot; let cell = tableView.dequeueReusableCell(withIdentifier: cellIdentifier, for: indexPath) // Configure the cell... let restaurantName = restaurantNames[indexPath.row] cell.textLabel?.text = restaurantName // 1 let imageName = restaurantName.lowercased().replacingOccurrences(of: &quot; &quot;, with: &quot;&quot;) if let image = UIImage(named: imageName) &#123; cell.imageView?.image = image &#125; else &#123; cell.imageView?.image = UIImage(named: &quot;restaurant&quot;) &#125; return cell &#125; 1 把菜馆名字字符串先修改成小写，然后去空格 最终结果 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 4 用Stack View设计UI]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-4.html</url>
    <content type="text"><![CDATA[前一篇开始用Swift开发iOS 10 - 3 介绍Auto Layout中提到Auto Layout工具栏有个stack按钮，这是Stack View功能。为了解决复杂UI时布局约束定义困难，Apple从iOS 9开始引入Stack View。这篇文章将学习到： 用Stack View布局UI。 用image views展示图片。 用内建的asset catalog管理图片。 用Size Classes适配Stack View Stack View是什么Stack View为在纵向或横向布置一个视图的集合，提供了一个流线型界面。可以用stack view将很多UI对象合成一个。视图嵌入一个stack view里以后,就不再需要定义自动布局约束. Stack View管理它子视图的布局,然后自动提供布局约束。这意味着子视图已经准备好去适应不同的屏幕尺寸。此外，也可以嵌入一个stack view到另一个stack view来构建更复杂的用户界面。但是，这并不意味着不需要处理自动布局。仍然需要定义stack view的布局。这样不仅能够节约在创作每个UI元素的约束的时间，也可以轻松的从布局里来添加/移除视图。 Xcode提供两种方法使用Stack View： 直接从Object library中拖出stack view（纵向或横向），然后把其他视图拖动stack view 选中一些视图，然后点击Interface Builder editor右下角一组按钮中的stack按钮 一个小程序 新建项目 StackViewDemo 向Xcode中添加图片 从图片下载所需图片，加压后有3组9张图片，每组有3张不同类型的图片，针对不同类型的设备： user1.png （ non-Retina的一些老设备） user1@2x.png （iPhone 4/4s/5/5s/6） user1@3x.png （iPhone 6 Plus等高分辨的） 拖动图片竟然xcode的asset catalog中，xcode会自动组织这些有规律的图片，使用时直接用user1,不需要靠后面的@2或@3。 用Stack View布局title的label 选择Main.storyboard，从Object library中拖出Vertical Stack View到storyboard中 拖出一个label到stack view中。一旦label进入stack view中，它就自动调整大小以适应label 修改label的title为“Instant Developer”，字体大小为40 points，font style为medium，字体颜色为红色 另外拖出一个label到stack view中，修改label的title为“Get help from experts in 15 minutes” 选择stack view，在属性检查器中修改Alignment参数为center，这样使stack view中的label水平居中对齐。 多个视图在一起不方便选择时，可以用 shift + 右击：stack view的几个属性： axis stack view中对象是水平放置还是垂直放置，也就是Vertical Stack View和Horizontal Stack View之间的切换 alignment stack view中对象的对齐方式 distribution 用Stack按钮布局多个图片 拖动一个image view对象，并修改其image属性为user1 同样的方法再添加两个image view对象，image属性分别为user2，user3。粗略调整图片的带下，放在一个水平，大概如下： 选中三个image view，击Interface Builder editor右下角一组按钮中的stack按钮，则生成一个新的horizontal stack view。 修改新生成的horizontal stack view的属性，spacing为 10，表示图片之间的间距，Distribution为Fill Equally 同时选中两个stack view，点击stack 按钮，再生成一个新的大vertical stack view 为stack view添加布局约束 选中大的stack view，添加space constraints，上，左右，分别为70，0，0添加约束后，如果出现布局问题，可通过issue indicator解决，可参考上一篇文章。 看预览assistant editor，查看其它设备会发现两个问题： Instant Developer label文本在小屏幕设备被截断 图片的宽高比改变了 选择Instant Developer label，修改Autoshrink属性为Minimum Font Size，值为20，这样就设置了label的字体可以变化，最小值为20 ，小屏幕就不会被截断了。 横向control-drag图片的stack view，选择Aspect Ratio，使图片的宽高比不变化。 在图片stack view下添加一个label 拖动一个label到图片下，看到一个蓝色线后松开 改变label的文本：Need help with your coding problems? We’ll find you the right developer who can help you in 15 minutes. label的属性lines改为0，表示不限制行数 选择大stack view，修改间距sapcing为10，修改Alignment为居中 用stack view布局Buttons 添加两个Button：”Sign in” 和 “Sign up with Facebook” 修改白字体，红背景，宽度为200 选择两个Button生成vertical stack view，spacing为10 为vertical stack view添加两个约束，水平居中和底边距20 当把两个button聚合成stack view时，button的大小会自动调节到适宜大小，也就是”Sign up with Facebook”的宽度变为155 。需要再添加一个宽度约束，修改Constant值为200 。 用Size Classes来调节Stack view landscape orientation vs portrait orientation直译就是风景画方向和肖像画方向，其实就是指横屏和竖屏 上面设计的UI看上去以不错了，但一直没有考虑的横屏的情况。因为横屏上下高度变小，原本在竖屏下适宜的stack view上边距，就有点大了，需要小一点。这也导致了，从iOS 8开始引入了一个新的UI设计概念Adaptive Layout（自适应布局），为此，Apple引入了Size Classes。通过Size Classes 和 auto layout一起设计自适应UI。Size Classes仅仅是对屏幕进行了分类, 实际上的布局还是交给autolayout Size Classes有两种类型：regular 和 compact（可以理解为大[R] 和 小[C]）。而这两种类型应用在两个方向上：vertical (height) 和 horizontal (width) ，就对应不同类型的设备：Regular width-Regular Height, Regular width-Compact Height, Compact width-Regular Height and Compact width-Compact Height 最新版本的Xcode已经为我们提供了不同设备和方向的Size Classes查看： 选择上边距约束。在属性检查器中，点击Constant前面的+号，弹框中分别选择：Width：Any，Height：Compact，Gamunt：Any，后面的值为0，表示只有在Compact height下上边距为0 为了更加简洁也可以在有些屏幕状态下把”Need help with your …” label隐藏掉，就是height为0。也就是为label添加一个只有在Width：Any，Height：Compact，Gamunt：Any这个Size Classes下，的height约束。用control-drag方法添加height约束： 选择现价的height约束，修改Constant为0；去除选中Installed，点击Installed前的+，弹出框选择Width：Any，Height：Compact，Gamunt：Any，并选择新加的Installed（height约束颜色变浅了，说明这个约束不是在任何状态下都有效的）： 练习还有考虑特殊的一些设备的情况，添加一些特殊的约束： 在wR hR时，修改两个按钮的宽度为300 在iphone 6/7 和一些老的iphone等设备竖屏时，修改”Need help with …” label 字体为15 在wR hR时，修改图像stack view的上下空间为30 代码Beginning-iOS-Programming-with-Swift 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 3 介绍Auto Layout]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-3.html</url>
    <content type="text"><![CDATA[Auto layout是一种基于约束的，描述性的布局系统。 iPhone尺寸 为什么使用Auto Layout前面的一部分的项目HelloWorld默认是运行的iPhone 7(iPhone 6)的竖屏下的，button是在屏幕中间的，但是如果其他屏幕大小或不同方位就不一定了。按照在默认iPhone 7的条件下，button的左上角的坐标是(147,318)，其他尺寸的设备和不同方位显示时也会按照这种坐标显示，就不会在中间了，这也就是为什么需要使用Auto Layout。 Auto Layout就是关于所有约束关于“Hello World”按钮的位置信息的描述可能比较好的是： 无论屏幕的分辨率和方位，这个按钮在水平和垂直方向都应该是居中的 这实际就定义了两个约束： 水平居中 垂直居中 在Auto Layout中约束都被描述成数学表示，例如上述两个限制就会被表示成： Hello World.centerX = centerX ， Hello World.centerY = centerY。当然我们不需要直接处理这种数学公式，Xcode会帮我们处理。 使用Auto Layout使Button到中央Xcode提供了两种方法定义Auto Layout的约束： Auto Layout工具栏 Control-drag Auto Layout工具栏提供了四个按钮： Stack - 组合views变成一个stack view Align - 构建对齐约束 Pin - 构建空间约束，例如UI的宽度，高度，边距等 Issues - 解决布局问题 使用Align来定义两个约束：水平居中 和 垂直居中。弹窗中”Horizontal in container”后的数字表示button中心点的x坐标与父视图中心点的x坐标的相差数， “Vertically in container”后的数字表示button中心点的y坐标与父视图中心点的y坐标的相差数。如果都为零就表示button的中心和父视图的中心是相同的，也就是说button水平和垂直方向都居中。 点击 “Add 2 Constraints” 后，会出现如下情况。在document outline中出现两个约束选项，在视图中出现垂直两条蓝色的实线，在size检查器中也能看到约束。 如果点击每个约束，在size检查器中还能看到每个约束的具体信息，也能在此修改约束。 解决布局约束问题Xcode可以非常智能的检测的布局约束方面的问题。当创建了模棱两可或冲突的约束时就会出现布局问题。试着将button拖动左下角，视图中原本的蓝色实线变成了黄色实线，并且线上还有数字，这些数字表示button现在的位置偏离约束的距离，document outline右上角出现一个黄色箭头(disclosure arrow)。 点击disclosure arrow，出现布局问题列表，红色框中的Expected表示现在约束所期望的位置也就是居中位置，Actual表示现在实际位置。每个问题右侧有个indicator icon，点击它出现一个弹框，选择Update Frame然后点击Fix Misplacement，按钮回到原来中央位置；选择Update constraints表示button的位置不变，更新到最新位置的约束。 实际上，点击Auto Layout工具栏最右侧的issue，也会出现类似的功能： 不同设备同时预览Xcode提供了一个同时预览不同设备下视图的界面。按住option，然后按menu &gt; Preview(1) &gt; Main.storyboard (Preview)，就能打开用于预览的assistant editor。 这个预览窗口可以预览目前所有iOS设备。 添加一个Label 添加一个”Welcome to Auto Layout”的标签在右下角，并打开预览窗口查看，发现出来除了默认的iPhone 7，其他设备要不偏离了，要不不见了。 用control+drag方法来添加spacing constraint。按住control，从label上向右拖动，拖出label到视图后松开，出现弹框，选择 “Trailing space to container margin” ，表示设置右边距的约束。 类似2的方法，向下拖动松开，选择弹框中的”Vertical Spacing to Bottom Layout Guide”，表示设置了下边距约束。所有约束线变成了蓝色实线，蓝色实线表示约束正常。 document outline上又出现两个约束： 此时如果用预览窗口查看，发现label在不同的设备上都在右下角了： 编辑约束前面也提到约束本身可以手动修改的，选择约束，然后在size检查器中修改。默认label的”trailingMargin”约束的constant值是0，可以试着修改。 练习 添加新的label，修改文本为Learn Swift 把字体大小改为30 point，调整label为适宜大小 添加两个约束 label的上边距为40point label水平居中 代码HelloWorldAutoLayoutHelloWorldAutoLayoutExercise 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[开始用Swift开发iOS 10 - 2 Hello World！第一个Swift APP]]></title>
    <url>%2F2017%2Fbeginning-ios-swift-2.html</url>
    <content type="text"><![CDATA[“Hello,World”已经成为编程世界里开始的惯例。 开始：先动起来，忘记代码 打开Xcode，选择”Create a new Xcode project” 选择 iOS &gt; Single View Application and click Next 填写项目的一些选项: Product Name: HelloWorld - app的名字 Team - Apple ID Organization Name: andyron - 这一般是组织的名字，或个人用户的名字；尽量保持不与别人重复 Organization Identifier: cn.andyron Bundle Identifier: com.andyron.HelloWorld - 根据Organization Identifier和Product Name自动组合而成 Language: Swift Devices: iPhone Use Core Data: [unchecked] Include Unit Tests: [unchecked] Include UI Tests: [unchecked] 选择一个项目保持位置，然后生成项目 熟悉Xcode界面Xcode Help中详细介绍了Xcode，主界面如下： 主要分六个区域： Toolbar(工具栏) Tab bar(便签页栏)：类似浏览器的标签页，快捷键也和大部分软件的相同(⌘+T新建，⌘+W关闭)，单个标签页时是隐藏的 Navigator area(导航区域)这个区域最上面有八个图标（快捷键分别对应⌘+1 ~ ⌘+8）： project navigator(源代码文件、图片文件、数据模型、属性列表等) symbol navigator(编译器能识别的：OC类、枚举类型、结构体、全局变量) find navigator issues navigator test navigator debug navigator breakpoint navigator log navigator Editor area（编辑区）这个区域最上面是jump bar(跳转栏) Debug area Utilities area（实用工具面板）分上下两块： Inspector pane(检查器)：选择不同文件会有不同个数的检查器，最多六个(快捷键分别对应⌘+option+1 ~ ⌘+option+6)。 Library pane(库面版, 快捷键分别对应⌘+option+control+1 ~ ⌘+option+control+4) 文件库模板(File Template Library) : 管理文件模板, 可以快速创建指定类型文件, 可以直接拖入项目中; 代码片段库(Code Snippet Library) : 管理各种代码片段, 可以直接拖入源代码中; 对象库(Object Library) : 界面组件, 可以直接拖入 故事板中; 媒体库(Media Library) : 管理各种 图片, 音频 等多媒体资源; 第一次运行AppRun和Stop分别对应 ⌘+R和⌘+.，Simulator用于选择模拟器或真实设备 快速了解Interface Builder（IB）在project navigator中选择main.storyboardThe Interface Builder editor为创造和设计app的UI提高了一个可视化的方法。在这里既可以设计单个页面，也可以设计多个页面。可以直接从右下角Object library拖动可用对象到IB中。当开始新建项目，选择了Single View Application模板时，Xcode默认在storyboard中生成一个view controller scene，对应一个view controller。通常app的每一个screen代表一个view controller。The Document Outline view在选择storyboard特定对象时特别有用。 设计UI 拖动一个Button到IB中 双击Button或在属性检查器中修改name为”Hello World** 根据蓝色虚线辅助线可以把Button拖到中心位置 写代码 选择main.storyboard，点击工具栏右侧的Assistant editor(option+⌘+return)，编辑区出现两部分，Ctrl拖动按钮到右侧ViewController类中： 然后写下如下代码：1234567@IBAction func showMessage() &#123; let alertController = UIAlertController(title: &quot;Welcome to My First App&quot;,message: &quot;Hello World&quot;, preferredStyle: UIAlertControllerStyle.alert) alertController.addAction(UIAlertAction(title: &quot;OK&quot;, style:UIAlertActionStyle.default, handler: nil)) present(alertController, animated: true, completion: nil)&#125; 上面的方法是先连接关系，然后写代码；也可以先写好代码，然后建立关系：@IBAction表示一个Action的标识符，没有特殊意义，当建立好关系后，@IBAction右侧会出现一个实心的点，点击会出现会出现以个弹框表示连接的地方： 修改按钮的颜色。选中按钮，在属性检查器中修改对应属性 测试应用选择特定的模拟器或设备，⌘+R Hello world 应用中事件流 更近一步 同上的方法添加几个按钮，并修改button的name为一些emoji表情（control+⌘+space） 添加@IBAction方法代码 通过先写好代码然后建立关系的方法，把几个button都与同一个@IBAction方法建立关系 代码HelloWorldHelloWordExercise 说明此文是学习appcode网站出的一本书 《Beginning iOS 10 Programming with Swift》 的一篇记录]]></content>
      <categories>
        <category>Beginning_iOS_Swift</category>
      </categories>
  </entry>
</search>