<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Swift on 欣欣向戎</title>
    <link>https://andyron.top/categories/swift/</link>
    <description>Recent content in Swift on 欣欣向戎</description>
    <generator>Hugo</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 16 Jul 2024 12:36:45 +0800</lastBuildDate>
    <atom:link href="https://andyron.top/categories/swift/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Swift中optionals使用总结</title>
      <link>https://andyron.top/blog/2019/07/swift-optionals.html/</link>
      <pubDate>Mon, 29 Jul 2019 13:40:40 +0000</pubDate>
      <guid>https://andyron.top/blog/2019/07/swift-optionals.html/</guid>
      <description>Github链接：https://github.com/andyRon/LearnSwift/blob/master/Tips/Swift中</description>
    </item>
    <item>
      <title>Swift中的高阶函数：sorted, map, reduce, forEach, flatMap, filter</title>
      <link>https://andyron.top/blog/2018/10/swift-higher-order-function.html/</link>
      <pubDate>Mon, 15 Oct 2018 20:41:19 +0000</pubDate>
      <guid>https://andyron.top/blog/2018/10/swift-higher-order-function.html/</guid>
      <description>高阶函数（Higher-order function） 在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数： 接受一个或多个函数作为输入 输</description>
    </item>
    <item>
      <title>Swift中where的用法总结</title>
      <link>https://andyron.top/blog/2017/11/swift-where.html/</link>
      <pubDate>Wed, 08 Nov 2017 13:40:40 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/11/swift-where.html/</guid>
      <description>不同的版本的Swift中where用法有些不同，以最新的Swift4为准， 1 if, guard, while三个语句中where被去掉了，直接使用,相隔就行了</description>
    </item>
    <item>
      <title>Swift中的问号三种用法</title>
      <link>https://andyron.top/blog/2017/08/swift-question.html/</link>
      <pubDate>Mon, 14 Aug 2017 13:45:41 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/08/swift-question.html/</guid>
      <description>三目运算符(Ternary Conditional Operator) 这在大部分语言中都比较常见 布尔值 ? &amp;quot;true&amp;quot; : &amp;quot;false&amp;quot; 可选值 可选值?和 !是一对。?用在某个类型后面，可以通俗的理解为，这个值</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-0：说明和目录</title>
      <link>https://andyron.top/blog/2017/07/swift-0.html/</link>
      <pubDate>Tue, 25 Jul 2017 13:45:29 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-0.html/</guid>
      <description>这是我学习Swift的一个笔记和总结，以playground的形式放在我的github上，学习的版本是swift 3 。 学习资源 官方文档 The Swift Programming Language</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-25：高级运算符(Advanced Operators)</title>
      <link>https://andyron.top/blog/2017/07/swift-25-advanced-operators.html/</link>
      <pubDate>Mon, 17 Jul 2017 13:45:17 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-25-advanced-operators.html/</guid>
      <description>1 位运算符 按位取反运算符 1 2 let initialBits: UInt8 = 0b00001111 let invertedBits = ~initialBits // 等于 0b11110000 按位与运算符 1 2 3 let firstSixBits: UInt8 = 0b11111100 let lastSixBits: UInt8 = 0b00111111 let middleFourBits = firstSixBits &amp;amp; lastSixBits // 等于 00111100 按位或运算符 1 2 3 let someBits: UInt8 = 0b10110010</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-24：访问控制(Access Control)</title>
      <link>https://andyron.top/blog/2017/07/swift-24-access-control.html/</link>
      <pubDate>Sat, 15 Jul 2017 13:44:52 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-24-access-control.html/</guid>
      <description>可以明确地给单个类型(类、结构体、枚举)设置访问级别，也可以给这些类型的属性、方法、构造器、下标等设置访问级别。协议也可以被限定在一定的范围</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-23：泛型(Generics)</title>
      <link>https://andyron.top/blog/2017/07/swift-23-generics.html/</link>
      <pubDate>Fri, 14 Jul 2017 13:44:42 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-23-generics.html/</guid>
      <description>泛型是 Swift 最强大的特性之一，许多 Swift 标准库是通过泛型代码构建的。 例如， Swift 的数组和字典都是泛型集合。你可以创建一个存有整型值或者字符串值的数组，有</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-22：协议(Protocols)</title>
      <link>https://andyron.top/blog/2017/07/swift-22-protocols.html/</link>
      <pubDate>Fri, 14 Jul 2017 13:44:31 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-22-protocols.html/</guid>
      <description>协议定义了一个蓝图，规定了用来实现某一特定任务或者功能的方法、属性，以及其他需要的东西。 类、结构体或枚举都可以采纳协议，并为协议定义的这些要</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-21：扩展(Extensions)</title>
      <link>https://andyron.top/blog/2017/07/swift-21-extensions.html/</link>
      <pubDate>Thu, 13 Jul 2017 13:44:20 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-21-extensions.html/</guid>
      <description>为一个已有的类、结构体、枚举类型或者协议类型添加新功能。 包括在没有权限获取原始源代码的情况下扩展类型的能力(即逆向建模) 扩展可以为一个类型添</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-20：嵌套类型(Nested Types)</title>
      <link>https://andyron.top/blog/2017/07/swift-20-nested-types.html/</link>
      <pubDate>Mon, 10 Jul 2017 13:44:08 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-20-nested-types.html/</guid>
      <description>1 🌰 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 struct BlackjackCard { // 二十一点 // nested Suit enumeration enum Suit: Character { // 描述扑克牌的四种花色 case spades =</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-19：类型转换(Type Casting)</title>
      <link>https://andyron.top/blog/2017/07/swift-19-type-casting.html/</link>
      <pubDate>Sun, 09 Jul 2017 13:43:50 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-19-type-casting.html/</guid>
      <description>1 定义一个类层次作为例子 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class MediaItem { var name: String init(name: String) { self.name = name } } class Movie: MediaItem { var director: String init(name: String, director: String) { self.director</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-18：错误处理(Error handling)</title>
      <link>https://andyron.top/blog/2017/07/swift-18-error-handling.html/</link>
      <pubDate>Thu, 06 Jul 2017 13:43:30 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-18-error-handling.html/</guid>
      <description>错误处理(Error handling)是响应错误以及从错误中恢复的过程。 1 表示并抛出错误 Error空协议表明该类型可以用于错误处理 1 2 3 4 5</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-17：可选链式调用(Optional Chaining)</title>
      <link>https://andyron.top/blog/2017/07/swift-17-optional-chaining.html/</link>
      <pubDate>Wed, 05 Jul 2017 13:42:56 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-17-optional-chaining.html/</guid>
      <description>一种可以在当前值可能为nil的可选值上请求和调用属性、方法及下标的方法 1 使用可选链式调用代替强制展开 可选链式调用的返回结果与原本的返回结果具</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-16：自动引用计数(Automatic Reference Counting, ARC)</title>
      <link>https://andyron.top/blog/2017/07/swift-16-automatic-reference-counting.html/</link>
      <pubDate>Tue, 04 Jul 2017 13:43:08 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-16-automatic-reference-counting.html/</guid>
      <description>引用计数仅仅应用于类的实例 1 自动引用计数的工作机制 每次创建一个类的新的实例的时候，ARC会分配一块内存来储存该实例信息(包含实例的类型信息，</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-15：(类的)析构过程(Deinitialization)</title>
      <link>https://andyron.top/blog/2017/07/swift-15-deinitialization.html/</link>
      <pubDate>Tue, 04 Jul 2017 13:42:44 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-15-deinitialization.html/</guid>
      <description>1 析构过程原理 每个类最多只能有一个析构器，而且析构器不带任何参数 析构器是在实例释放发生前被自动调用。不能主动调用析构器。 子类继承了父类的析构</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-14：构造过程(Initialization)</title>
      <link>https://andyron.top/blog/2017/07/swift-14-initialization.html/</link>
      <pubDate>Tue, 04 Jul 2017 13:42:40 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-14-initialization.html/</guid>
      <description>构造过程是使用类、结构体或枚举类型的实例之前的准备过程 通过定义构造器( Initializers )来实现构造过程 1 存储属性的初始赋值 类和结构体在创建实例时，必须为所</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-13：继承(Inheritance)</title>
      <link>https://andyron.top/blog/2017/07/swift-13-inheritance.html/</link>
      <pubDate>Tue, 04 Jul 2017 13:42:36 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-13-inheritance.html/</guid>
      <description>一个类可以继承(inherit)另一个类的方法(methods)，属性(properties)和其它特性 类可以调用和访问超类的方法，属性和下</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-12：下标(Subscripts)</title>
      <link>https://andyron.top/blog/2017/07/swift-12-subscripts.html/</link>
      <pubDate>Tue, 04 Jul 2017 13:42:28 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-12-subscripts.html/</guid>
      <description>下标 (subscripts)可以定义在类(class)、结构体(structure)和枚举(enumeration)中，是访问集合(coll</description>
    </item>
    <item>
      <title>以撸代码的形式学习Swift-11：方法(Methods)</title>
      <link>https://andyron.top/blog/2017/07/swift-11-methods.html/</link>
      <pubDate>Mon, 03 Jul 2017 13:41:36 +0000</pubDate>
      <guid>https://andyron.top/blog/2017/07/swift-11-methods.html/</guid>
      <description>方法是与某些特定类型相关联的函数 实例方法为给定类型的实例封装了具体的任务与功能 类、结构体、枚举都可以定义实例方法，也都可以定义类型方法 在OC</description>
    </item>
  </channel>
</rss>
