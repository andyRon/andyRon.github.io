<!DOCTYPE html>
<html
  lang="zh-cn"
  itemscope
  itemtype="http://schema.org/WebPage"
>
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>
          【译】Swift算法俱乐部-堆 - 欣欣向戎
        </title>
    

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=yes"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="andyron" />
  <meta name="description" content="本文是对 Swift Algorithm Club 翻译的一篇文章。 Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在Gi" />

  <meta name="keywords" content="linux, Go, Java, PHP, program, journal, andyron, 博客, 笔记" />






<meta name="generator" content="Hugo 0.128.2" />


<link rel="canonical" href="http://localhost:1313/blog/2019/01/swift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%A0%86.html/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.d8d87b982993a745e5e7b6a6cbf257be8c3e82aab5e485f0908ad7e6c3501ab2.css" integrity="sha256-2Nh7mCmTp0Xl57amy/JXvow&#43;gqq15IXwkIrX5sNQGrI=" media="screen" crossorigin="anonymous">






<link rel="stylesheet" href="/css/custom.css">


<meta property="og:url" content="http://localhost:1313/blog/2019/01/swift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%A0%86.html/">
  <meta property="og:site_name" content="欣欣向戎">
  <meta property="og:title" content="【译】Swift算法俱乐部-堆">
  <meta property="og:description" content="本文是对 Swift Algorithm Club 翻译的一篇文章。 Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在Gi">
  <meta property="og:locale" content="zh_cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2019-01-11T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-07-16T12:34:59+08:00">
    <meta property="article:tag" content="算法与数据结构">
    <meta property="article:tag" content="Swift">
    <meta property="article:tag" content="堆">
    <meta property="article:tag" content="Heap">

  <meta itemprop="name" content="【译】Swift算法俱乐部-堆">
  <meta itemprop="description" content="本文是对 Swift Algorithm Club 翻译的一篇文章。 Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在Gi">
  <meta itemprop="datePublished" content="2019-01-11T00:00:00+00:00">
  <meta itemprop="dateModified" content="2024-07-16T12:34:59+08:00">
  <meta itemprop="wordCount" content="6379">
  <meta itemprop="keywords" content="算法与数据结构,Swift,堆,Heap">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="【译】Swift算法俱乐部-堆">
  <meta name="twitter:description" content="本文是对 Swift Algorithm Club 翻译的一篇文章。 Swift Algorithm Club是 raywenderlich.com网站出品的用Swift实现算法和数据结构的开源项目，目前在Gi">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




  </head>
  <body>
    <div id="back-to-top"></div>

    <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">欣欣向戎</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/">主页</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/blog/">全部文章</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/tags/">标签</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/categories/">分类</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/index.xml">订阅</a>
          
        
      </li>
    

    
      <li class="mobile-menu-item">
        <a id="openSearchMobile" class="mobile-menu-item-link menu-item-search" href="#">
          <i class="iconfont">
            <svg version="1.1" viewBox="0 0 1024 1024"
  xmlns="http://www.w3.org/2000/svg" width="18" height="18"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M973.81454219 973.81454219a91.78207815 91.78207815 0 0 1-129.80999631 0l-161.97482118-161.97482118a425.48527711 425.48527711 0 0 1-230.35931791 68.16531768 428.3346319 428.3346319 0 1 1 428.3346319-428.3346319 425.48527711 425.48527711 0 0 1-68.16531768 230.35931791l162.02961656 161.97482118a91.83687354 91.83687354 0 0 1-0.05479538 129.80999631zM451.67040679 145.69361559a305.97679241 305.97679241 0 1 0 0 611.95358361 305.97679241 305.97679241 0 0 0 0-611.95358361z">
  </path>
</svg>

          </i>
        </a>
      </li>
    
  </ul>
</nav>


    
      






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

    

    
      
<div class="modal-dialog">
    
    <div class="modal-content">
      <div id="closeSearch" title="Close" class="close">X</div>
      <div class="modal-header">
        <div class="modal-title">Search</div>
      </div>
      <div class="modal-body">
          <script>
            (function() {
              var cx = '002186711602136249422:q1gkomof_em';
              var gcse = document.createElement('script');
              gcse.type = 'text/javascript';
              gcse.async = true;
              gcse.src = (document.location.protocol == 'https:' ? 'https:' :
                  'http:') +
                '//cse.google.com/cse.js?cx=' + cx;
              var s = document.getElementsByTagName('script')[0];
              s.parentNode.insertBefore(gcse, s);
            })();
          </script>
          <gcse:search></gcse:search>
      </div>
    </div>
</div>

    

    


    <header id="header" class="header">
      <div class="logo-wrapper">
  <a href="/" class="logo">
    
      欣欣向戎
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/">主页</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/blog/">全部文章</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/tags/">标签</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/categories/">分类</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="http://localhost:1313/index.xml">订阅</a>
          

        

      </li>
    

    
    

    
      <li class="menu-item">
        <a id="openSearch" class="menu-item-link menu-item-search" href="#">
          <i class="iconfont">
            <svg version="1.1" viewBox="0 0 1024 1024"
  xmlns="http://www.w3.org/2000/svg" width="18" height="18"
  xmlns:xlink="http://www.w3.org/1999/xlink">
  <path d="M973.81454219 973.81454219a91.78207815 91.78207815 0 0 1-129.80999631 0l-161.97482118-161.97482118a425.48527711 425.48527711 0 0 1-230.35931791 68.16531768 428.3346319 428.3346319 0 1 1 428.3346319-428.3346319 425.48527711 425.48527711 0 0 1-68.16531768 230.35931791l162.02961656 161.97482118a91.83687354 91.83687354 0 0 1-0.05479538 129.80999631zM451.67040679 145.69361559a305.97679241 305.97679241 0 1 0 0 611.95358361 305.97679241 305.97679241 0 0 0 0-611.95358361z">
  </path>
</svg>

          </i>
        </a>
      </li>
    
  </ul>
</nav>

    </header>

    <div id="mobile-panel">
      <main id="main" class="main bg-llight wallpaper">
        <div class="content-wrapper">
    <div id="content" class="content">
      <article class="post">
        
        <header class="post-header">
          <h1 class="post-title">【译】Swift算法俱乐部-堆</h1>
          

          <div class="post-meta">
  <div class="post-meta-author">
    by
      <a href="/about">
        <span class="post-meta-author-name">
          andyron
        </span>
      </a>
    
  </div>

  <div class="post-meta-time">
    <time datetime="2019-01-11">
      2019-01-11
    </time>
  </div>

  
    <div class="post-meta-lastmod">
      (上次更新:
      2024-07-16)
    </div>
  


  <div class="post-meta__right">
    

    <div class="post-meta-category">
        <a href="http://localhost:1313/categories/swift-algorithm-club-cn/"> swift-algorithm-club-cn </a>
          
      </div>


    
    


    
    
  </div>
</div>

        </header>

        
        <div class="post-content">
          <blockquote>
<p>本文是对 <a href="https://github.com/raywenderlich/swift-algorithm-club">Swift Algorithm Club</a> 翻译的一篇文章。</p>
<p><a href="https://github.com/raywenderlich/swift-algorithm-club">Swift Algorithm Club</a>是 <a href="https://www.raywenderlich.com">raywenderlich.com</a>网站出品的用Swift实现算法和数据结构的开源项目，目前在GitHub上有18000+⭐️，我初略统计了一下，大概有一百左右个的算法和数据结构，基本上常见的都包含了，是iOSer学习算法和数据结构不错的资源。</p>
<p>🐙<a href="https://github.com/andyRon/swift-algorithm-club-cn">andyRon/swift-algorithm-club-cn</a>是我对Swift Algorithm Club，边学习边翻译的项目。由于能力有限，如发现错误或翻译不妥，请指正，欢迎pull request。也欢迎有兴趣、有时间的小伙伴一起参与翻译和学习🤓。当然也欢迎加⭐️，🤩🤩🤩🤨🤪。</p>
<p>本文的翻译原文和代码可以查看🐙<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Heap">swift-algorithm-club-cn/Heap</a></p>
</blockquote>
<hr>
<p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fz2fdyqh68j30b407sjrb.jpg"></p>
<p><strong>堆(Heap)</strong></p>
<blockquote>
<p>这个话题已经有个辅导<a href="https://www.raywenderlich.com/160631/swift-algorithm-club-heap-and-priority-queue-data-structure">文章</a></p>
</blockquote>
<p>堆是数组内的<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Binary%20Tree/">二叉树</a>，因此它不使用父/子指针。 堆基于“堆属性”进行排序，“堆属性”确定树中节点的顺序。</p>
<p>堆的一般用途：</p>
<ul>
<li>构建<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Priority%20Queue">优先队列</a>。</li>
<li>支持<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Heap%20Sort/">堆排序</a>。</li>
<li>快速计算集合中最大（或最小）值。</li>
<li>给你的非程序员朋友留下深刻影响。</li>
</ul>
<!-- raw HTML omitted -->
<h2 id="堆属性">堆属性</h2>
<p>有两种堆：<em>max-heap</em> 和 <em>min-heap</em>，它们存储树节点的顺序不同。</p>
<p>在<em>max-heap</em>中，每个父节点的值大于其子节点。 在<em>min-heap</em>中，每个父节点的值都小于其子节点。 这称为“堆属性”，对于树中的每个节点都是如此。</p>
<p>一个例子：</p>
<p><img alt="A max-heap" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Heap1.png"></p>
<p>这是一个<em>max-heap</em>，因为每个父节点都大于其子节点。 <code>(10)</code>大于<code>(7)</code>和<code>(2)</code>。 <code>(7)</code>大于<code>(5)</code>和<code>(1)</code>。</p>
<p>堆属性的结果是，<em>max-heap</em>始终将其最大项存储在树的根节点中。 对于<em>min-heap</em>，根节点始终是树中的最小项。 堆属性很有用，因为堆通常用作<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Priority%20Queue/">优先队列</a>来快速访问“最重要的”（**译注：**最大或最小）元素。</p>
<blockquote>
<p><strong>注意：</strong> 堆的根节点是最大或最小元素，但其他元素的排序顺序是不可预测的。例如，最大元素始终位于<em>max-heap</em>中的索引0处，但最小元素不一定是最后一个元素。 —— 唯一的保证是，最小元素是叶节点之一，但不知道是哪一个。</p>
</blockquote>
<h2 id="堆与常规树对比">堆与常规树对比</h2>
<p>堆不是二叉搜索树的替代品，它们之间存在相似之处和不同之处。 以下是一些主要差异：</p>
<p>**节点的顺序。**在<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Binary%20Search%20Tree/">二叉搜索树（BST）</a>中，左子节点必须小于其父节点，右子节点必须更大。 堆不是这样。 在<em>max-heap</em>中，两个子节点必须小于父节点，而在<em>min-heap</em>中，子节点必须大于父节点。</p>
<p>**内存。**传统的树比它们存储的数据占用更多的内存。 需要为节点对象和指向左/右子节点的指针分配额外的存储空间。 堆只使用普通数组进行存储，不使用指针。</p>
<p><strong>平衡。</strong> 二叉搜索树（BST）必须“平衡”，以便大多数操作具有**O(log n)**性能。 您可以按随机顺序插入和删除数据，也可以使用<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/AVL%20Tree/">AVL树</a>或<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Red-Black%20Tree/">红黑树</a>，但 我们实际上并不需要对整个树进行排序。 我们只是希望实现堆属性，因此平衡不是问题。 由于堆的结构方式，堆可以保证 <strong>O(log n)</strong> 的性能。</p>
<p><strong>搜索。</strong> 虽然在二叉树中搜索速度很快，但在堆中搜索速度很慢。 搜索不是堆中的最高优先级，因为堆的目的是将最大（或最小）节点放在前面并允许相对快速的插入和删除。</p>
<h2 id="数组中的树">数组中的树</h2>
<p>用数组实现树状结构似乎比较奇怪，但它在时间和空间上都很高效的。</p>
<p>上面例子中的树用数组存储为：</p>
<pre><code>[ 10, 7, 2, 5, 1 ]
</code></pre>
<p>这里的所有了！ 我们不需要比这个简单数组更多的存储空间了。</p>
<p>那么，如果不允许使用任何指针，我们如何知道哪些节点是父节点，哪些节点是子节点？ 好问题！树节点的数组索引与其父节点和子节点的数组索引之间存在明确定义的关系。</p>
<p>如果<code>i</code>是节点的索引，则以下公式给出其父节点和子节点的数组索引：</p>
<pre><code>parent(i) = floor((i - 1)/2)
left(i)   = 2i + 1
right(i)  = 2i + 2
</code></pre>
<p>注意<code>right(i)</code>只是<code>left(i)+ 1</code>。 左侧和右侧子节点始终紧挨着存储。</p>
<p>对上面的例子使用这些公式。 填写数组索引，我们应该得到数组中父节点和子节点的位置：</p>
<table>
<thead>
<tr>
<th style="text-align:center">节点</th>
<th style="text-align:center">数组中的索引(<code>i</code>)</th>
<th style="text-align:center">父节点索引</th>
<th style="text-align:center">左子节点索引</th>
<th style="text-align:center">右子节点索引</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">0</td>
<td style="text-align:center">-1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">2</td>
<td style="text-align:center">0</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
<td style="text-align:center">1</td>
<td style="text-align:center">7</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">4</td>
<td style="text-align:center">1</td>
<td style="text-align:center">9</td>
<td style="text-align:center">10</td>
</tr>
</tbody>
</table>
<p>验证这些数组索引确实对应于上面树的图片。</p>
<blockquote>
<p><strong>注意：</strong> 根节点<code>(10)</code>没有父节点，因为<code>-1</code>不是有效的数组索引。 同样，节点<code>(2)</code>，<code>(5)</code>和<code>(1)</code>没有子节点，因为那些索引大于数组大小，所以用它们之前我们总是要确保我们计算的索引实际上是有效的。</p>
</blockquote>
<p>回想一下，在<em>max-heap</em>中，父节点的值总是大于（或等于）其子节点的值。 这意味着对于所有数组索引<code>i</code>必须满足以下条件：</p>
<div class="highlight"><div style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-0-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-0-1">1</a>
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>array[parent(i)] <span style="color:#666">&gt;=</span> array[i]
</span></span></code></pre></td></tr></table>
</div>
</div><p>验证此堆属性是否适用于示例堆中的数组。</p>
<p>如您所见，这些等式允许我们在不需要指针的情况下找到任何节点的父索引或子索引。 这样消除了使用指针的复杂，这是一种权衡：我们节省了内存空间，但需要额外的计算。 幸运的是，计算速度很快，只需要 <strong>O(1)</strong> 时间。</p>
<p>理解树中数组索引和位置之间的这种关系很重要。 下面👇是一个更大的堆，有15个节点分为四个级别：</p>
<p><img alt="Large heap" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/LargeHeap.png"></p>
<p>此图片中的数字不是节点的值，而是存储节点的数组索引！ 下面👇是数组索引对应树的不同级别：</p>
<p><img alt="The heap array" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Array.png"></p>
<p>要使公式起作用，父节点必须出现在数组中的子节点之前。 你可以在上面的图片中看到。</p>
<p>请注意，此方案有局限性。 您可以使用常规二叉树执行以下操作，但不能使用堆执行以下操作：</p>
<p><img alt="Impossible with a heap" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/RegularTree.png"></p>
<p>除非当前最低级别已满，否则无法开启新级别，因此堆总是具有这种形状：</p>
<p><img alt="The shape of a heap" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/HeapShape.png"></p>
<blockquote>
<p><strong>注意：</strong> 您<em>可以</em>使用堆模拟常规二叉树，但这会浪费空间，您需要将一些数组索引标记为空。</p>
</blockquote>
<p>突击测验！ 假设我们有数组：</p>
<pre><code>[ 10, 14, 25, 33, 81, 82, 99 ]
</code></pre>
<p>这是一个有效的堆吗？ 答案是肯定的！ 从低到高的排序数组是有效的<em>min-heap</em>。 我们可以按如下方式绘制这个堆：</p>
<p><img alt="A sorted array is a valid heap" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/SortedArray.png"></p>
<p>堆属性适用于每个节点，因为父节点始终小于其子节点。 （自己验证从高到低排序的数组始终是有效的<em>max-heap</em>。）</p>
<blockquote>
<p>**注意：**但并非每个<em>min-heap</em>都必须是一个排序数组！ 排序数组只是一种特殊情况。 要将堆重新转换为已排序的数组，需要使用<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Heap%20Sort/">堆排序</a>。</p>
</blockquote>
<h2 id="更多数学">更多数学！</h2>
<p>如果你很好奇，这里有一些描述堆的某些属性的公式。 你不需要知道这些，但它们有时会派上用场。 可以跳过此部分！</p>
<p>树的<em>height</em>定义为从根节点到最低叶节点所需的步数，或者更正式：<em>height</em>是节点之间的最大边数。 高度<em>h</em>的堆具有<em>h + 1</em>级别。</p>
<p>这个堆的高度为3，所以它有4个级别：</p>
<p><img alt="Large heap" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/LargeHeap.png"></p>
<p>具有<em>n</em>个节点的堆具有高度<em>h = floor(log2(n))</em>。 这是因为我们总是在添加新级别之前完全填满最低级别。 该示例有15个节点，因此高度为 <code>floor(log2(15)) = floor(3.91) = 3</code>。</p>
<p>如果最低级别已满，则该级别包含 <em>2^h</em> 个节点。 它上面的树的其余部分包含 <em>2^h - 1</em> 个节点。 上面示例就是：最低级别有8个节点，实际上是 <code>2^3 = 8</code> 。 前三个级别包含总共7个节点，即<code>2^3 - 1 = 8 - 1 = 7</code>。</p>
<p>因此，整个堆中的节点总数<em>n</em> 为 <em>2^(h+1) - 1</em>。 在示例中，<code>2^4 - 1 = 16 - 1 = 15</code>。</p>
<p>在<em>n</em>个元素堆中，高度为<em>h</em>的最多有 <em>ceil(n/2^(h+1))</em> 个的节点。（**译注：**示例中h为0时，<code>ceil(15/2^(0+1)) = 8</code>，h为1时,<code>ceil(15/2^(1+1)) = 4</code>）</p>
<p>叶节点总是位于数组索引 <em>floor(n/2)</em> 到 <em>n-1</em>。(<strong>译注：</strong> <code>7 ~ 14</code>) 我们将利用这一事实从数组中快速构建堆。 如果您不相信，请验证此示例。;-)</p>
<p>只是一些数学就能照亮你的一天。☀️</p>
<h2 id="你能用堆做什么">你能用堆做什么？</h2>
<p>在插入或删除元素之后，有两个必要的原始操作来确保堆是有效的<em>max-heap</em>或<em>min-heap</em>：</p>
<ul>
<li>
<p><code>shiftUp()</code>：如果元素比其父元素更大（<em>max-heap</em>）或更小（<em>min-heap</em>），则需要与父元素交换， 这使元素向上移动。</p>
</li>
<li>
<p><code>shiftDown()</code>。 如果元素比子元素小（max-heap）或更大（min-heap），这个操作使元素向下移动，也称为“堆化(heapify)”。</p>
</li>
</ul>
<p>向上或向下移动是一个递归过程，需要**O(log n)**时间。</p>
<p>以下是基于原始操作的其他操作：</p>
<ul>
<li>
<p><code>insert(value)</code>：将新元素添加到堆的末尾，然后使用<code>shiftUp()</code>来修复堆。</p>
</li>
<li>
<p><code>remove()</code>：删除并返回最大值(max-heap）或最小值(min-heap）。为了填充元素删除后留下的位置，让最后一个元素移动到根位置，然后使用<code>shiftDown()</code>修复堆。 (有时称为“提取最小值”或“提取最大值”。）</p>
</li>
<li>
<p><code>removeAtIndex(index)</code>：类似<code>remove()</code>，不仅可以删除根节点，也可以从堆中删除任何节点。如果新元素与其子元素不规整，则调用<code>shiftDown()</code>;如果元素与其父元素不规整，则调用<code>shiftUp()</code>。</p>
</li>
<li>
<p><code>replace(index, value)</code>：为节点分配一个较小(<em>min-heap</em>）或较大(<em>max-heap</em>）的值。因为这会使堆属性失效，所以它使用<code>shiftUp()</code>来修复。 (也称为“减少键”和“增加键”。）</p>
</li>
</ul>
<p>以上所有操作都需要时间**O(log n)**因为向上或向下移动是昂贵的。还有一些操作需要更多时间：</p>
<ul>
<li>
<p><code>search(value)</code>。堆不是为高效搜索而构建的，但<code>replace()</code>和<code>removeAtIndex()</code>操作需要节点的数组索引，因此您需要找到该索引。时间：<strong>O(n)</strong>。</p>
</li>
<li>
<p><code>buildHeap(array)</code>：通过重复调用<code>insert()</code>将数组(未排序的）转换为堆。如果您对此很聪明，可以在**O(n)**时间内完成。</p>
</li>
<li>
<p><a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Heap%20Sort/">堆排序</a>。由于堆是一个数组，我们可以使用它的唯一属性将数组从低到高排序。时间：<strong>O(n lg n)。</strong></p>
</li>
</ul>
<p>堆还有一个<code>peek()</code>函数，它返回最大(<em>max-heap</em>）或最小(<em>min-heap</em>）元素，而不从堆中删除它。时间：<strong>O(1)</strong>。</p>
<blockquote>
<p><strong>注意：</strong> 到目前为止，您将使用堆执行的最常见操作是使用<code>insert()</code>插入新值，并使用<code>remove()</code>删除最大值或最小值。 两者都需要**O(log n)**时间。 其他操作用来支持更高级的使用，例如构建优先队列，其中项目的“重要性”在添加到队列后可以改变。</p>
</blockquote>
<h2 id="向堆中插入元素">向堆中插入元素</h2>
<p>我们来看一个插入示例，详细了解其工作原理。 我们将值<code>16</code>插入此堆：</p>
<p><img alt="The heap before insertion" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Heap1.png"></p>
<p>这个堆的数组是<code>[10, 7, 2, 5, 1]</code>。</p>
<p>插入新项目的第一步是将其附加到数组的末尾。 该数组变为：</p>
<pre><code>[ 10, 7, 2, 5, 1, 16 ]
</code></pre>
<p>树结构如下：</p>
<p><img alt="The heap before insertion" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Insert1.png"></p>
<p><code>(16)</code>被添加到最后一行的第一个可用空间。</p>
<p>不幸的是，堆属性不再满足，因为<code>(2)</code>高于<code>(16)</code>，我们希望更高的数字高于低的数字。 (这是<em>max-heap</em>。)</p>
<p>要恢复堆属性，我们交换<code>(16)</code>和<code>(2)</code>。</p>
<p><img alt="The heap before insertion" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Insert2.png"></p>
<p>我们还没有完成，因为<code>(10)</code>也小于<code>(16)</code>。 我们继续将其插入值与其父项交换，直到父项更大或到达树的顶部。 这称为<strong>shift-up</strong> 或 <strong>sifting</strong> ，并在每次插入后完成。 它会使一个太大或太小的数字“浮起”树。</p>
<p>最后，我们得到：</p>
<p><img alt="The heap before insertion" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Insert3.png"></p>
<p>现在每个父节点都比其子节点更大了。</p>
<p>上移所需的时间与树的高度成正比，需要<strong>O(log n)<strong>时间。（将节点附加到数组末尾所需的时间仅为</strong>O(1)</strong>，因此不会降低它的速度。）</p>
<h2 id="删除根节点">删除根节点</h2>
<p>从树中移除<code>(10)</code>：</p>
<p><img alt="The heap before removal" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Heap1.png"></p>
<p>顶部的空白怎么办？</p>
<p><img alt="The root is gone" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Remove1.png"></p>
<p>插入时，我们将新值放在数组的末尾。 在这里，我们做相反的事情：我们采用我们拥有的最后一个对象，将其直接移动到树的顶部，然后恢复堆属性。</p>
<p><img alt="The last node goes to the root" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Remove2.png"></p>
<p>让我们来看看如何<strong>shift-down</strong><code>(1)</code>。 要维护此<em>max-heap</em>的堆属性，我们希望顶部为最大数。 我们有两个交换位置的候选者：<code>(7)</code>和<code>(2)</code>。 选择这三个节点之间的最高数字位于顶部，那是<code>(7)</code>，所以交换<code>(1)</code>和<code>(7)</code>，得到下面👇的树：</p>
<p><img alt="The last node goes to the root" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Remove3.png"></p>
<p>继续向下移动，直到节点没有任何子节点，或者它比两个子节点都大。 对于这个堆，只需要一个交换来恢复堆属性：</p>
<p><img alt="The last node goes to the root" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Remove4.png"></p>
<p>完全向下移动所需的时间与树的高度成正比，这需要**O(log n)**时间。</p>
<blockquote>
<p><strong>注意：</strong> <code>shiftUp()</code>和<code>shiftDown()</code>一次只能修复一个异常元素。 如果错误的位置有多个元素，则需要为每个元素调用一次这些函数。</p>
</blockquote>
<h2 id="删除任意节点">删除任意节点</h2>
<p>绝大多数情况下，将删除的是堆根节点，因为这是堆设计的目的。</p>
<p>但是，删除任意元素可能很有用。 这是<code>remove()</code>的一般版本，可能涉及<code>shiftDown()</code>或<code>shiftUp()</code>。</p>
<p>让我们再次采用前面的示例树，删除<code>(7)</code>：</p>
<p><img alt="The heap before removal" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Heap1.png"></p>
<p>提醒一下，数组是：</p>
<pre><code>[ 10, 7, 2, 5, 1 ]
</code></pre>
<p>如您所知，删除元素可能会使max-heap或min-heap属性失效。 要解决这个问题，我们将要移除的节点与最后一个元素交换：</p>
<pre><code>[ 10, 1, 2, 5, 7 ]
</code></pre>
<p>最后一个元素是我们将返回的元素; 我们将调用<code>removeLast()</code>将其从堆中删除。 <code>(1)</code>现在是乱序的，因为它小于它的子节点，<code>(5)</code>是在树中应该更高。 我们调用<code>shiftDown()</code>来修复它。</p>
<p>但是，向下移动并不是我们需要处理的唯一情况。 也可能发生新元素必须向上移动。 考虑如果从以下堆中删除<code>(5)</code>会发生什么：</p>
<p><img alt="We need to shift up" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Remove5.png"></p>
<blockquote>
<p>译注：这个的树对应的数组是<code>[10, 7, 9, 5, 1, 2, 8]</code>。</p>
</blockquote>
<p>现在<code>(5)</code>与<code>(8)</code>交换。 因为<code>(8)</code>比它的父节点(<code>(7)</code>)大，我们需要调用<code>shiftUp()</code>。</p>
<h2 id="用数组创建堆">用数组创建堆</h2>
<p>将数组转换为堆可以很方便。 只是对数组元素进行洗牌，直到满足堆属性。</p>
<p>在代码中它看起来像这样：</p>
<div class="highlight"><div style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-1-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-1-1">1</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-1-2"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-1-2">2</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-1-3"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-1-3">3</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-1-4"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-1-4">4</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-1-5"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-1-5">5</a>
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">private</span> <span style="color:#007020;font-weight:bold">mutating</span> <span style="color:#007020;font-weight:bold">func</span> <span style="color:#06287e">buildHeap</span>(fromArray array: [T]) {
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">for</span> value <span style="color:#007020;font-weight:bold">in</span> array {
</span></span><span style="display:flex;"><span>      insert(value)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们只要为数组中的每个值调用<code>insert()</code>。 简单但不是很高效。 这总共需要<strong>O(n log n)<strong>时间，因为有</strong>n</strong>个元素，每个插入需要<strong>log n</strong>时间。</p>
<p>如果你没有跳过前面数学部分，你已经看到，对于任何堆，数组索引<em>n / 2</em>到<em>n-1</em>的元素都是树的叶节点。 我们可以简单地跳过那些叶子。 我们只需要处理其他节点，因为它们是有一个或多个子节点的父节点，因此可能是错误的顺序。</p>
<p>代码:</p>
<div class="highlight"><div style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-2-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-2-1">1</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-2-2"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-2-2">2</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-2-3"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-2-3">3</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-2-4"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-2-4">4</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-2-5"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-2-5">5</a>
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-2-6"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-2-6">6</a>
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span>  <span style="color:#007020;font-weight:bold">private</span> <span style="color:#007020;font-weight:bold">mutating</span> <span style="color:#007020;font-weight:bold">func</span> <span style="color:#06287e">buildHeap</span>(fromArray array: [T]) {
</span></span><span style="display:flex;"><span>    elements = array
</span></span><span style="display:flex;"><span>    <span style="color:#007020;font-weight:bold">for</span> i <span style="color:#007020;font-weight:bold">in</span> stride(from: (nodes.count<span style="color:#666">/</span><span style="color:#40a070">2</span><span style="color:#666">-</span><span style="color:#40a070">1</span>), through: <span style="color:#40a070">0</span>, by: <span style="color:#666">-</span><span style="color:#40a070">1</span>) {
</span></span><span style="display:flex;"><span>      shiftDown(index: i, heapSize: elements.count)
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>  }
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里，<code>elements</code>是堆自己的数组。 我们从第一个非叶节点开始向后遍历这个数组，并调用<code>shiftDown()</code>。 这个简单的循环以正确的顺序放置这些节点以及我们跳过的叶节点。 这被称为<strong>Floyd算法</strong>，只需要**O(n)**时间。 ✌️</p>
<h2 id="搜索堆">搜索堆</h2>
<p>堆不能用于快速搜索，但如果要使用<code>removeAtIndex()</code>删除任意元素或使用<code>replace()</code>更改元素的值，则需要获取该元素的索引。搜索堆速度很慢。</p>
<p>在<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Binary%20Search%20Tree/">二叉搜索树</a>中，根据节点的顺序，可以保证快速搜索。 由于堆以不同方式对其节点进行排序，因此二叉搜索不起作用，您需要检查树中的每个节点。</p>
<p>再给出上面堆示例：</p>
<p><img alt="The heap" src="https://github.com/andyRon/swift-algorithm-club-cn/raw/master/Heap/Images/Heap1.png"></p>
<p>如果我们想要搜索节点<code>(1)</code>的索引，我们可以通过线性搜索分步搜索数组<code>[10, 7, 2, 5, 1]</code>。</p>
<p>即使堆属性没有考虑到搜索，我们仍然可以利用它。 我们知道在<em>max-heap</em>中父节点总是比它的子节点大，所以如果父节点已经小于我们要查找的值，我们可以忽略那些子节点(及其子节点等等）。</p>
<p>假设我们想要查看堆是否包含值<code>8</code>(没有包含)。 我们从根<code>(10)</code>开始。 这不是我们想要的，所以我们递归地看看它的左右子节点。 左边的孩子是<code>(7)</code>。 这也不是我们想要的，但由于这是一个<em>max-heap</em>，我们知道查看<code>(7)</code>的子节点是没有意义的，它们总是小于<code>7</code>，因此左侧不会找到<code>8</code>。 同样，对于右节点，<code>(2)</code>，也找不到。</p>
<p>尽管有一点优化，搜索仍然是**O(n)**操作。</p>
<blockquote>
<p><strong>注意：</strong> 有一种方法可以通过保留一个将节点值映射到索引的附加字典来将查找转换为**O(1)**操作。 如果你经常需要调用<code>replace()</code>来改变构建在堆上的<a href="https://github.com/andyRon/swift-algorithm-club-cn/tree/master/Priority%20Queue/">优先队列</a>中对象的“优先级”，这可能是值得做的。</p>
</blockquote>
<h2 id="代码">代码</h2>
<p>有关用Swift代码实现，请参见<a href="https://github.com/andyRon/swift-algorithm-club-cn/blob/master/Heap/Heap.swift">Heap.swift</a>。 大多数代码都很简单。 唯一棘手的是<code>shiftUp()</code>和<code>shiftDown()</code>。</p>
<p>您已经知道有两种类型的堆：<em>max-heap</em>和<em>min-heap</em>。 它们之间的唯一区别在于它们如何对节点进行排序：首先是最大值或最小值。</p>
<p>不是创建两个不同的版本，<code>MaxHeap</code>和<code>MinHeap</code>，而只有一个<code>Heap</code>对象，它需要一个<code>isOrderedBefore</code>闭包。 此闭包包含确定两个值的顺序的逻辑。 你之前可能已经看过了，因为它也是Swift的<code>sort()</code>的工作原理。</p>
<p>要创建一个max-heap整数堆：</p>
<div class="highlight"><div style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-3-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-3-1">1</a>
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">var</span> <span style="color:#bb60d5">maxHeap</span> = Heap&lt;<span style="color:#007020">Int</span>&gt;(sort: <span style="color:#666">&gt;</span>)
</span></span></code></pre></td></tr></table>
</div>
</div><p>要创建一个min-heap整数堆：</p>
<div class="highlight"><div style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#7f7f7f" id="hl-4-1"><a style="outline:none;text-decoration:none;color:inherit" href="#hl-4-1">1</a>
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-swift" data-lang="swift"><span style="display:flex;"><span><span style="color:#007020;font-weight:bold">var</span> <span style="color:#bb60d5">minHeap</span> = Heap&lt;<span style="color:#007020">Int</span>&gt;(sort: <span style="color:#666">&lt;</span>)
</span></span></code></pre></td></tr></table>
</div>
</div><p>I just wanted to point this out, because where most heap implementations use the <code>&lt;</code> and <code>&gt;</code> operators to compare values, this one uses the <code>isOrderedBefore()</code> closure.
我只想指出这一点，因为大多数堆实现使用<code>&lt;</code>和<code>&gt;</code>运算符来比较值，这个使用<code>isOrderedBefore()</code>闭包。</p>
<h2 id="扩展阅读">扩展阅读</h2>
<p><a href="https://en.wikipedia.org/wiki/Heap_%28data_structure%29">Heap的维基百科</a></p>
<p><em>作者：<a href="http://www.github.com/kevinrandrup">Kevin Randrup</a>， Matthijs Hollemans</em><br>
<em>翻译：<a href="https://github.com/andyRon">Andy Ron</a></em><br>
<em>校对：<a href="https://github.com/andyRon">Andy Ron</a></em></p>

        </div>

        
        
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">文章作者</span>
    <span class="item-content">andyron</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">上次更新</span>
    <span class="item-content">
      2024-07-16
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">许可协议</span>
    <span class="item-content">原创文章，如需转载请注明文章作者和出处。谢谢！</span>
  </p>
</div>



        
        
<div class="post-reward">
  <input type="checkbox" name="reward" id="reward" hidden />
  <label class="reward-button" for="reward">赞赏支持</label>
  <div class="qr-code">
    
    
      <label class="qr-code-image" for="reward">
        <img class="image" src="/wechatpay.jpg">
        <span>微信打赏</span>
      </label>
    
  </div>
</div>


        <footer class="post-footer">
          <div class="post-tags">
              <a href="http://localhost:1313/tags/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">算法与数据结构</a>
                <a href="http://localhost:1313/tags/swift/">swift</a>
                <a href="http://localhost:1313/tags/%E5%A0%86/">堆</a>
                <a href="http://localhost:1313/tags/heap/">Heap</a>
                
            </div>


          
          <nav class="post-nav">
            
              <a class="prev" href="/blog/2019/01/ios-animation-5-uiviewpropertyanimator.html/">
                
                <i class="iconfont">
                  <svg  class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M691.908486 949.511495l75.369571-89.491197c10.963703-12.998035 10.285251-32.864502-1.499144-44.378743L479.499795 515.267417 757.434875 204.940602c11.338233-12.190647 11.035334-32.285311-0.638543-44.850487l-80.46666-86.564541c-11.680017-12.583596-30.356378-12.893658-41.662889-0.716314L257.233596 494.235404c-11.332093 12.183484-11.041474 32.266891 0.657986 44.844348l80.46666 86.564541c1.772366 1.910513 3.706415 3.533476 5.750981 4.877077l306.620399 321.703933C662.505829 963.726242 680.945807 962.528973 691.908486 949.511495z"></path>
</svg>

                </i>
                <span class="prev-text nav-default">系统学习iOS动画之五：使用UIViewPropertyAnimator</span>
                <span class="prev-text nav-mobile">上一篇</span>
              </a>
            
              <a class="next" href="/blog/2019/01/swift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97.html/">
                <span class="next-text nav-default">【译】Swift算法俱乐部-双端队列</span>
                <span class="prev-text nav-mobile">下一篇</span>
                
                <i class="iconfont">
                  <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

                </i>
              </a>
          </nav>
        </footer>
      </article>

      
      


      
      

  

  
  
    <div class="post">
  <script
    src="https://giscus.app/client.js"
    data-repo="xianmin/comments---xianmin.org"
    data-repo-id="MDEwOlJlcG9zaXRvcnkxNDAyNTY2MDI="
    data-category="Announcements"
    data-category-id="DIC_kwDOCFwlWs4CRRxW"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="light"
    data-lang="zh-CN"
    
    crossorigin="anonymous"
    async
  ></script>
</div>

  

  
  

  

  <div class="disqus-comment">
  <div class="disqus-button" id="load_disqus" onclick="load_disqus()">
    显示 Disqus 评论
  </div>
  <div id="disqus_thread"></div>
  <script type="text/javascript">
    var disqus_config = function () {
      this.page.url = "http://localhost:1313/blog/2019/01/swift%E7%AE%97%E6%B3%95%E4%BF%B1%E4%B9%90%E9%83%A8-%E5%A0%86.html/";
    };
    function load_disqus() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'xianmin12';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);

      $('#load_disqus').remove();
    };
  </script>
  <noscript
    >Please enable JavaScript to view the
    <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
  </noscript>
  
</div>


    

  

  


    </div>

    
    <nav class="toc" id="toc">
    <div class="toc-title">文章目录</div>
    <div class="toc-content custom-scrollbar">
      <nav id="TableOfContents">
  <ul>
    <li><a href="#堆属性">堆属性</a></li>
    <li><a href="#堆与常规树对比">堆与常规树对比</a></li>
    <li><a href="#数组中的树">数组中的树</a></li>
    <li><a href="#更多数学">更多数学！</a></li>
    <li><a href="#你能用堆做什么">你能用堆做什么？</a></li>
    <li><a href="#向堆中插入元素">向堆中插入元素</a></li>
    <li><a href="#删除根节点">删除根节点</a></li>
    <li><a href="#删除任意节点">删除任意节点</a></li>
    <li><a href="#用数组创建堆">用数组创建堆</a></li>
    <li><a href="#搜索堆">搜索堆</a></li>
    <li><a href="#代码">代码</a></li>
    <li><a href="#扩展阅读">扩展阅读</a></li>
  </ul>
</nav>
    </div>
  </nav>


  </div>

      </main>

      <footer id="footer" class="footer">
        <div class="icon-links">
  
  
    <a href="mailto:rongming.2008@163.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://stackoverflow.com/users/3133839/andyron" rel="me noopener" class="iconfont"
      title="stack-overflow"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M809.714286 932.571429l-638.857143 0 0-274.285714-91.428571 0 0 365.714286 821.714286 0 0-365.714286-91.428571 0 0 274.285714zm-538.285714-299.428571l18.857143-89.714286 447.428571 94.285714-18.857143 89.142857zm58.857143-213.714286l38.285714-83.428571 414.285714 193.714286-38.285714 82.857143zm114.857143-203.428571l58.285714-70.285714 350.857143 293.142857-58.285714 70.285714zm226.857143-216l272.571429 366.285714-73.142857 54.857143-272.571429-366.285714zm-410.285714 840.571429l0-90.857143 457.142857 0 0 90.857143-457.142857 0z"></path>
</svg>

    </a>
  
    <a href="https://github.com/andyron" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="http://localhost:1313/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2025
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        andyron
        
      </span></span>

  
  

  
</div>

      </footer>

      <div class="button__back-to-top">
        <a href="#back-to-top">
          <i class="iconfont">
            
            <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

          </i>
        </a>
      </div>
    </div>
    
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.25d4b4ffb2db9a42760854fb017fe0cbe4413e299a94b43b52a058abedbf5ace.js" integrity="sha256-JdS0/7LbmkJ2CFT7AX/gy&#43;RBPimalLQ7UqBYq&#43;2/Ws4=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  













  <script>
    $("#openSearch, #openSearchMobile").click(function(){
      $(".modal-dialog").addClass("visible");
    });

    $("#closeSearch").click(function(){
      $(".modal-dialog").removeClass("visible");
    });

    $(document).click(function(event) {
    
      if (!$(event.target).closest(".modal-content, #openSearch, #openSearchMobile").length) {
        $("body").find(".modal-dialog").removeClass("visible");
      }
    });
  </script>




  <script src="/js/custom.js"></script>


  </body>
</html>
